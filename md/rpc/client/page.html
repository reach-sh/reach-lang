<p>
  The <a href="##ref-backends-rpc-proto">Reach RPC Protocol</a> is designed to be simple to implement in languages that support HTTP and JSON interaction.
  This document walks through the implementation of an RPC client in <a href="https://www.python.org">Python</a>.
  An example use of this library is shown in the <a href="##tut-7-rpc">tutorial section on RPC-based frontends</a>.
  The entire library is 80 lines of code.
</p>
<p>
  The library uses a few standard Python libraries for interacting with JSON,
  HTTP servers, and networking:
</p>
<pre class="snippet numbered"><ol class="snippet"><li value="1"># flake8: noqa</li><li value="2"></li><li value="3">import json</li><li value="4">import os</li><li value="5">import requests</li><li value="6">import socket</li><li value="7">import time</li><li value="8">import urllib3</li><li value="9"></li><li value="10"></li><li value="11">def mk_rpc(opts={}):</li><li value="12">    def opt_of(field, envvar, default=None, f=lambda x: x):</li><li value="13">        opt =  f(opts.get(field))        if opts.get(field)        is not None \</li><li value="14">          else f(os.environ.get(envvar)) if os.environ.get(envvar) is not None \</li><li value="15">          else default</li><li value="16"></li><li value="17">        if opt is None:</li><li value="18">            raise RuntimeError('Mandatory configuration unset for: %s' % field)</li><li value="19"></li><li value="20">        return opt</li><li value="21"></li><li value="22">    host    = opt_of('host',    'REACH_RPC_SERVER')</li><li value="23">    port    = opt_of('port',    'REACH_RPC_PORT')</li><li value="24">    key     = opt_of('key',     'REACH_RPC_KEY')</li><li value="25">    timeout = opt_of('timeout', 'REACH_RPC_TIMEOUT',               f=int, default=5)</li><li value="26">    verify  = opt_of('verify',  'REACH_RPC_TLS_REJECT_UNVERIFIED', f=lambda x: x != '0')</li><li value="27"></li><li value="28">    if not verify:</li><li value="29">        urllib3.disable_warnings()</li><li value="30">        print('\n*** Warning! TLS verification disabled! ***\n')</li><li value="31">        print(' This is highly insecure in Real Life™ applications and must')</li><li value="32">        print(' only be permitted under controlled conditions (such as')</li><li value="33">        print(' during development).\n')</li><li value="34"></li><li value="35">    # From: https://gist.github.com/butla/2d9a4c0f35ea47b7452156c96a4e7b12</li><li value="36">    start_time = time.perf_counter()</li><li value="37">    while True:</li><li value="38">        try:</li><li value="39">            with socket.create_connection((host, port), timeout=timeout):</li><li value="40">                break</li><li value="41">        except OSError as ex:</li><li value="42">            time.sleep(0.01)</li><li value="43">            if time.perf_counter() - start_time &gt;= timeout:</li><li value="44">                raise TimeoutError('Waited too long for the port {} '</li><li value="45">                                   'on host {} to accept connection.'</li><li value="46">                                   .format(port, host)) from ex</li><li value="47"></li><li value="48">    def debug(s):</li><li value="49">        if os.environ.get('REACH_DEBUG') is not None:</li><li value="50">            print(s)</li><li value="51"></li><li value="52">    def rpc(m, *args):</li><li value="53">        lab = 'RPC %s %s' % (m, json.dumps([*args]))</li><li value="54">        debug(lab)</li><li value="55">        ans = requests.post('https://%s:%s%s' % (host, port, m),</li><li value="56">                            json    = [*args],</li><li value="57">                            headers = {'X-API-Key': key},</li><li value="58">                            verify  = verify)</li><li value="59">        ans.raise_for_status()</li><li value="60">        debug('%s ==&gt; %s' % (lab, json.dumps(ans.json())))</li><li value="61">        return ans.json()</li><li value="62"></li><li value="63">    def rpc_callbacks(m, arg, cbacks):</li><li value="64">        vals  = {k: v    for k, v in cbacks.items() if not callable(v)}</li><li value="65">        meths = {k: True for k, v in cbacks.items() if     callable(v)}</li><li value="66">        p     = rpc(m, arg, vals, meths)</li><li value="67"></li><li value="68">        while True:</li><li value="69">            if p['t'] == 'Done':</li><li value="70">                return p</li><li value="71"></li><li value="72">            elif p['t'] == 'Kont':</li><li value="73">                cback = cbacks[p['m']]</li><li value="74">                ans   = cback(*p['args'])</li><li value="75">                p     = rpc('/kont', p['kid'], ans)</li><li value="76"></li><li value="77">            else:</li><li value="78">                raise Exception('Illegal callback return: %s' % json.dumps(p))</li><li value="79"></li><li value="80">    return rpc, rpc_callbacks</li></ol></pre>
<pre class="snippet numbered"><ol class="snippet"><li value="1"># flake8: noqa</li><li value="2"></li><li value="3">import json</li><li value="4">import os</li><li value="5">import requests</li><li value="6">import socket</li><li value="7">import time</li><li value="8">import urllib3</li><li value="9"></li><li value="10"></li><li value="11">def mk_rpc(opts={}):</li><li value="12">    def opt_of(field, envvar, default=None, f=lambda x: x):</li><li value="13">        opt =  f(opts.get(field))        if opts.get(field)        is not None \</li><li value="14">          else f(os.environ.get(envvar)) if os.environ.get(envvar) is not None \</li><li value="15">          else default</li><li value="16"></li><li value="17">        if opt is None:</li><li value="18">            raise RuntimeError('Mandatory configuration unset for: %s' % field)</li><li value="19"></li><li value="20">        return opt</li><li value="21"></li><li value="22">    host    = opt_of('host',    'REACH_RPC_SERVER')</li><li value="23">    port    = opt_of('port',    'REACH_RPC_PORT')</li><li value="24">    key     = opt_of('key',     'REACH_RPC_KEY')</li><li value="25">    timeout = opt_of('timeout', 'REACH_RPC_TIMEOUT',               f=int, default=5)</li><li value="26">    verify  = opt_of('verify',  'REACH_RPC_TLS_REJECT_UNVERIFIED', f=lambda x: x != '0')</li><li value="27"></li><li value="28">    if not verify:</li><li value="29">        urllib3.disable_warnings()</li><li value="30">        print('\n*** Warning! TLS verification disabled! ***\n')</li><li value="31">        print(' This is highly insecure in Real Life™ applications and must')</li><li value="32">        print(' only be permitted under controlled conditions (such as')</li><li value="33">        print(' during development).\n')</li><li value="34"></li><li value="35">    # From: https://gist.github.com/butla/2d9a4c0f35ea47b7452156c96a4e7b12</li><li value="36">    start_time = time.perf_counter()</li><li value="37">    while True:</li><li value="38">        try:</li><li value="39">            with socket.create_connection((host, port), timeout=timeout):</li><li value="40">                break</li><li value="41">        except OSError as ex:</li><li value="42">            time.sleep(0.01)</li><li value="43">            if time.perf_counter() - start_time &gt;= timeout:</li><li value="44">                raise TimeoutError('Waited too long for the port {} '</li><li value="45">                                   'on host {} to accept connection.'</li><li value="46">                                   .format(port, host)) from ex</li><li value="47"></li><li value="48">    def debug(s):</li><li value="49">        if os.environ.get('REACH_DEBUG') is not None:</li><li value="50">            print(s)</li><li value="51"></li><li value="52">    def rpc(m, *args):</li><li value="53">        lab = 'RPC %s %s' % (m, json.dumps([*args]))</li><li value="54">        debug(lab)</li><li value="55">        ans = requests.post('https://%s:%s%s' % (host, port, m),</li><li value="56">                            json    = [*args],</li><li value="57">                            headers = {'X-API-Key': key},</li><li value="58">                            verify  = verify)</li><li value="59">        ans.raise_for_status()</li><li value="60">        debug('%s ==&gt; %s' % (lab, json.dumps(ans.json())))</li><li value="61">        return ans.json()</li><li value="62"></li><li value="63">    def rpc_callbacks(m, arg, cbacks):</li><li value="64">        vals  = {k: v    for k, v in cbacks.items() if not callable(v)}</li><li value="65">        meths = {k: True for k, v in cbacks.items() if     callable(v)}</li><li value="66">        p     = rpc(m, arg, vals, meths)</li><li value="67"></li><li value="68">        while True:</li><li value="69">            if p['t'] == 'Done':</li><li value="70">                return p</li><li value="71"></li><li value="72">            elif p['t'] == 'Kont':</li><li value="73">                cback = cbacks[p['m']]</li><li value="74">                ans   = cback(*p['args'])</li><li value="75">                p     = rpc('/kont', p['kid'], ans)</li><li value="76"></li><li value="77">            else:</li><li value="78">                raise Exception('Illegal callback return: %s' % json.dumps(p))</li><li value="79"></li><li value="80">    return rpc, rpc_callbacks</li></ol></pre>
<p>The library provides a single function, <code>mk_rpc</code>, that accepts the ["XXX","seclink","ref-backends-rpc-opts"].</p>
<pre class="snippet numbered"><ol class="snippet"><li value="1"># flake8: noqa</li><li value="2"></li><li value="3">import json</li><li value="4">import os</li><li value="5">import requests</li><li value="6">import socket</li><li value="7">import time</li><li value="8">import urllib3</li><li value="9"></li><li value="10"></li><li value="11">def mk_rpc(opts={}):</li><li value="12">    def opt_of(field, envvar, default=None, f=lambda x: x):</li><li value="13">        opt =  f(opts.get(field))        if opts.get(field)        is not None \</li><li value="14">          else f(os.environ.get(envvar)) if os.environ.get(envvar) is not None \</li><li value="15">          else default</li><li value="16"></li><li value="17">        if opt is None:</li><li value="18">            raise RuntimeError('Mandatory configuration unset for: %s' % field)</li><li value="19"></li><li value="20">        return opt</li><li value="21"></li><li value="22">    host    = opt_of('host',    'REACH_RPC_SERVER')</li><li value="23">    port    = opt_of('port',    'REACH_RPC_PORT')</li><li value="24">    key     = opt_of('key',     'REACH_RPC_KEY')</li><li value="25">    timeout = opt_of('timeout', 'REACH_RPC_TIMEOUT',               f=int, default=5)</li><li value="26">    verify  = opt_of('verify',  'REACH_RPC_TLS_REJECT_UNVERIFIED', f=lambda x: x != '0')</li><li value="27"></li><li value="28">    if not verify:</li><li value="29">        urllib3.disable_warnings()</li><li value="30">        print('\n*** Warning! TLS verification disabled! ***\n')</li><li value="31">        print(' This is highly insecure in Real Life™ applications and must')</li><li value="32">        print(' only be permitted under controlled conditions (such as')</li><li value="33">        print(' during development).\n')</li><li value="34"></li><li value="35">    # From: https://gist.github.com/butla/2d9a4c0f35ea47b7452156c96a4e7b12</li><li value="36">    start_time = time.perf_counter()</li><li value="37">    while True:</li><li value="38">        try:</li><li value="39">            with socket.create_connection((host, port), timeout=timeout):</li><li value="40">                break</li><li value="41">        except OSError as ex:</li><li value="42">            time.sleep(0.01)</li><li value="43">            if time.perf_counter() - start_time &gt;= timeout:</li><li value="44">                raise TimeoutError('Waited too long for the port {} '</li><li value="45">                                   'on host {} to accept connection.'</li><li value="46">                                   .format(port, host)) from ex</li><li value="47"></li><li value="48">    def debug(s):</li><li value="49">        if os.environ.get('REACH_DEBUG') is not None:</li><li value="50">            print(s)</li><li value="51"></li><li value="52">    def rpc(m, *args):</li><li value="53">        lab = 'RPC %s %s' % (m, json.dumps([*args]))</li><li value="54">        debug(lab)</li><li value="55">        ans = requests.post('https://%s:%s%s' % (host, port, m),</li><li value="56">                            json    = [*args],</li><li value="57">                            headers = {'X-API-Key': key},</li><li value="58">                            verify  = verify)</li><li value="59">        ans.raise_for_status()</li><li value="60">        debug('%s ==&gt; %s' % (lab, json.dumps(ans.json())))</li><li value="61">        return ans.json()</li><li value="62"></li><li value="63">    def rpc_callbacks(m, arg, cbacks):</li><li value="64">        vals  = {k: v    for k, v in cbacks.items() if not callable(v)}</li><li value="65">        meths = {k: True for k, v in cbacks.items() if     callable(v)}</li><li value="66">        p     = rpc(m, arg, vals, meths)</li><li value="67"></li><li value="68">        while True:</li><li value="69">            if p['t'] == 'Done':</li><li value="70">                return p</li><li value="71"></li><li value="72">            elif p['t'] == 'Kont':</li><li value="73">                cback = cbacks[p['m']]</li><li value="74">                ans   = cback(*p['args'])</li><li value="75">                p     = rpc('/kont', p['kid'], ans)</li><li value="76"></li><li value="77">            else:</li><li value="78">                raise Exception('Illegal callback return: %s' % json.dumps(p))</li><li value="79"></li><li value="80">    return rpc, rpc_callbacks</li></ol></pre>
<p>
  It starts by observing the <code>verify</code> option and informing the Python library it uses for HTTPS interaction to turn off warnings.
  It displays a warning to users that they should be nervous about using this setting.
</p>
<pre class="snippet numbered"><ol class="snippet"><li value="1"># flake8: noqa</li><li value="2"></li><li value="3">import json</li><li value="4">import os</li><li value="5">import requests</li><li value="6">import socket</li><li value="7">import time</li><li value="8">import urllib3</li><li value="9"></li><li value="10"></li><li value="11">def mk_rpc(opts={}):</li><li value="12">    def opt_of(field, envvar, default=None, f=lambda x: x):</li><li value="13">        opt =  f(opts.get(field))        if opts.get(field)        is not None \</li><li value="14">          else f(os.environ.get(envvar)) if os.environ.get(envvar) is not None \</li><li value="15">          else default</li><li value="16"></li><li value="17">        if opt is None:</li><li value="18">            raise RuntimeError('Mandatory configuration unset for: %s' % field)</li><li value="19"></li><li value="20">        return opt</li><li value="21"></li><li value="22">    host    = opt_of('host',    'REACH_RPC_SERVER')</li><li value="23">    port    = opt_of('port',    'REACH_RPC_PORT')</li><li value="24">    key     = opt_of('key',     'REACH_RPC_KEY')</li><li value="25">    timeout = opt_of('timeout', 'REACH_RPC_TIMEOUT',               f=int, default=5)</li><li value="26">    verify  = opt_of('verify',  'REACH_RPC_TLS_REJECT_UNVERIFIED', f=lambda x: x != '0')</li><li value="27"></li><li value="28">    if not verify:</li><li value="29">        urllib3.disable_warnings()</li><li value="30">        print('\n*** Warning! TLS verification disabled! ***\n')</li><li value="31">        print(' This is highly insecure in Real Life™ applications and must')</li><li value="32">        print(' only be permitted under controlled conditions (such as')</li><li value="33">        print(' during development).\n')</li><li value="34"></li><li value="35">    # From: https://gist.github.com/butla/2d9a4c0f35ea47b7452156c96a4e7b12</li><li value="36">    start_time = time.perf_counter()</li><li value="37">    while True:</li><li value="38">        try:</li><li value="39">            with socket.create_connection((host, port), timeout=timeout):</li><li value="40">                break</li><li value="41">        except OSError as ex:</li><li value="42">            time.sleep(0.01)</li><li value="43">            if time.perf_counter() - start_time &gt;= timeout:</li><li value="44">                raise TimeoutError('Waited too long for the port {} '</li><li value="45">                                   'on host {} to accept connection.'</li><li value="46">                                   .format(port, host)) from ex</li><li value="47"></li><li value="48">    def debug(s):</li><li value="49">        if os.environ.get('REACH_DEBUG') is not None:</li><li value="50">            print(s)</li><li value="51"></li><li value="52">    def rpc(m, *args):</li><li value="53">        lab = 'RPC %s %s' % (m, json.dumps([*args]))</li><li value="54">        debug(lab)</li><li value="55">        ans = requests.post('https://%s:%s%s' % (host, port, m),</li><li value="56">                            json    = [*args],</li><li value="57">                            headers = {'X-API-Key': key},</li><li value="58">                            verify  = verify)</li><li value="59">        ans.raise_for_status()</li><li value="60">        debug('%s ==&gt; %s' % (lab, json.dumps(ans.json())))</li><li value="61">        return ans.json()</li><li value="62"></li><li value="63">    def rpc_callbacks(m, arg, cbacks):</li><li value="64">        vals  = {k: v    for k, v in cbacks.items() if not callable(v)}</li><li value="65">        meths = {k: True for k, v in cbacks.items() if     callable(v)}</li><li value="66">        p     = rpc(m, arg, vals, meths)</li><li value="67"></li><li value="68">        while True:</li><li value="69">            if p['t'] == 'Done':</li><li value="70">                return p</li><li value="71"></li><li value="72">            elif p['t'] == 'Kont':</li><li value="73">                cback = cbacks[p['m']]</li><li value="74">                ans   = cback(*p['args'])</li><li value="75">                p     = rpc('/kont', p['kid'], ans)</li><li value="76"></li><li value="77">            else:</li><li value="78">                raise Exception('Illegal callback return: %s' % json.dumps(p))</li><li value="79"></li><li value="80">    return rpc, rpc_callbacks</li></ol></pre>
<p>Next, it attempts to connect to the Reach RPC Server and throws an error if it does not respond quickly enough.</p>
<pre class="snippet numbered"><ol class="snippet"><li value="1"># flake8: noqa</li><li value="2"></li><li value="3">import json</li><li value="4">import os</li><li value="5">import requests</li><li value="6">import socket</li><li value="7">import time</li><li value="8">import urllib3</li><li value="9"></li><li value="10"></li><li value="11">def mk_rpc(opts={}):</li><li value="12">    def opt_of(field, envvar, default=None, f=lambda x: x):</li><li value="13">        opt =  f(opts.get(field))        if opts.get(field)        is not None \</li><li value="14">          else f(os.environ.get(envvar)) if os.environ.get(envvar) is not None \</li><li value="15">          else default</li><li value="16"></li><li value="17">        if opt is None:</li><li value="18">            raise RuntimeError('Mandatory configuration unset for: %s' % field)</li><li value="19"></li><li value="20">        return opt</li><li value="21"></li><li value="22">    host    = opt_of('host',    'REACH_RPC_SERVER')</li><li value="23">    port    = opt_of('port',    'REACH_RPC_PORT')</li><li value="24">    key     = opt_of('key',     'REACH_RPC_KEY')</li><li value="25">    timeout = opt_of('timeout', 'REACH_RPC_TIMEOUT',               f=int, default=5)</li><li value="26">    verify  = opt_of('verify',  'REACH_RPC_TLS_REJECT_UNVERIFIED', f=lambda x: x != '0')</li><li value="27"></li><li value="28">    if not verify:</li><li value="29">        urllib3.disable_warnings()</li><li value="30">        print('\n*** Warning! TLS verification disabled! ***\n')</li><li value="31">        print(' This is highly insecure in Real Life™ applications and must')</li><li value="32">        print(' only be permitted under controlled conditions (such as')</li><li value="33">        print(' during development).\n')</li><li value="34"></li><li value="35">    # From: https://gist.github.com/butla/2d9a4c0f35ea47b7452156c96a4e7b12</li><li value="36">    start_time = time.perf_counter()</li><li value="37">    while True:</li><li value="38">        try:</li><li value="39">            with socket.create_connection((host, port), timeout=timeout):</li><li value="40">                break</li><li value="41">        except OSError as ex:</li><li value="42">            time.sleep(0.01)</li><li value="43">            if time.perf_counter() - start_time &gt;= timeout:</li><li value="44">                raise TimeoutError('Waited too long for the port {} '</li><li value="45">                                   'on host {} to accept connection.'</li><li value="46">                                   .format(port, host)) from ex</li><li value="47"></li><li value="48">    def debug(s):</li><li value="49">        if os.environ.get('REACH_DEBUG') is not None:</li><li value="50">            print(s)</li><li value="51"></li><li value="52">    def rpc(m, *args):</li><li value="53">        lab = 'RPC %s %s' % (m, json.dumps([*args]))</li><li value="54">        debug(lab)</li><li value="55">        ans = requests.post('https://%s:%s%s' % (host, port, m),</li><li value="56">                            json    = [*args],</li><li value="57">                            headers = {'X-API-Key': key},</li><li value="58">                            verify  = verify)</li><li value="59">        ans.raise_for_status()</li><li value="60">        debug('%s ==&gt; %s' % (lab, json.dumps(ans.json())))</li><li value="61">        return ans.json()</li><li value="62"></li><li value="63">    def rpc_callbacks(m, arg, cbacks):</li><li value="64">        vals  = {k: v    for k, v in cbacks.items() if not callable(v)}</li><li value="65">        meths = {k: True for k, v in cbacks.items() if     callable(v)}</li><li value="66">        p     = rpc(m, arg, vals, meths)</li><li value="67"></li><li value="68">        while True:</li><li value="69">            if p['t'] == 'Done':</li><li value="70">                return p</li><li value="71"></li><li value="72">            elif p['t'] == 'Kont':</li><li value="73">                cback = cbacks[p['m']]</li><li value="74">                ans   = cback(*p['args'])</li><li value="75">                p     = rpc('/kont', p['kid'], ans)</li><li value="76"></li><li value="77">            else:</li><li value="78">                raise Exception('Illegal callback return: %s' % json.dumps(p))</li><li value="79"></li><li value="80">    return rpc, rpc_callbacks</li></ol></pre>
<p>
  It defines a function, <code>rpc</code>, which will be returned later on, that
  implements the protocol for synchronous value RPC methods.
  It formats a given request, posts it, and then returns the deserialized result.
  It prints debugging information for convenience.
</p>
<pre class="snippet numbered"><ol class="snippet"><li value="1"># flake8: noqa</li><li value="2"></li><li value="3">import json</li><li value="4">import os</li><li value="5">import requests</li><li value="6">import socket</li><li value="7">import time</li><li value="8">import urllib3</li><li value="9"></li><li value="10"></li><li value="11">def mk_rpc(opts={}):</li><li value="12">    def opt_of(field, envvar, default=None, f=lambda x: x):</li><li value="13">        opt =  f(opts.get(field))        if opts.get(field)        is not None \</li><li value="14">          else f(os.environ.get(envvar)) if os.environ.get(envvar) is not None \</li><li value="15">          else default</li><li value="16"></li><li value="17">        if opt is None:</li><li value="18">            raise RuntimeError('Mandatory configuration unset for: %s' % field)</li><li value="19"></li><li value="20">        return opt</li><li value="21"></li><li value="22">    host    = opt_of('host',    'REACH_RPC_SERVER')</li><li value="23">    port    = opt_of('port',    'REACH_RPC_PORT')</li><li value="24">    key     = opt_of('key',     'REACH_RPC_KEY')</li><li value="25">    timeout = opt_of('timeout', 'REACH_RPC_TIMEOUT',               f=int, default=5)</li><li value="26">    verify  = opt_of('verify',  'REACH_RPC_TLS_REJECT_UNVERIFIED', f=lambda x: x != '0')</li><li value="27"></li><li value="28">    if not verify:</li><li value="29">        urllib3.disable_warnings()</li><li value="30">        print('\n*** Warning! TLS verification disabled! ***\n')</li><li value="31">        print(' This is highly insecure in Real Life™ applications and must')</li><li value="32">        print(' only be permitted under controlled conditions (such as')</li><li value="33">        print(' during development).\n')</li><li value="34"></li><li value="35">    # From: https://gist.github.com/butla/2d9a4c0f35ea47b7452156c96a4e7b12</li><li value="36">    start_time = time.perf_counter()</li><li value="37">    while True:</li><li value="38">        try:</li><li value="39">            with socket.create_connection((host, port), timeout=timeout):</li><li value="40">                break</li><li value="41">        except OSError as ex:</li><li value="42">            time.sleep(0.01)</li><li value="43">            if time.perf_counter() - start_time &gt;= timeout:</li><li value="44">                raise TimeoutError('Waited too long for the port {} '</li><li value="45">                                   'on host {} to accept connection.'</li><li value="46">                                   .format(port, host)) from ex</li><li value="47"></li><li value="48">    def debug(s):</li><li value="49">        if os.environ.get('REACH_DEBUG') is not None:</li><li value="50">            print(s)</li><li value="51"></li><li value="52">    def rpc(m, *args):</li><li value="53">        lab = 'RPC %s %s' % (m, json.dumps([*args]))</li><li value="54">        debug(lab)</li><li value="55">        ans = requests.post('https://%s:%s%s' % (host, port, m),</li><li value="56">                            json    = [*args],</li><li value="57">                            headers = {'X-API-Key': key},</li><li value="58">                            verify  = verify)</li><li value="59">        ans.raise_for_status()</li><li value="60">        debug('%s ==&gt; %s' % (lab, json.dumps(ans.json())))</li><li value="61">        return ans.json()</li><li value="62"></li><li value="63">    def rpc_callbacks(m, arg, cbacks):</li><li value="64">        vals  = {k: v    for k, v in cbacks.items() if not callable(v)}</li><li value="65">        meths = {k: True for k, v in cbacks.items() if     callable(v)}</li><li value="66">        p     = rpc(m, arg, vals, meths)</li><li value="67"></li><li value="68">        while True:</li><li value="69">            if p['t'] == 'Done':</li><li value="70">                return p</li><li value="71"></li><li value="72">            elif p['t'] == 'Kont':</li><li value="73">                cback = cbacks[p['m']]</li><li value="74">                ans   = cback(*p['args'])</li><li value="75">                p     = rpc('/kont', p['kid'], ans)</li><li value="76"></li><li value="77">            else:</li><li value="78">                raise Exception('Illegal callback return: %s' % json.dumps(p))</li><li value="79"></li><li value="80">    return rpc, rpc_callbacks</li></ol></pre>
<p>
  It defines a function, <code>rpc_callbacks</code>, which will be returned later on, that
  implements the protocol for interactive RPC methods.
  On lines 64 and 65, this function inspects its third argument, <code>cbacks</code>,
  and separates the <code>callable</code> arguments from the values and creates the
  intermediate objects, <code>vals</code> and <code>meths</code>, to provide the RPC
  invocation.
  After it makes the call, in the <code>while</code> loop starting on line 68, it
  inspects the result to determine if it is a final answer or an
  interactive RPC callback.
  If it is a callback, as indicated by the test on line 72, then it extracts the
  name of the method, <code>p['m']</code>, and invokes it in the original third
  argument, <code>cbacks</code>, with the provided arguments.
  It replaces the <code>p</code> value with the result of that continuation invocation and continues.
</p>
<pre class="snippet numbered"><ol class="snippet"><li value="1"># flake8: noqa</li><li value="2"></li><li value="3">import json</li><li value="4">import os</li><li value="5">import requests</li><li value="6">import socket</li><li value="7">import time</li><li value="8">import urllib3</li><li value="9"></li><li value="10"></li><li value="11">def mk_rpc(opts={}):</li><li value="12">    def opt_of(field, envvar, default=None, f=lambda x: x):</li><li value="13">        opt =  f(opts.get(field))        if opts.get(field)        is not None \</li><li value="14">          else f(os.environ.get(envvar)) if os.environ.get(envvar) is not None \</li><li value="15">          else default</li><li value="16"></li><li value="17">        if opt is None:</li><li value="18">            raise RuntimeError('Mandatory configuration unset for: %s' % field)</li><li value="19"></li><li value="20">        return opt</li><li value="21"></li><li value="22">    host    = opt_of('host',    'REACH_RPC_SERVER')</li><li value="23">    port    = opt_of('port',    'REACH_RPC_PORT')</li><li value="24">    key     = opt_of('key',     'REACH_RPC_KEY')</li><li value="25">    timeout = opt_of('timeout', 'REACH_RPC_TIMEOUT',               f=int, default=5)</li><li value="26">    verify  = opt_of('verify',  'REACH_RPC_TLS_REJECT_UNVERIFIED', f=lambda x: x != '0')</li><li value="27"></li><li value="28">    if not verify:</li><li value="29">        urllib3.disable_warnings()</li><li value="30">        print('\n*** Warning! TLS verification disabled! ***\n')</li><li value="31">        print(' This is highly insecure in Real Life™ applications and must')</li><li value="32">        print(' only be permitted under controlled conditions (such as')</li><li value="33">        print(' during development).\n')</li><li value="34"></li><li value="35">    # From: https://gist.github.com/butla/2d9a4c0f35ea47b7452156c96a4e7b12</li><li value="36">    start_time = time.perf_counter()</li><li value="37">    while True:</li><li value="38">        try:</li><li value="39">            with socket.create_connection((host, port), timeout=timeout):</li><li value="40">                break</li><li value="41">        except OSError as ex:</li><li value="42">            time.sleep(0.01)</li><li value="43">            if time.perf_counter() - start_time &gt;= timeout:</li><li value="44">                raise TimeoutError('Waited too long for the port {} '</li><li value="45">                                   'on host {} to accept connection.'</li><li value="46">                                   .format(port, host)) from ex</li><li value="47"></li><li value="48">    def debug(s):</li><li value="49">        if os.environ.get('REACH_DEBUG') is not None:</li><li value="50">            print(s)</li><li value="51"></li><li value="52">    def rpc(m, *args):</li><li value="53">        lab = 'RPC %s %s' % (m, json.dumps([*args]))</li><li value="54">        debug(lab)</li><li value="55">        ans = requests.post('https://%s:%s%s' % (host, port, m),</li><li value="56">                            json    = [*args],</li><li value="57">                            headers = {'X-API-Key': key},</li><li value="58">                            verify  = verify)</li><li value="59">        ans.raise_for_status()</li><li value="60">        debug('%s ==&gt; %s' % (lab, json.dumps(ans.json())))</li><li value="61">        return ans.json()</li><li value="62"></li><li value="63">    def rpc_callbacks(m, arg, cbacks):</li><li value="64">        vals  = {k: v    for k, v in cbacks.items() if not callable(v)}</li><li value="65">        meths = {k: True for k, v in cbacks.items() if     callable(v)}</li><li value="66">        p     = rpc(m, arg, vals, meths)</li><li value="67"></li><li value="68">        while True:</li><li value="69">            if p['t'] == 'Done':</li><li value="70">                return p</li><li value="71"></li><li value="72">            elif p['t'] == 'Kont':</li><li value="73">                cback = cbacks[p['m']]</li><li value="74">                ans   = cback(*p['args'])</li><li value="75">                p     = rpc('/kont', p['kid'], ans)</li><li value="76"></li><li value="77">            else:</li><li value="78">                raise Exception('Illegal callback return: %s' % json.dumps(p))</li><li value="79"></li><li value="80">    return rpc, rpc_callbacks</li></ol></pre>
<p>Finally, it returns <code>rpc</code> and <code>rpc_callbacks</code> to the user.</p>