[
  {
    "objectID": "/#reach-top",
    "pt": "Reach: The Safest and Easiest DApp Programming Language",
    "t": 2,
    "c": "Reach: The Safest and Easiest DApp Programming Language"
  },
  {
    "objectID": "/#p_0",
    "pt": "Reach: The Safest and Easiest DApp Programming Language",
    "t": 3,
    "c": "Reach is a domain-specific language for building decentralized applications (DApps)."
  },
  {
    "objectID": "/#p_1",
    "pt": "Reach: The Safest and Easiest DApp Programming Language",
    "t": 3,
    "c": "This set of documents contains everything you need to know about Reach."
  },
  {
    "objectID": "/#p_2",
    "pt": "Reach: The Safest and Easiest DApp Programming Language",
    "t": 3,
    "c": "The quick start guide contains instructions for setting up the Reach environment on your Windows, Linux, or Mac computer."
  },
  {
    "objectID": "/#p_3",
    "pt": "Reach: The Safest and Easiest DApp Programming Language",
    "t": 3,
    "c": "The overview briefly introduces the basic ideas of Reach. It can be helpful to get some context before diving into other sections. If you have experience with blockchain development using existing tools, we recommend reading the overview and a comparision with other development platforms."
  },
  {
    "objectID": "/#p_4",
    "pt": "Reach: The Safest and Easiest DApp Programming Language",
    "t": 3,
    "c": "The tutorial is a directed series of steps to create a simple DApp. You should start here if you've never used Reach before and want to start at the beginning. It assumes no prior experience in DApp/blockchain development."
  },
  {
    "objectID": "/#p_5",
    "pt": "Reach: The Safest and Easiest DApp Programming Language",
    "t": 3,
    "c": "The guide continues the overview by discussing the key ideas and concepts used throughout Reach. You may want to revisit the guide often to reinforce background knowledge and to understand the \"why\" of newly learned topics."
  },
  {
    "objectID": "/#p_6",
    "pt": "Reach: The Safest and Easiest DApp Programming Language",
    "t": 3,
    "c": "The workshop continues the tutorial with a set of self-study projects to help you gain mastery in decentralized application design through practice with Reach. Each project contains a completed solution, so it is also a collection of recipes for building specific things in Reach and demonstrates effective use of Reach, as well as some of the design decisions that Reach programmers face."
  },
  {
    "objectID": "/#p_7",
    "pt": "Reach: The Safest and Easiest DApp Programming Language",
    "t": 3,
    "c": "Finally, the reference provides an exhaustive technical reference on each aspect of Reach."
  },
  {
    "objectID": "/#p_8",
    "pt": "Reach: The Safest and Easiest DApp Programming Language",
    "t": 3,
    "c": "If you are looking for something specific, here are some places to look:"
  },
  {
    "objectID": "/#p_9",
    "pt": "Reach: The Safest and Easiest DApp Programming Language",
    "t": 3,
    "c": "Try consulting the Index or the Table of Contents."
  },
  {
    "objectID": "/#p_10",
    "pt": "Reach: The Safest and Easiest DApp Programming Language",
    "t": 3,
    "c": "Start a discussion on the Discord community or GitHub Discussions."
  },
  {
    "objectID": "/#p_11",
    "pt": "Reach: The Safest and Easiest DApp Programming Language",
    "t": 3,
    "c": "Report issues with the GitHub issue tracker."
  },
  {
    "objectID": "/#p_12",
    "pt": "Reach: The Safest and Easiest DApp Programming Language",
    "t": 3,
    "c": "The source of this site is available on GitHub; we welcome Pull Requests for improvements and Issues for problem reports!"
  },
  {
    "objectID": "/changelog/#cmd_reach%20compile",
    "pt": "Changelog",
    "t": 0,
    "s": "cmd",
    "c": "reach compile"
  },
  {
    "objectID": "/changelog/#cmd_reach%20init",
    "pt": "Changelog",
    "t": 0,
    "s": "cmd",
    "c": "reach init"
  },
  {
    "objectID": "/changelog/#cmd_reach%20run",
    "pt": "Changelog",
    "t": 0,
    "s": "cmd",
    "c": "reach run"
  },
  {
    "objectID": "/changelog/#cmd_reach%20down",
    "pt": "Changelog",
    "t": 0,
    "s": "cmd",
    "c": "reach down"
  },
  {
    "objectID": "/changelog/#cmd_reach%20docker-reset",
    "pt": "Changelog",
    "t": 0,
    "s": "cmd",
    "c": "reach docker-reset"
  },
  {
    "objectID": "/changelog/#cmd_reach%20docker-reset",
    "pt": "Changelog",
    "t": 0,
    "s": "cmd",
    "c": "reach docker-reset"
  },
  {
    "objectID": "/changelog/#cmd_reach%20devnet",
    "pt": "Changelog",
    "t": 0,
    "s": "cmd",
    "c": "reach devnet"
  },
  {
    "objectID": "/changelog/#cmd_reach%20scaffold",
    "pt": "Changelog",
    "t": 0,
    "s": "cmd",
    "c": "reach scaffold"
  },
  {
    "objectID": "/changelog/#guide-changelog",
    "pt": "Changelog",
    "t": 2,
    "c": "Changelog"
  },
  {
    "objectID": "/changelog/#0111-202206---present",
    "pt": "Changelog",
    "t": 2,
    "c": "0.1.11: 2022/06 - present"
  },
  {
    "objectID": "/changelog/#0110-202204---202205",
    "pt": "Changelog",
    "t": 2,
    "c": "0.1.10: 2022/04 - 2022/05"
  },
  {
    "objectID": "/changelog/#019-202203---202204",
    "pt": "Changelog",
    "t": 2,
    "c": "0.1.9: 2022/03 - 2022/04"
  },
  {
    "objectID": "/changelog/#018-202201---202203",
    "pt": "Changelog",
    "t": 2,
    "c": "0.1.8: 2022/01 - 2022/03"
  },
  {
    "objectID": "/changelog/#017-202111---202112",
    "pt": "Changelog",
    "t": 2,
    "c": "0.1.7: 2021/11 - 2021/12"
  },
  {
    "objectID": "/changelog/#016-202110---202111",
    "pt": "Changelog",
    "t": 2,
    "c": "0.1.6: 2021/10 - 2021/11"
  },
  {
    "objectID": "/changelog/#015-202109---202110",
    "pt": "Changelog",
    "t": 2,
    "c": "0.1.5: 2021/09 - 2021/10"
  },
  {
    "objectID": "/changelog/#014-202109---202109",
    "pt": "Changelog",
    "t": 2,
    "c": "0.1.4: 2021/09 - 2021/09"
  },
  {
    "objectID": "/changelog/#013-202107---202108",
    "pt": "Changelog",
    "t": 2,
    "c": "0.1.3: 2021/07 - 2021/08"
  },
  {
    "objectID": "/changelog/#012-202009---202107",
    "pt": "Changelog",
    "t": 2,
    "c": "0.1.2: 2020/09 - 2021/07"
  },
  {
    "objectID": "/changelog/#011-201909---202009",
    "pt": "Changelog",
    "t": 2,
    "c": "0.1.1: 2019/09 - 2020/09"
  },
  {
    "objectID": "/changelog/#010-201909---202009",
    "pt": "Changelog",
    "t": 2,
    "c": "0.1.0: 2019/09 - 2020/09"
  },
  {
    "objectID": "/changelog/#p_0",
    "pt": "Changelog",
    "t": 3,
    "c": "Below is a list of changes to Reach. Versions and changes-within-versions are listed in reverse-chronological order: newest things first."
  },
  {
    "objectID": "/changelog/#p_1",
    "pt": "Changelog",
    "t": 3,
    "c": "Version 0.1.11 is the current Reach release candidate version."
  },
  {
    "objectID": "/changelog/#p_2",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/06/01: Added onCompletion field to {!rsh} remote.ALGO."
  },
  {
    "objectID": "/changelog/#p_3",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/06/01: Added Contract creation support."
  },
  {
    "objectID": "/changelog/#p_4",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/06/01: Added Contract code definition support."
  },
  {
    "objectID": "/changelog/#p_5",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/06/01: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_6",
    "pt": "Changelog",
    "t": 3,
    "c": "Version 0.1.10 is the current Reach release version."
  },
  {
    "objectID": "/changelog/#p_7",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/05/14: Added {!cmd} reach support sub-command."
  },
  {
    "objectID": "/changelog/#p_8",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/05/13: Support custom violation messages for {!rsh} invariants."
  },
  {
    "objectID": "/changelog/#p_9",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/05/13: Support multiple {!rsh} invariants for {!rsh} while loops and {!rsh} parallelReduce."
  },
  {
    "objectID": "/changelog/#p_10",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/05/13: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_11",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/05/13: Added {!rsh} getCompanion."
  },
  {
    "objectID": "/changelog/#p_12",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/05/13: Added apps field to {!rsh} remote.ALGO."
  },
  {
    "objectID": "/changelog/#p_13",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/05/07: Added addressToAccount field to {!rsh} remote.ALGO."
  },
  {
    "objectID": "/changelog/#p_14",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/05/05: Added support for multiple {!rsh} .define branches in a {!rsh} parallelReduce."
  },
  {
    "objectID": "/changelog/#p_15",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/05/04: Added .api_ branch to {!rsh} fork and {!rsh} parallelReduce."
  },
  {
    "objectID": "/changelog/#p_16",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/05/04: Added CHECK_EXPR to {!rsh} .case in {!rsh} fork and {!rsh} parallelReduce."
  },
  {
    "objectID": "/changelog/#p_17",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/05/04: Added .check to {!rsh} publish and API {!rsh} calls."
  },
  {
    "objectID": "/changelog/#p_18",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/30: Added assets field to {!rsh} remote.ALGO."
  },
  {
    "objectID": "/changelog/#p_19",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/28: Added {!rsh} sqrt and renamed old version to {!rsh} sqrtApprox. This change is backwards incompatible, but we believe that most users will prefer the new version and will want to be warned, via a compile error, that it is available."
  },
  {
    "objectID": "/changelog/#p_20",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/28: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_21",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/28: Added {!cmd} REACH_NO_WARN environment variable."
  },
  {
    "objectID": "/changelog/#p_22",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/28: Added {!js} test to the JavaScript standard library."
  },
  {
    "objectID": "/changelog/#p_23",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/26: Add support for calling {!rsh} APIs multiple times in a program."
  },
  {
    "objectID": "/changelog/#p_24",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/26: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_25",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/22: Added --verify-fail-once flag to reach compile to only print the first verification failure produced by a program."
  },
  {
    "objectID": "/changelog/#p_26",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/19: Added {!js} withDisconnect and {!js} disconnect to help participant frontends disconnect early from a contract."
  },
  {
    "objectID": "/changelog/#p_27",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/18: Added {!rsh} Contract.addressEq."
  },
  {
    "objectID": "/changelog/#p_28",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/18: Added {!rsh} remote.ALGO."
  },
  {
    "objectID": "/changelog/#p_29",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/18: Ethereum-like-only: The backend interface to deployed contracts was updated, so old contracts will not work with this version."
  },
  {
    "objectID": "/changelog/#p_30",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/18: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_31",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/12: Added {!js} getTimeSecs for converting network time to network seconds."
  },
  {
    "objectID": "/changelog/#p_32",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/09: Added the note field to {!js} launchToken."
  },
  {
    "objectID": "/changelog/#p_33",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/07: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_34",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/07: Added {!rsh} UInt256 type and associated operations."
  },
  {
    "objectID": "/changelog/#p_35",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/07: Algorand indexer upgraded to 2.10.0."
  },
  {
    "objectID": "/changelog/#p_36",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/07: Algorand node upgraded to 3.5.1."
  },
  {
    "objectID": "/changelog/#p_37",
    "pt": "Changelog",
    "t": 3,
    "c": "Version 0.1.9 is an old Reach release version."
  },
  {
    "objectID": "/changelog/#p_38",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/06: Added support for arbitrary {!rsh} Map keys on Ethereum/Conflux."
  },
  {
    "objectID": "/changelog/#p_39",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/05: Added support for creating overloaded {!rsh} API functions and calling overloaded {!rsh} remote functions."
  },
  {
    "objectID": "/changelog/#p_40",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/30: Added {!rsh} thisConsensusTime and {!rsh} thisConsensusSecs."
  },
  {
    "objectID": "/changelog/#p_41",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/30: Added {!rsh} polyMod, which supports {!rsh} Bytes and {!rsh} Digests."
  },
  {
    "objectID": "/changelog/#p_42",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/22: Added {!rsh} Set.Map field."
  },
  {
    "objectID": "/changelog/#p_43",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/22: Added support for {!js} _ in JavaScript number literals, like {!js} 1_337."
  },
  {
    "objectID": "/changelog/#p_44",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/17: Removed {!rsh} polyXor and made {!rsh} xor polymorphic."
  },
  {
    "objectID": "/changelog/#p_45",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/16: On Algorand, Reach will use a companion application and inner transaction calls to it to provide up to 179,200 units of computation budget. Each 700 costs an extra transaction fee. The compiler will produce a fee and resource allocation report when run with debugging enabled."
  },
  {
    "objectID": "/changelog/#p_46",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/14: Algorand-only: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_47",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/14: Added {!rsh} polyXor and update {!rsh} ^ to use it."
  },
  {
    "objectID": "/changelog/#p_48",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/12: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_49",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/09: Added {!rsh} _local to {!rsh} parallelReduce and {!rsh} fork."
  },
  {
    "objectID": "/changelog/#p_50",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/08: Added {!rsh} distinct."
  },
  {
    "objectID": "/changelog/#p_51",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/07: {!rsh} remote objects supported on Algorand."
  },
  {
    "objectID": "/changelog/#p_52",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/02: Algorand-only: Drastically reduced the cost of {!rsh} muldiv."
  },
  {
    "objectID": "/changelog/#p_53",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/02: Algorand-only: Contract bytecode upgraded to version 6. (This enables {!rsh} API and {!rsh} View functions to be called on-chain.)"
  },
  {
    "objectID": "/changelog/#p_54",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/02: Algorand-only: Updated the default faucet. If you upgrade the standard library, but do not restart your devnet, tests will fail."
  },
  {
    "objectID": "/changelog/#p_55",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/02: Algorand indexer upgraded to 2.9.0."
  },
  {
    "objectID": "/changelog/#p_56",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/02: Algorand node upgraded to 3.4.2."
  },
  {
    "objectID": "/changelog/#p_57",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/02: Ethers upgraded to 5.5.4."
  },
  {
    "objectID": "/changelog/#p_58",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/02: Ethereum ERC-20 implementation upgraded to OpenZeppelin 4.5.0."
  },
  {
    "objectID": "/changelog/#p_59",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/02: Ethereum (geth) upgraded to 1.10.16."
  },
  {
    "objectID": "/changelog/#p_60",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/02: Solidity upgraded to 0.8.12."
  },
  {
    "objectID": "/changelog/#p_61",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/02: Z3 upgraded to 4.8.14."
  },
  {
    "objectID": "/changelog/#p_62",
    "pt": "Changelog",
    "t": 3,
    "c": "Version 0.1.8 is an old Reach release version."
  },
  {
    "objectID": "/changelog/#p_63",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/02/28: Added {!js} launchToken for token minting in frontends."
  },
  {
    "objectID": "/changelog/#p_64",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/02/25: Added support for tracking {!rsh} Token information—such as balance, supply, and whether its destroyed—dynamically."
  },
  {
    "objectID": "/changelog/#p_65",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/02/25: Added {!cmd} reach info."
  },
  {
    "objectID": "/changelog/#p_66",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/02/25: Removed {!cmd} reach upgrade (subsumed by {!cmd} reach update)."
  },
  {
    "objectID": "/changelog/#p_67",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/02/08: Added {!js} balancesOf."
  },
  {
    "objectID": "/changelog/#p_68",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/02/06: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_69",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/29: Added {!cmd} ALGO_NODE_WRITE_ONLY."
  },
  {
    "objectID": "/changelog/#p_70",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/28: Added {!js} setSigningMonitor."
  },
  {
    "objectID": "/changelog/#p_71",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/27: Added {!js} setMinMillisBetweenRequests."
  },
  {
    "objectID": "/changelog/#p_72",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/27: Added {!js} setCustomHttpEventHandler."
  },
  {
    "objectID": "/changelog/#p_73",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/27: Added {!js} minimumBalanceOf."
  },
  {
    "objectID": "/changelog/#p_74",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/26: Added {!rsh} untrustworthyMaps option to {!rsh} setOptions."
  },
  {
    "objectID": "/changelog/#p_75",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/25: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_76",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/24: Added {!rsh} Array.forEachWithIndex."
  },
  {
    "objectID": "/changelog/#p_77",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/20: Added {!rsh} check."
  },
  {
    "objectID": "/changelog/#p_78",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/13: Algorand-only: The backend interface to deployed contracts was updated, so old contracts will not work with this version."
  },
  {
    "objectID": "/changelog/#p_79",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/13: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_80",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/13: Added {!js} ctc.getABI."
  },
  {
    "objectID": "/changelog/#p_81",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/08: The Algorand connector does not rely on an Algorand Node for any information available through an Algorand Indexer. This is compatible with some Algorand network providers that restrict the API on Algorand Nodes."
  },
  {
    "objectID": "/changelog/#p_82",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/06: The analysis of cost on Algorand is more precise in the presence of array operations."
  },
  {
    "objectID": "/changelog/#p_83",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/06: Verification of only-one-honest participant is disabled. This proves nothing that wasn't verified already by the other two cases and just takes more time."
  },
  {
    "objectID": "/changelog/#p_84",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/05: Conflux devnet has been upgraded to 0.1.7."
  },
  {
    "objectID": "/changelog/#p_85",
    "pt": "Changelog",
    "t": 3,
    "c": "Version 0.1.7 is an old Reach release version."
  },
  {
    "objectID": "/changelog/#p_86",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/06: Added {!rsh} getUntrackedFunds."
  },
  {
    "objectID": "/changelog/#p_87",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/12/31: {!js} setQueryLowerBound is deprecated."
  },
  {
    "objectID": "/changelog/#p_88",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/12/28: Algorand-only: The backend interface to compiled contract objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_89",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/12/23: Algorand-only: The backend interface to deployed contracts was updated, so old contracts will not work with this version."
  },
  {
    "objectID": "/changelog/#p_90",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/12/23: Added {!rsh} verifyMuldiv."
  },
  {
    "objectID": "/changelog/#p_91",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/12/23: {!rsh} deploy was renamed to {!rsh} init."
  },
  {
    "objectID": "/changelog/#p_92",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/12/21: The backend interface to deployed contracts was updated, so old contracts will not work with this version."
  },
  {
    "objectID": "/changelog/#p_93",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/12/21: EVM-only: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_94",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/12/20: Added support for {!rsh} PAY_REQUIRE_EXPR, which allows {!rsh} require claims to be made about payments."
  },
  {
    "objectID": "/changelog/#p_95",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/12/16: Added {!rsh} Events."
  },
  {
    "objectID": "/changelog/#p_96",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/12/16: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_97",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/12/16: The backend interface to deployed contracts was updated, so old contracts will not work with this version."
  },
  {
    "objectID": "/changelog/#p_98",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/12/10: Added support for using Reach on Apple Silicon."
  },
  {
    "objectID": "/changelog/#p_99",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/11/25: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_100",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/11/19: The backend interface to deployed contracts was updated, so old contracts will not work with this version."
  },
  {
    "objectID": "/changelog/#p_101",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/11/19: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_102",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/11/17: Added {!js} ctc.unsafeViews and {!js} ctc.safeApis."
  },
  {
    "objectID": "/changelog/#p_103",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/11/15: Algorand connector now uses the application-controlled account for the escrow account. This means that some programs will no longer work, if they do certain things, like trying to transfer non-network tokens in the same step that they share them with the consensus, because the contract needs to opt-in. On the other hand, some things that used to not work, now do; for example, there used to be a limit of 15 extra transactions per consensus transfer, but now the limit is 31, with 15 from the client and 16 generated by the contract."
  },
  {
    "objectID": "/changelog/#p_104",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/11/15: Algorand-only: The backend interface to deployed contracts was updated, so old contracts will not work with this version."
  },
  {
    "objectID": "/changelog/#p_105",
    "pt": "Changelog",
    "t": 3,
    "c": "Version 0.1.6 is an old Reach release version."
  },
  {
    "objectID": "/changelog/#p_106",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/11/02: Allow {!rsh} APIs and {!rsh} Views to be specified without names."
  },
  {
    "objectID": "/changelog/#p_107",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/28: REACH_CONNECTOR_MODE no longer defaults to ETH when unset."
  },
  {
    "objectID": "/changelog/#p_108",
    "pt": "Changelog",
    "t": 3,
    "c": "Users are instead encouraged to run reach config to set a persistent default in their shell or supply REACH_CONNECTOR_MODE explicitly at the command-line and in scripts."
  },
  {
    "objectID": "/changelog/#p_109",
    "pt": "Changelog",
    "t": 3,
    "c": "Attempting to reach run|react|rpc-server|rpc-run|devnet without setting REACH_CONNECTOR_MODE in one's terminal will result in an error message being shown and execution aborted."
  },
  {
    "objectID": "/changelog/#p_110",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/28: Added reach config subcommand."
  },
  {
    "objectID": "/changelog/#p_111",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/28: The backend interface to deployed contracts was updated, so old contracts will not work with this version."
  },
  {
    "objectID": "/changelog/#p_112",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/28: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_113",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/20: Added {!rsh} decimals field for token minting."
  },
  {
    "objectID": "/changelog/#p_114",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/18: Added APIs via the {!rsh} API form."
  },
  {
    "objectID": "/changelog/#p_115",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/15: The backend interface to deployed contracts was updated, so old contracts will not work with this version."
  },
  {
    "objectID": "/changelog/#p_116",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/15: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_117",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/15: Algorand devnet updated to versions 3.0.1 and 2.6."
  },
  {
    "objectID": "/changelog/#p_118",
    "pt": "Changelog",
    "t": 3,
    "c": "Version 0.1.5 is an old Reach release version."
  },
  {
    "objectID": "/changelog/#p_119",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/15: Added {!js} setValidQueryWindow."
  },
  {
    "objectID": "/changelog/#p_120",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/11: The Solidity compiler has been upgraded to 0.8.9."
  },
  {
    "objectID": "/changelog/#p_121",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/08: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_122",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/08: {!rsh} parallelReduce is more strict in checking that the msg argument is present in the parameter list of {!rsh} case components, even when it is is bound to a {!rsh} null."
  },
  {
    "objectID": "/changelog/#p_123",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/08: Added {!rsh} getContract and {!rsh} getAddress."
  },
  {
    "objectID": "/changelog/#p_124",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/08: Added {!js} ctc.getContractAddress."
  },
  {
    "objectID": "/changelog/#p_125",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/05: Added {!rsh} Contract. Updated {!js} ctc.getInfo to return a {!rsh} Contract."
  },
  {
    "objectID": "/changelog/#p_126",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/04: Added {!rsh} unstrict."
  },
  {
    "objectID": "/changelog/#p_127",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/09/25: Reach clients will detect that they are attempting to publish in a race that they cannot win and switch to listening for the publication of another. This has the impact of frontends not being asked to sign transactions that cannot possibly succeed."
  },
  {
    "objectID": "/changelog/#p_128",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/09/25: Added {!rsh} didPublish()."
  },
  {
    "objectID": "/changelog/#p_129",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/09/24: Contracts do not store the Merkleization of the state, but store the state itself; this changes the interface to contracts, so this release cannot communicate with DApps compiled by older versions of Reach."
  },
  {
    "objectID": "/changelog/#p_130",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/09/16: Bare integers used as time arguments will throw a deprecation warning. Use {!rsh} relativeTime instead."
  },
  {
    "objectID": "/changelog/#p_131",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/09/16: The concept of deployment modes has been removed and the only available behavior is what was previously the firstMsg deployment mode."
  },
  {
    "objectID": "/changelog/#p_132",
    "pt": "Changelog",
    "t": 3,
    "c": "If you would like the old behavior, then you'll want to create a new participant, perhaps called Constructor, that exists simply to run {!rsh} Constructor.publish(); commit();, but we expect that almost no one actually wants the old behavior exactly. Instead, you probably want to select one of your existing participants and assign the first publication to them."
  },
  {
    "objectID": "/changelog/#p_133",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/09/16: The backend interface to deployed contracts was updated, so old contracts will not work with this version."
  },
  {
    "objectID": "/changelog/#p_134",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/09/16: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_135",
    "pt": "Changelog",
    "t": 3,
    "c": "Version 0.1.4 is an old Reach release version."
  },
  {
    "objectID": "/changelog/#p_136",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/09/15: {!rsh} muldiv added."
  },
  {
    "objectID": "/changelog/#p_137",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/09/08: Add --stop-after-eval and --verify-timeout options to reach compile."
  },
  {
    "objectID": "/changelog/#p_138",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/08/31: Removed {!js} getSignStrategy and {!js} setSignStrategy in favor of {!js} setWalletFallBack and {!js} walletFallback."
  },
  {
    "objectID": "/changelog/#p_139",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/08/31: Algorand devnet updated to versions 2.9.1 and 2.6."
  },
  {
    "objectID": "/changelog/#p_140",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/08/31: The reach command-line has changed:"
  },
  {
    "objectID": "/changelog/#p_141",
    "pt": "Changelog",
    "t": 3,
    "c": "All subcommands now support -h/--help switches, e.g. reach compile --help."
  },
  {
    "objectID": "/changelog/#p_142",
    "pt": "Changelog",
    "t": 3,
    "c": "The APP argument to reach init has been removed."
  },
  {
    "objectID": "/changelog/#p_143",
    "pt": "Changelog",
    "t": 3,
    "c": "The reach script now permits the use of subdirectories as arguments to certain subcommands, e.g. reach compile dir/index.rsh, but disallows parent directories (..) for reasons pertaining to Docker."
  },
  {
    "objectID": "/changelog/#p_144",
    "pt": "Changelog",
    "t": 3,
    "c": "Devnets have been consolidated into a single Dockerized network and container topology."
  },
  {
    "objectID": "/changelog/#p_145",
    "pt": "Changelog",
    "t": 3,
    "c": "The --use-existing-devnet flag has been deprecated and no longer has any effect."
  },
  {
    "objectID": "/changelog/#p_146",
    "pt": "Changelog",
    "t": 3,
    "c": "reach run will now automatically connect to a given connector's devnet when already present. Devnets which are not yet running will be launched as needed."
  },
  {
    "objectID": "/changelog/#p_147",
    "pt": "Changelog",
    "t": 3,
    "c": "reach down now halts ALL Dockerized Reach containers and devnets (i.e. it's no longer specific to a single project). Non-Reach Docker services are unaffected (see reach docker-reset)."
  },
  {
    "objectID": "/changelog/#p_148",
    "pt": "Changelog",
    "t": 3,
    "c": "reach docker-reset now prompts the user for confirmation before continuing since it kills and removes ALL containers (not just those related to Reach). The -y or --even-non-reach flags may be appended for non-interactive execution."
  },
  {
    "objectID": "/changelog/#p_149",
    "pt": "Changelog",
    "t": 3,
    "c": "An --await-background flag has been introduced to the reach devnet subcommand."
  },
  {
    "objectID": "/changelog/#p_150",
    "pt": "Changelog",
    "t": 3,
    "c": "The reach script has been simplified such that Makefile and docker-compose.yml files are no longer integral to its function. Accordingly, these files have been removed from reach scaffold's output. Authors of existing projects which contain unmodified Makefile or docker-compose.yml files are encouraged to remove them."
  },
  {
    "objectID": "/changelog/#p_151",
    "pt": "Changelog",
    "t": 3,
    "c": "Version 0.1.3 is an old Reach release version."
  },
  {
    "objectID": "/changelog/#p_152",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/08/31: Added {!js} acc.setStorageLimit to JavaScript standard library for Conflux."
  },
  {
    "objectID": "/changelog/#p_153",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/08/16: Allow {!rsh} continue in step in some cases."
  },
  {
    "objectID": "/changelog/#p_154",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/31: Added {!js} newTestAccounts, {!js} waitUntilSecs, and {!js} getNetworkSecs to JavaScript standard library."
  },
  {
    "objectID": "/changelog/#p_155",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/31: Updated {!js} onProgress type in JavaScript standard library."
  },
  {
    "objectID": "/changelog/#p_156",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/31: Added {!rsh} relativeTime, {!rsh} absoluteTime, {!rsh} relativeSecs, {!rsh} absoluteSecs, {!rsh} baseWaitTime, {!rsh} baseWaitSecs, and {!rsh} lastConsensusSecs to Reach, with support in {!rsh} wait and {!rsh} .timeout."
  },
  {
    "objectID": "/changelog/#p_157",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/22: {!js} numberToFixedPoint() and {!js} numberToInt() added."
  },
  {
    "objectID": "/changelog/#p_158",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/21: Renamed Ethereum devnet Docker image to devnet-eth."
  },
  {
    "objectID": "/changelog/#p_159",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/21: Renamed connector modes to use naming convention $NET-devnet, rather than exposing implementation."
  },
  {
    "objectID": "/changelog/#p_160",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/21: Ethereum contract bytecode verification changed to directly compare deployment data"
  },
  {
    "objectID": "/changelog/#p_161",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/20: {!rsh} Array.slice() added."
  },
  {
    "objectID": "/changelog/#p_162",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/19: {!rsh} Token.destroyed() added."
  },
  {
    "objectID": "/changelog/#p_163",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/15: Ethereum contract info (i.e. {!js} ctc.getInfo()) reduced to address only."
  },
  {
    "objectID": "/changelog/#p_164",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/14: Algorand contract info (i.e. {!js} ctc.getInfo()) reduced to application id only."
  },
  {
    "objectID": "/changelog/#p_165",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/14: Minted tokens must be destroyed by end of application."
  },
  {
    "objectID": "/changelog/#p_166",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/14: Token minting support added to Algorand."
  },
  {
    "objectID": "/changelog/#p_167",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/14: Token URL metadata increased to 96 bytes."
  },
  {
    "objectID": "/changelog/#p_168",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/14: Algorand {!rsh} digest switched to SHA256 (to save compute cost)."
  },
  {
    "objectID": "/changelog/#p_169",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/14: Algorand connector updated to AVM 0.9 (TEAL version 4)"
  },
  {
    "objectID": "/changelog/#p_170",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/14: Algorand devnet version updated to 2.7.1, plus DevMode patch"
  },
  {
    "objectID": "/changelog/#p_171",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/14: Algorand devnet image renamed to devnet-algo"
  },
  {
    "objectID": "/changelog/#p_172",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/14: version tagged"
  },
  {
    "objectID": "/changelog/#p_173",
    "pt": "Changelog",
    "t": 3,
    "c": "Version 0.1.2 is an old Reach release version."
  },
  {
    "objectID": "/changelog/#p_174",
    "pt": "Changelog",
    "t": 3,
    "c": "It is the last version that supports Algorand using TEAL3; if you deployed a contract on Algorand using Reach version 0.1.2, you will need to continue accessing it via the 0.1.2 version of the Reach standard library."
  },
  {
    "objectID": "/changelog/#p_175",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/09: {!rsh} .define component added to {!rsh} parallelReduce"
  },
  {
    "objectID": "/changelog/#p_176",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/08: Error code reference created"
  },
  {
    "objectID": "/changelog/#p_177",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/06/20: Token minting introduced, with implementation on ETH."
  },
  {
    "objectID": "/changelog/#p_178",
    "pt": "Changelog",
    "t": 3,
    "c": "... many interesting things ..."
  },
  {
    "objectID": "/changelog/#p_179",
    "pt": "Changelog",
    "t": 3,
    "c": "2020/09/01: version tagged"
  },
  {
    "objectID": "/changelog/#p_180",
    "pt": "Changelog",
    "t": 3,
    "c": "Version 0.1.1 was used prior to our documented release process."
  },
  {
    "objectID": "/changelog/#p_181",
    "pt": "Changelog",
    "t": 3,
    "c": "Version 0.1.0 was used prior to our documented release process."
  },
  {
    "objectID": "/frontend/#js_Contract",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "Contract"
  },
  {
    "objectID": "/frontend/#js_loadStdlib",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "loadStdlib"
  },
  {
    "objectID": "/frontend/#js_unsafeAllowMultipleStdlibs",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "unsafeAllowMultipleStdlibs"
  },
  {
    "objectID": "/frontend/#js_setWalletFallback",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "setWalletFallback"
  },
  {
    "objectID": "/frontend/#js_walletFallback",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "walletFallback"
  },
  {
    "objectID": "/frontend/#js_setProviderByName",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "setProviderByName"
  },
  {
    "objectID": "/frontend/#js_providerEnvByName",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "providerEnvByName"
  },
  {
    "objectID": "/frontend/#js_setProviderByEnv",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "setProviderByEnv"
  },
  {
    "objectID": "/frontend/#js_setProvider",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "setProvider"
  },
  {
    "objectID": "/frontend/#js_getProvider",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "getProvider"
  },
  {
    "objectID": "/frontend/#js_setMinMillisBetweenRequests",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "setMinMillisBetweenRequests"
  },
  {
    "objectID": "/frontend/#js_setCustomHttpEventHandler",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "setCustomHttpEventHandler"
  },
  {
    "objectID": "/frontend/#js_setSigningMonitor",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "setSigningMonitor"
  },
  {
    "objectID": "/frontend/#js_acc",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "acc"
  },
  {
    "objectID": "/frontend/#js_getDefaultAccount",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "getDefaultAccount"
  },
  {
    "objectID": "/frontend/#js_stdlib.getDefaultAccount",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.getDefaultAccount"
  },
  {
    "objectID": "/frontend/#js_newTestAccount",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "newTestAccount"
  },
  {
    "objectID": "/frontend/#js_stdlib.newTestAccount",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.newTestAccount"
  },
  {
    "objectID": "/frontend/#js_newTestAccounts",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "newTestAccounts"
  },
  {
    "objectID": "/frontend/#js_stdlib.newTestAccounts",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.newTestAccounts"
  },
  {
    "objectID": "/frontend/#js_newAccountFromSecret",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "newAccountFromSecret"
  },
  {
    "objectID": "/frontend/#js_newAccountFromMnemonic",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "newAccountFromMnemonic"
  },
  {
    "objectID": "/frontend/#js_createAccount",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "createAccount"
  },
  {
    "objectID": "/frontend/#js_fundFromFaucet",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "fundFromFaucet"
  },
  {
    "objectID": "/frontend/#js_canFundFromFaucet",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "canFundFromFaucet"
  },
  {
    "objectID": "/frontend/#js_connectAccount",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "connectAccount"
  },
  {
    "objectID": "/frontend/#js_networkAccount",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "networkAccount"
  },
  {
    "objectID": "/frontend/#js_getAddress",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "getAddress"
  },
  {
    "objectID": "/frontend/#js_setDebugLabel",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "setDebugLabel"
  },
  {
    "objectID": "/frontend/#js_tokenAccept",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "tokenAccept"
  },
  {
    "objectID": "/frontend/#js_tokenAccepted",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "tokenAccepted"
  },
  {
    "objectID": "/frontend/#js_tokenMetadata",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "tokenMetadata"
  },
  {
    "objectID": "/frontend/#js_balanceOf",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "balanceOf"
  },
  {
    "objectID": "/frontend/#js_stdlib.balanceOf",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.balanceOf"
  },
  {
    "objectID": "/frontend/#js_acc.balanceOf",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "acc.balanceOf"
  },
  {
    "objectID": "/frontend/#js_balancesOf",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "balancesOf"
  },
  {
    "objectID": "/frontend/#js_stdlib.balancesOf",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.balancesOf"
  },
  {
    "objectID": "/frontend/#js_acc.balancesOf",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "acc.balancesOf"
  },
  {
    "objectID": "/frontend/#js_minimumBalanceOf",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "minimumBalanceOf"
  },
  {
    "objectID": "/frontend/#js_transfer",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "transfer"
  },
  {
    "objectID": "/frontend/#js_setGasLimit",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "setGasLimit"
  },
  {
    "objectID": "/frontend/#js_setStorageLimit",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "setStorageLimit"
  },
  {
    "objectID": "/frontend/#js_ctc",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ctc"
  },
  {
    "objectID": "/frontend/#js_contract",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "contract"
  },
  {
    "objectID": "/frontend/#js_getInfo",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "getInfo"
  },
  {
    "objectID": "/frontend/#js_getContractAddress",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "getContractAddress"
  },
  {
    "objectID": "/frontend/#js_ctc.getABI",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ctc.getABI"
  },
  {
    "objectID": "/frontend/#js_deploy",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "deploy"
  },
  {
    "objectID": "/frontend/#js_attach",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "attach"
  },
  {
    "objectID": "/frontend/#js_ctc.participants",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ctc.participants"
  },
  {
    "objectID": "/frontend/#js_ctc.p",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ctc.p"
  },
  {
    "objectID": "/frontend/#js_withDisconnect",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "withDisconnect"
  },
  {
    "objectID": "/frontend/#js_stdlib.withDisconnect",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.withDisconnect"
  },
  {
    "objectID": "/frontend/#js_disconnect",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "disconnect"
  },
  {
    "objectID": "/frontend/#js_stdlib.disconnect",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.disconnect"
  },
  {
    "objectID": "/frontend/#js_ctc.apis",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ctc.apis"
  },
  {
    "objectID": "/frontend/#js_ctc.a",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ctc.a"
  },
  {
    "objectID": "/frontend/#js_ctc.safeApis",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ctc.safeApis"
  },
  {
    "objectID": "/frontend/#js_ctc.views",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ctc.views"
  },
  {
    "objectID": "/frontend/#js_ctc.v",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ctc.v"
  },
  {
    "objectID": "/frontend/#js_ctc.unsafeViews",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ctc.unsafeViews"
  },
  {
    "objectID": "/frontend/#js_ctc.getViews",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ctc.getViews"
  },
  {
    "objectID": "/frontend/#js_getViews",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "getViews"
  },
  {
    "objectID": "/frontend/#js_ctc.events",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ctc.events"
  },
  {
    "objectID": "/frontend/#js_ctc.e",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ctc.e"
  },
  {
    "objectID": "/frontend/#js_EventStream",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "EventStream"
  },
  {
    "objectID": "/frontend/#js_Event",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "Event"
  },
  {
    "objectID": "/frontend/#js_launchToken",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "launchToken"
  },
  {
    "objectID": "/frontend/#js_stdlib.launchToken",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.launchToken"
  },
  {
    "objectID": "/frontend/#js_stdlib.connector",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.connector"
  },
  {
    "objectID": "/frontend/#js_connector",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "connector"
  },
  {
    "objectID": "/frontend/#js_stdlib.getNetworkTime",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.getNetworkTime"
  },
  {
    "objectID": "/frontend/#js_getNetworkTime",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "getNetworkTime"
  },
  {
    "objectID": "/frontend/#js_stdlib.getNetworkSecs",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.getNetworkSecs"
  },
  {
    "objectID": "/frontend/#js_getNetworkSecs",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "getNetworkSecs"
  },
  {
    "objectID": "/frontend/#js_stdlib.getTimeSecs",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.getTimeSecs"
  },
  {
    "objectID": "/frontend/#js_getTimeSecs",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "getTimeSecs"
  },
  {
    "objectID": "/frontend/#js_stdlib.waitUntilTime",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.waitUntilTime"
  },
  {
    "objectID": "/frontend/#js_waitUntilTime",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "waitUntilTime"
  },
  {
    "objectID": "/frontend/#js_stdlib.waitUntilSecs",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.waitUntilSecs"
  },
  {
    "objectID": "/frontend/#js_waitUntilSecs",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "waitUntilSecs"
  },
  {
    "objectID": "/frontend/#js_stdlib.wait",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.wait"
  },
  {
    "objectID": "/frontend/#js_wait",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "wait"
  },
  {
    "objectID": "/frontend/#js_stdlib.setValidQueryWindow",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.setValidQueryWindow"
  },
  {
    "objectID": "/frontend/#js_setValidQueryWindow",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "setValidQueryWindow"
  },
  {
    "objectID": "/frontend/#js_stdlib.protect",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.protect"
  },
  {
    "objectID": "/frontend/#js_protect",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "protect"
  },
  {
    "objectID": "/frontend/#js_T_Null",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "T_Null"
  },
  {
    "objectID": "/frontend/#js_T_Bool",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "T_Bool"
  },
  {
    "objectID": "/frontend/#js_T_UInt",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "T_UInt"
  },
  {
    "objectID": "/frontend/#js_T_Bytes",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "T_Bytes"
  },
  {
    "objectID": "/frontend/#js_T_Address",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "T_Address"
  },
  {
    "objectID": "/frontend/#js_T_Array",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "T_Array"
  },
  {
    "objectID": "/frontend/#js_T_Tuple",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "T_Tuple"
  },
  {
    "objectID": "/frontend/#js_T_Object",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "T_Object"
  },
  {
    "objectID": "/frontend/#js_assert",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "assert"
  },
  {
    "objectID": "/frontend/#js_Array_set",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "Array_set"
  },
  {
    "objectID": "/frontend/#js_bigNumberify",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "bigNumberify"
  },
  {
    "objectID": "/frontend/#js_isBigNumber",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "isBigNumber"
  },
  {
    "objectID": "/frontend/#js_bigNumberToNumber",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "bigNumberToNumber"
  },
  {
    "objectID": "/frontend/#js_bigNumberToBigInt",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "bigNumberToBigInt"
  },
  {
    "objectID": "/frontend/#js_isHex",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "isHex"
  },
  {
    "objectID": "/frontend/#js_hexToBigNumber",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "hexToBigNumber"
  },
  {
    "objectID": "/frontend/#js_stringToHex",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stringToHex"
  },
  {
    "objectID": "/frontend/#js_bigNumberToHex",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "bigNumberToHex"
  },
  {
    "objectID": "/frontend/#js_uintToBytes",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "uintToBytes"
  },
  {
    "objectID": "/frontend/#js_bytesEq",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "bytesEq"
  },
  {
    "objectID": "/frontend/#js_digestEq",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "digestEq"
  },
  {
    "objectID": "/frontend/#js_addressEq",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "addressEq"
  },
  {
    "objectID": "/frontend/#js_digest",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "digest"
  },
  {
    "objectID": "/frontend/#js_randomUInt",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "randomUInt"
  },
  {
    "objectID": "/frontend/#js_hasRandom",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "hasRandom"
  },
  {
    "objectID": "/frontend/#js_stdlib.hasRandom",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.hasRandom"
  },
  {
    "objectID": "/frontend/#js_hasConsoleLogger",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "hasConsoleLogger"
  },
  {
    "objectID": "/frontend/#js_stdlib.hasConsoleLogger",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.hasConsoleLogger"
  },
  {
    "objectID": "/frontend/#js_parseFixedPoint",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "parseFixedPoint"
  },
  {
    "objectID": "/frontend/#js_numberToFixedPoint",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "numberToFixedPoint"
  },
  {
    "objectID": "/frontend/#js_parseInt",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "parseInt"
  },
  {
    "objectID": "/frontend/#js_numberToInt",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "numberToInt"
  },
  {
    "objectID": "/frontend/#js_add",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "add"
  },
  {
    "objectID": "/frontend/#js_sub",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "sub"
  },
  {
    "objectID": "/frontend/#js_mod",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "mod"
  },
  {
    "objectID": "/frontend/#js_mul",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "mul"
  },
  {
    "objectID": "/frontend/#js_div",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "div"
  },
  {
    "objectID": "/frontend/#js_eq",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "eq"
  },
  {
    "objectID": "/frontend/#js_ge",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ge"
  },
  {
    "objectID": "/frontend/#js_gt",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "gt"
  },
  {
    "objectID": "/frontend/#js_le",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "le"
  },
  {
    "objectID": "/frontend/#js_lt",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "lt"
  },
  {
    "objectID": "/frontend/#js_btoiLast8",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "btoiLast8"
  },
  {
    "objectID": "/frontend/#js_standardUnit",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "standardUnit"
  },
  {
    "objectID": "/frontend/#js_atomicUnit",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "atomicUnit"
  },
  {
    "objectID": "/frontend/#js_minimumBalance",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "minimumBalance"
  },
  {
    "objectID": "/frontend/#js_parseCurrency",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "parseCurrency"
  },
  {
    "objectID": "/frontend/#js_formatCurrency",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "formatCurrency"
  },
  {
    "objectID": "/frontend/#js_formatWithDecimals",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "formatWithDecimals"
  },
  {
    "objectID": "/frontend/#js_formatAddress",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "formatAddress"
  },
  {
    "objectID": "/frontend/#js_stdlib.formatAddress",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.formatAddress"
  },
  {
    "objectID": "/frontend/#js_ask",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ask"
  },
  {
    "objectID": "/frontend/#js_ask.ask",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ask.ask"
  },
  {
    "objectID": "/frontend/#js_ask.yesno",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ask.yesno"
  },
  {
    "objectID": "/frontend/#js_ask.done",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ask.done"
  },
  {
    "objectID": "/frontend/#js_test",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "test"
  },
  {
    "objectID": "/frontend/#js_test.shouldRun",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "test.shouldRun"
  },
  {
    "objectID": "/frontend/#js_test.shouldRunExac",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "test.shouldRunExac"
  },
  {
    "objectID": "/frontend/#js_test.chk",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "test.chk"
  },
  {
    "objectID": "/frontend/#js_test.chkErr",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "test.chkErr"
  },
  {
    "objectID": "/frontend/#js_test.one",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "test.one"
  },
  {
    "objectID": "/frontend/#js_test.makeChkExport",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "test.makeChkExport"
  },
  {
    "objectID": "/frontend/#js_test.run",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "test.run"
  },
  {
    "objectID": "/frontend/#term_API%20function",
    "pt": "Frontends",
    "t": 1,
    "c": "API function"
  },
  {
    "objectID": "/frontend/#term_view%20function",
    "pt": "Frontends",
    "t": 1,
    "c": "view function"
  },
  {
    "objectID": "/frontend/#term_EventStream",
    "pt": "Frontends",
    "t": 1,
    "c": "EventStream"
  },
  {
    "objectID": "/frontend/#term_isolated%20testing%20mode",
    "pt": "Frontends",
    "t": 1,
    "c": "isolated testing mode"
  },
  {
    "objectID": "/frontend/#term_bigNumberify",
    "pt": "Frontends",
    "t": 1,
    "c": "bigNumberify"
  },
  {
    "objectID": "/frontend/#term_isBigNumber",
    "pt": "Frontends",
    "t": 1,
    "c": "isBigNumber"
  },
  {
    "objectID": "/frontend/#term_bigNumberToNumber",
    "pt": "Frontends",
    "t": 1,
    "c": "bigNumberToNumber"
  },
  {
    "objectID": "/frontend/#term_bigNumberToBigInt",
    "pt": "Frontends",
    "t": 1,
    "c": "bigNumberToBigInt"
  },
  {
    "objectID": "/frontend/#term_hasRandom%20(Frontend)",
    "pt": "Frontends",
    "t": 1,
    "c": "hasRandom (Frontend)"
  },
  {
    "objectID": "/frontend/#term_hasConsoleLogger%20(Frontend)",
    "pt": "Frontends",
    "t": 1,
    "c": "hasConsoleLogger (Frontend)"
  },
  {
    "objectID": "/frontend/#term_standard%20unit",
    "pt": "Frontends",
    "t": 1,
    "c": "standard unit"
  },
  {
    "objectID": "/frontend/#term_atomic%20unit",
    "pt": "Frontends",
    "t": 1,
    "c": "atomic unit"
  },
  {
    "objectID": "/frontend/#term_atomic",
    "pt": "Frontends",
    "t": 1,
    "c": "atomic"
  },
  {
    "objectID": "/frontend/#ref-frontends",
    "pt": "Frontends",
    "t": 2,
    "c": "Frontends"
  },
  {
    "objectID": "/frontend/#ref-frontends-js",
    "pt": "Frontends",
    "t": 2,
    "c": "JavaScript"
  },
  {
    "objectID": "/frontend/#ref-frontends-js-types",
    "pt": "Frontends",
    "t": 2,
    "c": "Types"
  },
  {
    "objectID": "/frontend/#ref-frontends-js-loader",
    "pt": "Frontends",
    "t": 2,
    "c": "Loading the Standard Library"
  },
  {
    "objectID": "/frontend/#ref-frontends-js-provider",
    "pt": "Frontends",
    "t": 2,
    "c": "Provider Selection"
  },
  {
    "objectID": "/frontend/#provider-utilities",
    "pt": "Frontends",
    "t": 2,
    "c": "Provider Utilities"
  },
  {
    "objectID": "/frontend/#ref-frontends-js-acc",
    "pt": "Frontends",
    "t": 2,
    "c": "Creating an Account Handle"
  },
  {
    "objectID": "/frontend/#using-account-handles",
    "pt": "Frontends",
    "t": 2,
    "c": "Using Account Handles"
  },
  {
    "objectID": "/frontend/#ref-frontends-js-acc-eth",
    "pt": "Frontends",
    "t": 2,
    "c": "EVM-specific (Ethereum and Conflux)"
  },
  {
    "objectID": "/frontend/#ref-frontends-js-acc-cfx",
    "pt": "Frontends",
    "t": 2,
    "c": "Conflux-specific"
  },
  {
    "objectID": "/frontend/#ref-frontends-js-ctc",
    "pt": "Frontends",
    "t": 2,
    "c": "Creating a Contract Handle"
  },
  {
    "objectID": "/frontend/#running-participants--ctcparticipants---ctcp",
    "pt": "Frontends",
    "t": 2,
    "c": "Running Participants: ctc.participants, ctc.p"
  },
  {
    "objectID": "/frontend/#calling-api-functions--ctcapis---ctca",
    "pt": "Frontends",
    "t": 2,
    "c": "Calling API functions: ctc.apis, ctc.a"
  },
  {
    "objectID": "/frontend/#calling-view-functions--ctcviews---ctcv",
    "pt": "Frontends",
    "t": 2,
    "c": "Calling View functions: ctc.views, ctc.v"
  },
  {
    "objectID": "/frontend/#observing-events--ctcevents---ctce",
    "pt": "Frontends",
    "t": 2,
    "c": "Observing Events: ctc.events, ctc.e"
  },
  {
    "objectID": "/frontend/#launching-tokens",
    "pt": "Frontends",
    "t": 2,
    "c": "Launching tokens"
  },
  {
    "objectID": "/frontend/#ref-frontends-js-network",
    "pt": "Frontends",
    "t": 2,
    "c": "Network Utilities"
  },
  {
    "objectID": "/frontend/#ref-frontends-js-utils",
    "pt": "Frontends",
    "t": 2,
    "c": "Utilities"
  },
  {
    "objectID": "/frontend/#ref-frontends-js-ask",
    "pt": "Frontends",
    "t": 2,
    "c": "Reading User Input: ask"
  },
  {
    "objectID": "/frontend/#ref-frontends-js-test",
    "pt": "Frontends",
    "t": 2,
    "c": "Writing tests: test"
  },
  {
    "objectID": "/frontend/#p_0",
    "pt": "Frontends",
    "t": 3,
    "c": "This section describes the libraries provided by Reach version 0.1.11 to support developing frontends."
  },
  {
    "objectID": "/frontend/#p_1",
    "pt": "Frontends",
    "t": 3,
    "c": "Frontends are implemented in JavaScript or via the the RPC server and one of the languages with an RPC client: C Sharp, JavaScript, Go, and Python."
  },
  {
    "objectID": "/frontend/#p_2",
    "pt": "Frontends",
    "t": 3,
    "c": "You import the Reach JavaScript standard library by writing"
  },
  {
    "objectID": "/frontend/#p_3",
    "pt": "Frontends",
    "t": 3,
    "c": "When you use {!cmd} reach run or {!cmd} reach react, you don't need to do anything else."
  },
  {
    "objectID": "/frontend/#p_4",
    "pt": "Frontends",
    "t": 3,
    "c": "However, most developers when they stop learning and experimenting will use their own testing or deployment infrastructure. At that point, you should install the @reach-sh/stdlib npm package however you prefer installing packages. For example, you can use {!cmd} npm:"
  },
  {
    "objectID": "/frontend/#p_5",
    "pt": "Frontends",
    "t": 3,
    "c": "You only need to install the package directly if you are running your frontend without reach or using a tool like webpack for deployment."
  },
  {
    "objectID": "/frontend/#p_6",
    "pt": "Frontends",
    "t": 3,
    "c": "Whenever you are interacting with the Reach standard library, you need to remember the JavaScript representation of each of the Reach types:"
  },
  {
    "objectID": "/frontend/#p_7",
    "pt": "Frontends",
    "t": 3,
    "c": "For example, the Reach type {!rsh} MInt = Data({None: Null, Some: UInt}) inhabitant {!rsh} MInt.Some(42) is represented as {!rsh} ['Some', 42] in JavaScript."
  },
  {
    "objectID": "/frontend/#p_8",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns the standard library based on the provided {!js} env."
  },
  {
    "objectID": "/frontend/#p_9",
    "pt": "Frontends",
    "t": 3,
    "c": "In environments where the Reach standard library has implicit access to {!js} process.env, you may omit the {!js} env argument, in which case {!js} process.env will be used. If the standard library is being used with JavaScript bundlers like Webpack ---as it is with React, for example--- then Reach does not have implicit access to {!js} process.env. In such scenarios, we recommend that you call this function like so:"
  },
  {
    "objectID": "/frontend/#p_10",
    "pt": "Frontends",
    "t": 3,
    "c": "Alternatively, you can construct a custom object that has all of the environment keys and fields you need. Each network supports different keys; see Networks for details."
  },
  {
    "objectID": "/frontend/#p_11",
    "pt": "Frontends",
    "t": 3,
    "c": "As a special case, you may instead pass in the string 'ETH', 'ALGO', or 'CFX', to select the desired connector directly."
  },
  {
    "objectID": "/frontend/#p_12",
    "pt": "Frontends",
    "t": 3,
    "c": "By default, this method allows a user to load a standard library for a single connector. That is, this method may not be called multiple times with varying connectors. To bypass this restriction, use {!js} unsafeAllowMultipleStdlibs."
  },
  {
    "objectID": "/frontend/#p_13",
    "pt": "Frontends",
    "t": 3,
    "c": "Calling this function will lift the restriction that {!js} loadStdlib imposes on loading multiple standard libraries."
  },
  {
    "objectID": "/frontend/#p_14",
    "pt": "Frontends",
    "t": 3,
    "c": "The first thing you should do in a frontend is decide if you need to specify a provider."
  },
  {
    "objectID": "/frontend/#p_15",
    "pt": "Frontends",
    "t": 3,
    "c": "If you are building a browser-based DApp, then you may need to set up a fallback for users that do not have a wallet."
  },
  {
    "objectID": "/frontend/#p_16",
    "pt": "Frontends",
    "t": 3,
    "c": "When you call this function, if no browser wallet is available, then {!js} make will be called to construct one. The value that {!js} make should return differs between connectors."
  },
  {
    "objectID": "/frontend/#p_17",
    "pt": "Frontends",
    "t": 3,
    "c": "On Ethereum, it must match the interface of MetaMask. On Conflux, it must match the interface of ConfluxPortal. On Algorand, it must match the ARC-0011 standard."
  },
  {
    "objectID": "/frontend/#p_18",
    "pt": "Frontends",
    "t": 3,
    "c": "This function returns a value that may be passed to {!js} setWalletFallback to synthesize a wallet for use in browsers that do not supply a compliant wallet. Its customization options, {!js} opts, depend on the connector."
  },
  {
    "objectID": "/frontend/#p_19",
    "pt": "Frontends",
    "t": 3,
    "c": "On Ethereum and Conflux, it always errors and cannot provide a wallet."
  },
  {
    "objectID": "/frontend/#p_20",
    "pt": "Frontends",
    "t": 3,
    "c": "On Algorand, it can provide a wallet that directly connects to the Algorand network, like {!js} setProviderByName (& {!js} setProviderByEnv), but provide interactive signing. The network connection is specified via the providerEnv key, which may be a string (which is used as an argument to {!js} providerEnvByName) or an environment (which is used as an argument to {!js} setProviderByEnv). By default, signing is via an interactive browser window prompt, where the user repeatedly provides their mnemonic."
  },
  {
    "objectID": "/frontend/#p_21",
    "pt": "Frontends",
    "t": 3,
    "c": "If the key MyAlgoConnect is provided, and bound to the ALGO_MyAlgoConnect export of @reach-sh/stdlib, then MyAlgo will be used for signing. For example, this sets the wallet fallback to be MyAlgo used with Algorand TestNet:"
  },
  {
    "objectID": "/frontend/#p_22",
    "pt": "Frontends",
    "t": 3,
    "c": "If the key WalletConnect is provided, and bound to the ALGO_WalletConnect export of @reach-sh/stdlib, then WalletConnect is used to connect to the Algorand Wallet for signing. For example, this sets the wallet fallback to be WalletConnect and the Algorand TestNet:"
  },
  {
    "objectID": "/frontend/#p_23",
    "pt": "Frontends",
    "t": 3,
    "c": "Because these are fallbacks, you need to decide for your users which wallet they'll use, or make a user interface element to let them select which wallet fallback to use."
  },
  {
    "objectID": "/frontend/#p_24",
    "pt": "Frontends",
    "t": 3,
    "c": "If you are not building a browser-based DApp, you may want to set the network provider by using a standard name or using environment variables:"
  },
  {
    "objectID": "/frontend/#p_25",
    "pt": "Frontends",
    "t": 3,
    "c": "Supported provider names are: {!js} 'MainNet', {!js} 'TestNet', and {!js} 'LocalHost'."
  },
  {
    "objectID": "/frontend/#p_26",
    "pt": "Frontends",
    "t": 3,
    "c": "On Ethereum, {!js} 'MainNet' will connect to homestead, and {!js} 'TestNet' to ropsten. Multiple free API providers are used behind the scenes, as implemented by ethers.js."
  },
  {
    "objectID": "/frontend/#p_27",
    "pt": "Frontends",
    "t": 3,
    "c": "On Algorand, {!js} 'MainNet' will connect to MainNet, and {!js} 'TestNet' to TestNet. The free RandLabs API provider is used (https://algoexplorerapi.io)."
  },
  {
    "objectID": "/frontend/#p_28",
    "pt": "Frontends",
    "t": 3,
    "c": "Retrieve configuration information about providers by name."
  },
  {
    "objectID": "/frontend/#p_29",
    "pt": "Frontends",
    "t": 3,
    "c": "Select an API provider by supplying information about it."
  },
  {
    "objectID": "/frontend/#p_30",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} env is a record with string keys and string values."
  },
  {
    "objectID": "/frontend/#p_31",
    "pt": "Frontends",
    "t": 3,
    "c": "The environment object supports the same fields as {!js} stdlib.loadStdlib, which are documented in Networks."
  },
  {
    "objectID": "/frontend/#p_32",
    "pt": "Frontends",
    "t": 3,
    "c": "Finally, Reach provides low-level access to defining a network provider."
  },
  {
    "objectID": "/frontend/#p_33",
    "pt": "Frontends",
    "t": 3,
    "c": "Select an API provider by providing an object satisfying its interface."
  },
  {
    "objectID": "/frontend/#p_34",
    "pt": "Frontends",
    "t": 3,
    "c": "This function's API is considered unstable."
  },
  {
    "objectID": "/frontend/#p_35",
    "pt": "Frontends",
    "t": 3,
    "c": "On Ethereum, {!js} provider is an instance of {!js} ethers.provider. See: https://docs.ethers.io/v5/api/providers/provider/"
  },
  {
    "objectID": "/frontend/#p_36",
    "pt": "Frontends",
    "t": 3,
    "c": "On Algorand, {!js} provider is an object:"
  },
  {
    "objectID": "/frontend/#p_37",
    "pt": "Frontends",
    "t": 3,
    "c": "The {!js} algodClient and {!js} indexer values are as specified by the Algorand JS SDK. The {!js} signAndPostTxns function obeys ARC-0008."
  },
  {
    "objectID": "/frontend/#p_38",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_39",
    "pt": "Frontends",
    "t": 3,
    "c": "Promises a provider, matching the interface specified above."
  },
  {
    "objectID": "/frontend/#p_40",
    "pt": "Frontends",
    "t": 3,
    "c": "There are a few options to customize how Reach interacts with the Provider, however it is found."
  },
  {
    "objectID": "/frontend/#p_41",
    "pt": "Frontends",
    "t": 3,
    "c": "Setting this to a positive number forces outgoing requests to occur one at a time, and limits them to occur no more frequently than one request every ms milliseconds. This is only supported with certain connectors, and applies to all Providers created by the Reach standard library."
  },
  {
    "objectID": "/frontend/#p_42",
    "pt": "Frontends",
    "t": 3,
    "c": "Allows for the installation of a custom hook to observe outgoing HTTP requests. The handler h will be called before and after every request. The handler will be called with one argument: an object e. Inspection of e's fields should be considered an unstable API that may change over time. Currently, it has a field eventName which may be 'before', 'success', or 'error', as well as various other fields describing the HTTP event. This is only supported with certain connectors, and applies to all Providers created by the Reach standard library."
  },
  {
    "objectID": "/frontend/#p_43",
    "pt": "Frontends",
    "t": 3,
    "c": "Allows for the installation of a custom hook to observe signing requests. The handler h will be called on every request. The evt argument is an unstable object that describes the request. The pre argument is a Promise of an unstable object with details about the request, available after the request has been made. The post argument is a Promise of an unstable object with details about the completed request, available after the request has been completed."
  },
  {
    "objectID": "/frontend/#p_44",
    "pt": "Frontends",
    "t": 3,
    "c": "The second thing you should do in a frontend is create an account handle."
  },
  {
    "objectID": "/frontend/#p_45",
    "pt": "Frontends",
    "t": 3,
    "c": "In real applications, you will use access the user's account via their wallet with"
  },
  {
    "objectID": "/frontend/#p_46",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise for a Reach account abstraction for a \"default\" account on the consensus network. The meaning of \"default account\" varies between contexts. When running in the browser, the default account will be connected to a wallet. This promise will be rejected with an exception if no sensible default account can be accessed for the current context."
  },
  {
    "objectID": "/frontend/#p_47",
    "pt": "Frontends",
    "t": 3,
    "c": "But, when you are testing, you will use"
  },
  {
    "objectID": "/frontend/#p_48",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise for a Reach account abstraction for a new account on the consensus network with a given balance of network tokens. This can only be used in private testing scenarios, because it uses a private faucet to issue network tokens."
  },
  {
    "objectID": "/frontend/#p_49",
    "pt": "Frontends",
    "t": 3,
    "c": "This example from the Trust Fund workshop creates a startingBalance of 100 tokens, and then creates new accounts for the funder, receiver and bystander. Each get funded 100 tokens by setting each {!js} newTestAccount balance to the startingBalance value."
  },
  {
    "objectID": "/frontend/#p_50",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise for an array of {!js} howMany test accounts, using {!js} stdlib.newTestAccount."
  },
  {
    "objectID": "/frontend/#p_51",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_52",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} newTestAccounts sets up 3 new accounts (accA, accB, and accC) and loads them with the startingBalance of tokens so that they are usable for testing."
  },
  {
    "objectID": "/frontend/#p_53",
    "pt": "Frontends",
    "t": 3,
    "c": "Reach also provides some low-level tools for creating account handles. You will probably not use these."
  },
  {
    "objectID": "/frontend/#p_54",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise for a Reach account abstraction for an account on the consensus network specified by the given secret. The details of the secret encoding are specified uniquely to the consensus network."
  },
  {
    "objectID": "/frontend/#p_55",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_56",
    "pt": "Frontends",
    "t": 3,
    "c": "In this code, if the user chooses to not create a new account, then the DApp uses {!rsh} newAccountFromSecret to create a new account. The acc object {!rsh} awaits the user to input the secret and then sets the provided account to itself."
  },
  {
    "objectID": "/frontend/#p_57",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise for a Reach account abstraction for an account on the consensus network specified by the given mnemonic phrase. The details of the mnemonic phrase encoding are specified uniquely to the consensus network."
  },
  {
    "objectID": "/frontend/#p_58",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise for a Reach account abstraction for a new account on the consensus network. The account will have an empty balance of network tokens."
  },
  {
    "objectID": "/frontend/#p_59",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_60",
    "pt": "Frontends",
    "t": 3,
    "c": "This code creates an account for accD without a starting balance."
  },
  {
    "objectID": "/frontend/#p_61",
    "pt": "Frontends",
    "t": 3,
    "c": "Adds the given balance of network tokens to a Reach account abstraction. This can only be used in private testing scenarios, as it uses a private faucet to issue network tokens, as well as certain public TestNet scenarios. You can use {!js} canFundFromFaucet to check if {!js} fundFromFaucet can be used."
  },
  {
    "objectID": "/frontend/#p_62",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_63",
    "pt": "Frontends",
    "t": 3,
    "c": "This code creates an account and then funds that account with 100,000 network tokens from a private faucet. This is used in cases where funding from a normal faucet is difficult or impossible, such as when using large token quantities."
  },
  {
    "objectID": "/frontend/#p_64",
    "pt": "Frontends",
    "t": 3,
    "c": "A Promise that resolves to {!js} true if {!js} fundFromFaucet can be used, {!js} false if not."
  },
  {
    "objectID": "/frontend/#p_65",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_66",
    "pt": "Frontends",
    "t": 3,
    "c": "This React frontend from the Rock, Paper, Scissors tutorial checks if the account can be funded from a faucet using {!js} canFundFromFaucet. If the value returns true, then the account is funded by {!js} fundFromFaucet."
  },
  {
    "objectID": "/frontend/#p_67",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise for a Reach account abstraction for an existing account for the consensus network based on the connector-specific account specification provided by the {!js} networkAccount argument."
  },
  {
    "objectID": "/frontend/#p_68",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_69",
    "pt": "Frontends",
    "t": 3,
    "c": "Here, faucet is set to the previously coded ganacheProvider that has a {!js} getSigner method. This allows {!js} connectAccount to be able to connect faucet to {!js} setFaucet to provide the testing funds."
  },
  {
    "objectID": "/frontend/#p_70",
    "pt": "Frontends",
    "t": 3,
    "c": "Once you have an account handle, you can inspect it"
  },
  {
    "objectID": "/frontend/#p_71",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns the connector-specific account specification of a Reach account abstraction."
  },
  {
    "objectID": "/frontend/#p_72",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns the account's address as a string. The format of this string varies across connectors."
  },
  {
    "objectID": "/frontend/#p_73",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_74",
    "pt": "Frontends",
    "t": 3,
    "c": "In this snippet, {!js} getAddress obtains the addresses of Alice and Bob, which were created with the {!js} newTestAccounts method. Next, each address is logged so that participants can see both addresses. This can be useful to verify that the address receiving the payment is the correct address."
  },
  {
    "objectID": "/frontend/#p_75",
    "pt": "Frontends",
    "t": 3,
    "c": "An account may set a distinguishing label to use in debug logs. If no label is provided, then the first four digits of the account address will be used."
  },
  {
    "objectID": "/frontend/#p_76",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise that completes when the Reach account abstraction is ready to accept non-network tokens specified by the {!js} token. This does nothing on some consensus networks, but should always be used to ensure your frontend is blockchain agnostic."
  },
  {
    "objectID": "/frontend/#p_77",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise that returns if an account may accept a given token. This does nothing on some consensus networks, but should always be used to ensure your frontend is blockchain agnostic."
  },
  {
    "objectID": "/frontend/#p_78",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise of the metadata for a non-network token specified by the {!js} token."
  },
  {
    "objectID": "/frontend/#p_79",
    "pt": "Frontends",
    "t": 3,
    "c": "Promises the balance of network tokens (or non-network tokens if {!js} token is provided) held by given by a Reach account abstraction {!js} acc."
  },
  {
    "objectID": "/frontend/#p_80",
    "pt": "Frontends",
    "t": 3,
    "c": "Promises an array of balances that corresponds with the provided array of tokens, {!js} tokens, for a given Reach account {!js} acc. If {!js} tokens contains a {!js} null, the corresponding position in the output array will contain the account's balance of network tokens. This function is more efficient for getting multiple token balances than repeated calls to {!js} stdlib.balanceOf."
  },
  {
    "objectID": "/frontend/#p_81",
    "pt": "Frontends",
    "t": 3,
    "c": "Promises the portion of {!js} balanceOf(acc) which may not be transferred by the given account. Some networks restrict the usage of an account's funds. On networks that do not, this will always return zero."
  },
  {
    "objectID": "/frontend/#p_82",
    "pt": "Frontends",
    "t": 3,
    "c": "Performs a transfer of {!js} amount from {!js} from to {!js} to, which are accounts, such as those returned by {!js} connectAccount. If {!js} token is not provided, then the transfer is of network tokens; otherwise, it is of the designated non-network token. The returned {!js} Promise will only be resolved after the transfer completes."
  },
  {
    "objectID": "/frontend/#p_83",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_84",
    "pt": "Frontends",
    "t": 3,
    "c": "This transfers one (1) unit of the network token from Alice's account accAlice, to Bob's account accBob."
  },
  {
    "objectID": "/frontend/#p_85",
    "pt": "Frontends",
    "t": 3,
    "c": "When connected to an EVM-based consensus network, the standard library provides additional functionality."
  },
  {
    "objectID": "/frontend/#p_86",
    "pt": "Frontends",
    "t": 3,
    "c": "Modifies the gas limit for each transaction originating from the given account for the rest of the program. {!js} n must be a value that {!js} bigNumberify will accept."
  },
  {
    "objectID": "/frontend/#p_87",
    "pt": "Frontends",
    "t": 3,
    "c": "On EVM-based consensus networks, the Reach standard library will automatically estimate the required gas necessary to execute transactions, i.e. make publications. However, sometimes this estimation process is inaccurate, especially when Reach programs interact with remote objects. In those cases, it is sometimes useful to specify a particular gas limit. It is common on Ethereum to use gas limits like {!js} 5000000 in testing. If you do this, you should inform your clients that they should pay attention to the gas stipend issued."
  },
  {
    "objectID": "/frontend/#p_88",
    "pt": "Frontends",
    "t": 3,
    "c": "Here, there is a {!js} myGasLimit object created, which is set to {!js} 5000000. This is then applied to both the {!js} accAlice and {!js} accBob by using the {!js} setGasLimit method so that the maximum gas cost is set for each account."
  },
  {
    "objectID": "/frontend/#p_89",
    "pt": "Frontends",
    "t": 3,
    "c": "When connected to the Conflux consensus network, the standard library provides additional functionality."
  },
  {
    "objectID": "/frontend/#p_90",
    "pt": "Frontends",
    "t": 3,
    "c": "Modifies the storage limit for each transaction originating from the given account for the rest of the program. {!js} n must be a value that {!js} bigNumberify will accept."
  },
  {
    "objectID": "/frontend/#p_91",
    "pt": "Frontends",
    "t": 3,
    "c": "On the Conflux consensus networks, the Reach standard library will automatically use a storage limit of 2024 to execute transactions, i.e. make publications. Storage fees are refunded once the storage space is no longer used by the contract. The {!js} setStorageLimit function allows you to choose a different storage limit, as you see fit."
  },
  {
    "objectID": "/frontend/#p_92",
    "pt": "Frontends",
    "t": 3,
    "c": "The third thing you should do in a frontend is create a contract handle, so you can actually interact with your Reach program."
  },
  {
    "objectID": "/frontend/#p_93",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Reach contract handle based on the {!js} bin argument provided with access to the account {!js} acc. This {!js} bin argument is the module produced by {!cmd} reach compile."
  },
  {
    "objectID": "/frontend/#p_94",
    "pt": "Frontends",
    "t": 3,
    "c": "If {!js} info is provided, it must be a {!rsh} Contract value, or a {!js} Promise that eventually yields a {!rsh} Contract value. When provided, Reach will verify that the contract given actually matches the bytecode produced by {!cmd} reach compile and will error if it is different in any way."
  },
  {
    "objectID": "/frontend/#p_95",
    "pt": "Frontends",
    "t": 3,
    "c": "Typically, the deployer of a contract will not provide {!js} info, while users of a contract will. In an automated, single instance program, {!rsh} ctc.getInfo() is typically used to acquire {!js} info; while in non-automated programs, an application uses out-of-band communication, such as an external database or user input, to acquire the {!js} info argument."
  },
  {
    "objectID": "/frontend/#p_96",
    "pt": "Frontends",
    "t": 3,
    "c": "The first publishing participant will attempt to deploy a contract for an application. If {!js} info was provided, an error will be thrown. This deployment can only happen one time, so subsequent attempts will fail with an error."
  },
  {
    "objectID": "/frontend/#p_97",
    "pt": "Frontends",
    "t": 3,
    "c": "This function may emit warnings if there is any danger, risk, or subtlety to using this contract on your chosen consensus network. You can omit this warning by setting {!cmd} REACH_NO_WARN, but we recommend that you do not."
  },
  {
    "objectID": "/frontend/#p_98",
    "pt": "Frontends",
    "t": 3,
    "c": "This function does not block."
  },
  {
    "objectID": "/frontend/#p_99",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise for a {!rsh} Contract value that may be given to {!js} contract to construct a Reach contract handle for this contract. This object may be stringified with {!js} JSON.stringify for printing and parsed again with {!js} JSON.parse without any loss of information."
  },
  {
    "objectID": "/frontend/#p_100",
    "pt": "Frontends",
    "t": 3,
    "c": "If {!js} ctc will deploy the program, then the Promise will only be resolved after the contract is actually deployed on the network, thus you cannot block on this Promise with {!js} await until after the first {!rsh} publish has occurred. Awaiting {!rsh} getInfo too early may cause your program to enter a state of deadlock. It is safer to make an {!rsh} interact function that receives {!rsh} getContract() from the Reach program."
  },
  {
    "objectID": "/frontend/#p_101",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise for the {!js} Address of the connected Reach contract."
  },
  {
    "objectID": "/frontend/#p_102",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns the ABI to the contract in a connector-specific format. When the {!js} showFull argument is not {!js} true, internal implementation details are omitted."
  },
  {
    "objectID": "/frontend/#p_103",
    "pt": "Frontends",
    "t": 3,
    "c": "This deprecated function is an abbreviation of {!js} acc.contract(bin)."
  },
  {
    "objectID": "/frontend/#p_104",
    "pt": "Frontends",
    "t": 3,
    "c": "This deprecated function is an abbreviation of {!js} acc.contract(bin, info)."
  },
  {
    "objectID": "/frontend/#p_105",
    "pt": "Frontends",
    "t": 3,
    "c": "Contract handles provide access to the {!rsh} Participants of the compiled backend, {!js} bin, that they were constructed with."
  },
  {
    "objectID": "/frontend/#p_106",
    "pt": "Frontends",
    "t": 3,
    "c": "An object where the keys are the participant names and the values are functions that accept an interact object and return a Promise that completes when the participant ends."
  },
  {
    "objectID": "/frontend/#p_107",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} acc.contract(backend).p.Alice(io) is equivalent to {!js} backend.Alice(acc.contract(backend), io), but does not require duplication of the {!js} backend component."
  },
  {
    "objectID": "/frontend/#p_108",
    "pt": "Frontends",
    "t": 3,
    "c": "When you run a participant, you may want to run it up until a particular {!rsh} interact function and then disconnect. If so, then you should use"
  },
  {
    "objectID": "/frontend/#p_109",
    "pt": "Frontends",
    "t": 3,
    "c": "withDisconnect calls the given function f such that any calls to disconnect within f will cause withDisconnect to return immediately. withDisconnect returns the value passed to disconnect."
  },
  {
    "objectID": "/frontend/#p_110",
    "pt": "Frontends",
    "t": 3,
    "c": "disconnect causes the surrounding call to withDisconnect to immediately return t. disconnect must be called from within a function passed to withDisconnect, otherwise an exception will be thrown."
  },
  {
    "objectID": "/frontend/#p_111",
    "pt": "Frontends",
    "t": 3,
    "c": "withDisconnect and disconnect are intended as a utility to exit participant frontends early, like such:"
  },
  {
    "objectID": "/frontend/#p_112",
    "pt": "Frontends",
    "t": 3,
    "c": "Once an account disconnects from the contract, they cannot rejoin as the same participant."
  },
  {
    "objectID": "/frontend/#p_113",
    "pt": "Frontends",
    "t": 3,
    "c": "Contract handles provide access to the {!rsh} APIs of the compiled backend, {!js} bin, that they were constructed with."
  },
  {
    "objectID": "/frontend/#p_114",
    "pt": "Frontends",
    "t": 3,
    "c": "An object that mirrors the API hierarchy, so if X.Y is an API, then {!js} ctc.apis.X.Y is an API function. An API function accepts the arguments of the API and returns a {!js} Promise that results in the value of the API. This function may throw an error if the API is not available."
  },
  {
    "objectID": "/frontend/#p_115",
    "pt": "Frontends",
    "t": 3,
    "c": "If an API was specified without an {!rsh} apiName, for example {!rsh} API({ cast: Fun([String], Null)}), it may be accessed by its property name:"
  },
  {
    "objectID": "/frontend/#p_116",
    "pt": "Frontends",
    "t": 3,
    "c": "This object is the same as {!js} ctc.apis except the API functions return a {!rsh} Maybe value. If the call fails, then {!js} ['None', null] will be returned. If the call succeeds, the return value will be wrapped with {!js} Some, e.g. {!js} ['Some', 4]."
  },
  {
    "objectID": "/frontend/#p_117",
    "pt": "Frontends",
    "t": 3,
    "c": "Contract handles provide access to the {!rsh} Views of the compiled backend, {!js} bin, that they were constructed with."
  },
  {
    "objectID": "/frontend/#p_118",
    "pt": "Frontends",
    "t": 3,
    "c": "Views are defined in application initialization and then they are set in consensus steps. Both of these steps are in Reach. This section is about accessing them in JavaScript frontends."
  },
  {
    "objectID": "/frontend/#p_119",
    "pt": "Frontends",
    "t": 3,
    "c": "An object that mirrors the view hierarchy, so if X.Y is a view, then {!js} ctc.views.X.Y is a view function. A view function accepts the arguments of the view and returns a {!js} Promise that results in the value of the view wrapped in a {!rsh} Maybe type (because the view may not be bound). For example, if NFT.owner is a view with no arguments that represents the {!rsh} Address that owns an NFT, then {!js} await ctc.v.NFT.owner() is either {!js} ['Some', Owner] or {!js} ['None', null]."
  },
  {
    "objectID": "/frontend/#p_120",
    "pt": "Frontends",
    "t": 3,
    "c": "If a View was specified without a {!rsh} viewName, for example {!rsh} View({ owner: Address }), it may be accessed by its property name:"
  },
  {
    "objectID": "/frontend/#p_121",
    "pt": "Frontends",
    "t": 3,
    "c": "This object is the same as {!js} ctc.views except the value of the view is not wrapped in a {!rsh} Maybe type. If a view is set, the value will be returned as is, without being wrapped in {!rsh} Some. If a view is not set, an error will be thrown."
  },
  {
    "objectID": "/frontend/#p_122",
    "pt": "Frontends",
    "t": 3,
    "c": "This deprecated function is an abbreviation of {!js} ctc.views."
  },
  {
    "objectID": "/frontend/#p_123",
    "pt": "Frontends",
    "t": 3,
    "c": "Contract handles provide access to the {!rsh} Events of the compiled backend, {!js} bin, that they were constructed with."
  },
  {
    "objectID": "/frontend/#p_124",
    "pt": "Frontends",
    "t": 3,
    "c": "An object that mirrors the event hierarchy, so if X.Y is an event, then {!js} ctc.events.X.Y is an EventStream. An EventStream supports the following operations for a given {!rsh} Event:"
  },
  {
    "objectID": "/frontend/#p_125",
    "pt": "Frontends",
    "t": 3,
    "c": "where"
  },
  {
    "objectID": "/frontend/#p_126",
    "pt": "Frontends",
    "t": 3,
    "c": "An {!js} Event is instantiated with it's corresponding type declared in Reach."
  },
  {
    "objectID": "/frontend/#p_127",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} next will wait for the next {!rsh} Event to occur, returning the time the event occurred and the arguments to the event."
  },
  {
    "objectID": "/frontend/#p_128",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} seek will set the internal time of the EventStream to the given argument. The EventStream will use this time as the minimum bound when searching for {!rsh} Events."
  },
  {
    "objectID": "/frontend/#p_129",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} seekNow will set the internal time of the EventStream to the latest network time. The EventStream will use this time as the minimum bound when searching for {!rsh} Events."
  },
  {
    "objectID": "/frontend/#p_130",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} lastTime will return the last network time that an {!rsh} Event was emitted."
  },
  {
    "objectID": "/frontend/#p_131",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} monitor accepts a function of type {!js} Event<T> => void as an argument. The provided function will be called whenever the {!rsh} Event occurs."
  },
  {
    "objectID": "/frontend/#p_132",
    "pt": "Frontends",
    "t": 3,
    "c": "The standard library provides a convenient way to launch new non-network tokens."
  },
  {
    "objectID": "/frontend/#p_133",
    "pt": "Frontends",
    "t": 3,
    "c": "Launches a non-network token with the given {!js} name and unit symbol {!js} sym. Launched on the network by {!js} accCreator."
  },
  {
    "objectID": "/frontend/#p_134",
    "pt": "Frontends",
    "t": 3,
    "c": "Possible options to provide in {!js} opts include:"
  },
  {
    "objectID": "/frontend/#p_135",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} decimals The number of digits to use after the decimal point when displaying the non-network token. The default is the same as the network token."
  },
  {
    "objectID": "/frontend/#p_136",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} supply The total number of atomic token units to create. The default is the maximum possible on the network."
  },
  {
    "objectID": "/frontend/#p_137",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} url A URL where more information about the non-network token can be retrieved. The default is no url."
  },
  {
    "objectID": "/frontend/#p_138",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} metadataHash A hash of some metadata that is relevant to your non-network token. The default is no metadata hash."
  },
  {
    "objectID": "/frontend/#p_139",
    "pt": "Frontends",
    "t": 3,
    "c": "Algorand-only options:"
  },
  {
    "objectID": "/frontend/#p_140",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} clawback Address that can claw back holdings of the token. The default is no clawback address."
  },
  {
    "objectID": "/frontend/#p_141",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} note A {!js} Uint8Array for the Note field of the asset creation transaction."
  },
  {
    "objectID": "/frontend/#p_142",
    "pt": "Frontends",
    "t": 3,
    "c": "For more information on Algorand-only options, see https://developer.algorand.org/docs/get-details/transactions/transactions/#asset-parameters."
  },
  {
    "objectID": "/frontend/#p_143",
    "pt": "Frontends",
    "t": 3,
    "c": "The standard library provides a number of utilities functions for interacting with the connected network."
  },
  {
    "objectID": "/frontend/#p_144",
    "pt": "Frontends",
    "t": 3,
    "c": "Represents the {!js} Connector the {!js} stdlib uses."
  },
  {
    "objectID": "/frontend/#p_145",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise for the current consensus network time, represented as a BigNumber."
  },
  {
    "objectID": "/frontend/#p_146",
    "pt": "Frontends",
    "t": 3,
    "c": "This example obtains the starting time of the DApp by using {!js} getNetworkTime. The network time is then written to the console to provide the information to users. Then, it is converted to seconds using {!js} getTimeSecs, which is also written to the console."
  },
  {
    "objectID": "/frontend/#p_147",
    "pt": "Frontends",
    "t": 3,
    "c": "Like {!js} stdlib.getNetworkTime, but returns a network seconds Promise."
  },
  {
    "objectID": "/frontend/#p_148",
    "pt": "Frontends",
    "t": 3,
    "c": "Takes a network time, such as a value returned from {!js} stdlib.getNetworkTime, and converts it into network seconds."
  },
  {
    "objectID": "/frontend/#p_149",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise that will only be resolved after the specified consensus network time. In isolated testing modes, this will also force time to pass on the network, usually by sending trivial transactions. An isolated testing mode is a REACH_CONNECTOR_MODE that matches $NET-devnet for all valid $NET, or when REACH_ISOLATED_NETWORK is set."
  },
  {
    "objectID": "/frontend/#p_150",
    "pt": "Frontends",
    "t": 3,
    "c": "You may provide an optional {!js} onProgress callback, used for reporting progress, which may be called many times up until the specified network time. It will receive an object with keys {!js} current and {!js} target,"
  },
  {
    "objectID": "/frontend/#p_151",
    "pt": "Frontends",
    "t": 3,
    "c": "Like {!js} stdlib.waitUntilSecs, but waits for a certain network seconds deadline."
  },
  {
    "objectID": "/frontend/#p_152",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise that will only be resolved after the specified time delta has elapsed. The expression {!js} await stdlib.wait(delta, onProgress) is the same as {!js} await stdlib.waitUntilTime(add(await stdlib.getNetworkTime(), delta), onProgress). As with {!js} stdlib.waitUntilTime, the {!js} onProgress callback is optional."
  },
  {
    "objectID": "/frontend/#p_153",
    "pt": "Frontends",
    "t": 3,
    "c": "One use case example of {!js} stdlib.wait is to emit an event and then call stdlib.wait(delta, onProgress) to ensure the event has time to complete. (In the example below, wt is shorthand for \"wait time\".)"
  },
  {
    "objectID": "/frontend/#p_154",
    "pt": "Frontends",
    "t": 3,
    "c": "Although, it is possible to use {!js} wait to give an event time to execute, it is a better practice to create an explicit synchronization with an event or instruct the deployer to communicate with API callers off-chain."
  },
  {
    "objectID": "/frontend/#p_155",
    "pt": "Frontends",
    "t": 3,
    "c": "Sets the maximum width of the query windows used to query the network for event logs. The value {!js} true indicates that no window size should be used, and queries may span arbitrarily large window sizes. While each connector has a default value that works for most common cases, tweaking this setting may be useful when dealing with layer two networks or custom endpoints that are more restrictive than normal nodes on the network."
  },
  {
    "objectID": "/frontend/#p_156",
    "pt": "Frontends",
    "t": 3,
    "c": "The standard library provides a number of utilities functions for interacting with JavaScript representations of Reach values."
  },
  {
    "objectID": "/frontend/#p_157",
    "pt": "Frontends",
    "t": 3,
    "c": "Asserts that value {!js} x has Reach type {!js} t. An exception is thrown if this is not the case."
  },
  {
    "objectID": "/frontend/#p_158",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_159",
    "pt": "Frontends",
    "t": 3,
    "c": "This code tests to see if variables that are supposed to be {!js} null return {!js} null. The first expect asserts that {!js} null has Reach type {!js} T_Null. The next expect asserts that {!js} undefined has Reach type {!js} T_Null."
  },
  {
    "objectID": "/frontend/#p_160",
    "pt": "Frontends",
    "t": 3,
    "c": "Each of these represent the corresponding Reach type."
  },
  {
    "objectID": "/frontend/#p_161",
    "pt": "Frontends",
    "t": 3,
    "c": "Throws an exception if not given {!js} true."
  },
  {
    "objectID": "/frontend/#p_162",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_163",
    "pt": "Frontends",
    "t": 3,
    "c": "This code checks the arguments passed to the {!cmd} ./reach run command. Lines 6 and 7 will not throw an exception if {!cmd} ./reach run index hello \"Mr. Postman\" is run in the terminal, because {!js} process.argv will return the following array:"
  },
  {
    "objectID": "/frontend/#p_164",
    "pt": "Frontends",
    "t": 3,
    "c": "Thereby making {!js} process.argv[2] === 'Hello' and {!js} process.argv[3] === 'Mr. Postman' to evaluate to {!js} true."
  },
  {
    "objectID": "/frontend/#p_165",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a new array identical to {!js} arr, except that index {!js} idx is {!js} val."
  },
  {
    "objectID": "/frontend/#p_166",
    "pt": "Frontends",
    "t": 3,
    "c": "bigNumberify converts a JavaScript number to a BigNumber, the JavaScript representation of Reach's {!rsh} UInt."
  },
  {
    "objectID": "/frontend/#p_167",
    "pt": "Frontends",
    "t": 3,
    "c": "isBigNumber checks if its input is a BigNumber."
  },
  {
    "objectID": "/frontend/#p_168",
    "pt": "Frontends",
    "t": 3,
    "c": "bigNumberToNumber transparently applies {!js} bigNumberify to its argument and returns a JavaScript number."
  },
  {
    "objectID": "/frontend/#p_169",
    "pt": "Frontends",
    "t": 3,
    "c": "bigNumberToBigInt transparently applies {!js} bigNumberify to its argument and returns a JavaScript bigint."
  },
  {
    "objectID": "/frontend/#p_170",
    "pt": "Frontends",
    "t": 3,
    "c": "These are additional conversion and comparison utilities."
  },
  {
    "objectID": "/frontend/#p_171",
    "pt": "Frontends",
    "t": 3,
    "c": "Hashes the value."
  },
  {
    "objectID": "/frontend/#p_172",
    "pt": "Frontends",
    "t": 3,
    "c": "The ExampleeExampleeExampleeExamplee is a string of the Reach type that {!rsh} digest turns into a hash. The maximum string length that can be digested in this example is set to 32 bytes."
  },
  {
    "objectID": "/frontend/#p_173",
    "pt": "Frontends",
    "t": 3,
    "c": "Generates random bits as a {!rsh} UInt. The number of bits generated depends on the particular consensus network."
  },
  {
    "objectID": "/frontend/#p_174",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_175",
    "pt": "Frontends",
    "t": 3,
    "c": "This code is used to generate random bits as a {!rsh} UInt as the unique identifier of Alice stored as id on line 92. Line 93 reveals the id in the console and line 94 returns the id."
  },
  {
    "objectID": "/frontend/#p_176",
    "pt": "Frontends",
    "t": 3,
    "c": "hasRandom (Frontend) A value suitable for use as a participant interact interface requiring a random function, such as {!rsh} hasRandom. Reach does not natively support randomness and leaves random number generation to the frontend implementation. This value is provided out of convenience; it is not mandatory to use this implementation."
  },
  {
    "objectID": "/frontend/#p_177",
    "pt": "Frontends",
    "t": 3,
    "c": "hasConsoleLogger (Frontend) A value suitable for use as a participant interact interface requiring a log function, such as {!rsh} hasConsoleLogger. The {!js} log function provided takes an arbitrary amount of elements and prints them to stdout. This value is provided out of convenience; it is not mandatory to use this implementation."
  },
  {
    "objectID": "/frontend/#p_178",
    "pt": "Frontends",
    "t": 3,
    "c": "Parses a {!rsh} FixedPoint number into a JavaScript number."
  },
  {
    "objectID": "/frontend/#p_179",
    "pt": "Frontends",
    "t": 3,
    "c": "Parses a JavaScript number into a {!rsh} FixedPoint."
  },
  {
    "objectID": "/frontend/#p_180",
    "pt": "Frontends",
    "t": 3,
    "c": "Parses a signed {!rsh} Int into a JavaScript number."
  },
  {
    "objectID": "/frontend/#p_181",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_182",
    "pt": "Frontends",
    "t": 3,
    "c": "In this example, {!js} stdlib's {!js} parseInt takes an object as its parameter and returns a number. The object in this snippet has a {!js} sign property, and an {!js} i property, which contains the number to parse."
  },
  {
    "objectID": "/frontend/#p_183",
    "pt": "Frontends",
    "t": 3,
    "c": "Parses a JavaScript number into an {!rsh} Int."
  },
  {
    "objectID": "/frontend/#p_184",
    "pt": "Frontends",
    "t": 3,
    "c": "Integer arithmetic on {!rsh} UInt."
  },
  {
    "objectID": "/frontend/#p_185",
    "pt": "Frontends",
    "t": 3,
    "c": "Integer comparisons on {!rsh} UInt."
  },
  {
    "objectID": "/frontend/#p_186",
    "pt": "Frontends",
    "t": 3,
    "c": "Converts the last 8 bytes of a string to an {!rsh} UInt."
  },
  {
    "objectID": "/frontend/#p_187",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_188",
    "pt": "Frontends",
    "t": 3,
    "c": "This code converts the last 8 bytes of b1, b2, b3 and b4 to an {!rsh} UInt on lines 22, 23, 24 and 25, respectively. After which, the {!js} mod method is called on the respective results."
  },
  {
    "objectID": "/frontend/#p_189",
    "pt": "Frontends",
    "t": 3,
    "c": "If the string is less than 8 bytes long, this function will convert the entire string to an {!rsh} UInt."
  },
  {
    "objectID": "/frontend/#p_190",
    "pt": "Frontends",
    "t": 3,
    "c": "The following exports are for dealing with network tokens."
  },
  {
    "objectID": "/frontend/#p_191",
    "pt": "Frontends",
    "t": 3,
    "c": "These functions handle amounts in a network's standard unit and its atomic unit. A standard unit is the network token unit most commonly associated with a network. For example, the standard unit of Ethereum is ETH. An atomic unit is the smallest unit of measure for the standard unit. For example, the atomic unit of Ethereum is WEI. An atomic unit is atomic, which means it cannot be divided into smaller units."
  },
  {
    "objectID": "/frontend/#p_192",
    "pt": "Frontends",
    "t": 3,
    "c": "Some consensus networks, typically those with proof-of-stake, have minimum balances on their accounts, so this is exposed as {!js} minimumBalance."
  },
  {
    "objectID": "/frontend/#p_193",
    "pt": "Frontends",
    "t": 3,
    "c": "Because there are 1,000,000,000,000,000,000 WEI in 1 ETH, BigNumber is used to represet values in WEI."
  },
  {
    "objectID": "/frontend/#p_194",
    "pt": "Frontends",
    "t": 3,
    "c": "Quantities of a network token should always be passed into Reach in the token's atomic unit."
  },
  {
    "objectID": "/frontend/#p_195",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} stdlib.bigNumberify is transparently applied to {!js} stdlib.formatCurrency's and {!js} stdlib.formatWithDecimals's first arguments."
  },
  {
    "objectID": "/frontend/#p_196",
    "pt": "Frontends",
    "t": 3,
    "c": "Formats the address in the way the user would expect to see it:"
  },
  {
    "objectID": "/frontend/#p_197",
    "pt": "Frontends",
    "t": 3,
    "c": "On Ethereum, it is a hex-encoded string starting with {!js} '0x'."
  },
  {
    "objectID": "/frontend/#p_198",
    "pt": "Frontends",
    "t": 3,
    "c": "On Algorand, it is a base32-encoded string, ending with the checksum."
  },
  {
    "objectID": "/frontend/#p_199",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_200",
    "pt": "Frontends",
    "t": 3,
    "c": "This code is a {!rsh} function that takes in addr on line 32. Line 33 formats addr based on the consensus network's encoding. On line 35, the formatted addr (now stored as address) is revealed to the user in the console."
  },
  {
    "objectID": "/frontend/#p_201",
    "pt": "Frontends",
    "t": 3,
    "c": "There is no corresponding {!js} parseAddress function because the user-friendly form is also accepted from the frontend in all places that Reach expects an address."
  },
  {
    "objectID": "/frontend/#p_202",
    "pt": "Frontends",
    "t": 3,
    "c": "The Reach JavaScript standard library provides the ask object for constructing console interfaces to your frontends."
  },
  {
    "objectID": "/frontend/#p_203",
    "pt": "Frontends",
    "t": 3,
    "c": "You do not need to use this module. It is simply provided as a convenience for when you are starting out testing and building simple DApps."
  },
  {
    "objectID": "/frontend/#p_204",
    "pt": "Frontends",
    "t": 3,
    "c": "It provides the following exports:"
  },
  {
    "objectID": "/frontend/#p_205",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} ask.ask is an asynchronous function that asks a question on the console and returns a Promise for the first result that its second argument does not error on."
  },
  {
    "objectID": "/frontend/#p_206",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} ask.yesno is an argument appropriate to give as the second argument to {!js} ask.ask that parses \"Yes\"/\"No\" answers."
  },
  {
    "objectID": "/frontend/#p_207",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} ask.done indicates that no more questions will be asked."
  },
  {
    "objectID": "/frontend/#p_208",
    "pt": "Frontends",
    "t": 3,
    "c": "Read the Interaction and Independence section the Rock, Paper, Scissors tutorial for a longer use case example of the {!js} ask object."
  },
  {
    "objectID": "/frontend/#p_209",
    "pt": "Frontends",
    "t": 3,
    "c": "The Reach JavaScript standard library provides the test object for constructing automated tests."
  },
  {
    "objectID": "/frontend/#p_210",
    "pt": "Frontends",
    "t": 3,
    "c": "You do not need to use this module. We think it is a great way to write tests, but it doesn't do anything you couldn't do on your own or with any other of the excellent JavaScript testing frameworks."
  },
  {
    "objectID": "/frontend/#p_211",
    "pt": "Frontends",
    "t": 3,
    "c": "On initialization, {!js} test will read the process's command-line arguments and interpret them as a list of tests to run. If no arguments are given, then all tests will be run."
  },
  {
    "objectID": "/frontend/#p_212",
    "pt": "Frontends",
    "t": 3,
    "c": "If you want to inspect this set of tests-to-run, then you can use the functions:"
  },
  {
    "objectID": "/frontend/#p_213",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns {!js} true if x is in the set of tests or if none were given."
  },
  {
    "objectID": "/frontend/#p_214",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns {!js} true if x is in the set of tests."
  },
  {
    "objectID": "/frontend/#p_215",
    "pt": "Frontends",
    "t": 3,
    "c": "The main way to write tests is to call these functions:"
  },
  {
    "objectID": "/frontend/#p_216",
    "pt": "Frontends",
    "t": 3,
    "c": "Runs a check named id that does not fail if actual is the same as expected. Records additional information in the log from xtra."
  },
  {
    "objectID": "/frontend/#p_217",
    "pt": "Frontends",
    "t": 3,
    "c": "Runs a check named id that expects f to throw an exception that contains the string expected."
  },
  {
    "objectID": "/frontend/#p_218",
    "pt": "Frontends",
    "t": 3,
    "c": "Schedules a test named id which is run by calling f."
  },
  {
    "objectID": "/frontend/#p_219",
    "pt": "Frontends",
    "t": 3,
    "c": "This uses {!js} test.shouldRun to determine if the test should be run."
  },
  {
    "objectID": "/frontend/#p_220",
    "pt": "Frontends",
    "t": 3,
    "c": "Accepts a standard library object ({!js} stdlib) and a compiled backend (like given to {!js} acc.contract) and returns two objects:"
  },
  {
    "objectID": "/frontend/#p_221",
    "pt": "Frontends",
    "t": 3,
    "c": "exports --- The object containing all of the {!rsh} exported functions."
  },
  {
    "objectID": "/frontend/#p_222",
    "pt": "Frontends",
    "t": 3,
    "c": "chkExport --- A function to run tests on a particular function."
  },
  {
    "objectID": "/frontend/#p_223",
    "pt": "Frontends",
    "t": 3,
    "c": "chkExport takes two arguments:"
  },
  {
    "objectID": "/frontend/#p_224",
    "pt": "Frontends",
    "t": 3,
    "c": "fn --- The name of a function to test"
  },
  {
    "objectID": "/frontend/#p_225",
    "pt": "Frontends",
    "t": 3,
    "c": "go --- A function that accepts a customized version of {!js} test.chk and {!js} test.chkErr."
  },
  {
    "objectID": "/frontend/#p_226",
    "pt": "Frontends",
    "t": 3,
    "c": "These customized versions are referred to as:"
  },
  {
    "objectID": "/frontend/#p_227",
    "pt": "Frontends",
    "t": 3,
    "c": "chkf --- A function that accepts a domain and an expected range and ensures that the actual function result matches it."
  },
  {
    "objectID": "/frontend/#p_228",
    "pt": "Frontends",
    "t": 3,
    "c": "chkfErr --- A function that accepts an expected exception value and a domain and ensures that the actual function throws the exception."
  },
  {
    "objectID": "/frontend/#p_229",
    "pt": "Frontends",
    "t": 3,
    "c": "This function uses {!js} test.one internally."
  },
  {
    "objectID": "/frontend/#p_230",
    "pt": "Frontends",
    "t": 3,
    "c": "Runs any tests scheduled with {!js} test.one."
  },
  {
    "objectID": "/frontend/#p_231",
    "pt": "Frontends",
    "t": 3,
    "c": "opts.howManyAtOnce may be a number that determines how many tests to run in parallel. It defaults to {!js} 1."
  },
  {
    "objectID": "/frontend/#p_232",
    "pt": "Frontends",
    "t": 3,
    "c": "opts.exitOnFail may be a boolean that determines whether testing should end whenever the first test fails. It defaults to {!js} true."
  },
  {
    "objectID": "/frontend/#p_233",
    "pt": "Frontends",
    "t": 3,
    "c": "When testing is finished, the process will be exited with an error code signifying whether any tests failed."
  },
  {
    "objectID": "/frontend/#p_234",
    "pt": "Frontends",
    "t": 3,
    "c": "In addition, three lines will be outputed with the following format:"
  },
  {
    "objectID": "/frontend/#p_235",
    "pt": "Frontends",
    "t": 3,
    "c": "where"
  },
  {
    "objectID": "/frontend/#p_236",
    "pt": "Frontends",
    "t": 3,
    "c": "x is the base64 encoding of test results in the JUnit format as accepted by tools like CircleCI."
  },
  {
    "objectID": "/frontend/#p_237",
    "pt": "Frontends",
    "t": 3,
    "c": "y is a single line summary of how many tests failed"
  },
  {
    "objectID": "/frontend/#p_238",
    "pt": "Frontends",
    "t": 3,
    "c": "z is a six character prefix suitable for using with y."
  },
  {
    "objectID": "/frontend/#p_239",
    "pt": "Frontends",
    "t": 3,
    "c": "A convenient way to consume this output is with the following shell code:"
  },
  {
    "objectID": "/frontend/#p_240",
    "pt": "Frontends",
    "t": 3,
    "c": "We use this setup generate messages from CircleCI to Slack for continuous integration."
  },
  {
    "objectID": "/cout/#js_backend",
    "pt": "Compiled Output",
    "t": 0,
    "s": "js",
    "c": "backend"
  },
  {
    "objectID": "/cout/#js_getExports",
    "pt": "Compiled Output",
    "t": 0,
    "s": "js",
    "c": "getExports"
  },
  {
    "objectID": "/cout/#ref-backends",
    "pt": "Compiled Output",
    "t": 2,
    "c": "Compiled Output"
  },
  {
    "objectID": "/cout/#ref-backends-js",
    "pt": "Compiled Output",
    "t": 2,
    "c": "JavaScript"
  },
  {
    "objectID": "/cout/#ref-backends-js-guarantees",
    "pt": "Compiled Output",
    "t": 2,
    "c": "Guarantees"
  },
  {
    "objectID": "/cout/#p_0",
    "pt": "Compiled Output",
    "t": 3,
    "c": "This section describes the compilation output of Reach version 0.1.11, which are participant backends."
  },
  {
    "objectID": "/cout/#p_1",
    "pt": "Compiled Output",
    "t": 3,
    "c": "They are accessed via JavaScript or via the RPC server."
  },
  {
    "objectID": "/cout/#p_2",
    "pt": "Compiled Output",
    "t": 3,
    "c": "The Reach JavaScript backend produces a compilation output named input.APP.mjs. This will normally be imported by writing:"
  },
  {
    "objectID": "/cout/#p_3",
    "pt": "Compiled Output",
    "t": 3,
    "c": "This module exports an asynchronous function for each participant. For example, if a Reach program contains a participant named {!rsh} 'A' in the {!rsh} Reach.App, then the JavaScript backend will include a function named {!js} A (i.e. {!js} backend.A). The {!js} Promise returned by these functions is resolved when the Reach program terminates (i.e. reaches {!rsh} exit();)."
  },
  {
    "objectID": "/cout/#p_4",
    "pt": "Compiled Output",
    "t": 3,
    "c": "Each function accepts two arguments: {!js} ctc and {!js} interact. These functions should be called by the frontend."
  },
  {
    "objectID": "/cout/#p_5",
    "pt": "Compiled Output",
    "t": 3,
    "c": "The {!js} ctc argument is the result of a call to the functions {!js} acc.deploy or {!js} acc.attach provided by the JavaScript frontend support library."
  },
  {
    "objectID": "/cout/#p_6",
    "pt": "Compiled Output",
    "t": 3,
    "c": "The {!js} interact argument is an object matching the participant interact interface for the corresponding participant. The types of values this object contains must match those specified on this list. Each function may return a {!js} Promise, which the backend will {!js} await, if it needs to perform an asynchronous action."
  },
  {
    "objectID": "/cout/#p_7",
    "pt": "Compiled Output",
    "t": 3,
    "c": "The backend provides a value, {!js} _version, which is a string representation of the Reach version used to compile the program. For example, the version of Reach used to produce this documentation would contain the string {!js} 'reach-vers'."
  },
  {
    "objectID": "/cout/#p_8",
    "pt": "Compiled Output",
    "t": 3,
    "c": "The backend provides a function, {!js} getExports, which exposes the exports of a Reach program. This function receives the standard library as an argument and returns an object with all the exports present in the module being compiled."
  },
  {
    "objectID": "/cout/#p_9",
    "pt": "Compiled Output",
    "t": 3,
    "c": "It's possible to expose bindings from other modules to {!js} getExports by re-exporting them in your \"top-level\" module."
  },
  {
    "objectID": "/cout/#p_10",
    "pt": "Compiled Output",
    "t": 3,
    "c": "For example, if a Reach program exported a variable x, i.e. {!rsh} export const x = 5, the frontend could access the value in the following manner:"
  },
  {
    "objectID": "/cout/#p_11",
    "pt": "Compiled Output",
    "t": 3,
    "c": "Finally, the backend provides a value, {!js} _Connectors, which is an opaque object representing the connectors the app was compiled for."
  },
  {
    "objectID": "/cout/#p_12",
    "pt": "Compiled Output",
    "t": 3,
    "c": "This backend does not guarantee that values in a positive position in a participant interact interface, that are later passed to a negative position in a participant interact interface, will be identical, in the sense of JavaScript's {!js} === operator, to the original value. In other words, this backend does not ensure that Reach programs are parametric over JavaScript values that they interact with."
  },
  {
    "objectID": "/cout/#p_13",
    "pt": "Compiled Output",
    "t": 3,
    "c": "Positive and negative are best understood by example with a function type: a positive position is supplied by the function, such as the result; while a negative position is supplied by the caller, such as the arguments. These notions generalize, however, to higher (and lower) order contexts. In the case of Reach, this means that non-function values in a participant interact interface are positive."
  },
  {
    "objectID": "/cout/#p_14",
    "pt": "Compiled Output",
    "t": 3,
    "c": "For example, if the Reach program,"
  },
  {
    "objectID": "/cout/#p_15",
    "pt": "Compiled Output",
    "t": 3,
    "c": "is given the {!js} interact object,"
  },
  {
    "objectID": "/cout/#p_16",
    "pt": "Compiled Output",
    "t": 3,
    "c": "then it is not guaranteed that {!rsh} A will publish {!rsh} true, because the {!js} str given to {!js} give may not be identical to {!js} x. (However, they are {!js} bytesEq.)"
  },
  {
    "objectID": "/index/#cmd_REACH_CONNECTOR_MODE",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "REACH_CONNECTOR_MODE"
  },
  {
    "objectID": "/index/#cmd_REACH_VERSION",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "REACH_VERSION"
  },
  {
    "objectID": "/index/#cmd_REACH_DEBUG",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "REACH_DEBUG"
  },
  {
    "objectID": "/index/#cmd_reach%20compile",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach compile"
  },
  {
    "objectID": "/index/#cmd_reach%20init",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach init"
  },
  {
    "objectID": "/index/#cmd_reach%20run",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach run"
  },
  {
    "objectID": "/index/#cmd_reach%20down",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach down"
  },
  {
    "objectID": "/index/#cmd_reach%20scaffold",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach scaffold"
  },
  {
    "objectID": "/index/#cmd_reach%20react",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach react"
  },
  {
    "objectID": "/index/#cmd_reach%20devnet",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach devnet"
  },
  {
    "objectID": "/index/#cmd_reach%20rpc-server",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach rpc-server"
  },
  {
    "objectID": "/index/#cmd_reach%20rpc-run",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach rpc-run"
  },
  {
    "objectID": "/index/#cmd_reach%20docker-reset",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach docker-reset"
  },
  {
    "objectID": "/index/#cmd_reach%20info",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach info"
  },
  {
    "objectID": "/index/#cmd_reach%20update",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach update"
  },
  {
    "objectID": "/index/#cmd_reach%20version",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach version"
  },
  {
    "objectID": "/index/#cmd_reach%20hashes",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach hashes"
  },
  {
    "objectID": "/index/#cmd_reach%20config",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach config"
  },
  {
    "objectID": "/index/#cmd_reach%20--disable-reporting",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach --disable-reporting"
  },
  {
    "objectID": "/index/#doc-index",
    "pt": "Index",
    "t": 2,
    "c": "Index"
  },
  {
    "objectID": "/networks/#ref-networks",
    "pt": "Networks",
    "t": 2,
    "c": "Networks"
  },
  {
    "objectID": "/networks/#ref-network-algo",
    "pt": "Networks",
    "t": 2,
    "c": "Algorand"
  },
  {
    "objectID": "/networks/#ref-network-cfx",
    "pt": "Networks",
    "t": 2,
    "c": "Conflux"
  },
  {
    "objectID": "/networks/#cfx-faq",
    "pt": "Networks",
    "t": 2,
    "c": "FAQ"
  },
  {
    "objectID": "/networks/#cfx-faq-mainnet",
    "pt": "Networks",
    "t": 2,
    "c": "How do I run my Reach DApp on CFX TestNet or MainNet?"
  },
  {
    "objectID": "/networks/#cfx-faq-cplocal",
    "pt": "Networks",
    "t": 2,
    "c": "How can I use ConfluxPortal with the Reach devnet?"
  },
  {
    "objectID": "/networks/#cfx-faq-sponsor",
    "pt": "Networks",
    "t": 2,
    "c": "How can I use gas and storage sponsorship?"
  },
  {
    "objectID": "/networks/#ref-network-eth",
    "pt": "Networks",
    "t": 2,
    "c": "Ethereum"
  },
  {
    "objectID": "/networks/#p_0",
    "pt": "Networks",
    "t": 3,
    "c": "This section describes the consensus network connectors supported by Reach version 0.1.11:"
  },
  {
    "objectID": "/networks/#p_1",
    "pt": "Networks",
    "t": 3,
    "c": "The Algorand Reach connector generates a contract that manage one instance of the DApp's execution."
  },
  {
    "objectID": "/networks/#p_2",
    "pt": "Networks",
    "t": 3,
    "c": "It uses finite on-chain state. The DApp consists of one application. The contract escrow account is the application account. Sometimes a companion contract is created that is used to increased the opcode budget during contract execution."
  },
  {
    "objectID": "/networks/#p_3",
    "pt": "Networks",
    "t": 3,
    "c": "It relies on versions of algod that support TEAL version 6, such as Algorand 3.5.1. It uses the Algorand indexer version 2 to lookup and monitor publications; in other words, it does not rely on any communication network other than Algorand itself."
  },
  {
    "objectID": "/networks/#p_4",
    "pt": "Networks",
    "t": 3,
    "c": "Algorand uses the SHA256 algorithm to perform digests. Its bit width is 64-bits."
  },
  {
    "objectID": "/networks/#p_5",
    "pt": "Networks",
    "t": 3,
    "c": "Non-network tokens are compiled to Algorand Standard Assets (ASAs). Specifically, the {!rsh} Token type refers to the id of the ASA."
  },
  {
    "objectID": "/networks/#p_6",
    "pt": "Networks",
    "t": 3,
    "c": "Token minting creates an ASA owned and managed by the contract account. Freezing, clawback, reserves, and separate managers are not supported."
  },
  {
    "objectID": "/networks/#p_7",
    "pt": "Networks",
    "t": 3,
    "c": "Views are compiled to client-side functions that can interpret the global and local state of the Algorand Application associated with the DApp. This means they are sensitive to the particular compilation details of the particular Reach program. We hope to work with the Algorand community to define a standard for views. Views expand the on-chain state to include the free variables of all values bound to a view."
  },
  {
    "objectID": "/networks/#p_8",
    "pt": "Networks",
    "t": 3,
    "c": "{!rsh} Maps on Algorand only support keys that are of type {!rsh} Address."
  },
  {
    "objectID": "/networks/#p_9",
    "pt": "Networks",
    "t": 3,
    "c": "Linear state is compiled into Application Local State. This means that participants must explicitly \"opt-in\" to storing this state on their account (which increases their minimum balance). The Reach standard library will do this automatically when connecting to Reach generated contracts, but other users must be specifically programmed to do this. This \"opt-in\" requirement means that DApps with linear state deployed on Algorand can deadlock and be held hostage: Suppose that Alice transfers 10 ALGO to a contract in step one, then in step two, the consensus must store a value associated with Bob, and then she can receive her 10 ALGO back, then the program terminates. On some networks, Alice can perform these two steps completely on her own and she is in complete control of her funds. However, on Algorand, running this program requires that Bob \"opt-in\" to storing values for the application. We hope that future versions of Algorand will allow other parties to pay the fees to \"opt-in\" to applications to prevent these kinds of deadlock attacks."
  },
  {
    "objectID": "/networks/#p_10",
    "pt": "Networks",
    "t": 3,
    "c": "In Algorand, network time corresponds to round numbers. Each round is assigned a Unix timestamp, but when you look at the timestamp in code executing in round N+1, you read the timestamp assigned to round N. Ensure that you read RW0006 if you use network seconds."
  },
  {
    "objectID": "/networks/#p_11",
    "pt": "Networks",
    "t": 3,
    "c": "The connector provides a binding named {!rsh} ALGO to backends."
  },
  {
    "objectID": "/networks/#p_12",
    "pt": "Networks",
    "t": 3,
    "c": "Reach uses the following environment variables:"
  },
  {
    "objectID": "/networks/#p_13",
    "pt": "Networks",
    "t": 3,
    "c": "ALGO_TOKEN is used as the API token for your algod. When left unspecified, this defaults to the token of the Reach devnet."
  },
  {
    "objectID": "/networks/#p_14",
    "pt": "Networks",
    "t": 3,
    "c": "ALGO_SERVER is used as the address of your algod. When left unspecified, this defaults to http://localhost."
  },
  {
    "objectID": "/networks/#p_15",
    "pt": "Networks",
    "t": 3,
    "c": "ALGO_PORT is used as the port of your algod. When left unspecified, this defaults to 4180."
  },
  {
    "objectID": "/networks/#p_16",
    "pt": "Networks",
    "t": 3,
    "c": "ALGO_INDEXER_TOKEN is used as the API token for your indexer. When left unspecified, this defaults to the token of the Reach devnet."
  },
  {
    "objectID": "/networks/#p_17",
    "pt": "Networks",
    "t": 3,
    "c": "ALGO_INDEXER_SERVER is used as the address of your indexer. When left unspecified, this defaults to http://localhost."
  },
  {
    "objectID": "/networks/#p_18",
    "pt": "Networks",
    "t": 3,
    "c": "ALGO_INDEXER_PORT is used as the port of your indexer. When left unspecified, this defaults to 8980."
  },
  {
    "objectID": "/networks/#p_19",
    "pt": "Networks",
    "t": 3,
    "c": "ALGO_NODE_WRITE_ONLY specifies if your algod will handle read requests, or just writes. When left unspecified, this defaults to no."
  },
  {
    "objectID": "/networks/#p_20",
    "pt": "Networks",
    "t": 3,
    "c": "ALGO_FAUCET_PASSPHRASE is used as the mnemonic for the faucet of your network. When left unspecified, this defaults to the passphrase of the Reach devnet's faucet. This is useful if you are running your own testing network."
  },
  {
    "objectID": "/networks/#p_21",
    "pt": "Networks",
    "t": 3,
    "c": "ALGO_GENESIS_ID or ALGO_GENESIS_HASH (or both), which allows you to request that the user's ARC-6 compliant wallet connect to a specific network. When left unspecified, it allows the user to select one of their wallet's supported networks."
  },
  {
    "objectID": "/networks/#p_22",
    "pt": "Networks",
    "t": 3,
    "c": "ALGO_ACCOUNT, which allows you to request the use of a specific account from the user's ARC-6 compliant wallet by address. This should usually be left unspecified, which allows the user to instead select their preferred account."
  },
  {
    "objectID": "/networks/#p_23",
    "pt": "Networks",
    "t": 3,
    "c": "The Conflux Reach connector works almost identically to the Ethereum connector, except that it behaves differently at runtime: using, for example, Conflux Portal rather than MetaMask, and connecting to Conflux nodes."
  },
  {
    "objectID": "/networks/#p_24",
    "pt": "Networks",
    "t": 3,
    "c": "Backends must respect the following environment variables:"
  },
  {
    "objectID": "/networks/#p_25",
    "pt": "Networks",
    "t": 3,
    "c": "CFX_NODE_URI is used to contact the Conflux node. It defaults to http://localhost:12537."
  },
  {
    "objectID": "/networks/#p_26",
    "pt": "Networks",
    "t": 3,
    "c": "CFX_NETWORK_ID is used to determine the Conflux network id. It defaults to 999."
  },
  {
    "objectID": "/networks/#p_27",
    "pt": "Networks",
    "t": 3,
    "c": "You can add the following JavaScript near the beginning of your index.js or index.mjs file in order to run on Conflux TestNet:"
  },
  {
    "objectID": "/networks/#p_28",
    "pt": "Networks",
    "t": 3,
    "c": "Or this to run on Conflux MainNet:"
  },
  {
    "objectID": "/networks/#p_29",
    "pt": "Networks",
    "t": 3,
    "c": "If you find that ConfluxPortal's Localhost 12537 default configuration does not work correctly with Reach apps, you can try configuring ConfluxPortal to use a custom RPC endpoint:"
  },
  {
    "objectID": "/networks/#p_30",
    "pt": "Networks",
    "t": 3,
    "c": "Click the network dropdown in Conflux Portal"
  },
  {
    "objectID": "/networks/#p_31",
    "pt": "Networks",
    "t": 3,
    "c": "Select: Custom RPC"
  },
  {
    "objectID": "/networks/#p_32",
    "pt": "Networks",
    "t": 3,
    "c": "Use RPC url: http://127.0.0.1:"
  },
  {
    "objectID": "/networks/#p_33",
    "pt": "Networks",
    "t": 3,
    "c": "If your locally-running Conflux devnet restarts, you may find that you need to reset ConfluxPortal's account history, which you can do like so:"
  },
  {
    "objectID": "/networks/#p_34",
    "pt": "Networks",
    "t": 3,
    "c": "Select the desired account"
  },
  {
    "objectID": "/networks/#p_35",
    "pt": "Networks",
    "t": 3,
    "c": "Click the profile image of the account (top-right)"
  },
  {
    "objectID": "/networks/#p_36",
    "pt": "Networks",
    "t": 3,
    "c": "Click Settings > Advanced > Reset Account > (confirm) Reset"
  },
  {
    "objectID": "/networks/#p_37",
    "pt": "Networks",
    "t": 3,
    "c": "Switch to a different network and back"
  },
  {
    "objectID": "/networks/#p_38",
    "pt": "Networks",
    "t": 3,
    "c": "CTRL+SHIFT+R to hard-reset the webpage."
  },
  {
    "objectID": "/networks/#p_39",
    "pt": "Networks",
    "t": 3,
    "c": "Conflux, like many other networks, charges fees for using the network and interacting with smart contracts. These fees are normally pay by the originator the transaction: who we would call the \"publisher\" in Reach. However, unlike other networks, Conflux does not require these fees to be paid for by the originator. Instead, Conflux allows fees to be paid for by a third-party. This is called \"sponsorship\"."
  },
  {
    "objectID": "/networks/#p_40",
    "pt": "Networks",
    "t": 3,
    "c": "Conflux maintains documentation for this feature on their internal contract documentation page. You can follow the directions on the Conflux page exactly and it will work with Reach, because Reach programs, when deployed on Conflux, are just normal programs."
  },
  {
    "objectID": "/networks/#p_41",
    "pt": "Networks",
    "t": 3,
    "c": "We duplicate these instructions below; if you have any difficulties with these directions, please refer to the Conflux source and then let us know, so we can update them."
  },
  {
    "objectID": "/networks/#p_42",
    "pt": "Networks",
    "t": 3,
    "c": "There are three steps to enabling sponsorship."
  },
  {
    "objectID": "/networks/#p_43",
    "pt": "Networks",
    "t": 3,
    "c": "First, you have to directly interact with the Conflux SDK. This will require adding an npm package dependency and initializing the library. The Conflux SDK Quickstart walks through this process. It will look something like:"
  },
  {
    "objectID": "/networks/#p_44",
    "pt": "Networks",
    "t": 3,
    "c": "Second, you must call the addPrivilegeByAdmin Conflux internal contract from the creator (i.e. deployer) of the smart contract. This function requires you to provide an address that is eligible for sponsorship. It is documented in this section of the Conflux manual. If you use an address which is all zeros, then every address is sponsored. The code will look something like:"
  },
  {
    "objectID": "/networks/#p_45",
    "pt": "Networks",
    "t": 3,
    "c": "In this code sample, we assume that {!js} contractAddress is the address of the Reach contract, which you might have acquired via {!js} await ctc.getContractAddress() and {!js} creatorAddress is the address of the creator of the Reach contract."
  },
  {
    "objectID": "/networks/#p_46",
    "pt": "Networks",
    "t": 3,
    "c": "Third, you have to provide a sponsoring account by calling setSponsorForGas (or setSponsorForCollateral) on the Conflux internal contract. This function must be called by the sponsoring account. It is documented in this section of the Conflux manual. The code will look something like:"
  },
  {
    "objectID": "/networks/#p_47",
    "pt": "Networks",
    "t": 3,
    "c": "In this code sample, we assume that {!js} contractAddress is the address of the Reach contract, which you might have acquired via {!js} await ctc.getContractAddress(), {!js} amount is the maximum amount the sponsor is willing to sponsor, and {!js} sponsorAddress is the address of the sponsor."
  },
  {
    "objectID": "/networks/#p_48",
    "pt": "Networks",
    "t": 3,
    "c": "If your application is made of equal peers, you may not want to enable the sponsorship feature. But, if your application has a clear party with extra authority and resources, you might like to make them the creator and sponsor of the contract, because this incentivizes participation in the program by lowering the cost to do so."
  },
  {
    "objectID": "/networks/#p_49",
    "pt": "Networks",
    "t": 3,
    "c": "As of November 2021, the Conflux Foundation is willing to sponsor some smart contracts. This forum post discusses how to request sponsorship of your contract. If the Foundation agrees to sponsor your program, then you only need to do steps one and two above: you can skip step three."
  },
  {
    "objectID": "/networks/#p_50",
    "pt": "Networks",
    "t": 3,
    "c": "The Ethereum Reach connector generates a contract that manages one instance of the DApp's execution. It is guaranteed to use exactly one word of on-chain state, while each piece of consensus state appears as a transaction argument."
  },
  {
    "objectID": "/networks/#p_51",
    "pt": "Networks",
    "t": 3,
    "c": "Ethereum uses the Keccak256 algorithm to perform digests. Its bit width is 256-bits."
  },
  {
    "objectID": "/networks/#p_52",
    "pt": "Networks",
    "t": 3,
    "c": "Non-network tokens are compiled to ERC-20 fungible tokens. Specifically, the {!rsh} Token type refers to the address of the ERC-20 contract. Token minting launches a fresh ERC-20 contract based on the OpenZeppelin ERC-20 implementation, which stores additional metadata and allows the creator to burn tokens and destroy the token if there is no supply (i.e. it has all been burned)."
  },
  {
    "objectID": "/networks/#p_53",
    "pt": "Networks",
    "t": 3,
    "c": "Views are compiled to view functions. A view named X.Y will be named X_Y. A view named X will be named X. Views expand the on-chain state to include the free variables of all values bound to a view."
  },
  {
    "objectID": "/networks/#p_54",
    "pt": "Networks",
    "t": 3,
    "c": "In Ethereum, network time corresponds to block numbers and network seconds correspond to the Unix timestamp of the block. Ensure that you read RW0006 if you use network seconds."
  },
  {
    "objectID": "/networks/#p_55",
    "pt": "Networks",
    "t": 3,
    "c": "The connector provides a binding named {!rsh} ETH to backends."
  },
  {
    "objectID": "/networks/#p_56",
    "pt": "Networks",
    "t": 3,
    "c": "During compilation, the connector produces one intermediate output: input.export.sol, containing the Solidity code implementing the contract."
  },
  {
    "objectID": "/networks/#p_57",
    "pt": "Networks",
    "t": 3,
    "c": "A few details of Ethereum leak through to Reach. The node that a given participant is connected to does not instantly know that its blocks are correct and may revert past transactions after it reaches consensus with the rest of the network. This means that Reach applications must not make externally observable effects until after such consensus is reached."
  },
  {
    "objectID": "/networks/#p_58",
    "pt": "Networks",
    "t": 3,
    "c": "Backends must respect the following environment variables:"
  },
  {
    "objectID": "/networks/#p_59",
    "pt": "Networks",
    "t": 3,
    "c": "ETH_NODE_URI is used to contact the Ethereum node. It defaults to http://localhost:8545."
  },
  {
    "objectID": "/networks/#p_60",
    "pt": "Networks",
    "t": 3,
    "c": "ETH_NODE_NETWORK is used to name the Ethereum network. It defaults to unspecified."
  },
  {
    "objectID": "/quickstart/#quickstart",
    "pt": "Quickstart",
    "t": 2,
    "c": "Quickstart"
  },
  {
    "objectID": "/quickstart/#qs-win",
    "pt": "Quickstart",
    "t": 2,
    "c": "Windows"
  },
  {
    "objectID": "/quickstart/#qs-win-prereqs",
    "pt": "Quickstart",
    "t": 2,
    "c": "Prerequisites"
  },
  {
    "objectID": "/quickstart/#qs-win-install",
    "pt": "Quickstart",
    "t": 2,
    "c": "Installation"
  },
  {
    "objectID": "/quickstart/#qs-installing-docker",
    "pt": "Quickstart",
    "t": 2,
    "c": "Installing Docker:"
  },
  {
    "objectID": "/quickstart/#qs-win-conf-docker",
    "pt": "Quickstart",
    "t": 2,
    "c": "Configuring Docker:"
  },
  {
    "objectID": "/quickstart/#qs-linux",
    "pt": "Quickstart",
    "t": 2,
    "c": "Linux"
  },
  {
    "objectID": "/quickstart/#qs-linux-prereqs",
    "pt": "Quickstart",
    "t": 2,
    "c": "Prerequisites"
  },
  {
    "objectID": "/quickstart/#qs-linux-install",
    "pt": "Quickstart",
    "t": 2,
    "c": "Installation for Ubuntu"
  },
  {
    "objectID": "/quickstart/#qs-mac",
    "pt": "Quickstart",
    "t": 2,
    "c": "MacOS"
  },
  {
    "objectID": "/quickstart/#qs-mac-install",
    "pt": "Quickstart",
    "t": 2,
    "c": "Installation"
  },
  {
    "objectID": "/quickstart/#p_0",
    "pt": "Quickstart",
    "t": 3,
    "c": "This quickstart guide outlines the step-by-step instructions for getting started with programming in Reach. You can install on the following operating systems:"
  },
  {
    "objectID": "/quickstart/#p_1",
    "pt": "Quickstart",
    "t": 3,
    "c": "If you have any issues running reach, please check the Troubleshooting page for solutions."
  },
  {
    "objectID": "/quickstart/#p_2",
    "pt": "Quickstart",
    "t": 3,
    "c": "Reach requires WSL 2 and Docker Desktop to be installed."
  },
  {
    "objectID": "/quickstart/#p_3",
    "pt": "Quickstart",
    "t": 3,
    "c": "Windows 10 installed with version 2004 or higher,"
  },
  {
    "objectID": "/quickstart/#p_4",
    "pt": "Quickstart",
    "t": 3,
    "c": "or"
  },
  {
    "objectID": "/quickstart/#p_5",
    "pt": "Quickstart",
    "t": 3,
    "c": "Windows "
  },
  {
    "objectID": "/quickstart/#p_6",
    "pt": "Quickstart",
    "t": 3,
    "c": "Virtualization Technology (VT-x) enabled on the BIOS"
  },
  {
    "objectID": "/quickstart/#p_7",
    "pt": "Quickstart",
    "t": 3,
    "c": "Click the Windows icon, type Powershell, and then click Run as Administrator. There are a number of commands that need to be run to get Windows ready for Reach."
  },
  {
    "objectID": "/quickstart/#p_8",
    "pt": "Quickstart",
    "t": 3,
    "c": "To install WSL on Windows, enable these two features:"
  },
  {
    "objectID": "/quickstart/#p_9",
    "pt": "Quickstart",
    "t": 3,
    "c": "Enable WSL:"
  },
  {
    "objectID": "/quickstart/#p_10",
    "pt": "Quickstart",
    "t": 3,
    "c": "Enable the Virtual Machine feature:"
  },
  {
    "objectID": "/quickstart/#p_11",
    "pt": "Quickstart",
    "t": 3,
    "c": "After enabling these two features, reboot:"
  },
  {
    "objectID": "/quickstart/#p_12",
    "pt": "Quickstart",
    "t": 3,
    "c": "After rebooting, reopen Powershell as an administrator, and execute the following commands:"
  },
  {
    "objectID": "/quickstart/#p_13",
    "pt": "Quickstart",
    "t": 3,
    "c": "In the Command Prompt window, run the following command to set the WSL version to 2:"
  },
  {
    "objectID": "/quickstart/#p_14",
    "pt": "Quickstart",
    "t": 3,
    "c": "After setting up the default version, install the WSL distribution:"
  },
  {
    "objectID": "/quickstart/#p_15",
    "pt": "Quickstart",
    "t": 3,
    "c": "When the installation is finished, a terminal called Ubuntu should open on your screen. It will request that you set up a user and password. Make sure you don't skip this step."
  },
  {
    "objectID": "/quickstart/#p_16",
    "pt": "Quickstart",
    "t": 3,
    "c": "To install Docker we will use winget. It is the official package manager for Windows. We will download the package from Microsoft's official GitHub account."
  },
  {
    "objectID": "/quickstart/#p_17",
    "pt": "Quickstart",
    "t": 3,
    "c": "To install Winget run:"
  },
  {
    "objectID": "/quickstart/#p_18",
    "pt": "Quickstart",
    "t": 3,
    "c": "A window should pop up. Click Update."
  },
  {
    "objectID": "/quickstart/#p_19",
    "pt": "Quickstart",
    "t": 3,
    "c": "Next, install Docker using winget:"
  },
  {
    "objectID": "/quickstart/#p_20",
    "pt": "Quickstart",
    "t": 3,
    "c": "After installing Docker, reboot:"
  },
  {
    "objectID": "/quickstart/#p_21",
    "pt": "Quickstart",
    "t": 3,
    "c": "Open Docker and wait for it to initialize. Click the Settings (gear) icon along the top of the Docker app."
  },
  {
    "objectID": "/quickstart/#p_22",
    "pt": "Quickstart",
    "t": 3,
    "c": "Verify that WSL 2.0 and Use Docker Compose V2 are checked."
  },
  {
    "objectID": "/quickstart/#p_23",
    "pt": "Quickstart",
    "t": 3,
    "c": "Click Resources in the left-hand menu, and make sure that Enable integration with additional distros is checked, and that Ubuntu is selected."
  },
  {
    "objectID": "/quickstart/#p_24",
    "pt": "Quickstart",
    "t": 3,
    "c": "Click the Ubuntu icon in the Windows Start-up menu to open the Ubuntu terminal. You will need to provide a username and password for Ubuntu."
  },
  {
    "objectID": "/quickstart/#p_25",
    "pt": "Quickstart",
    "t": 3,
    "c": "In the terminal, run the following to install make and curl:"
  },
  {
    "objectID": "/quickstart/#p_26",
    "pt": "Quickstart",
    "t": 3,
    "c": "Create and navigate to the reach directory with the following command:"
  },
  {
    "objectID": "/quickstart/#p_27",
    "pt": "Quickstart",
    "t": 3,
    "c": "Download Reach with the following command:"
  },
  {
    "objectID": "/quickstart/#p_28",
    "pt": "Quickstart",
    "t": 3,
    "c": "Reach is successfully downloaded if the following command returns a version number:"
  },
  {
    "objectID": "/quickstart/#p_29",
    "pt": "Quickstart",
    "t": 3,
    "c": "You are now ready to start programming in Reach. Check out our tutorials to get started."
  },
  {
    "objectID": "/quickstart/#p_30",
    "pt": "Quickstart",
    "t": 3,
    "c": "Reach requires make, Docker Engine, and Docker Compose."
  },
  {
    "objectID": "/quickstart/#p_31",
    "pt": "Quickstart",
    "t": 3,
    "c": "A version of Linux compatible with Docker."
  },
  {
    "objectID": "/quickstart/#p_32",
    "pt": "Quickstart",
    "t": 3,
    "c": "Our instructions are written assuming you're using the most recent version of Ubuntu. Check the Docker Engine page for supported distros."
  },
  {
    "objectID": "/quickstart/#p_33",
    "pt": "Quickstart",
    "t": 3,
    "c": "Follow the Docker Engine instructions for installing on your version of Linux. Check the commands required for completing the tasks below for your distro. The following instructions from Docker assume that Ubuntu is the installed distro."
  },
  {
    "objectID": "/quickstart/#p_34",
    "pt": "Quickstart",
    "t": 3,
    "c": "In the terminal, run the following to install make:"
  },
  {
    "objectID": "/quickstart/#p_35",
    "pt": "Quickstart",
    "t": 3,
    "c": "Next, run the following to allow apt to use repositories containing HTTPS:"
  },
  {
    "objectID": "/quickstart/#p_36",
    "pt": "Quickstart",
    "t": 3,
    "c": "Docker will be installed by adding a package repository from Docker; this requires updating your apt configuration:"
  },
  {
    "objectID": "/quickstart/#p_37",
    "pt": "Quickstart",
    "t": 3,
    "c": "Then run:"
  },
  {
    "objectID": "/quickstart/#p_38",
    "pt": "Quickstart",
    "t": 3,
    "c": "And then run:"
  },
  {
    "objectID": "/quickstart/#p_39",
    "pt": "Quickstart",
    "t": 3,
    "c": "You may want to run the post-installation steps for Linux that Docker recommends."
  },
  {
    "objectID": "/quickstart/#p_40",
    "pt": "Quickstart",
    "t": 3,
    "c": "Create and navigate to the reach directory with the following command:"
  },
  {
    "objectID": "/quickstart/#p_41",
    "pt": "Quickstart",
    "t": 3,
    "c": "Download Reach with the following command:"
  },
  {
    "objectID": "/quickstart/#p_42",
    "pt": "Quickstart",
    "t": 3,
    "c": "Reach is successfully downloaded if the following command returns a version number:"
  },
  {
    "objectID": "/quickstart/#p_43",
    "pt": "Quickstart",
    "t": 3,
    "c": "You are now ready to start programming in Reach. Check out our tutorials to get started."
  },
  {
    "objectID": "/quickstart/#p_44",
    "pt": "Quickstart",
    "t": 3,
    "c": "Reach is compatible with M1 chips and Intel chips running macOS 10.15 or newer. Installation instructions should not differ regardless of the MacOS architecture. Reach requires installing Docker."
  },
  {
    "objectID": "/quickstart/#p_45",
    "pt": "Quickstart",
    "t": 3,
    "c": "make should be preinstalled. Test this by opening terminal and running the following command:"
  },
  {
    "objectID": "/quickstart/#p_46",
    "pt": "Quickstart",
    "t": 3,
    "c": "Download Docker Desktop and follow the prompts to complete application setup."
  },
  {
    "objectID": "/quickstart/#p_47",
    "pt": "Quickstart",
    "t": 3,
    "c": "According to the Docker Docs, \"Docker Desktop for Mac includes Compose along with other Docker apps, so Mac users do not need to install Compose separately.\""
  },
  {
    "objectID": "/quickstart/#p_48",
    "pt": "Quickstart",
    "t": 3,
    "c": "To verify that Docker Compose is operating on your Mac, execute the command:"
  },
  {
    "objectID": "/quickstart/#p_49",
    "pt": "Quickstart",
    "t": 3,
    "c": "When it returns a version number, Reach is ready to be installed."
  },
  {
    "objectID": "/quickstart/#p_50",
    "pt": "Quickstart",
    "t": 3,
    "c": "Create and navigate to the reach directory with the following command:"
  },
  {
    "objectID": "/quickstart/#p_51",
    "pt": "Quickstart",
    "t": 3,
    "c": "Download Reach with the following command:"
  },
  {
    "objectID": "/quickstart/#p_52",
    "pt": "Quickstart",
    "t": 3,
    "c": "Reach is successfully downloaded if the following command returns a version number:"
  },
  {
    "objectID": "/quickstart/#p_53",
    "pt": "Quickstart",
    "t": 3,
    "c": "You are now ready to start programming in Reach. Check out our tutorials to get started."
  },
  {
    "objectID": "/search/#search",
    "pt": "Search",
    "t": 2,
    "c": "Search"
  },
  {
    "objectID": "/rsh/#term_programs",
    "pt": "Language",
    "t": 1,
    "c": "programs"
  },
  {
    "objectID": "/rsh/#term_valid",
    "pt": "Language",
    "t": 1,
    "c": "valid"
  },
  {
    "objectID": "/rsh/#term_invalid",
    "pt": "Language",
    "t": 1,
    "c": "invalid"
  },
  {
    "objectID": "/rsh/#term_secret",
    "pt": "Language",
    "t": 1,
    "c": "secret"
  },
  {
    "objectID": "/rsh/#term_dominated",
    "pt": "Language",
    "t": 1,
    "c": "dominated"
  },
  {
    "objectID": "/rsh/#ref-programs",
    "pt": "Language",
    "t": 2,
    "c": "Language"
  },
  {
    "objectID": "/rsh/#ref-programs-valid",
    "pt": "Language",
    "t": 2,
    "c": "Validity and other concepts"
  },
  {
    "objectID": "/rsh/#security-levels-and-scope",
    "pt": "Language",
    "t": 2,
    "c": "Security levels and scope"
  },
  {
    "objectID": "/rsh/#domination",
    "pt": "Language",
    "t": 2,
    "c": "Domination"
  },
  {
    "objectID": "/rsh/#p_0",
    "pt": "Language",
    "t": 3,
    "c": "This document describes the structure and content of Reach programs, including their syntactic forms, the standard library, and the standards of valid programs."
  },
  {
    "objectID": "/rsh/#p_1",
    "pt": "Language",
    "t": 3,
    "c": "Get language support for Reach in your editor by visiting IDE/Text Editor Support."
  },
  {
    "objectID": "/rsh/#p_2",
    "pt": "Language",
    "t": 3,
    "c": "The rest of this section is structured according to the contexts of the different parts of a Reach program, as follows:"
  },
  {
    "objectID": "/rsh/#p_3",
    "pt": "Language",
    "t": 3,
    "c": "Validity and other concepts describes what is meant by the term valid in Reach."
  },
  {
    "objectID": "/rsh/#p_4",
    "pt": "Language",
    "t": 3,
    "c": "Modules describes the top-level structure of a Reach module."
  },
  {
    "objectID": "/rsh/#p_5",
    "pt": "Language",
    "t": 3,
    "c": "Application Initialization describes the structure of Reach application initialization."
  },
  {
    "objectID": "/rsh/#p_6",
    "pt": "Language",
    "t": 3,
    "c": "Steps describes the structure of Reach steps."
  },
  {
    "objectID": "/rsh/#p_7",
    "pt": "Language",
    "t": 3,
    "c": "Local Steps describes the structure of Reach local steps."
  },
  {
    "objectID": "/rsh/#p_8",
    "pt": "Language",
    "t": 3,
    "c": "Consensus Steps describes the structure of Reach consensus steps."
  },
  {
    "objectID": "/rsh/#p_9",
    "pt": "Language",
    "t": 3,
    "c": "Computations describes the common structure of Reach computations shared by all contexts."
  },
  {
    "objectID": "/rsh/#p_10",
    "pt": "Language",
    "t": 3,
    "c": "The relationship between the modes of a Reach application is shown by this diagram:"
  },
  {
    "objectID": "/rsh/#p_11",
    "pt": "Language",
    "t": 3,
    "c": "Reach imposes further restrictions on syntactically well-formed programs. These restrictions are described throughout this manual using the term valid to refer to constructions that obey the restrictions, and the term invalid to refer to constructions that do not obey them."
  },
  {
    "objectID": "/rsh/#p_12",
    "pt": "Language",
    "t": 3,
    "c": "It is always invalid to use a value with an operation for which it is undefined. For example, {!rsh} 1 + true is invalid. In other words, Reach enforces a static type discipline."
  },
  {
    "objectID": "/rsh/#p_13",
    "pt": "Language",
    "t": 3,
    "c": "The text of a Reach program is public knowledge to all participants. However, any value that comes from an interaction expression is a secret which only that participant knows. Furthermore, any values derived from secret values are also secret. A value, X, is considered derived from another, Y, if the value of Y is provided to a primitive operation to arrive at X, or if Y is used as part of a conditional that influences the definition of X. Secrets can only be made public by using the declassify primitive."
  },
  {
    "objectID": "/rsh/#p_14",
    "pt": "Language",
    "t": 3,
    "c": "When secret values are bound to an identifier within a local step, the identifier name MUST be prefixed by an underscore ({!rsh} _)."
  },
  {
    "objectID": "/rsh/#p_15",
    "pt": "Language",
    "t": 3,
    "c": "When public values are bound to an identifier, regardless of context, the identifier name MUST NOT be prefixed by an underscore ({!rsh} _)."
  },
  {
    "objectID": "/rsh/#p_16",
    "pt": "Language",
    "t": 3,
    "c": "Consequently, identifiers which appear inside of a function definition or arrow expression MAY be prefixed by an underscore. This will cause a compiler error if any value bound to that identifier is public."
  },
  {
    "objectID": "/rsh/#p_17",
    "pt": "Language",
    "t": 3,
    "c": "A term Y is said to be \"dominated\" by a term X if all paths in the control-flow graph of the application from the root to Y pass through X. In most cases, this corresponds to \"X appears above Y at the same or lower level of indentation\" in the program source code."
  },
  {
    "objectID": "/rsh/#p_18",
    "pt": "Language",
    "t": 3,
    "c": "For example, in the following program:"
  },
  {
    "objectID": "/rsh/#p_19",
    "pt": "Language",
    "t": 3,
    "c": "{!rsh} f dominates {!rsh} p, {!rsh} g, {!rsh} h, and {!rsh} m. But no other term dominates any other term. In particular, {!rsh} g does not dominate {!rsh} m because it is possible to reach {!rsh} m without going through {!rsh} g, such as when {!rsh} p() is false."
  },
  {
    "objectID": "/tool/#cmd_REACH_CONNECTOR_MODE",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "REACH_CONNECTOR_MODE"
  },
  {
    "objectID": "/tool/#cmd_REACH_VERSION",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "REACH_VERSION"
  },
  {
    "objectID": "/tool/#cmd_REACH_DEBUG",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "REACH_DEBUG"
  },
  {
    "objectID": "/tool/#cmd_reach%20compile",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach compile"
  },
  {
    "objectID": "/tool/#cmd_reach%20init",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach init"
  },
  {
    "objectID": "/tool/#cmd_reach%20run",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach run"
  },
  {
    "objectID": "/tool/#cmd_reach%20down",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach down"
  },
  {
    "objectID": "/tool/#cmd_reach%20scaffold",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach scaffold"
  },
  {
    "objectID": "/tool/#cmd_reach%20react",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach react"
  },
  {
    "objectID": "/tool/#cmd_reach%20devnet",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach devnet"
  },
  {
    "objectID": "/tool/#cmd_reach%20rpc-server",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach rpc-server"
  },
  {
    "objectID": "/tool/#cmd_reach%20rpc-run",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach rpc-run"
  },
  {
    "objectID": "/tool/#cmd_reach%20docker-reset",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach docker-reset"
  },
  {
    "objectID": "/tool/#cmd_reach%20info",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach info"
  },
  {
    "objectID": "/tool/#cmd_reach%20update",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach update"
  },
  {
    "objectID": "/tool/#cmd_reach%20version",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach version"
  },
  {
    "objectID": "/tool/#cmd_reach%20hashes",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach hashes"
  },
  {
    "objectID": "/tool/#cmd_reach%20config",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach config"
  },
  {
    "objectID": "/tool/#cmd_reach%20--disable-reporting",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach --disable-reporting"
  },
  {
    "objectID": "/tool/#term_lockfile",
    "pt": "Tool",
    "t": 1,
    "c": "lockfile"
  },
  {
    "objectID": "/tool/#ref",
    "pt": "Tool",
    "t": 2,
    "c": "Tool"
  },
  {
    "objectID": "/tool/#ref-install",
    "pt": "Tool",
    "t": 2,
    "c": "Installation"
  },
  {
    "objectID": "/tool/#ref-usage",
    "pt": "Tool",
    "t": 2,
    "c": "Usage"
  },
  {
    "objectID": "/tool/#ref-usage-envvar-connector-mode",
    "pt": "Tool",
    "t": 2,
    "c": "REACH_CONNECTOR_MODE"
  },
  {
    "objectID": "/tool/#ref-usage-envvar-version",
    "pt": "Tool",
    "t": 2,
    "c": "REACH_VERSION"
  },
  {
    "objectID": "/tool/#ref-usage-envvar-debug",
    "pt": "Tool",
    "t": 2,
    "c": "REACH_DEBUG"
  },
  {
    "objectID": "/tool/#ref-usage-compile",
    "pt": "Tool",
    "t": 2,
    "c": "reach compile"
  },
  {
    "objectID": "/tool/#ref-usage-init",
    "pt": "Tool",
    "t": 2,
    "c": "reach init"
  },
  {
    "objectID": "/tool/#ref-usage-run",
    "pt": "Tool",
    "t": 2,
    "c": "reach run"
  },
  {
    "objectID": "/tool/#ref-usage-down",
    "pt": "Tool",
    "t": 2,
    "c": "reach down"
  },
  {
    "objectID": "/tool/#ref-usage-scaffold",
    "pt": "Tool",
    "t": 2,
    "c": "reach scaffold"
  },
  {
    "objectID": "/tool/#ref-usage-react",
    "pt": "Tool",
    "t": 2,
    "c": "reach react"
  },
  {
    "objectID": "/tool/#ref-usage-devnet",
    "pt": "Tool",
    "t": 2,
    "c": "reach devnet"
  },
  {
    "objectID": "/tool/#ref-usage-rpc-server",
    "pt": "Tool",
    "t": 2,
    "c": "reach rpc-server"
  },
  {
    "objectID": "/tool/#ref-usage-rpc-run",
    "pt": "Tool",
    "t": 2,
    "c": "reach rpc-run"
  },
  {
    "objectID": "/tool/#ref-usage-docker-reset",
    "pt": "Tool",
    "t": 2,
    "c": "reach docker-reset"
  },
  {
    "objectID": "/tool/#ref-usage-info",
    "pt": "Tool",
    "t": 2,
    "c": "reach info"
  },
  {
    "objectID": "/tool/#ref-usage-update",
    "pt": "Tool",
    "t": 2,
    "c": "reach update"
  },
  {
    "objectID": "/tool/#ref-usage-version",
    "pt": "Tool",
    "t": 2,
    "c": "reach version"
  },
  {
    "objectID": "/tool/#ref-usage-hashes",
    "pt": "Tool",
    "t": 2,
    "c": "reach hashes"
  },
  {
    "objectID": "/tool/#ref-usage-config",
    "pt": "Tool",
    "t": 2,
    "c": "reach config"
  },
  {
    "objectID": "/tool/#ref-usage-arg-disable-reporting",
    "pt": "Tool",
    "t": 2,
    "c": "reach --disable-reporting"
  },
  {
    "objectID": "/tool/#p_0",
    "pt": "Tool",
    "t": 3,
    "c": "This document describes the reach tool: how to install it and how to use it."
  },
  {
    "objectID": "/tool/#p_1",
    "pt": "Tool",
    "t": 3,
    "c": "Reach is designed to work on POSIX systems with make, Docker, and Docker Compose installed. The best way to install Docker on Mac and Windows is with Docker Desktop."
  },
  {
    "objectID": "/tool/#p_2",
    "pt": "Tool",
    "t": 3,
    "c": "You probably already have make installed. For example, OS X and many other POSIX systems come with make, but some versions of Linux do not include it by default and will require you to install it. If you are on Ubuntu, you can run sudo apt install make to get it."
  },
  {
    "objectID": "/tool/#p_3",
    "pt": "Tool",
    "t": 3,
    "c": "You can install Reach by running:"
  },
  {
    "objectID": "/tool/#p_4",
    "pt": "Tool",
    "t": 3,
    "c": "in your project repository. You can copy this file to other repositories or move it to a directory in your PATH, like ~/bin. (PATH is a UNIX environment variable listing each of the directories that contain programs you can run in a shell session.)"
  },
  {
    "objectID": "/tool/#p_5",
    "pt": "Tool",
    "t": 3,
    "c": "If you're using Windows, consult the guide to using Reach on Windows."
  },
  {
    "objectID": "/tool/#p_6",
    "pt": "Tool",
    "t": 3,
    "c": "{!cmd} REACH_CONNECTOR_MODE is how one targets their desired network."
  },
  {
    "objectID": "/tool/#p_7",
    "pt": "Tool",
    "t": 3,
    "c": "The following are all valid options:"
  },
  {
    "objectID": "/tool/#p_8",
    "pt": "Tool",
    "t": 3,
    "c": "ALGO (this is a shortcut for ALGO-devnet)"
  },
  {
    "objectID": "/tool/#p_9",
    "pt": "Tool",
    "t": 3,
    "c": "CFX (this is a shortcut for CFX-devnet)"
  },
  {
    "objectID": "/tool/#p_10",
    "pt": "Tool",
    "t": 3,
    "c": "ETH (this is a shortcut for ETH-devnet)"
  },
  {
    "objectID": "/tool/#p_11",
    "pt": "Tool",
    "t": 3,
    "c": "Not all Reach commands require {!cmd} REACH_CONNECTOR_MODE to be set, and some commands only support a subset of the list above (e.g. {!cmd} reach run and {!cmd} reach react)."
  },
  {
    "objectID": "/tool/#p_12",
    "pt": "Tool",
    "t": 3,
    "c": "Commands for which {!cmd} REACH_CONNECTOR_MODE is mandatory will raise an exception at runtime if it isn't specified."
  },
  {
    "objectID": "/tool/#p_13",
    "pt": "Tool",
    "t": 3,
    "c": "For the sake of convenience it's recommended to run {!cmd} reach config to select a permanent default when first setting up your development machine, but you may also supply an ad hoc network explicitly like so:"
  },
  {
    "objectID": "/tool/#p_14",
    "pt": "Tool",
    "t": 3,
    "c": "Making an explicit selection in this way is how Reach developers can target multiple networks since an environment variable specified at the command-line takes precedence over one's {!cmd} reach config settings."
  },
  {
    "objectID": "/tool/#p_15",
    "pt": "Tool",
    "t": 3,
    "c": "{!cmd} REACH_VERSION may be used to override Reach's default-to-latest behavior and instead select a specific, pinned release."
  },
  {
    "objectID": "/tool/#p_16",
    "pt": "Tool",
    "t": 3,
    "c": "Although normally expressed in a semantic versioning-friendly format, e.g. v0.1 or v0.1.6, {!cmd} REACH_VERSION also supports:"
  },
  {
    "objectID": "/tool/#p_17",
    "pt": "Tool",
    "t": 3,
    "c": "Hashes such as 639fa565."
  },
  {
    "objectID": "/tool/#p_18",
    "pt": "Tool",
    "t": 3,
    "c": "Valid hashes may be obtained by running:"
  },
  {
    "objectID": "/tool/#p_19",
    "pt": "Tool",
    "t": 3,
    "c": "Date-stamps such as 2021-11-04."
  },
  {
    "objectID": "/tool/#p_20",
    "pt": "Tool",
    "t": 3,
    "c": "Valid date-stamps may be obtained by browsing Reach's public Docker image registry on DockerHub."
  },
  {
    "objectID": "/tool/#p_21",
    "pt": "Tool",
    "t": 3,
    "c": "Tip: try entering your desired year in the filter box to skip other tag types."
  },
  {
    "objectID": "/tool/#p_22",
    "pt": "Tool",
    "t": 3,
    "c": "The identifer \"stable\"."
  },
  {
    "objectID": "/tool/#p_23",
    "pt": "Tool",
    "t": 3,
    "c": "Reach will interpret this to mean the most recent stable major version."
  },
  {
    "objectID": "/tool/#p_24",
    "pt": "Tool",
    "t": 3,
    "c": "When using the semantic versioning form of {!cmd} REACH_VERSION the preceding v character is optional. In other words, v0.1.6 is equivalent to 0.1.6."
  },
  {
    "objectID": "/tool/#p_25",
    "pt": "Tool",
    "t": 3,
    "c": "For commands that support it, setting {!cmd} REACH_DEBUG to any non-empty value produces verbose output which may be helpful during development or debugging."
  },
  {
    "objectID": "/tool/#p_26",
    "pt": "Tool",
    "t": 3,
    "c": "See {!cmd} reach compile, {!cmd} reach run, or {!cmd} reach react for examples."
  },
  {
    "objectID": "/tool/#p_27",
    "pt": "Tool",
    "t": 3,
    "c": "Compile Reach code by executing"
  },
  {
    "objectID": "/tool/#p_28",
    "pt": "Tool",
    "t": 3,
    "c": "where SOURCE is your source file, and each EXPORT is an exported {!rsh} Reach.App."
  },
  {
    "objectID": "/tool/#p_29",
    "pt": "Tool",
    "t": 3,
    "c": "If no SOURCE is provided, then index.rsh is used."
  },
  {
    "objectID": "/tool/#p_30",
    "pt": "Tool",
    "t": 3,
    "c": "If no EXPORT is provided, then all the exported {!rsh} Reach.Apps will be compiled. If there are no {!rsh} Reach.Apps exported, then the program will be compiled as a library, where its exports are available to other Reach programs and frontends. The output name of a library is the same as if it exported a {!rsh} Reach.App named default."
  },
  {
    "objectID": "/tool/#p_31",
    "pt": "Tool",
    "t": 3,
    "c": "{!cmd} reach compile supports the following options:"
  },
  {
    "objectID": "/tool/#p_32",
    "pt": "Tool",
    "t": 3,
    "c": "-o/--output OUTPUT --- Writes compiler output files to OUTPUT, which defaults to a directory named build in the same directory as SOURCE."
  },
  {
    "objectID": "/tool/#p_33",
    "pt": "Tool",
    "t": 3,
    "c": "--intermediate-files --- Write intermediate files, which may be interesting for debugging compilation failures or using in other contexts."
  },
  {
    "objectID": "/tool/#p_34",
    "pt": "Tool",
    "t": 3,
    "c": "--install-pkgs --- Allows Reach to fetch remote package imports and stop after doing so."
  },
  {
    "objectID": "/tool/#p_35",
    "pt": "Tool",
    "t": 3,
    "c": "Reach will fail with an error message if package imports have not yet been fetched and this flag is not activated."
  },
  {
    "objectID": "/tool/#p_36",
    "pt": "Tool",
    "t": 3,
    "c": "Using this flag will create a .reach directory for your project. This directory stores your project's lockfile, which is how Reach pins remote packages to specific versions. It is recommended that you commit the .reach directory to source control. Deleting this directory is also safe; it can easily be rebuilt by using the --install-pkgs flag again; in fact, this is the best way to upgrade your packages."
  },
  {
    "objectID": "/tool/#p_37",
    "pt": "Tool",
    "t": 3,
    "c": "--stop-after-eval --- Stops the compilation process before verification and producing output files. This might be useful for performing syntax and type checking quickly."
  },
  {
    "objectID": "/tool/#p_38",
    "pt": "Tool",
    "t": 3,
    "c": "--verify-timeout TIMEOUT-MS --- Sets the timeout of individual verification theorems, in milliseconds. The default value is 2 minutes."
  },
  {
    "objectID": "/tool/#p_39",
    "pt": "Tool",
    "t": 3,
    "c": "--verify-fail-once --- Stops the compilation process after printing a single verification failure. This may help keep you organized while fixing verification failures in your program."
  },
  {
    "objectID": "/tool/#p_40",
    "pt": "Tool",
    "t": 3,
    "c": "The environment variable {!cmd} REACH_DEBUG, if set to any non-empty value, enables debug messages from the Reach compiler, which will appear in the console. This debug information includes: the estimated cost of the contract on Algorand. This variable automatically enables --intermediate-files."
  },
  {
    "objectID": "/tool/#p_41",
    "pt": "Tool",
    "t": 3,
    "c": "A {!cmd} reach compile usage example is available in Overview."
  },
  {
    "objectID": "/tool/#p_42",
    "pt": "Tool",
    "t": 3,
    "c": "This creates the index.rsh and index.mjs template files required for a basic Reach DApp. It allows you to open the files and start writing code. The index.rsh file is the DApp and is written in Reach, and the index.mjs file is the frontend of the DApp and is written in JavaScript."
  },
  {
    "objectID": "/tool/#p_43",
    "pt": "Tool",
    "t": 3,
    "c": "The {!cmd} reach run command with no arguments starts the index application in the current directory by default, but you can set a different directory, application name, or both."
  },
  {
    "objectID": "/tool/#p_44",
    "pt": "Tool",
    "t": 3,
    "c": "The {!cmd} reach run command uses the following interface:"
  },
  {
    "objectID": "/tool/#p_45",
    "pt": "Tool",
    "t": 3,
    "c": "APP represents a Reach module name without its extension (e.g. \"index\" by default)."
  },
  {
    "objectID": "/tool/#p_46",
    "pt": "Tool",
    "t": 3,
    "c": "If no APP or DIR is provided then index in the current working directory is assumed."
  },
  {
    "objectID": "/tool/#p_47",
    "pt": "Tool",
    "t": 3,
    "c": "If DIR matches an existing, relative subdirectory of the current working directory then DIR/index is used."
  },
  {
    "objectID": "/tool/#p_48",
    "pt": "Tool",
    "t": 3,
    "c": "ARGS represents zero or more arguments to be passed into APP's frontend."
  },
  {
    "objectID": "/tool/#p_49",
    "pt": "Tool",
    "t": 3,
    "c": "This assumes"
  },
  {
    "objectID": "/tool/#p_50",
    "pt": "Tool",
    "t": 3,
    "c": "Your Reach program is named APP.rsh."
  },
  {
    "objectID": "/tool/#p_51",
    "pt": "Tool",
    "t": 3,
    "c": "You are using the JavaScript backend and your frontend is named APP.mjs. It also assumes the backend is located at DIR/build/APP.main.mjs, and only depends on the Reach standard library."
  },
  {
    "objectID": "/tool/#p_52",
    "pt": "Tool",
    "t": 3,
    "c": "It then"
  },
  {
    "objectID": "/tool/#p_53",
    "pt": "Tool",
    "t": 3,
    "c": "Compiles your program with Reach."
  },
  {
    "objectID": "/tool/#p_54",
    "pt": "Tool",
    "t": 3,
    "c": "Builds a Docker image named reachsh/reach-app-APP:latest that depends on the Reach JavaScript standard library."
  },
  {
    "objectID": "/tool/#p_55",
    "pt": "Tool",
    "t": 3,
    "c": "Executes a container based upon that image while connected to the network determined by {!cmd} REACH_CONNECTOR_MODE."
  },
  {
    "objectID": "/tool/#p_56",
    "pt": "Tool",
    "t": 3,
    "c": "{!cmd} reach run supports the following options:"
  },
  {
    "objectID": "/tool/#p_57",
    "pt": "Tool",
    "t": 3,
    "c": "The mandatory environment variable {!cmd} REACH_CONNECTOR_MODE specifies which context to run in. The options are:"
  },
  {
    "objectID": "/tool/#p_58",
    "pt": "Tool",
    "t": 3,
    "c": "ETH-devnet (or ETH for short), which uses a Dockerized private Ethereum network."
  },
  {
    "objectID": "/tool/#p_59",
    "pt": "Tool",
    "t": 3,
    "c": "ETH-live, which uses a live Ethereum network node, specified by the environment variable ETH_NODE_URI."
  },
  {
    "objectID": "/tool/#p_60",
    "pt": "Tool",
    "t": 3,
    "c": "ALGO-devnet (or ALGO for short), which uses a Dockerized private Algorand network."
  },
  {
    "objectID": "/tool/#p_61",
    "pt": "Tool",
    "t": 3,
    "c": "ALGO-live, which uses a live Algorand network node, specified by the environment variables documented in the Algorand connector section."
  },
  {
    "objectID": "/tool/#p_62",
    "pt": "Tool",
    "t": 3,
    "c": "CFX-devnet (or CFX for short), which uses a Dockerized private Conflux network."
  },
  {
    "objectID": "/tool/#p_63",
    "pt": "Tool",
    "t": 3,
    "c": "CFX-live, which uses a live Conflux network node, specified by the environment variable CFX_NODE_URI."
  },
  {
    "objectID": "/tool/#p_64",
    "pt": "Tool",
    "t": 3,
    "c": "The environment variable {!cmd} REACH_DEBUG, if set to any non-empty value, enables debug messages from the Reach standard library, which will appear in the console."
  },
  {
    "objectID": "/tool/#p_65",
    "pt": "Tool",
    "t": 3,
    "c": "{!cmd} reach run can be further specialized via the presence of a Dockerfile and package.json file. If either are absent, {!cmd} reach run assumes a default behavior (which may be persisted with {!cmd} reach scaffold)."
  },
  {
    "objectID": "/tool/#p_66",
    "pt": "Tool",
    "t": 3,
    "c": "The Dockerfile can be modified to introduce new dependencies, services, or filesystem prerequisites into your app's containerized environment, and the package.json file may likewise be extended to include additional libraries or make configuration changes to the resultant Node.js package."
  },
  {
    "objectID": "/tool/#p_67",
    "pt": "Tool",
    "t": 3,
    "c": "You can halt all Dockerized Reach apps and devnets by running"
  },
  {
    "objectID": "/tool/#p_68",
    "pt": "Tool",
    "t": 3,
    "c": "You can create templated Dockerfile and package.json files for a simple Reach app by running"
  },
  {
    "objectID": "/tool/#p_69",
    "pt": "Tool",
    "t": 3,
    "c": "The files created are the same as those used temporarily by {!cmd} reach run."
  },
  {
    "objectID": "/tool/#p_70",
    "pt": "Tool",
    "t": 3,
    "c": "You can run a simple React app by executing"
  },
  {
    "objectID": "/tool/#p_71",
    "pt": "Tool",
    "t": 3,
    "c": "This assumes"
  },
  {
    "objectID": "/tool/#p_72",
    "pt": "Tool",
    "t": 3,
    "c": "Your Reach program is named index.rsh"
  },
  {
    "objectID": "/tool/#p_73",
    "pt": "Tool",
    "t": 3,
    "c": "Your frontend React program is named index.js"
  },
  {
    "objectID": "/tool/#p_74",
    "pt": "Tool",
    "t": 3,
    "c": "It then"
  },
  {
    "objectID": "/tool/#p_75",
    "pt": "Tool",
    "t": 3,
    "c": "Compiles your program with Reach"
  },
  {
    "objectID": "/tool/#p_76",
    "pt": "Tool",
    "t": 3,
    "c": "Runs the appropriate devnet based on {!cmd} REACH_CONNECTOR_MODE"
  },
  {
    "objectID": "/tool/#p_77",
    "pt": "Tool",
    "t": 3,
    "c": "Mounts the current directory into /app/src/ in the reachsh/react-runner Docker image and runs it."
  },
  {
    "objectID": "/tool/#p_78",
    "pt": "Tool",
    "t": 3,
    "c": "{!cmd} reach react supports the following options:"
  },
  {
    "objectID": "/tool/#p_79",
    "pt": "Tool",
    "t": 3,
    "c": "The mandatory environment variable {!cmd} REACH_CONNECTOR_MODE specifies which context to run in. The options are:"
  },
  {
    "objectID": "/tool/#p_80",
    "pt": "Tool",
    "t": 3,
    "c": "ETH-browser (or ETH for short), which targets a Dockerized private Ethereum network via a browser extension, like MetaMask."
  },
  {
    "objectID": "/tool/#p_81",
    "pt": "Tool",
    "t": 3,
    "c": "ALGO-browser (or ALGO for short), which targets a Dockerized private Algorand network via an ARC-0011 browser wallet."
  },
  {
    "objectID": "/tool/#p_82",
    "pt": "Tool",
    "t": 3,
    "c": "CFX-browser (or CFX for short), which targets a Dockerized private Conflux network via a browser extension, like ConfluxPortal."
  },
  {
    "objectID": "/tool/#p_83",
    "pt": "Tool",
    "t": 3,
    "c": "The environment variable {!cmd} REACH_DEBUG, if set to any non-empty value, enables debug messages from the Reach standard library, which will appear in the browser console."
  },
  {
    "objectID": "/tool/#p_84",
    "pt": "Tool",
    "t": 3,
    "c": "When using {!js} loadStdlib in conjunction with {!cmd} reach react, be sure to pass in {!js} process.env as its argument. See {!js} loadStdlib for details."
  },
  {
    "objectID": "/tool/#p_85",
    "pt": "Tool",
    "t": 3,
    "c": "{!cmd} reach react does not respect the same scaffolded files as {!cmd} reach run. It is just a simplified tool to give you a taste of web programming with reach. If you would like access to more customizations on a browser-based project, such as custom environment variables, custom JavaScript dependencies, or using other JavaScript frameworks like Angular, we recommend that you simply use {!cmd} reach compile, and use your own preferred JavaScript setup for the project. The compiled build/index.main.mjs JavaScript file and the '@reach-sh/stdlib' JavaScript library may be used in any JavaScript project like any other JavaScript file and library, respectively."
  },
  {
    "objectID": "/tool/#p_86",
    "pt": "Tool",
    "t": 3,
    "c": "You can run a private Reach devnet by executing the following command:"
  },
  {
    "objectID": "/tool/#p_87",
    "pt": "Tool",
    "t": 3,
    "c": "If running {!cmd} reach devnet, it is recommended to permanently set {!cmd} REACH_CONNECTOR_MODE to the desired consensus network. If you did not set this when you originally ran {!cmd} reach config, then you can run {!cmd} reach devnet with the argument {!cmd} REACH_CONNECTOR_MODE=[OPTION] as in the following command."
  },
  {
    "objectID": "/tool/#p_88",
    "pt": "Tool",
    "t": 3,
    "c": "{!cmd} reach devnet supports the following options:"
  },
  {
    "objectID": "/tool/#p_89",
    "pt": "Tool",
    "t": 3,
    "c": "--await-background --- Run in the background and await availability."
  },
  {
    "objectID": "/tool/#p_90",
    "pt": "Tool",
    "t": 3,
    "c": "For more information on devnet options, refer to Networks."
  },
  {
    "objectID": "/tool/#p_91",
    "pt": "Tool",
    "t": 3,
    "c": "The following command"
  },
  {
    "objectID": "/tool/#p_92",
    "pt": "Tool",
    "t": 3,
    "c": "starts an instance of the Reach RPC Server, sharing all of the same options and defaults as {!cmd} reach run, but also including the following:"
  },
  {
    "objectID": "/tool/#p_93",
    "pt": "Tool",
    "t": 3,
    "c": "The environment variable {!cmd} REACH_RPC_KEY is used to determine the RPC server key. If not defined, it defaults to opensesame, and a warning will appear in the console stating that the development key is being used."
  },
  {
    "objectID": "/tool/#p_94",
    "pt": "Tool",
    "t": 3,
    "c": "In a production context this key must be kept secret, and it should be randomly generated with a suitably strong method, such as:"
  },
  {
    "objectID": "/tool/#p_95",
    "pt": "Tool",
    "t": 3,
    "c": "The environment variable {!cmd} REACH_RPC_PORT is used to determine which port to bind to. It defaults to 3000."
  },
  {
    "objectID": "/tool/#p_96",
    "pt": "Tool",
    "t": 3,
    "c": "The environment variable {!cmd} REACH_RPC_TLS_KEY is used to determine the path to the TLS key file, which must be in the ./tls directory. It defaults to reach-server.key."
  },
  {
    "objectID": "/tool/#p_97",
    "pt": "Tool",
    "t": 3,
    "c": "The environment variable {!cmd} REACH_RPC_TLS_CRT is used to determine the path to the TLS crt file, which must be in the ./tls directory. It defaults to reach-server.crt."
  },
  {
    "objectID": "/tool/#p_98",
    "pt": "Tool",
    "t": 3,
    "c": "The environment variable {!cmd} REACH_RPC_TLS_PASSPHRASE is used to determine the TLS passphrase. It defaults to rpc-demo."
  },
  {
    "objectID": "/tool/#p_99",
    "pt": "Tool",
    "t": 3,
    "c": "The following command"
  },
  {
    "objectID": "/tool/#p_100",
    "pt": "Tool",
    "t": 3,
    "c": "is a convenient means of launching a pre-configured RPC server and frontend which are suitable for development purposes. It uses a REACH_RPC_KEY value of opensesame (the standard development API key), and sets REACH_RPC_TLS_REJECT_UNVERIFIED to 0."
  },
  {
    "objectID": "/tool/#p_101",
    "pt": "Tool",
    "t": 3,
    "c": "Consider this example from the Rock, Paper, Scissors in Python tutorial:"
  },
  {
    "objectID": "/tool/#p_102",
    "pt": "Tool",
    "t": 3,
    "c": "You can easily kill and remove all Docker containers by executing"
  },
  {
    "objectID": "/tool/#p_103",
    "pt": "Tool",
    "t": 3,
    "c": "This can be a useful thing to try if your Docker containers stop responding to requests or otherwise misbehave, or if you have updated your Reach images (with {!cmd} reach update) but those changes are not taking effect."
  },
  {
    "objectID": "/tool/#p_104",
    "pt": "Tool",
    "t": 3,
    "c": "It will affect all Docker containers on your machine, not just those created by Reach. For this reason it's recommended to prefer {!cmd} reach down."
  },
  {
    "objectID": "/tool/#p_105",
    "pt": "Tool",
    "t": 3,
    "c": "To check whether new releases are available, run"
  },
  {
    "objectID": "/tool/#p_106",
    "pt": "Tool",
    "t": 3,
    "c": "{!cmd} reach info may be paired with the {!cmd} REACH_VERSION environment variable in order to respect version-pinning (e.g. if you want the latest version on Reach's 0.1.6 branch but don't wish to upgrade to 0.1.7)."
  },
  {
    "objectID": "/tool/#p_107",
    "pt": "Tool",
    "t": 3,
    "c": "An interactive menu, allowing you to selectively perform suggested updates, is also available:"
  },
  {
    "objectID": "/tool/#p_108",
    "pt": "Tool",
    "t": 3,
    "c": "You can update Reach to a newer release by executing"
  },
  {
    "objectID": "/tool/#p_109",
    "pt": "Tool",
    "t": 3,
    "c": "As with {!cmd} reach info, {!cmd} reach update respects the {!cmd} REACH_VERSION environment variable for the purpose of version-pinning."
  },
  {
    "objectID": "/tool/#p_110",
    "pt": "Tool",
    "t": 3,
    "c": "Check which version of the Reach command-line tool is currently installed by running"
  },
  {
    "objectID": "/tool/#p_111",
    "pt": "Tool",
    "t": 3,
    "c": "This is less precise than {!cmd} reach hashes, but gives you an idea of which features are, or are not, available in your build version."
  },
  {
    "objectID": "/tool/#p_112",
    "pt": "Tool",
    "t": 3,
    "c": "Check which version of each Reach Docker image is installed. This command returns the hash version of each image in an 8 digit alpha-numeric code (such as 639fa565)."
  },
  {
    "objectID": "/tool/#p_113",
    "pt": "Tool",
    "t": 3,
    "c": "This is more precise, but less readable, than {!cmd} reach version, in that each hash refers to the git commit used to build the image."
  },
  {
    "objectID": "/tool/#p_114",
    "pt": "Tool",
    "t": 3,
    "c": "Reach recommends tuning your default workflow settings by executing"
  },
  {
    "objectID": "/tool/#p_115",
    "pt": "Tool",
    "t": 3,
    "c": "Using {!cmd} reach config is advisable when running Reach for the first time since it will set the {!cmd} REACH_CONNECTOR_MODE environment variable, which is required when executing some other sub-commands (e.g. {!cmd} reach run)."
  },
  {
    "objectID": "/tool/#p_116",
    "pt": "Tool",
    "t": 3,
    "c": "{!cmd} reach config presents users with a guided menu which automatically creates an env file and suggests subsequent steps to activate and make it permanent. This env file exports environment variable settings and is intended to be sourced by users' shells."
  },
  {
    "objectID": "/tool/#p_117",
    "pt": "Tool",
    "t": 3,
    "c": "If an env file already exists, {!cmd} reach config offers to back it up before proceeding."
  },
  {
    "objectID": "/tool/#p_118",
    "pt": "Tool",
    "t": 3,
    "c": "The Reach command-line tool collects anonymous usage data by default, but this can be skipped by prepending --disable-reporting before any given sub-command, e.g.:"
  },
  {
    "objectID": "/tool/#p_119",
    "pt": "Tool",
    "t": 3,
    "c": "Out of respect for users' privacy and the security of their intellectual property, Reach takes special care to avoid gathering personally-identifiable information and instead tallies only metrics which cannot easily be correlated back to specific individuals and which doesn't leak sensitive details about their code."
  },
  {
    "objectID": "/tool/#p_120",
    "pt": "Tool",
    "t": 3,
    "c": "For instance, we discard IP addresses and strip timestamps to just UTC dates."
  },
  {
    "objectID": "/tool/#p_121",
    "pt": "Tool",
    "t": 3,
    "c": "Only the following are tracked:"
  },
  {
    "objectID": "/tool/#p_122",
    "pt": "Tool",
    "t": 3,
    "c": "From the Reach command-line tool or VS Code extension:"
  },
  {
    "objectID": "/tool/#p_123",
    "pt": "Tool",
    "t": 3,
    "c": "A random ID that's unique per-user and per-machine (but which doesn't reveal the user's identity);"
  },
  {
    "objectID": "/tool/#p_124",
    "pt": "Tool",
    "t": 3,
    "c": "The UTC date on which an event occurred;"
  },
  {
    "objectID": "/tool/#p_125",
    "pt": "Tool",
    "t": 3,
    "c": "The type of event, e.g. {!cmd} reach run or {!cmd} reach devnet;"
  },
  {
    "objectID": "/tool/#p_126",
    "pt": "Tool",
    "t": 3,
    "c": "Resultant error code or indication of success associated with the event;"
  },
  {
    "objectID": "/tool/#p_127",
    "pt": "Tool",
    "t": 3,
    "c": "{!cmd} REACH_VERSION;"
  },
  {
    "objectID": "/tool/#p_128",
    "pt": "Tool",
    "t": 3,
    "c": "{!cmd} REACH_CONNECTOR_MODE;"
  },
  {
    "objectID": "/tool/#p_129",
    "pt": "Tool",
    "t": 3,
    "c": "Whether the event was triggered by the Reach VSCode extension."
  },
  {
    "objectID": "/tool/#p_130",
    "pt": "Tool",
    "t": 3,
    "c": "Geolocation data inferred from your IP address:"
  },
  {
    "objectID": "/tool/#p_131",
    "pt": "Tool",
    "t": 3,
    "c": "The user's country;"
  },
  {
    "objectID": "/tool/#p_132",
    "pt": "Tool",
    "t": 3,
    "c": "The user's state or region."
  },
  {
    "objectID": "/tool/#p_133",
    "pt": "Tool",
    "t": 3,
    "c": "Invoking a sub-command with --disable-reporting instructs reach not to send any usage data at all."
  },
  {
    "objectID": "/trouble/#trouble",
    "pt": "Troubleshooting",
    "t": 2,
    "c": "Troubleshooting"
  },
  {
    "objectID": "/trouble/#ts-perm",
    "pt": "Troubleshooting",
    "t": 2,
    "c": "Permissions"
  },
  {
    "objectID": "/trouble/#ts-win8",
    "pt": "Troubleshooting",
    "t": 2,
    "c": "Windows 8 Docker installation problems"
  },
  {
    "objectID": "/trouble/#ts-reachdir",
    "pt": "Troubleshooting",
    "t": 2,
    "c": "./reach: is a directory"
  },
  {
    "objectID": "/trouble/#ts-reachsudo",
    "pt": "Troubleshooting",
    "t": 2,
    "c": "reach run seems to require sudo"
  },
  {
    "objectID": "/trouble/#ts-vscode",
    "pt": "Troubleshooting",
    "t": 2,
    "c": "Troubleshooting Reach VSCode Extension"
  },
  {
    "objectID": "/trouble/#ts-mac-platform",
    "pt": "Troubleshooting",
    "t": 2,
    "c": "MacOS M1 problems"
  },
  {
    "objectID": "/trouble/#ts-out-of-memory",
    "pt": "Troubleshooting",
    "t": 2,
    "c": "Out of Memory"
  },
  {
    "objectID": "/trouble/#other-issues",
    "pt": "Troubleshooting",
    "t": 2,
    "c": "Other issues"
  },
  {
    "objectID": "/trouble/#p_0",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "This document contains explanations and solutions for a variety of common problems we've observed users facing."
  },
  {
    "objectID": "/trouble/#p_1",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "If you receive one of the following errors:"
  },
  {
    "objectID": "/trouble/#p_2",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "or"
  },
  {
    "objectID": "/trouble/#p_3",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "This generally means that Reach was previously run or installed with sudo and directories were created that only root can access."
  },
  {
    "objectID": "/trouble/#p_4",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "If this is the case, delete the local copy of the Reach program and reinstall per the instructions."
  },
  {
    "objectID": "/trouble/#p_5",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "You should also delete all of the files in the /tmp directory with the prefix reach. You probably need to do this with sudo."
  },
  {
    "objectID": "/trouble/#p_6",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "Unfortunately, Docker Desktop does not support Windows 8. And Reach requires Docker. So, Reach is not able to run on Windows 8. You should upgrade to a newer version of Windows."
  },
  {
    "objectID": "/trouble/#p_7",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "If executing ./reach version on Linux outputs ./reach: is a directory, then it means that you are intending to run the reach command, but are doing it in a directory where it is not installed, but that contains a directory named reach."
  },
  {
    "objectID": "/trouble/#p_8",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "For example, if you installed by running"
  },
  {
    "objectID": "/trouble/#p_9",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "Then you might be running ./reach in your home directory (~), rather than the Reach directory (~/reach)."
  },
  {
    "objectID": "/trouble/#p_10",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "You can check what directory you're in by running pwd (print working directory)."
  },
  {
    "objectID": "/trouble/#p_11",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "If running ./reach run seems to require sudo, then it is likely that:"
  },
  {
    "objectID": "/trouble/#p_12",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "A component used by reach was installed/created using sudo, such as the directory. Make sure that the current user has read/write permissions in the directory."
  },
  {
    "objectID": "/trouble/#p_13",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "Docker might have been installed using Snap."
  },
  {
    "objectID": "/trouble/#p_14",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "Snap installation in Ubuntu creates permissions issues. Uninstall Docker and then re-install using the apt command in the terminal."
  },
  {
    "objectID": "/trouble/#p_15",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "Your user is not authorized to run Docker commands. See Docker's post-installation steps for Linux for help."
  },
  {
    "objectID": "/trouble/#p_16",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "If you don't see syntax highlighting in VSCode, despite having the Reach extension installed and activated, then you probably need to restart VSCode."
  },
  {
    "objectID": "/trouble/#p_17",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "If you receive the following error on Macs with an M1 chip:"
  },
  {
    "objectID": "/trouble/#p_18",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "Check which mode the terminal is in by executing $ arch in the terminal."
  },
  {
    "objectID": "/trouble/#p_19",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "On M1 machines, the output should be arm64. If it doesn't, then open a new terminal without Rosetta."
  },
  {
    "objectID": "/trouble/#p_20",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "Make sure the latest reach-cli image is installed: $ docker pull reachsh/reach-cli:latest"
  },
  {
    "objectID": "/trouble/#p_21",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "Use reach-cli to update the other Reach docker images by running $ ./reach update in the terminal."
  },
  {
    "objectID": "/trouble/#p_22",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "If you receive the following error:"
  },
  {
    "objectID": "/trouble/#p_23",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "Then that means docker needs more memory to function properly."
  },
  {
    "objectID": "/trouble/#p_24",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "Please follow the next steps to fix the problem:"
  },
  {
    "objectID": "/trouble/#p_25",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "Open your Docker home page"
  },
  {
    "objectID": "/trouble/#p_26",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "Click on the settings Icon at the top-right corner."
  },
  {
    "objectID": "/trouble/#p_27",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "In the side bar, click on Resources. This drops down a sub menu."
  },
  {
    "objectID": "/trouble/#p_28",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "In the sub menu, click on Advanced if it is not selected already."
  },
  {
    "objectID": "/trouble/#p_29",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "In the main panel at the middle, adjust the Memory to 4GB or more depending on how much RAM you have in your machine."
  },
  {
    "objectID": "/trouble/#p_30",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "Still in the main panel, adjust the Disk image size to 200GB or more depending on how much HDD or SSD storage you have in your machine."
  },
  {
    "objectID": "/trouble/#p_31",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "At the bottom-right, click on Apply & Restart."
  },
  {
    "objectID": "/trouble/#p_32",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "This should fix the problem after it is done restarting."
  },
  {
    "objectID": "/trouble/#p_33",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "If this didn't fix the issue, please restart your machine."
  },
  {
    "objectID": "/trouble/#p_34",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "If the information in this troubleshooting guide does not fix your issue, please report any errors you encounter in the Discord #help channel. This page will be updated based on issues and solutions discovered in that channel."
  },
  {
    "objectID": "/model/#term_DApp",
    "pt": "Model",
    "t": 1,
    "c": "DApp"
  },
  {
    "objectID": "/model/#term_consensus%20network",
    "pt": "Model",
    "t": 1,
    "c": "consensus network"
  },
  {
    "objectID": "/model/#term_network%20token",
    "pt": "Model",
    "t": 1,
    "c": "network token"
  },
  {
    "objectID": "/model/#term_non-network%20token",
    "pt": "Model",
    "t": 1,
    "c": "non-network token"
  },
  {
    "objectID": "/model/#term_network%20time",
    "pt": "Model",
    "t": 1,
    "c": "network time"
  },
  {
    "objectID": "/model/#term_time%20delta",
    "pt": "Model",
    "t": 1,
    "c": "time delta"
  },
  {
    "objectID": "/model/#term_network%20second",
    "pt": "Model",
    "t": 1,
    "c": "network second"
  },
  {
    "objectID": "/model/#term_transfers",
    "pt": "Model",
    "t": 1,
    "c": "transfers"
  },
  {
    "objectID": "/model/#term_account",
    "pt": "Model",
    "t": 1,
    "c": "account"
  },
  {
    "objectID": "/model/#term_address",
    "pt": "Model",
    "t": 1,
    "c": "address"
  },
  {
    "objectID": "/model/#term_publication",
    "pt": "Model",
    "t": 1,
    "c": "publication"
  },
  {
    "objectID": "/model/#term_Contracts",
    "pt": "Model",
    "t": 1,
    "c": "Contracts"
  },
  {
    "objectID": "/model/#term_consensus%20state",
    "pt": "Model",
    "t": 1,
    "c": "consensus state"
  },
  {
    "objectID": "/model/#term_mappings",
    "pt": "Model",
    "t": 1,
    "c": "mappings"
  },
  {
    "objectID": "/model/#term_linear%20state",
    "pt": "Model",
    "t": 1,
    "c": "linear state"
  },
  {
    "objectID": "/model/#term_views",
    "pt": "Model",
    "t": 1,
    "c": "views"
  },
  {
    "objectID": "/model/#term_event",
    "pt": "Model",
    "t": 1,
    "c": "event"
  },
  {
    "objectID": "/model/#term_companion",
    "pt": "Model",
    "t": 1,
    "c": "companion"
  },
  {
    "objectID": "/model/#term_deploy",
    "pt": "Model",
    "t": 1,
    "c": "deploy"
  },
  {
    "objectID": "/model/#term_participant",
    "pt": "Model",
    "t": 1,
    "c": "participant"
  },
  {
    "objectID": "/model/#term_local%20state",
    "pt": "Model",
    "t": 1,
    "c": "local state"
  },
  {
    "objectID": "/model/#term_frontend",
    "pt": "Model",
    "t": 1,
    "c": "frontend"
  },
  {
    "objectID": "/model/#term_interact",
    "pt": "Model",
    "t": 1,
    "c": "interact"
  },
  {
    "objectID": "/model/#term_participant%20class",
    "pt": "Model",
    "t": 1,
    "c": "participant class"
  },
  {
    "objectID": "/model/#term_participant%20instances",
    "pt": "Model",
    "t": 1,
    "c": "participant instances"
  },
  {
    "objectID": "/model/#term_API",
    "pt": "Model",
    "t": 1,
    "c": "API"
  },
  {
    "objectID": "/model/#term_token%20linearity%20property",
    "pt": "Model",
    "t": 1,
    "c": "token linearity property"
  },
  {
    "objectID": "/model/#term_step",
    "pt": "Model",
    "t": 1,
    "c": "step"
  },
  {
    "objectID": "/model/#term_local%20step",
    "pt": "Model",
    "t": 1,
    "c": "local step"
  },
  {
    "objectID": "/model/#term_local%20computation",
    "pt": "Model",
    "t": 1,
    "c": "local computation"
  },
  {
    "objectID": "/model/#term_consensus%20transfer",
    "pt": "Model",
    "t": 1,
    "c": "consensus transfer"
  },
  {
    "objectID": "/model/#term_originator",
    "pt": "Model",
    "t": 1,
    "c": "originator"
  },
  {
    "objectID": "/model/#term_timeout",
    "pt": "Model",
    "t": 1,
    "c": "timeout"
  },
  {
    "objectID": "/model/#term_private",
    "pt": "Model",
    "t": 1,
    "c": "private"
  },
  {
    "objectID": "/model/#term_public",
    "pt": "Model",
    "t": 1,
    "c": "public"
  },
  {
    "objectID": "/model/#term_declassification",
    "pt": "Model",
    "t": 1,
    "c": "declassification"
  },
  {
    "objectID": "/model/#term_join",
    "pt": "Model",
    "t": 1,
    "c": "join"
  },
  {
    "objectID": "/model/#term_fixed",
    "pt": "Model",
    "t": 1,
    "c": "fixed"
  },
  {
    "objectID": "/model/#term_consensus%20step",
    "pt": "Model",
    "t": 1,
    "c": "consensus step"
  },
  {
    "objectID": "/model/#term_consensus%20computation",
    "pt": "Model",
    "t": 1,
    "c": "consensus computation"
  },
  {
    "objectID": "/model/#term_commits",
    "pt": "Model",
    "t": 1,
    "c": "commits"
  },
  {
    "objectID": "/model/#term_assert",
    "pt": "Model",
    "t": 1,
    "c": "assert"
  },
  {
    "objectID": "/model/#term_knowledge%20assertion",
    "pt": "Model",
    "t": 1,
    "c": "knowledge assertion"
  },
  {
    "objectID": "/model/#term_static%20assertion",
    "pt": "Model",
    "t": 1,
    "c": "static assertion"
  },
  {
    "objectID": "/model/#term_assumption",
    "pt": "Model",
    "t": 1,
    "c": "assumption"
  },
  {
    "objectID": "/model/#term_requirement",
    "pt": "Model",
    "t": 1,
    "c": "requirement"
  },
  {
    "objectID": "/model/#term_possibility%20assertion",
    "pt": "Model",
    "t": 1,
    "c": "possibility assertion"
  },
  {
    "objectID": "/model/#term_honest",
    "pt": "Model",
    "t": 1,
    "c": "honest"
  },
  {
    "objectID": "/model/#term_value",
    "pt": "Model",
    "t": 1,
    "c": "value"
  },
  {
    "objectID": "/model/#term_digest",
    "pt": "Model",
    "t": 1,
    "c": "digest"
  },
  {
    "objectID": "/model/#term_compile",
    "pt": "Model",
    "t": 1,
    "c": "compile"
  },
  {
    "objectID": "/model/#term_connector",
    "pt": "Model",
    "t": 1,
    "c": "connector"
  },
  {
    "objectID": "/model/#term_backends",
    "pt": "Model",
    "t": 1,
    "c": "backends"
  },
  {
    "objectID": "/model/#ref-model",
    "pt": "Model",
    "t": 2,
    "c": "Model"
  },
  {
    "objectID": "/model/#ref-model-eval",
    "pt": "Model",
    "t": 2,
    "c": "Evaluation Model"
  },
  {
    "objectID": "/model/#ref-model-compile",
    "pt": "Model",
    "t": 2,
    "c": "Compilation Model"
  },
  {
    "objectID": "/model/#ref-model-syntax",
    "pt": "Model",
    "t": 2,
    "c": "Syntax Model"
  },
  {
    "objectID": "/model/#p_0",
    "pt": "Model",
    "t": 3,
    "c": "This document describes the fundamental assumptions and concepts of Reach. First, we discuss the model of running a Reach program in Evaluation Model. Next, we discuss the details about compilation of a Reach program that are relevant to Reach programmers in Compilation Model. Finally, we discuss how Reach programs are syntactically constructed in Syntax Model."
  },
  {
    "objectID": "/model/#p_1",
    "pt": "Model",
    "t": 3,
    "c": "This is not an introduction to Reach. We recommend reading the overview for an introduction to what Reach is and the tutorial to get started with programming Reach."
  },
  {
    "objectID": "/model/#p_2",
    "pt": "Model",
    "t": 3,
    "c": "Furthermore, it is not an introduction to consensus networks or \"blockchain\". If you would like to read such an introduction, we recommend the Wikipedia article on consensus and the Wikipedia article on blockchains."
  },
  {
    "objectID": "/model/#p_3",
    "pt": "Model",
    "t": 3,
    "c": "Reach programs specify a decentralized application (DApp), which is a distributed computation involving many participants and utilizing one contract on one consensus network for reaching agreement on the intermediate values of the computation."
  },
  {
    "objectID": "/model/#p_4",
    "pt": "Model",
    "t": 3,
    "c": "\"Many\" is a technical term that means \"zero or more\"."
  },
  {
    "objectID": "/model/#p_5",
    "pt": "Model",
    "t": 3,
    "c": "When the computation terminates, all participants agree on the outcome, because they agreed on the intermediate values."
  },
  {
    "objectID": "/model/#p_6",
    "pt": "Model",
    "t": 3,
    "c": "At the start of a Reach computation, the set of participants is not necessarily known and can evolve throughout the execution of the application."
  },
  {
    "objectID": "/model/#p_7",
    "pt": "Model",
    "t": 3,
    "c": "A consensus network is a network protocol with a network token, a set of non-network tokens, a set of accounts, a set of contracts, and a network time. A network token is an opaque unit of account. A non-network token is an opaque unit of account; typical consensus networks allow the set of non-network tokens to grow over time and be issued by accounts."
  },
  {
    "objectID": "/model/#p_8",
    "pt": "Model",
    "t": 3,
    "c": "Reach assumes that network tokens and non-network tokens behave identically, but often they do not; this article discusses the causes and consequences of this."
  },
  {
    "objectID": "/model/#p_9",
    "pt": "Model",
    "t": 3,
    "c": "A consensus network's network time is some monotonically increasing discrete value from a totally ordered set; typically, it is the height of the blockchain for consensus networks that use blockchains. A time delta represents the difference between two points in network time as a discrete number of network time units. Each network time corresponds to some network second, which has a connection to real time; typically, it is a Unix time."
  },
  {
    "objectID": "/model/#p_10",
    "pt": "Model",
    "t": 3,
    "c": "This description of consensus networks is an abstraction that may not be directly implemented by actual networks."
  },
  {
    "objectID": "/model/#p_11",
    "pt": "Model",
    "t": 3,
    "c": "For example, in UTXO-based networks, there is not typically an explicitly represented account balance ledger. However, such networks do abstractly have accounts with balances, because particular private keys represent accounts which have exclusive access to some set of network tokens which is their balance."
  },
  {
    "objectID": "/model/#p_12",
    "pt": "Model",
    "t": 3,
    "c": "Similarly, Reach's notion of time may appear overly abstract (\"monotonically increasing ... totally ordered set\") if you know that many consensus networks are based on blockchains and use the chain length, also called the height or block number, as a notion of time. In this case, network time would be a natural number, which is a prototypical model of a totally ordered set. However, Reach is flexible enough to support non-blockchain-based consensus networks, so it does not mandate this particular natural number-based notion of time."
  },
  {
    "objectID": "/model/#p_13",
    "pt": "Model",
    "t": 3,
    "c": "Finally, Reach's definition of consensus network does not require any particular technology or features of this. In particular, it does not only refer to so-called \"layer-1\" protocols, nor does it exclude centralized systems with trusted parties controlling the network."
  },
  {
    "objectID": "/model/#p_14",
    "pt": "Model",
    "t": 3,
    "c": "Consensus networks support transfers of network tokens and non-network tokens between accounts. An account is a unique identity (called an address) with a non-negative balance of network tokens. Accounts may sign values in a way that may not be repudiated or impersonated; this is called publication. The chapter, Networks, discusses which consensus networks are supported by Reach."
  },
  {
    "objectID": "/model/#p_15",
    "pt": "Model",
    "t": 3,
    "c": "Contracts are accounts with three extra capacities: they persistently store values (called the consensus state), they may receive publications, and when they receive publications, they systematically process them and may modify their consensus state, make publications, and may transfer network tokens and non-network tokens in response to the reception. In addition to values, consensus state may contain a fixed number of mappings between an address and a value. These mappings are referred to as \"linear state\" because their size is linear in the number of addresses visible to the contract. Furthermore, a contract may provide views of its consensus state, which are labeled functions and values which may be hierarchically organized, such as NFT.owner or scoreOfPlayer. These views are visible in sub-trees of the computation graph. A contract may also emit events, which are externally observable values that are persistently available. On some networks, contracts have companions, which are another contract that does work for them that cannot be done in the contract itself. The creation of a contract is called deployment."
  },
  {
    "objectID": "/model/#p_16",
    "pt": "Model",
    "t": 3,
    "c": "A participant is a logical actor which takes part in a DApp. It is associated with an account on the consensus network."
  },
  {
    "objectID": "/model/#p_17",
    "pt": "Model",
    "t": 3,
    "c": "The same account may be used by multiple participants in a DApp."
  },
  {
    "objectID": "/model/#p_18",
    "pt": "Model",
    "t": 3,
    "c": "A participant has persistently stored values, called its local state. It has a frontend which it interacts with. A frontend is an abstract actor which supports a set of functions which consume and produce values; when a participant invokes one of these functions it is referred to as interaction."
  },
  {
    "objectID": "/model/#p_19",
    "pt": "Model",
    "t": 3,
    "c": "A participant class is a category of participant that may occur many times in a single application. Members of a participant class are referred to as participant instances when their status as a member of a class is important, but just \"participants\" otherwise. Participant instances are independent participants like any other; for example, with their own local state, frontend, and so on. The main distinction is that when a member of a participant class joins an application, it is not fixed like other participants, because a participant instance does not exclusively represent the participant class."
  },
  {
    "objectID": "/model/#p_20",
    "pt": "Model",
    "t": 3,
    "c": "An API is a source of publications that do not correspond to any participant and are therefore like asynchronous events that impinge on the computation. The contract returns a value to an API call. APIs are organized into a labeled hierarchy, like Contest.vote and User.write."
  },
  {
    "objectID": "/model/#p_21",
    "pt": "Model",
    "t": 3,
    "c": "Since DApps have an associated contract, they have an associated account."
  },
  {
    "objectID": "/model/#p_22",
    "pt": "Model",
    "t": 3,
    "c": "The contract account must be distinct from all participant accounts."
  },
  {
    "objectID": "/model/#p_23",
    "pt": "Model",
    "t": 3,
    "c": "This account is assumed to be empty when the computation starts."
  },
  {
    "objectID": "/model/#p_24",
    "pt": "Model",
    "t": 3,
    "c": "On some consensus networks, it is possible for transfers to a contract account to occur outside of the purview of Reach. If this occurs, then those network tokens are remitted to the originator of the final consensus transfer."
  },
  {
    "objectID": "/model/#p_25",
    "pt": "Model",
    "t": 3,
    "c": "Any network tokens transferred into the account must be removed by the DApp's completion. This is called the token linearity property."
  },
  {
    "objectID": "/model/#p_26",
    "pt": "Model",
    "t": 3,
    "c": "A DApp computation can be seen as a graph of steps with a unique first step. A step is a set of local steps by participants followed by a single consensus step introduced via a single consensus transfer."
  },
  {
    "objectID": "/model/#p_27",
    "pt": "Model",
    "t": 3,
    "c": "A local step is executed by a single participant and is a sequence of local computations. A local computation may bind a piece of local state, assert a property of the local state, or interact with the frontend. A consensus transfer is executed by a single participant (called the originator) which makes a publication of a set of public values from its local state and transfers zero or more network tokens to the contract account. A consensus transfer specifies an alternative step, called a timeout, that is executed if the originator fails to make the transfer before a given time delta has elapsed. All local state is initially private, until it is explicitly made public via a declassification, which is a kind of local computation."
  },
  {
    "objectID": "/model/#p_28",
    "pt": "Model",
    "t": 3,
    "c": "A participant is said to join an application when it first makes a publication. For non-participant instances, this also makes the participant fixed, whereby the consensus state includes an assignment from the participant to the particular account (i.e. address) which it is fixed to. All subsequent publications by a fixed participant must be from the fixed account."
  },
  {
    "objectID": "/model/#p_29",
    "pt": "Model",
    "t": 3,
    "c": "A consensus step is a graph of consensus computations with a unique first computation. A consensus computation either binds consensus state, asserts a property of the consensus state, performs a transfer, selects between different next consensus computations, communicates with another contract (referred to as a remote object), or commits to the next step."
  },
  {
    "objectID": "/model/#p_30",
    "pt": "Model",
    "t": 3,
    "c": "An assertion is either: a knowledge assertion, which is a claim that one honest participant cannot know something that another honest participant does know; a static assertion, which is an always-true formula; an assumption, which is a true formula if frontends behave honestly; a requirement, which is a true formula if participants behave honestly; or, a possibility assertion, which is a formula for which there exists some values that honest participants and frontends could submit which results in the truth of the formula. An honest participant is one that executes the steps specified by the DApp, while an honest frontend is one that only returns values which ensure that all assumptions evaluate to the boolean {!rsh} true."
  },
  {
    "objectID": "/model/#p_31",
    "pt": "Model",
    "t": 3,
    "c": "A value is either: the null value, a boolean, an unsigned integer, a string of bytes, a digest, an address, a fixed tuple of values, a statically-sized homogeneous array of values, or a fixed record of values. Values may be digested to produce a cryptographic hash of their binary encoding."
  },
  {
    "objectID": "/model/#p_32",
    "pt": "Model",
    "t": 3,
    "c": "Values are in one of three possible conditions. They could be consensus state, in which case they are known to all participants. They could be local state of a single participant, which means they are known by only that participant. Local state is further divided into private local state, which cannot be included in a publication, and public local state, which can. These conditions are summarized thus:"
  },
  {
    "objectID": "/model/#p_33",
    "pt": "Model",
    "t": 3,
    "c": "Local, private: The initial state."
  },
  {
    "objectID": "/model/#p_34",
    "pt": "Model",
    "t": 3,
    "c": "Local, public: The result of {!rsh} declassify."
  },
  {
    "objectID": "/model/#p_35",
    "pt": "Model",
    "t": 3,
    "c": "Consensus: The result of {!rsh} publish."
  },
  {
    "objectID": "/model/#p_36",
    "pt": "Model",
    "t": 3,
    "c": "Reach programs cannot execute independently of a consensus network and a set of frontends. Thus, the semantics of Reach treats these components abstractly and does not specify their semantics. Therefore, the semantics of Reach cannot be effectively implemented directly in a virtual machine or interpreter. Instead, Reach programs are compiled to a particular consensus network connector and a set of participant backends which execute the computation of the particular consensus network. Connectors and backends are sound if they faithfully model the abstract semantics assumed by Reach."
  },
  {
    "objectID": "/model/#p_37",
    "pt": "Model",
    "t": 3,
    "c": "During compilation, the Reach compiler automatically verifies that the token linearity property and all static assertions and possibility assertions are true whether participants and frontends are honest or not. Similarly, all knowledge assertions are verified using a conservative approximation of participant knowledge. This conservative approximation assumes that all inputs to a computation are revealed by the result of the computation, except for digests and interaction. This approximation means that Reach cannot, for example, reason about the details of manually expressed encryption formulas and will assume they are insecure. Finally, a subtle point about the knowledge checker is relevant: technically participants with different identities in a Reach program may actually be instantiated by the same principals, i.e. if Alice choses to play a game of a Chess against herself, where she controls both Black and White; as this is always possible, the knowledge checker does not consider it a violation of a claim that White knows something Black does not."
  },
  {
    "objectID": "/model/#p_38",
    "pt": "Model",
    "t": 3,
    "c": "If these assertions cannot be statically verified, then the compilation process aborts. After this verification, such static assertions and possibility assertions are removed from the program and do not occur at runtime. In contrast, assumptions are enforced at runtime by backends and requirements are enforced at runtime by connectors. If assumptions are violated at runtime, then the backend aborts. If requirements are violated at runtime, then the connector ensures that all aspects of the DApp (the contract and participant) ignore the inducing consensus transfer, which often results in a timeout."
  },
  {
    "objectID": "/model/#p_39",
    "pt": "Model",
    "t": 3,
    "c": "Reach programs are specified via a subset of well-formed JavaScript syntax inside source files. The section Language describes the syntax of Reach programs in detail."
  },
  {
    "objectID": "/guide/#guide",
    "pt": "Guide",
    "t": 2,
    "c": "Guide"
  },
  {
    "objectID": "/guide/#p_0",
    "pt": "Guide",
    "t": 3,
    "c": "These guides discuss some key ideas and concepts used through Reach. They aim to teach the \"Why\" of aspects of some Reach features and discuss the many alternatives available to DApp developers. Indeed, many of these points are relevant to all DApp developers, because the problems appear in all applications."
  },
  {
    "objectID": "/guide/#p_1",
    "pt": "Guide",
    "t": 3,
    "c": "The following guides are available:"
  },
  {
    "objectID": "/rpc/#term_RPC%20methods",
    "pt": "RPC Server",
    "t": 1,
    "c": "RPC methods"
  },
  {
    "objectID": "/rpc/#ref-backends-rpc",
    "pt": "RPC Server",
    "t": 2,
    "c": "RPC Server"
  },
  {
    "objectID": "/rpc/#ref-backends-rpc-opts",
    "pt": "RPC Server",
    "t": 2,
    "c": "Reach RPC Client Standard Options"
  },
  {
    "objectID": "/rpc/#p_0",
    "pt": "RPC Server",
    "t": 3,
    "c": "The Reach RPC Server provides access to compiled JavaScript backends via an HTTPS-accessible JSON-based RPC protocol. The server allows frontends to be written in any programming language. Reach provides client libraries for C#, JavaScript, Python, and Go. It is easy to implement a client library yourself. An example frontend written using the Reach RPC Server is shown in the tutorial section on RPC-based frontends."
  },
  {
    "objectID": "/rpc/#p_1",
    "pt": "RPC Server",
    "t": 3,
    "c": "The command"
  },
  {
    "objectID": "/rpc/#p_2",
    "pt": "RPC Server",
    "t": 3,
    "c": "starts an instance of the Reach RPC Server."
  },
  {
    "objectID": "/rpc/#p_3",
    "pt": "RPC Server",
    "t": 3,
    "c": "The Reach RPC Server supports the following RPC methods:"
  },
  {
    "objectID": "/rpc/#p_4",
    "pt": "RPC Server",
    "t": 3,
    "c": "/health returns {!js} true to indicate the server is running properly."
  },
  {
    "objectID": "/rpc/#p_5",
    "pt": "RPC Server",
    "t": 3,
    "c": "/stdlib/$METHOD where $METHOD is a function of the JavaScript standard library."
  },
  {
    "objectID": "/rpc/#p_6",
    "pt": "RPC Server",
    "t": 3,
    "c": "All /stdlib methods are synchronous value RPC methods that accept and produce the same arguments and return values as the corresponding function, encoded as JSON objects, except those that produce or consume account representations."
  },
  {
    "objectID": "/rpc/#p_7",
    "pt": "RPC Server",
    "t": 3,
    "c": "Those methods instead accept and produce account RPC handles, which are random strings that represent the corresponding account representations. For example, /stdlib/newTestAccount does not return an account like {!js} newTestAccount, but instead returns an account RPC handle."
  },
  {
    "objectID": "/rpc/#p_8",
    "pt": "RPC Server",
    "t": 3,
    "c": "/forget/acc accepts an account RPC handle and deletes it from the Reach RPC Server's memory."
  },
  {
    "objectID": "/rpc/#p_9",
    "pt": "RPC Server",
    "t": 3,
    "c": "/acc/$METHOD where $METHOD is a method of an account representation of the JavaScript standard library."
  },
  {
    "objectID": "/rpc/#p_10",
    "pt": "RPC Server",
    "t": 3,
    "c": "All /acc methods are synchronous value RPC methods that accept and produce the same arguments and return values as the corresponding function, encoded as JSON objects, except they accept an additional first argument, which is the account RPC handle returned by a prior RPC method invocation; and, a method that accepts a backend (like /acc/attach (i.e. {!js} acc.attach) or /acc/deploy (i.e. {!js} acc.deploy) does not accept a backend argument, but has it implicitly provided by the Reach RPC Server."
  },
  {
    "objectID": "/rpc/#p_11",
    "pt": "RPC Server",
    "t": 3,
    "c": "Furthermore, those that produce contract representations instead produce contract RPC handles. For example, /acc/deploy does not return a contract representation like {!js} acc.deploy, but instead returns a contract RPC handle."
  },
  {
    "objectID": "/rpc/#p_12",
    "pt": "RPC Server",
    "t": 3,
    "c": "/forget/ctc accepts a contract RPC handle and deletes it from the Reach RPC Server's memory."
  },
  {
    "objectID": "/rpc/#p_13",
    "pt": "RPC Server",
    "t": 3,
    "c": "/ctc/$METHOD where $METHOD is a method of a contract representation of the JavaScript standard library."
  },
  {
    "objectID": "/rpc/#p_14",
    "pt": "RPC Server",
    "t": 3,
    "c": "Most /ctc methods are synchronous value RPC methods that accept and produce the same arguments and return values as the corresponding function, encoded as JSON objects, except they accept an additional first argument, which is the contract RPC handle returned by a prior RPC method invocation."
  },
  {
    "objectID": "/rpc/#p_15",
    "pt": "RPC Server",
    "t": 3,
    "c": "/ctc/p/$PARTICIPANT and /ctc/participants/$PARTICIPANT are interactive RPC method alternatives to the /backend/$PARTICIPANT method described below. They accept the same arguments and behave identically."
  },
  {
    "objectID": "/rpc/#p_16",
    "pt": "RPC Server",
    "t": 3,
    "c": "/forget/token accepts a token RPC handle and deletes it from the Reach RPC Server's memory."
  },
  {
    "objectID": "/rpc/#p_17",
    "pt": "RPC Server",
    "t": 3,
    "c": "/backend/$PARTICIPANT where $PARTICIPANT is a participant of the backend compiled by the JavaScript backend."
  },
  {
    "objectID": "/rpc/#p_18",
    "pt": "RPC Server",
    "t": 3,
    "c": "All /backend/$PARTICIPANT methods are interactive RPC methods that accept three arguments:"
  },
  {
    "objectID": "/rpc/#p_19",
    "pt": "RPC Server",
    "t": 3,
    "c": "ctcId --- A contract RPC handle to provide as the contract to the backend"
  },
  {
    "objectID": "/rpc/#p_20",
    "pt": "RPC Server",
    "t": 3,
    "c": "values --- An object containing the non-function components of the participant interact interface of the backend."
  },
  {
    "objectID": "/rpc/#p_21",
    "pt": "RPC Server",
    "t": 3,
    "c": "methods --- An object whose keys correspond to the function components of the participant interact interface of the backend, but whose values are {!js} true."
  },
  {
    "objectID": "/rpc/#p_22",
    "pt": "RPC Server",
    "t": 3,
    "c": "As a special case, if values contains stdlib.hasRandom bound to {!js} true, then the JavaScript standard library's implementation of {!js} hasRandom is provided to the backend."
  },
  {
    "objectID": "/rpc/#p_23",
    "pt": "RPC Server",
    "t": 3,
    "c": "As the backend executes, any of the components of methods invoked will be executed as interactive RPC callbacks as described by the Reach RPC Protocol Specification. Reach RPC Client libraries should expose a function that hides the details of the construction of the values and methods objects and implements interactive RPC callback handlers automatically."
  },
  {
    "objectID": "/rpc/#p_24",
    "pt": "RPC Server",
    "t": 3,
    "c": "/backend/getExports/$EXPORT_NAME where $EXPORT_NAME is an export of the backend compiled by the JavaScript backend."
  },
  {
    "objectID": "/rpc/#p_25",
    "pt": "RPC Server",
    "t": 3,
    "c": "Any Reach module exports, including functions, may be accessed via this method. Field accessors and zero-indexed array references support arbitrarily deep nesting."
  },
  {
    "objectID": "/rpc/#p_26",
    "pt": "RPC Server",
    "t": 3,
    "c": "For example:"
  },
  {
    "objectID": "/rpc/#p_27",
    "pt": "RPC Server",
    "t": 3,
    "c": "Requests for non-existent exports and non-existent nested fields or elements always return null."
  },
  {
    "objectID": "/rpc/#p_28",
    "pt": "RPC Server",
    "t": 3,
    "c": "/kont handles interactive RPC continuation completion during an interactive RPC method. It should not be invoked directly by frontends."
  },
  {
    "objectID": "/rpc/#p_29",
    "pt": "RPC Server",
    "t": 3,
    "c": "/stop quits the server."
  },
  {
    "objectID": "/rpc/#p_30",
    "pt": "RPC Server",
    "t": 3,
    "c": "Reach RPC client libraries must accept a dictionary data structure with the following keys for customizing their behavior:"
  },
  {
    "objectID": "/rpc/#p_31",
    "pt": "RPC Server",
    "t": 3,
    "c": "host --- This value sets the hostname to contact for the Reach RPC Server instance. If it is not present, the client library must default to the value of the environment variable REACH_RPC_SERVER."
  },
  {
    "objectID": "/rpc/#p_32",
    "pt": "RPC Server",
    "t": 3,
    "c": "port --- This value sets the TCP port to contact for the Reach RPC Server instance. If it is not present, the client library must default to the value of the environment variable REACH_RPC_PORT."
  },
  {
    "objectID": "/rpc/#p_33",
    "pt": "RPC Server",
    "t": 3,
    "c": "verify --- This value determines whether to verify the TLS certificate of the Reach RPC Server instance. If it is not present, the client library must default to the value of the environment variable REACH_RPC_TLS_REJECT_UNVERIFIED. If that is not present, it must default to true."
  },
  {
    "objectID": "/rpc/#p_34",
    "pt": "RPC Server",
    "t": 3,
    "c": "To disable verification, set this value to the string: \"0\"; any other value will be considered to mean \"enable\"."
  },
  {
    "objectID": "/rpc/#p_35",
    "pt": "RPC Server",
    "t": 3,
    "c": "timeout --- This value sets the number of seconds to wait for the Reach RPC Server instance to respond to its first request. If it is not present, the client library must default to the value of the environment variable REACH_RPC_TIMEOUT. If that is not present, it must default to 5 seconds."
  },
  {
    "objectID": "/rpc/#p_36",
    "pt": "RPC Server",
    "t": 3,
    "c": "key --- This value sets the API key for the Reach RPC Server instance. If it is not present, the client library must default to the value of the environment variable REACH_RPC_KEY."
  },
  {
    "objectID": "/tut/#tuts",
    "pt": "Tutorials",
    "t": 2,
    "c": "Tutorials"
  },
  {
    "objectID": "/tut/#p_0",
    "pt": "Tutorials",
    "t": 3,
    "c": "There are two tutorials:"
  },
  {
    "objectID": "/workshop/#workshop",
    "pt": "Workshop",
    "t": 2,
    "c": "Workshop"
  },
  {
    "objectID": "/workshop/#workshop-rps-fair",
    "pt": "Workshop",
    "t": 2,
    "c": "Fair Rock-Paper-Scissors"
  },
  {
    "objectID": "/workshop/#workshop-rps-eff",
    "pt": "Workshop",
    "t": 2,
    "c": "Efficient Rock-Paper-Scissors"
  },
  {
    "objectID": "/workshop/#workshop-rental",
    "pt": "Workshop",
    "t": 2,
    "c": "Rental Agreement"
  },
  {
    "objectID": "/workshop/#workshop-abstract-simul",
    "pt": "Workshop",
    "t": 2,
    "c": "Simultaneous Games"
  },
  {
    "objectID": "/workshop/#workshop-guardian-account",
    "pt": "Workshop",
    "t": 2,
    "c": "Guardian Account"
  },
  {
    "objectID": "/workshop/#workshop-utility",
    "pt": "Workshop",
    "t": 2,
    "c": "Periodic Payment"
  },
  {
    "objectID": "/workshop/#workshop-nim",
    "pt": "Workshop",
    "t": 2,
    "c": "Nim"
  },
  {
    "objectID": "/workshop/#workshop-ttt",
    "pt": "Workshop",
    "t": 2,
    "c": "Tic-Tac-Toe"
  },
  {
    "objectID": "/workshop/#workshop-secured-loan",
    "pt": "Workshop",
    "t": 2,
    "c": "Secured Loan"
  },
  {
    "objectID": "/workshop/#workshop-atomic-swap",
    "pt": "Workshop",
    "t": 2,
    "c": "Atomic Swap"
  },
  {
    "objectID": "/workshop/#workshop-atomic-swap-auction",
    "pt": "Workshop",
    "t": 2,
    "c": "Atomic Swap Auction"
  },
  {
    "objectID": "/workshop/#workshop-race",
    "pt": "Workshop",
    "t": 2,
    "c": "Race"
  },
  {
    "objectID": "/workshop/#workshop-chicken-race",
    "pt": "Workshop",
    "t": 2,
    "c": "Chicken"
  },
  {
    "objectID": "/workshop/#workshop-popularity-contest",
    "pt": "Workshop",
    "t": 2,
    "c": "Popularity Contest"
  },
  {
    "objectID": "/workshop/#workshop-nft-dumb",
    "pt": "Workshop",
    "t": 2,
    "c": "Simple NFT"
  },
  {
    "objectID": "/workshop/#workshop-nft-auction",
    "pt": "Workshop",
    "t": 2,
    "c": "NFT with Auction"
  },
  {
    "objectID": "/workshop/#workshop-nft-tax",
    "pt": "Workshop",
    "t": 2,
    "c": "NFT with Royalties and Harberger Tax"
  },
  {
    "objectID": "/workshop/#workshop-raffle",
    "pt": "Workshop",
    "t": 2,
    "c": "Raffle"
  },
  {
    "objectID": "/workshop/#workshop-rent-seeking",
    "pt": "Workshop",
    "t": 2,
    "c": "Rent Seeking"
  },
  {
    "objectID": "/workshop/#workshop-remote",
    "pt": "Workshop",
    "t": 2,
    "c": "Remote Objects"
  },
  {
    "objectID": "/workshop/#workshop-oracle",
    "pt": "Workshop",
    "t": 2,
    "c": "Oracle"
  },
  {
    "objectID": "/workshop/#workshop-auction-te",
    "pt": "Workshop",
    "t": 2,
    "c": "Timed English Auction"
  },
  {
    "objectID": "/workshop/#workshop-crowdfund",
    "pt": "Workshop",
    "t": 2,
    "c": "Crowd-funding"
  },
  {
    "objectID": "/workshop/#p_0",
    "pt": "Workshop",
    "t": 3,
    "c": "The workshop is a collection of self-study projects to help you on your way to mastery building decentralized applications through practice by building specific projects in Reach. It is designed to help direct you along the path of learning effective use of Reach and points out for you some of the design decisions that Reach programmers often make."
  },
  {
    "objectID": "/workshop/#p_1",
    "pt": "Workshop",
    "t": 3,
    "c": "Unlike the tutorial, it is not meant for you just to copy code and see what appears; instead, you're meant to work on your own to build a project yourself. This way, you'll learn more and slowly be able to build your own project using Reach."
  },
  {
    "objectID": "/workshop/#p_2",
    "pt": "Workshop",
    "t": 3,
    "c": "At the end of every project, we'll always show a \"final\" version with commentary about why we implemented it the way that we did."
  },
  {
    "objectID": "/workshop/#p_3",
    "pt": "Workshop",
    "t": 3,
    "c": "We would love your feedback on any project, especially the parts that you struggled the most with. This will help us improve the language, our developer tools, and the project materials. The best way is through the GitHub issue tracker or by messaging @team in the Discord community."
  },
  {
    "objectID": "/workshop/#p_4",
    "pt": "Workshop",
    "t": 3,
    "c": "We highly recommend going through the overview and the tutorial before continuing through the workshop. However, you can do most workshops in any order. If there's a pre-requisite, it will be explicitly mentioned."
  },
  {
    "objectID": "/workshop/#p_5",
    "pt": "Workshop",
    "t": 3,
    "c": "Here are the current workshops, in the order we recommend doing them:"
  },
  {
    "objectID": "/workshop/#p_6",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Rock, Paper, Scissors!."
  },
  {
    "objectID": "/workshop/#p_7",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we observe that the tutorial's version of Rock, Paper, Scissors! is unfair in that Alice is responsible for more steps than Bob. On most consensus networks, each action is charged a fee to run, so this means that Alice pays more than Bob for the game to be played. How could you revise the application to make it fair, without requiring a change to the frontend?"
  },
  {
    "objectID": "/workshop/#p_8",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above!"
  },
  {
    "objectID": "/workshop/#p_9",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Fair Rock-Paper-Scissors."
  },
  {
    "objectID": "/workshop/#p_10",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we study how transaction costs on consensus networks can be understood as the constants hidden by asymptotic notations when determining the expense of an algorithm when run on a decentralized application. In typical programming contexts, an algorithm that uses 3 log_2 n + 4 n operations is considered equivalent to an algorithm that uses 5 log_4 n + 22 n operations, because constants and bases are ignored in asymptoptic analysis. However, imagine that a program used n local computations and m consensus computations. We'll call n the \"computations\" and m the \"communications\". In this case, the computations are free from the perspective of the consensus network, because they don't cost network tokens, while the communications cost their price in gas, plus the fee to run them. Therefore, it is often economically efficient to increase n so that m can be smaller."
  },
  {
    "objectID": "/workshop/#p_11",
    "pt": "Workshop",
    "t": 3,
    "c": "For example, in the context of the tutorial's version of Rock, Paper, Scissors!, the application uses 2 + 3r communications for a game with r rounds. This is because it takes two communications to set up the loop, then each round of the loop takes three communications. We could make a more complicated version of the application that is optimized in two ways."
  },
  {
    "objectID": "/workshop/#p_12",
    "pt": "Workshop",
    "t": 3,
    "c": "First, we could optimize for the common case of when there is no draw and bundle a hand into the opening messages, and use 3 + 3(r - 1) = 3r communications for r rounds, for a saving of two communications. This would slightly increase the complexity of our program by duplicating the submission of hands, but we could easily abstract this into a Reach function."
  },
  {
    "objectID": "/workshop/#p_13",
    "pt": "Workshop",
    "t": 3,
    "c": "Second, we could bundle k hands into each communication, so that the number of communications is 3(r//k) for r rounds for a reduction of communications by k times. This is possible through Reach's ability to deal with array values. The exact value of k would be chosen empirically based on the relative difference in cost between increased message sizes and computations versus the fixed cost of having any transaction at all on the consensus network. Reach's ability to abstract away the details of communication patterns allows us to write this program abstractly and only specify the value of k as a compile-time parameter."
  },
  {
    "objectID": "/workshop/#p_14",
    "pt": "Workshop",
    "t": 3,
    "c": "This is a general strategy that is regularly employed in efficient decentralized applications: although a textbook algorithm might say to use a setup phase and many round trips as you divide a space in half each time, it might be vastly more efficient on an actual network to apply meaning-preserving transformations like merging the setup into the loop and dividing the space by a much larger constant, like one hundred."
  },
  {
    "objectID": "/workshop/#p_15",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above!"
  },
  {
    "objectID": "/workshop/#p_16",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Rock, Paper, Scissors!."
  },
  {
    "objectID": "/workshop/#p_17",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we consider a scenario where Alice and Bob are engaged in an indefinite rental agreement where they both made a security deposit to be given to whomever leaves the arrangement first. At some regular interval, both participants submit whether they would like to Stay or Leave. If they both decide to Stay, then they wait for the next round. If they both decide to Leave, then they both get back their deposit. But if only one wants to Leave, then both deposits go to the participant that wants to Stay, based on the assumption that they are harmed by being surprised at the change in circumstances in the next interval."
  },
  {
    "objectID": "/workshop/#p_18",
    "pt": "Workshop",
    "t": 3,
    "c": "This scenario demonstrates the value of decentralization, because in traditional institutions, one party is typically empowered as always dictating the decision to the other who must take it, as is the case for most landlords; or, the two parties must play \"chicken\" with each other to see who will flinch first, as is often the case in divorces; or, the two parties must pay a third-party to act as the arbitrator."
  },
  {
    "objectID": "/workshop/#p_19",
    "pt": "Workshop",
    "t": 3,
    "c": "It turns out that this scenario is structurally identical to Rock, Paper, Scissors!, except with different \"hands\" and a different pay-out structure."
  },
  {
    "objectID": "/workshop/#p_20",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/rental."
  },
  {
    "objectID": "/workshop/#p_21",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Rental Agreement."
  },
  {
    "objectID": "/workshop/#p_22",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we generalize from the tutorial and the rental workshop to build an abstract library that models any game with simultaneous play. This shows the power of Reach's ability to construct and reason about communication abstractions."
  },
  {
    "objectID": "/workshop/#p_23",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/abstract-simul."
  },
  {
    "objectID": "/workshop/#p_24",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Trust Fund."
  },
  {
    "objectID": "/workshop/#p_25",
    "pt": "Workshop",
    "t": 3,
    "c": "In Trust Fund, we developed an application where the entire contents of a trust fund devolve to the receipient after a certain time. In this workshop, we revisit this problem and instead allow portions of the funds to be removed by the funder at her discretion. This is like a \"multi-signature wallet\", where one account originates the funds and approves transactions, while another account solely spends those funds. It might be used to give a child an \"allowance\" from their trust fund. It could be modified to allow the funder to add funds over time if the fund runs low. This is the first workshop on the \"transfer funds\" track that introduces {!rsh} while statements."
  },
  {
    "objectID": "/workshop/#p_26",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/multisig."
  },
  {
    "objectID": "/workshop/#p_27",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Guardian Account."
  },
  {
    "objectID": "/workshop/#p_28",
    "pt": "Workshop",
    "t": 3,
    "c": "In Guardian Account, we developed an application where a funder has discretion over the disbursement on portions of a pre-funded account. In this workshop, we modify this application so that the funder has no discretion and automatically approves transfers out, but the receiver is restricted to only asking for a certain amount at a time and at a particular interval. This could be used to make a periodic payment to a utility company, for example."
  },
  {
    "objectID": "/workshop/#p_29",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above!"
  },
  {
    "objectID": "/workshop/#p_30",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Rock, Paper, Scissors!."
  },
  {
    "objectID": "/workshop/#p_31",
    "pt": "Workshop",
    "t": 3,
    "c": "In the tutorial, we built a version of Rock, Paper, Scissors! where two parties can wager over the results of the game. This application has an interesting communication pattern with information hiding through cryptographic commitments, but the application logic is simple and uninteresting. In this workshop, we implement a version of Nim, where the communication structure is simpler, since it is a combinatorial game, but has a more interesting application logic. Thus, this workshop demonstrates using more interesting data-structures in Reach programs, as well as using compile-time abstractions to simplify DApp structure."
  },
  {
    "objectID": "/workshop/#p_32",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/nim."
  },
  {
    "objectID": "/workshop/#p_33",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Nim."
  },
  {
    "objectID": "/workshop/#p_34",
    "pt": "Workshop",
    "t": 3,
    "c": "Like Nim, this workshop develops an implementation of the combinatorial game, Tic-tac-toe. This workshop demonstrates the use of arrays and more advanced Reach data-structures. We'll discuss two variations of this same application: one where the consensus network verifies the moves of each player; and, another where the consensus network allows illegal moves to be disputed by the other player. These variations demonstrate two DApp patterns that occur commonly in existing DApp designs, each with different usage constraints and performance trade-offs."
  },
  {
    "objectID": "/workshop/#p_35",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/ttt."
  },
  {
    "objectID": "/workshop/#p_36",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Trust Fund."
  },
  {
    "objectID": "/workshop/#p_37",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we implement a secured loan, wherein a Borrower posts collateral and terms to the public, and an arbitrary Lender gives a loan, then after some maturity, the Borrower either repays the loan, plus interest, or sacrifices the collateral. It is easy to model this scenario using only network tokens, but it would be useless, because the premise of a loan is that the participants believe the Borrower can make better use of the funds than the Lender. However, many consensus networks also support custom fungible assets that are like tokens. If this is the case, then a secured loan will typically have different assets as the loan amount and the collateral amount. Thus, the interest rate for the loan is essentially the Lender's prediction of the movement of the exchange rate between the two currencies over the lifetime of the loan. In this workshop, the Borrower pledges non-network tokens as collateral for the loan."
  },
  {
    "objectID": "/workshop/#p_38",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/secured-loan."
  },
  {
    "objectID": "/workshop/#p_39",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Rock, Paper, Scissors!."
  },
  {
    "objectID": "/workshop/#p_40",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we implement an atomic swap, or sell order, wherein a Seller offers an amount of an asset, X of A, in exchange for a prescribed amount of another asset, Y of B, and waits for a Buyer to complete the other side of the trade. This workshop demonstrates the use of non-network tokens."
  },
  {
    "objectID": "/workshop/#p_41",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/atomic-swap."
  },
  {
    "objectID": "/workshop/#p_42",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Atomic Swap."
  },
  {
    "objectID": "/workshop/#p_43",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we extend the Atomic Swap workshop by allowing the Seller to solicit bids for their X of A in a prescribed asset B and accept whichever buyer is willing to provide the most before a preset time."
  },
  {
    "objectID": "/workshop/#p_44",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/atomic-swap-auction."
  },
  {
    "objectID": "/workshop/#p_45",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Rock, Paper, Scissors!."
  },
  {
    "objectID": "/workshop/#p_46",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we implement the example of the {!rsh} race expression discussed in the guide section on races. This provides an introduction to races, as well as a cautionary tale on their danger."
  },
  {
    "objectID": "/workshop/#p_47",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/race."
  },
  {
    "objectID": "/workshop/#p_48",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Race."
  },
  {
    "objectID": "/workshop/#p_49",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we implement a game of Chicken, where each player submits an equal wager, and then competes with the other to submit more transactions to the consensus before a deadline. In other words, they must decide between the risk of losing the entire pot and the risk of overspending on transaction costs. Like Race, this demonstrates the deadweight losses associated with {!rsh} races, as discussed in the guide section on races."
  },
  {
    "objectID": "/workshop/#p_50",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/chicken-race."
  },
  {
    "objectID": "/workshop/#p_51",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Chicken."
  },
  {
    "objectID": "/workshop/#p_52",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we implement a two-party winner-takes-all vote, where a pollster proposes two candidates---Alice and Bob---along with a voting price and a deadline, then a participant class of voters each pay and cast their ballot. Once the deadline passes, the winning candidate takes the entire pot. This workshop introduces effective use of participant classes and {!rsh} parallelReduce."
  },
  {
    "objectID": "/workshop/#p_53",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/popularity-contest."
  },
  {
    "objectID": "/workshop/#p_54",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Race."
  },
  {
    "objectID": "/workshop/#p_55",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we implement a trivial non-fungible token (NFT) where a single creator creates a unique item and initial owns it. The creator and all subsequent owners may transfer ownership of the unique item to a different owner and so on. This workshop uses a participant class to represent owners and is a kind of trivial template before we explore more interesting and in-depth variants of the NFT concept."
  },
  {
    "objectID": "/workshop/#p_56",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/nft-dumb."
  },
  {
    "objectID": "/workshop/#p_57",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Simple NFT."
  },
  {
    "objectID": "/workshop/#p_58",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we extend Simple NFT by adding an auction when the current owner is ready to sell their NFT. This could be extended to give creators (or royalty rights holders) a percentage of the auction yield."
  },
  {
    "objectID": "/workshop/#p_59",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/nft-auction."
  },
  {
    "objectID": "/workshop/#p_60",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Simple NFT."
  },
  {
    "objectID": "/workshop/#p_61",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we extend Simple NFT by incorporating a Harberger Tax (c.f. Arnold Harberger) where owners must state a price at which they are willing to part with the asset and pay a percentage of that price to the creator. They can update this price upwards by paying an additional tax, or decrease it without cost (to free themselves of the asset). This represents an interesting place in the NFT design space where utility increasing transfers are immediate and creators receive royalties."
  },
  {
    "objectID": "/workshop/#p_62",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Popularity Contest."
  },
  {
    "objectID": "/workshop/#p_63",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we implement a raffle, where a sponsor starts a timed raffle and a participant class of ticket buyers each buy tickets. This workshop contains two interesting ideas: first, it uses linear state through the {!rsh} Map structure; second, it uses a commitment pattern structure to acquire safe randomness from the set of buyers."
  },
  {
    "objectID": "/workshop/#p_64",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/raffle."
  },
  {
    "objectID": "/workshop/#p_65",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Raffle."
  },
  {
    "objectID": "/workshop/#p_66",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we implement a rent-seeking competition, where a sponsor attempts to sell a prize (e.g. 10 ETH) and a number of bidders seek to acquire the prize by bidding for it (e.g. 5 ETH). Unlike a \"normal\" auction, however, the bidders lose the money they bid to the sponsor. Thus, while the winner may get more than the bid, and the sponsor may get more than they give away, there is a net transfer away from the bidders to the sponsor. This program also uses linear state."
  },
  {
    "objectID": "/workshop/#p_67",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/rent-seeking."
  },
  {
    "objectID": "/workshop/#p_68",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Rock, Paper, Scissors!."
  },
  {
    "objectID": "/workshop/#p_69",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we demonstrate interaction with a remote object implemented externally to Reach. Rather than connect to an existing contract, this example includes testing code to launch a bespoke contract simply to demonstrate how remote interactions can occur. It may be representative of a DApp that is implemented simultaneously in Reach and the low-level language of the chosen consensus network, in this case Solidity."
  },
  {
    "objectID": "/workshop/#p_70",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/remote."
  },
  {
    "objectID": "/workshop/#p_71",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Rock, Paper, Scissors!."
  },
  {
    "objectID": "/workshop/#p_72",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we implement a centralized oracle for some property not otherwise computable within a Reach program. Typically oracles are used to connect physical data from outside a consensus network to the agents of the network, such as by reading physical sensors, like a thermometer, and posting the information inside the network."
  },
  {
    "objectID": "/workshop/#p_73",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above!"
  },
  {
    "objectID": "/workshop/#p_74",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Rock, Paper, Scissors!."
  },
  {
    "objectID": "/workshop/#p_75",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we implement a timed English auction wherein a Seller auctions off the right for a Bidder to decide the argument to call a certain external contract method with. This demonstrates the use of collective operations in Reach with finite state."
  },
  {
    "objectID": "/workshop/#p_76",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above!"
  },
  {
    "objectID": "/workshop/#p_77",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Timed English Auction."
  },
  {
    "objectID": "/workshop/#p_78",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we implement a crowdfunding campaign wherein a Fundraiser requests a funding amount, which is provided by Donors if a reserve is reached before the funding window closes, after which it is either disbursed to the Fundraiser, or returned to the Donors."
  },
  {
    "objectID": "/workshop/#p_79",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above!"
  },
  {
    "objectID": "/rsh/appinit/#rsh_init",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "init"
  },
  {
    "objectID": "/rsh/appinit/#rsh_deploy",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "deploy"
  },
  {
    "objectID": "/rsh/appinit/#rsh_setOptions",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "setOptions"
  },
  {
    "objectID": "/rsh/appinit/#rsh_untrustworthyMaps",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "untrustworthyMaps"
  },
  {
    "objectID": "/rsh/appinit/#rsh_verifyArithmetic",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "verifyArithmetic"
  },
  {
    "objectID": "/rsh/appinit/#rsh_verifyPerConnector",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "verifyPerConnector"
  },
  {
    "objectID": "/rsh/appinit/#rsh_connectors",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "connectors"
  },
  {
    "objectID": "/rsh/appinit/#rsh_ETH",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "ETH"
  },
  {
    "objectID": "/rsh/appinit/#rsh_ALGO",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "ALGO"
  },
  {
    "objectID": "/rsh/appinit/#rsh_Participant",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "Participant"
  },
  {
    "objectID": "/rsh/appinit/#rsh_ParticipantClass",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "ParticipantClass"
  },
  {
    "objectID": "/rsh/appinit/#rsh_API",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "API"
  },
  {
    "objectID": "/rsh/appinit/#rsh_View",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "View"
  },
  {
    "objectID": "/rsh/appinit/#rsh_Events",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "Events"
  },
  {
    "objectID": "/rsh/appinit/#rsh_ContractCode",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "ContractCode"
  },
  {
    "objectID": "/rsh/appinit/#term_application%20initialization",
    "pt": "Application Initialization",
    "t": 1,
    "c": "application initialization"
  },
  {
    "objectID": "/rsh/appinit/#term_init%20statement",
    "pt": "Application Initialization",
    "t": 1,
    "c": "init statement"
  },
  {
    "objectID": "/rsh/appinit/#term_compilation%20options",
    "pt": "Application Initialization",
    "t": 1,
    "c": "compilation options"
  },
  {
    "objectID": "/rsh/appinit/#term_participant%20interact%20interface",
    "pt": "Application Initialization",
    "t": 1,
    "c": "participant interact interface"
  },
  {
    "objectID": "/rsh/appinit/#term_function%20alias",
    "pt": "Application Initialization",
    "t": 1,
    "c": "function alias"
  },
  {
    "objectID": "/rsh/appinit/#term_API%20member%20function",
    "pt": "Application Initialization",
    "t": 1,
    "c": "API member function"
  },
  {
    "objectID": "/rsh/appinit/#ref-programs-appinit",
    "pt": "Application Initialization",
    "t": 2,
    "c": "Application Initialization"
  },
  {
    "objectID": "/rsh/appinit/#ref-programs-appinit-stmts",
    "pt": "Application Initialization",
    "t": 2,
    "c": "Statements"
  },
  {
    "objectID": "/rsh/appinit/#init",
    "pt": "Application Initialization",
    "t": 2,
    "c": "init"
  },
  {
    "objectID": "/rsh/appinit/#setoptions",
    "pt": "Application Initialization",
    "t": 2,
    "c": "setOptions"
  },
  {
    "objectID": "/rsh/appinit/#ref-programs-appinit-exprs",
    "pt": "Application Initialization",
    "t": 2,
    "c": "Expressions"
  },
  {
    "objectID": "/rsh/appinit/#participant-definition",
    "pt": "Application Initialization",
    "t": 2,
    "c": "Participant Definition"
  },
  {
    "objectID": "/rsh/appinit/#ref-programs-appinit-api",
    "pt": "Application Initialization",
    "t": 2,
    "c": "API Definition"
  },
  {
    "objectID": "/rsh/appinit/#ref-programs-appinit-view",
    "pt": "Application Initialization",
    "t": 2,
    "c": "View Definition"
  },
  {
    "objectID": "/rsh/appinit/#ref-programs-appinit-events",
    "pt": "Application Initialization",
    "t": 2,
    "c": "Events Definition"
  },
  {
    "objectID": "/rsh/appinit/#ref-programs-appinit-contractcode",
    "pt": "Application Initialization",
    "t": 2,
    "c": "Contract code definition"
  },
  {
    "objectID": "/rsh/appinit/#p_0",
    "pt": "Application Initialization",
    "t": 3,
    "c": "The body of {!rsh} Reach.app is an application initialization. It defines the various participants and views of the DApp, as well as sets compilation options. It is finalized with {!rsh} init() and then the application begins in a step."
  },
  {
    "objectID": "/rsh/appinit/#p_1",
    "pt": "Application Initialization",
    "t": 3,
    "c": "Any statements valid for a computation are valid for application initialization. However, some additional statements are allowed."
  },
  {
    "objectID": "/rsh/appinit/#p_2",
    "pt": "Application Initialization",
    "t": 3,
    "c": "A init statement, written {!rsh} init();, finalizes all of the available participants, views, and compilation options."
  },
  {
    "objectID": "/rsh/appinit/#p_3",
    "pt": "Application Initialization",
    "t": 3,
    "c": "In earlier versions of Reach, this was called {!rsh} deploy(), but it was changed because that name was misleading."
  },
  {
    "objectID": "/rsh/appinit/#p_4",
    "pt": "Application Initialization",
    "t": 3,
    "c": "Its continuation is a step, which means its content is specified by Steps. It represents the body of the DApp to be compiled."
  },
  {
    "objectID": "/rsh/appinit/#p_5",
    "pt": "Application Initialization",
    "t": 3,
    "c": "In the example below, see how {!rsh} init(); is used to finalize the available {!rsh} Participant and {!rsh} API. After which a local step is introduced:"
  },
  {
    "objectID": "/rsh/appinit/#p_6",
    "pt": "Application Initialization",
    "t": 3,
    "c": "The compilation options for the DApp may be set by calling {!rsh} setOptions(OBJ_EXPR); where {!rsh} OBJ_EXPR is an object with the following keys and values:"
  },
  {
    "objectID": "/rsh/appinit/#p_7",
    "pt": "Application Initialization",
    "t": 3,
    "c": "{!rsh} untrustworthyMaps"
  },
  {
    "objectID": "/rsh/appinit/#p_8",
    "pt": "Application Initialization",
    "t": 3,
    "c": "{!rsh} true or {!rsh} false (default)"
  },
  {
    "objectID": "/rsh/appinit/#p_9",
    "pt": "Application Initialization",
    "t": 3,
    "c": "Determines whether mappings are treated as trustworthy. A mapping is trustworthy if its values are guaranteed to be preserved across interactions. When this is {!rsh} true, the verifier will enforce that your program does not rely on values being preserved."
  },
  {
    "objectID": "/rsh/appinit/#p_10",
    "pt": "Application Initialization",
    "t": 3,
    "c": "See example below:"
  },
  {
    "objectID": "/rsh/appinit/#p_11",
    "pt": "Application Initialization",
    "t": 3,
    "c": "Reach cannot provide trustworthy mappings with some connectors; therefore it is dangerous to not set this to {!rsh} true on such connectors. Reach will emit a warning during compilation if you do such a dangerous thing."
  },
  {
    "objectID": "/rsh/appinit/#p_12",
    "pt": "Application Initialization",
    "t": 3,
    "c": "{!rsh} verifyArithmetic"
  },
  {
    "objectID": "/rsh/appinit/#p_13",
    "pt": "Application Initialization",
    "t": 3,
    "c": "{!rsh} true or {!rsh} false (default)"
  },
  {
    "objectID": "/rsh/appinit/#p_14",
    "pt": "Application Initialization",
    "t": 3,
    "c": "Determines whether arithmetic operations automatically introduce static assertions that they do not overflow beyond {!rsh} UInt.max."
  },
  {
    "objectID": "/rsh/appinit/#p_15",
    "pt": "Application Initialization",
    "t": 3,
    "c": "See example below:"
  },
  {
    "objectID": "/rsh/appinit/#p_16",
    "pt": "Application Initialization",
    "t": 3,
    "c": "This defaults to {!rsh} false, because it is onerous to verify. We recommend turning it on before final deployment, but leaving it off during development. When it is {!rsh} false, connectors will ensure that overflows do not actually occur on the network."
  },
  {
    "objectID": "/rsh/appinit/#p_17",
    "pt": "Application Initialization",
    "t": 3,
    "c": "{!rsh} verifyPerConnector"
  },
  {
    "objectID": "/rsh/appinit/#p_18",
    "pt": "Application Initialization",
    "t": 3,
    "c": "{!rsh} true or {!rsh} false (default)"
  },
  {
    "objectID": "/rsh/appinit/#p_19",
    "pt": "Application Initialization",
    "t": 3,
    "c": "Determines whether verification is done per connector, or once for a generic connector. When this is {!rsh} true, then connector-specific constants, like {!rsh} UInt.max, will be instantiated to literal numbers. This concretization of these constants can induce performance degradation in the verifier."
  },
  {
    "objectID": "/rsh/appinit/#p_20",
    "pt": "Application Initialization",
    "t": 3,
    "c": "See example below:"
  },
  {
    "objectID": "/rsh/appinit/#p_21",
    "pt": "Application Initialization",
    "t": 3,
    "c": "{!rsh} connectors"
  },
  {
    "objectID": "/rsh/appinit/#p_22",
    "pt": "Application Initialization",
    "t": 3,
    "c": "{!rsh} [ETH, ALGO] (default)"
  },
  {
    "objectID": "/rsh/appinit/#p_23",
    "pt": "Application Initialization",
    "t": 3,
    "c": "A tuple of the connectors that the application should be compiled for. By default, all available connectors are chosen."
  },
  {
    "objectID": "/rsh/appinit/#p_24",
    "pt": "Application Initialization",
    "t": 3,
    "c": "In the example below, only ETH and ALGO are chosen:"
  },
  {
    "objectID": "/rsh/appinit/#p_25",
    "pt": "Application Initialization",
    "t": 3,
    "c": "Any expressions valid for a computation are valid for application initialization. However, some additional expressions are allowed."
  },
  {
    "objectID": "/rsh/appinit/#p_26",
    "pt": "Application Initialization",
    "t": 3,
    "c": "A participant and participant class may be declared with"
  },
  {
    "objectID": "/rsh/appinit/#p_27",
    "pt": "Application Initialization",
    "t": 3,
    "c": "and"
  },
  {
    "objectID": "/rsh/appinit/#p_28",
    "pt": "Application Initialization",
    "t": 3,
    "c": "respectively."
  },
  {
    "objectID": "/rsh/appinit/#p_29",
    "pt": "Application Initialization",
    "t": 3,
    "c": "Since {!rsh} ParticipantClass is being deprecated, it is preferable to use {!rsh} API."
  },
  {
    "objectID": "/rsh/appinit/#p_30",
    "pt": "Application Initialization",
    "t": 3,
    "c": "{!rsh} participantName is a string which indicates the name of the participant function in the generated backend code. Each {!rsh} participantName must be unique."
  },
  {
    "objectID": "/rsh/appinit/#p_31",
    "pt": "Application Initialization",
    "t": 3,
    "c": "{!rsh} participantInteractInterface is a participant interact interface, an object where each field indicates the type of a function or value which must be provided to the backend by the frontend for interacting with the participant."
  },
  {
    "objectID": "/rsh/appinit/#p_32",
    "pt": "Application Initialization",
    "t": 3,
    "c": "In the Rock, Paper, and Scissors tutorial, Alice and Bob receive the getHand and seeOutcome interact interfaces from the construct Player in the following sample code:"
  },
  {
    "objectID": "/rsh/appinit/#p_33",
    "pt": "Application Initialization",
    "t": 3,
    "c": "APIs are functions that can be called by other contracts, as well as off-chain."
  },
  {
    "objectID": "/rsh/appinit/#p_34",
    "pt": "Application Initialization",
    "t": 3,
    "c": "An API is defined with {!rsh} API(apiName, apiInterface, ?apiAlias) or {!rsh} API(apiInterface, ?apiAlias), where {!rsh} apiName is a string that labels the API, {!rsh} apiInterface is an object where each field indicates the type of a function provided by the contract as an API, and {!rsh} apiAlias is an optional object that maps function names from the {!rsh} apiInterface to an alias. This function alias allows overloaded methods to be created. Many functions may map to the same alias as long as each function domain is unique. These APIs are available in frontends via the {!js} ctc.apis object, wherein fields are the members of {!rsh} apiInterface and may be used in {!rsh} .api components of {!rsh} fork and {!rsh} parallelReduce to specify the behavior of the corresponding call. These are called API member functions. Each function must occur exactly once in the entire program."
  },
  {
    "objectID": "/rsh/appinit/#p_35",
    "pt": "Application Initialization",
    "t": 3,
    "c": "This example creates an API that has a name of Investor, and it has two functions. The first function is to invest in the contract, and the second function is to collect the payment if the Entrepreneur fails to form a quorum."
  },
  {
    "objectID": "/rsh/appinit/#p_36",
    "pt": "Application Initialization",
    "t": 3,
    "c": "This section is about defining views during application initialization. Views are set in consensus steps, in your Reach program. But, they are accessed by frontends by using the Reach standard library of the frontend language, such as JavaScript."
  },
  {
    "objectID": "/rsh/appinit/#p_37",
    "pt": "Application Initialization",
    "t": 3,
    "c": "Views are read-only functions that can be called by other contracts, as well as off-chain."
  },
  {
    "objectID": "/rsh/appinit/#p_38",
    "pt": "Application Initialization",
    "t": 3,
    "c": "A view is defined with {!rsh} View(viewName, viewInterface) or {!rsh} View(viewInterface), where {!rsh} viewName is a string that labels the view and {!rsh} viewInterface is an object where each field indicates the type of a function or value provided by the contract associated with the specified DApp."
  },
  {
    "objectID": "/rsh/appinit/#p_39",
    "pt": "Application Initialization",
    "t": 3,
    "c": "For example, {!rsh} View is used in the code below without a {!rsh} viewName:"
  },
  {
    "objectID": "/rsh/appinit/#p_40",
    "pt": "Application Initialization",
    "t": 3,
    "c": "While the {!rsh} View in the following code contains a {!rsh} viewName:"
  },
  {
    "objectID": "/rsh/appinit/#p_41",
    "pt": "Application Initialization",
    "t": 3,
    "c": "These views are available in frontends via the {!js} ctc.views object. In the DApp, the result of this application argument is referred to as a view object."
  },
  {
    "objectID": "/rsh/appinit/#p_42",
    "pt": "Application Initialization",
    "t": 3,
    "c": "An event is defined with {!rsh} Events(eventName, eventInterface) or {!rsh} Events(eventInterface), where {!rsh} eventName is a string that labels the event and {!rsh} eventInterface is an object where each field is a {!rsh} Tuple of {!rsh} Types, representing the type of values that an event will emit."
  },
  {
    "objectID": "/rsh/appinit/#p_43",
    "pt": "Application Initialization",
    "t": 3,
    "c": "For example, the {!rsh} Events in the code below has no {!rsh} eventName:"
  },
  {
    "objectID": "/rsh/appinit/#p_44",
    "pt": "Application Initialization",
    "t": 3,
    "c": "While the {!rsh} Events in following example has an {!rsh} eventName:"
  },
  {
    "objectID": "/rsh/appinit/#p_45",
    "pt": "Application Initialization",
    "t": 3,
    "c": "These events are available in the frontends via the {!js} ctc.events object. In the DApp, the result of this application argument is referred to as an event object."
  },
  {
    "objectID": "/rsh/appinit/#p_46",
    "pt": "Application Initialization",
    "t": 3,
    "c": "Reach programs can create new child contracts based on predetermined, static code during compile time. This code is specified with {!rsh} ContractCode, documented below, but is actually deployed with {!rsh} new Contract ({!rsh} Contract.new), which you can read about in Contract creation."
  },
  {
    "objectID": "/rsh/appinit/#p_47",
    "pt": "Application Initialization",
    "t": 3,
    "c": "As part of an application's specification, you can indicate some child contracts that may be created with:"
  },
  {
    "objectID": "/rsh/appinit/#p_48",
    "pt": "Application Initialization",
    "t": 3,
    "c": "where connectors is an object with one field for each enabled connector. Each connector expects the code for the child to be specified in a different way."
  },
  {
    "objectID": "/rsh/appinit/#p_49",
    "pt": "Application Initialization",
    "t": 3,
    "c": "The {!rsh} ETH connector accepts:"
  },
  {
    "objectID": "/rsh/appinit/#p_50",
    "pt": "Application Initialization",
    "t": 3,
    "c": "A literal string of the shape ${BASE}.bin, where ${BASE}.bin is a file that contains the ASCII hexadecimal encoding of the EVM bytecode."
  },
  {
    "objectID": "/rsh/appinit/#p_51",
    "pt": "Application Initialization",
    "t": 3,
    "c": "A literal string of the shape ${BASE}.json:${FILE}:${CONTRACT}, where ${BASE}.json is a file that contains the JSON output of the Solidity compiler and ${FILE}:${CONTRACT} is a key in the contracts object therein."
  },
  {
    "objectID": "/rsh/appinit/#p_52",
    "pt": "Application Initialization",
    "t": 3,
    "c": "A literal string of the shape ${BASE}.sol:${CONTRACT}, where ${BASE}.sol is a Solidity file that defines the contract ${CONTRACT}. Reach will call the Solidity compiler it uses internally to compile the file."
  },
  {
    "objectID": "/rsh/appinit/#p_53",
    "pt": "Application Initialization",
    "t": 3,
    "c": "The {!rsh} ALGO connector accepts an object with the keys approval and clearState that may be:"
  },
  {
    "objectID": "/rsh/appinit/#p_54",
    "pt": "Application Initialization",
    "t": 3,
    "c": "A literal string of the shape ${BASE}.tok, where ${BASE}.tok is a file that contains the binary encoding of the AVM bytecode (as produced by {!cmd} goal clerk compile.)"
  },
  {
    "objectID": "/rsh/appinit/#p_55",
    "pt": "Application Initialization",
    "t": 3,
    "c": "A literal string of the shape ${BASE}.teal, where ${BASE}.teal is a TEAL file that defines the program. Reach will call the TEAL compiler it uses internally to compile the file."
  },
  {
    "objectID": "/rsh/appinit/#p_56",
    "pt": "Application Initialization",
    "t": 3,
    "c": "The value returned (cc) can be used with {!rsh} new Contract to actually deploy the child contracts. It embeds the actual bytecode of the child contracts, so it can (potentially drastically) expand the size (and thus cost) of deploying the parent contract."
  },
  {
    "objectID": "/rsh/appinit/#p_57",
    "pt": "Application Initialization",
    "t": 3,
    "c": "How do I get valid input to {!rsh} ContractCode from Reach?"
  },
  {
    "objectID": "/rsh/appinit/#p_58",
    "pt": "Application Initialization",
    "t": 3,
    "c": "A future version of Reach will accept {!rsh} Reach.App values as arguments to {!rsh} ContractCode, but until then, the best way to get the necessary files is to use {!cmd} reach compile --intermediate-files and inspect the build directory, which contains the necessary input for each connector."
  },
  {
    "objectID": "/rsh/compute/#rsh_const",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "const"
  },
  {
    "objectID": "/rsh/compute/#rsh_function",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "function"
  },
  {
    "objectID": "/rsh/compute/#rsh_return",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "return"
  },
  {
    "objectID": "/rsh/compute/#rsh_if",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "if"
  },
  {
    "objectID": "/rsh/compute/#rsh_else",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "else"
  },
  {
    "objectID": "/rsh/compute/#rsh_switch",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "switch"
  },
  {
    "objectID": "/rsh/compute/#rsh_case",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "case"
  },
  {
    "objectID": "/rsh/compute/#rsh_default",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "default"
  },
  {
    "objectID": "/rsh/compute/#rsh_'use%20strict'",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "'use strict'"
  },
  {
    "objectID": "/rsh/compute/#rsh_unstrict",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "unstrict"
  },
  {
    "objectID": "/rsh/compute/#rsh_this",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "this"
  },
  {
    "objectID": "/rsh/compute/#rsh_new",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "new"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.new",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.new"
  },
  {
    "objectID": "/rsh/compute/#rsh_Set.new",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Set.new"
  },
  {
    "objectID": "/rsh/compute/#rsh_Token.new",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Token.new"
  },
  {
    "objectID": "/rsh/compute/#rsh_Null",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Null"
  },
  {
    "objectID": "/rsh/compute/#rsh_Bool",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Bool"
  },
  {
    "objectID": "/rsh/compute/#rsh_UInt",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "UInt"
  },
  {
    "objectID": "/rsh/compute/#rsh_UInt.max",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "UInt.max"
  },
  {
    "objectID": "/rsh/compute/#rsh_UInt256",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "UInt256"
  },
  {
    "objectID": "/rsh/compute/#rsh_UInt256.max",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "UInt256.max"
  },
  {
    "objectID": "/rsh/compute/#rsh_Bytes",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Bytes"
  },
  {
    "objectID": "/rsh/compute/#rsh_Digest",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Digest"
  },
  {
    "objectID": "/rsh/compute/#rsh_Address",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Address"
  },
  {
    "objectID": "/rsh/compute/#rsh_Contract",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Contract"
  },
  {
    "objectID": "/rsh/compute/#rsh_Token",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Token"
  },
  {
    "objectID": "/rsh/compute/#rsh_Fun",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Fun"
  },
  {
    "objectID": "/rsh/compute/#rsh_Tuple",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Tuple"
  },
  {
    "objectID": "/rsh/compute/#rsh_Object",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Object"
  },
  {
    "objectID": "/rsh/compute/#rsh_Struct",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Struct"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array"
  },
  {
    "objectID": "/rsh/compute/#rsh_Data",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Data"
  },
  {
    "objectID": "/rsh/compute/#rsh_Refine",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Refine"
  },
  {
    "objectID": "/rsh/compute/#rsh_typeOf",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "typeOf"
  },
  {
    "objectID": "/rsh/compute/#rsh_isType",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "isType"
  },
  {
    "objectID": "/rsh/compute/#rsh_is",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "is"
  },
  {
    "objectID": "/rsh/compute/#rsh_true",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "true"
  },
  {
    "objectID": "/rsh/compute/#rsh_false",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "false"
  },
  {
    "objectID": "/rsh/compute/#rsh_null",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "null"
  },
  {
    "objectID": "/rsh/compute/#rsh_!",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "!"
  },
  {
    "objectID": "/rsh/compute/#rsh_-",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "-"
  },
  {
    "objectID": "/rsh/compute/#rsh_+",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "+"
  },
  {
    "objectID": "/rsh/compute/#rsh_typeof",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "typeof"
  },
  {
    "objectID": "/rsh/compute/#rsh_not",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "not"
  },
  {
    "objectID": "/rsh/compute/#rsh_minus",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "minus"
  },
  {
    "objectID": "/rsh/compute/#rsh_plus",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "plus"
  },
  {
    "objectID": "/rsh/compute/#rsh_void",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "void"
  },
  {
    "objectID": "/rsh/compute/#rsh_&&",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "&&"
  },
  {
    "objectID": "/rsh/compute/#rsh_%7C%7C",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "||"
  },
  {
    "objectID": "/rsh/compute/#rsh_+",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "+"
  },
  {
    "objectID": "/rsh/compute/#rsh_-",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "-"
  },
  {
    "objectID": "/rsh/compute/#rsh_*",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "*"
  },
  {
    "objectID": "/rsh/compute/#rsh_/",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "/"
  },
  {
    "objectID": "/rsh/compute/#rsh_%25",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "%"
  },
  {
    "objectID": "/rsh/compute/#rsh_%7C",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "|"
  },
  {
    "objectID": "/rsh/compute/#rsh_&",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "&"
  },
  {
    "objectID": "/rsh/compute/#rsh_%5E",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "^"
  },
  {
    "objectID": "/rsh/compute/#rsh_%3C%3C",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "<<"
  },
  {
    "objectID": "/rsh/compute/#rsh_%3E%3E",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": ">>"
  },
  {
    "objectID": "/rsh/compute/#rsh_==",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "=="
  },
  {
    "objectID": "/rsh/compute/#rsh_!=",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "!="
  },
  {
    "objectID": "/rsh/compute/#rsh_===",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "==="
  },
  {
    "objectID": "/rsh/compute/#rsh_!==",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "!=="
  },
  {
    "objectID": "/rsh/compute/#rsh_%3E",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": ">"
  },
  {
    "objectID": "/rsh/compute/#rsh_%3E=",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": ">="
  },
  {
    "objectID": "/rsh/compute/#rsh_%3C=",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "<="
  },
  {
    "objectID": "/rsh/compute/#rsh_%3C",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "<"
  },
  {
    "objectID": "/rsh/compute/#rsh_and",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "and"
  },
  {
    "objectID": "/rsh/compute/#rsh_or",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "or"
  },
  {
    "objectID": "/rsh/compute/#rsh_xor",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "xor"
  },
  {
    "objectID": "/rsh/compute/#rsh_add",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "add"
  },
  {
    "objectID": "/rsh/compute/#rsh_sub",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "sub"
  },
  {
    "objectID": "/rsh/compute/#rsh_mul",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "mul"
  },
  {
    "objectID": "/rsh/compute/#rsh_div",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "div"
  },
  {
    "objectID": "/rsh/compute/#rsh_mod",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "mod"
  },
  {
    "objectID": "/rsh/compute/#rsh_polyMod",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "polyMod"
  },
  {
    "objectID": "/rsh/compute/#rsh_eq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "eq"
  },
  {
    "objectID": "/rsh/compute/#rsh_lt",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "lt"
  },
  {
    "objectID": "/rsh/compute/#rsh_le",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "le"
  },
  {
    "objectID": "/rsh/compute/#rsh_ge",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "ge"
  },
  {
    "objectID": "/rsh/compute/#rsh_gt",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "gt"
  },
  {
    "objectID": "/rsh/compute/#rsh_lsh",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "lsh"
  },
  {
    "objectID": "/rsh/compute/#rsh_rsh",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "rsh"
  },
  {
    "objectID": "/rsh/compute/#rsh_band",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "band"
  },
  {
    "objectID": "/rsh/compute/#rsh_bior",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "bior"
  },
  {
    "objectID": "/rsh/compute/#rsh_bxor",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "bxor"
  },
  {
    "objectID": "/rsh/compute/#rsh_polyEq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "polyEq"
  },
  {
    "objectID": "/rsh/compute/#rsh_polyNeq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "polyNeq"
  },
  {
    "objectID": "/rsh/compute/#rsh_boolEq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "boolEq"
  },
  {
    "objectID": "/rsh/compute/#rsh_typeEq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "typeEq"
  },
  {
    "objectID": "/rsh/compute/#rsh_intEq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intEq"
  },
  {
    "objectID": "/rsh/compute/#rsh_digestEq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "digestEq"
  },
  {
    "objectID": "/rsh/compute/#rsh_addressEq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "addressEq"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxeq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxeq"
  },
  {
    "objectID": "/rsh/compute/#rsh_ieq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "ieq"
  },
  {
    "objectID": "/rsh/compute/#rsh_Contract.addressEq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Contract.addressEq"
  },
  {
    "objectID": "/rsh/compute/#rsh_boolXor",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "boolXor"
  },
  {
    "objectID": "/rsh/compute/#rsh_Bytes.pad",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Bytes.pad"
  },
  {
    "objectID": "/rsh/compute/#rsh_array",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "array"
  },
  {
    "objectID": "/rsh/compute/#rsh_Tuple.length",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Tuple.length"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.length",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.length"
  },
  {
    "objectID": "/rsh/compute/#rsh_length",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "length"
  },
  {
    "objectID": "/rsh/compute/#rsh_Tuple.set",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Tuple.set"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.set",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.set"
  },
  {
    "objectID": "/rsh/compute/#rsh_set",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "set"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.elemType",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.elemType"
  },
  {
    "objectID": "/rsh/compute/#rsh_elemType",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "elemType"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.forEach",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.forEach"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.forEach",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.forEach"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.forEach",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.forEach"
  },
  {
    "objectID": "/rsh/compute/#rsh_forEach",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "forEach"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.all",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.all"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.all",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.all"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.all",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.all"
  },
  {
    "objectID": "/rsh/compute/#rsh_all",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "all"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.any",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.any"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.any",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.any"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.any",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.any"
  },
  {
    "objectID": "/rsh/compute/#rsh_any",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "any"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.or",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.or"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.or",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.or"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.or",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.or"
  },
  {
    "objectID": "/rsh/compute/#rsh_or",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "or"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.and",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.and"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.and",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.and"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.and",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.and"
  },
  {
    "objectID": "/rsh/compute/#rsh_and",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "and"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.includes",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.includes"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.includes",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.includes"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.includes",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.includes"
  },
  {
    "objectID": "/rsh/compute/#rsh_includes",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "includes"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.count",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.count"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.count",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.count"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.count",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.count"
  },
  {
    "objectID": "/rsh/compute/#rsh_count",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "count"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.size",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.size"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.size",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.size"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.size",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.size"
  },
  {
    "objectID": "/rsh/compute/#rsh_size",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "size"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.min",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.min"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.min",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.min"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.min",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.min"
  },
  {
    "objectID": "/rsh/compute/#rsh_min",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "min"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.max",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.max"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.max",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.max"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.max",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.max"
  },
  {
    "objectID": "/rsh/compute/#rsh_max",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "max"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.sum",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.sum"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.sum",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.sum"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.sum",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.sum"
  },
  {
    "objectID": "/rsh/compute/#rsh_sum",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "sum"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.product",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.product"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.product",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.product"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.product",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.product"
  },
  {
    "objectID": "/rsh/compute/#rsh_product",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "product"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.average",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.average"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.average",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.average"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.average",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.average"
  },
  {
    "objectID": "/rsh/compute/#rsh_average",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "average"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.imin",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.imin"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.imax",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.imax"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.imin",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.imin"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.imax",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.imax"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.imin",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.imin"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.imax",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.imax"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.iota",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.iota"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array_replicate",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array_replicate"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.replicate",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.replicate"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.concat",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.concat"
  },
  {
    "objectID": "/rsh/compute/#rsh_concat",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "concat"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array_empty",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array_empty"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.empty",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.empty"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.zip",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.zip"
  },
  {
    "objectID": "/rsh/compute/#rsh_zip",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "zip"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.map",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.map"
  },
  {
    "objectID": "/rsh/compute/#rsh_map",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "map"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.mapWithIndex",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.mapWithIndex"
  },
  {
    "objectID": "/rsh/compute/#rsh_mapWithIndex",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "mapWithIndex"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.forEachWithIndex",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.forEachWithIndex"
  },
  {
    "objectID": "/rsh/compute/#rsh_forEachWithIndex",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "forEachWithIndex"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.reduce",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.reduce"
  },
  {
    "objectID": "/rsh/compute/#rsh_reduce",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "reduce"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.reduceWithIndex",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.reduceWithIndex"
  },
  {
    "objectID": "/rsh/compute/#rsh_reduceWithIndex",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "reduceWithIndex"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.indexOf",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.indexOf"
  },
  {
    "objectID": "/rsh/compute/#rsh_indexOf",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "indexOf"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.findIndex",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.findIndex"
  },
  {
    "objectID": "/rsh/compute/#rsh_findIndex",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "findIndex"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.find",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.find"
  },
  {
    "objectID": "/rsh/compute/#rsh_find",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "find"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.withIndex",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.withIndex"
  },
  {
    "objectID": "/rsh/compute/#rsh_withIndex",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "withIndex"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.slice",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.slice"
  },
  {
    "objectID": "/rsh/compute/#rsh_slice",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "slice"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.reduce",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.reduce"
  },
  {
    "objectID": "/rsh/compute/#rsh_Struct.toObject",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Struct.toObject"
  },
  {
    "objectID": "/rsh/compute/#rsh_Struct.toTuple",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Struct.toTuple"
  },
  {
    "objectID": "/rsh/compute/#rsh_Object.set",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Object.set"
  },
  {
    "objectID": "/rsh/compute/#rsh_Object_set",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Object_set"
  },
  {
    "objectID": "/rsh/compute/#rsh_Object.setIfUnset",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Object.setIfUnset"
  },
  {
    "objectID": "/rsh/compute/#rsh_Object_setIfUnset",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Object_setIfUnset"
  },
  {
    "objectID": "/rsh/compute/#rsh_Object.has",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Object.has"
  },
  {
    "objectID": "/rsh/compute/#rsh_Maybe",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Maybe"
  },
  {
    "objectID": "/rsh/compute/#rsh_Maybe.Some",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Maybe.Some"
  },
  {
    "objectID": "/rsh/compute/#rsh_Maybe.None",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Maybe.None"
  },
  {
    "objectID": "/rsh/compute/#rsh_fromMaybe",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fromMaybe"
  },
  {
    "objectID": "/rsh/compute/#rsh_isNone",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "isNone"
  },
  {
    "objectID": "/rsh/compute/#rsh_isSome",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "isSome"
  },
  {
    "objectID": "/rsh/compute/#rsh_fromSome",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fromSome"
  },
  {
    "objectID": "/rsh/compute/#rsh_maybe",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "maybe"
  },
  {
    "objectID": "/rsh/compute/#rsh_Either",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Either"
  },
  {
    "objectID": "/rsh/compute/#rsh_Either.Left",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Either.Left"
  },
  {
    "objectID": "/rsh/compute/#rsh_Either.Right",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Either.Right"
  },
  {
    "objectID": "/rsh/compute/#rsh_either",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "either"
  },
  {
    "objectID": "/rsh/compute/#rsh_isLeft",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "isLeft"
  },
  {
    "objectID": "/rsh/compute/#rsh_isRight",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "isRight"
  },
  {
    "objectID": "/rsh/compute/#rsh_fromLeft",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fromLeft"
  },
  {
    "objectID": "/rsh/compute/#rsh_fromRight",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fromRight"
  },
  {
    "objectID": "/rsh/compute/#rsh_match",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "match"
  },
  {
    "objectID": "/rsh/compute/#rsh_?",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "?"
  },
  {
    "objectID": "/rsh/compute/#rsh_ite",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "ite"
  },
  {
    "objectID": "/rsh/compute/#rsh_=%3E",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "=>"
  },
  {
    "objectID": "/rsh/compute/#rsh_makeEnum",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "makeEnum"
  },
  {
    "objectID": "/rsh/compute/#rsh_assert",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "assert"
  },
  {
    "objectID": "/rsh/compute/#rsh_check",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "check"
  },
  {
    "objectID": "/rsh/compute/#rsh_forall",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "forall"
  },
  {
    "objectID": "/rsh/compute/#rsh_possible",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "possible"
  },
  {
    "objectID": "/rsh/compute/#rsh_digest",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "digest"
  },
  {
    "objectID": "/rsh/compute/#rsh_balance",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "balance"
  },
  {
    "objectID": "/rsh/compute/#rsh_getContract",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "getContract"
  },
  {
    "objectID": "/rsh/compute/#rsh_getAddress",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "getAddress"
  },
  {
    "objectID": "/rsh/compute/#rsh_getCompanion",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "getCompanion"
  },
  {
    "objectID": "/rsh/compute/#rsh_lastConsensusTime",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "lastConsensusTime"
  },
  {
    "objectID": "/rsh/compute/#rsh_lastConsensusSecs",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "lastConsensusSecs"
  },
  {
    "objectID": "/rsh/compute/#rsh_thisConsensusTime",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "thisConsensusTime"
  },
  {
    "objectID": "/rsh/compute/#rsh_thisConsensusSecs",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "thisConsensusSecs"
  },
  {
    "objectID": "/rsh/compute/#rsh_baseWaitTime",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "baseWaitTime"
  },
  {
    "objectID": "/rsh/compute/#rsh_baseWaitSecs",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "baseWaitSecs"
  },
  {
    "objectID": "/rsh/compute/#rsh_relativeTime",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "relativeTime"
  },
  {
    "objectID": "/rsh/compute/#rsh_absoluteTime",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "absoluteTime"
  },
  {
    "objectID": "/rsh/compute/#rsh_relativeSecs",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "relativeSecs"
  },
  {
    "objectID": "/rsh/compute/#rsh_absoluteSecs",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "absoluteSecs"
  },
  {
    "objectID": "/rsh/compute/#rsh_verifyRelativeTime",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "verifyRelativeTime"
  },
  {
    "objectID": "/rsh/compute/#rsh_verifyAbsoluteTime",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "verifyAbsoluteTime"
  },
  {
    "objectID": "/rsh/compute/#rsh_verifyRelativeSecs",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "verifyRelativeSecs"
  },
  {
    "objectID": "/rsh/compute/#rsh_verifyAbsoluteSecs",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "verifyAbsoluteSecs"
  },
  {
    "objectID": "/rsh/compute/#rsh_makeDeadline",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "makeDeadline"
  },
  {
    "objectID": "/rsh/compute/#rsh_implies",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "implies"
  },
  {
    "objectID": "/rsh/compute/#rsh_ensure",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "ensure"
  },
  {
    "objectID": "/rsh/compute/#rsh_hasRandom",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "hasRandom"
  },
  {
    "objectID": "/rsh/compute/#rsh_hasRandom.random",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "hasRandom.random"
  },
  {
    "objectID": "/rsh/compute/#rsh_hasConsoleLogger",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "hasConsoleLogger"
  },
  {
    "objectID": "/rsh/compute/#rsh_hasConsoleLogger.log",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "hasConsoleLogger.log"
  },
  {
    "objectID": "/rsh/compute/#rsh_compose",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "compose"
  },
  {
    "objectID": "/rsh/compute/#rsh_muldiv",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "muldiv"
  },
  {
    "objectID": "/rsh/compute/#rsh_verifyMuldiv",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "verifyMuldiv"
  },
  {
    "objectID": "/rsh/compute/#rsh_sqrt",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "sqrt"
  },
  {
    "objectID": "/rsh/compute/#rsh_sqrtApprox",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "sqrtApprox"
  },
  {
    "objectID": "/rsh/compute/#rsh_pow",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "pow"
  },
  {
    "objectID": "/rsh/compute/#rsh_Int",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Int"
  },
  {
    "objectID": "/rsh/compute/#rsh_Pos",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Pos"
  },
  {
    "objectID": "/rsh/compute/#rsh_Neg",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Neg"
  },
  {
    "objectID": "/rsh/compute/#rsh_int",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "int"
  },
  {
    "objectID": "/rsh/compute/#rsh_iadd",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "iadd"
  },
  {
    "objectID": "/rsh/compute/#rsh_isub",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "isub"
  },
  {
    "objectID": "/rsh/compute/#rsh_imul",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "imul"
  },
  {
    "objectID": "/rsh/compute/#rsh_idiv",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "idiv"
  },
  {
    "objectID": "/rsh/compute/#rsh_imod",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "imod"
  },
  {
    "objectID": "/rsh/compute/#rsh_ilt",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "ilt"
  },
  {
    "objectID": "/rsh/compute/#rsh_ile",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "ile"
  },
  {
    "objectID": "/rsh/compute/#rsh_igt",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "igt"
  },
  {
    "objectID": "/rsh/compute/#rsh_ige",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "ige"
  },
  {
    "objectID": "/rsh/compute/#rsh_ieq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "ieq"
  },
  {
    "objectID": "/rsh/compute/#rsh_ine",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "ine"
  },
  {
    "objectID": "/rsh/compute/#rsh_imax",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "imax"
  },
  {
    "objectID": "/rsh/compute/#rsh_abs",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "abs"
  },
  {
    "objectID": "/rsh/compute/#rsh_FixedPoint",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "FixedPoint"
  },
  {
    "objectID": "/rsh/compute/#rsh_fx",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fx"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxint",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxint"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxrescale",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxrescale"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxunify",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxunify"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxadd",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxadd"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxsub",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxsub"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxmul",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxmul"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxdiv",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxdiv"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxmod",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxmod"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxfloor",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxfloor"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxsqrt",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxsqrt"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxsqrtApprox",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxsqrtApprox"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxpow",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxpow"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxpowi",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxpowi"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxpowui",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxpowui"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxcmp",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxcmp"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxlt",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxlt"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxle",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxle"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxgt",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxgt"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxge",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxge"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxeq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxeq"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxne",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxne"
  },
  {
    "objectID": "/rsh/compute/#rsh_Anybody",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Anybody"
  },
  {
    "objectID": "/rsh/compute/#rsh_Interval",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Interval"
  },
  {
    "objectID": "/rsh/compute/#rsh_isInterval",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "isInterval"
  },
  {
    "objectID": "/rsh/compute/#rsh_IntervalType",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "IntervalType"
  },
  {
    "objectID": "/rsh/compute/#rsh_isIntervalType",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "isIntervalType"
  },
  {
    "objectID": "/rsh/compute/#rsh_Closed",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Closed"
  },
  {
    "objectID": "/rsh/compute/#rsh_Open",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Open"
  },
  {
    "objectID": "/rsh/compute/#rsh_interval",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "interval"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalCC",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalCC"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalCO",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalCO"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalOC",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalOC"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalOO",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalOO"
  },
  {
    "objectID": "/rsh/compute/#rsh_leftEndpoint",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "leftEndpoint"
  },
  {
    "objectID": "/rsh/compute/#rsh_rightEndpoint",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "rightEndpoint"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalEq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalEq"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalNeq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalNeq"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalLt",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalLt"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalLte",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalLte"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalGt",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalGt"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalGte",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalGte"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalAdd",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalAdd"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalSub",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalSub"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalMul",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalMul"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalDiv",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalDiv"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalIntersection",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalIntersection"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalUnion",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalUnion"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalWidth",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalWidth"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalAbs",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalAbs"
  },
  {
    "objectID": "/rsh/compute/#rsh_getUntrackedFunds",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "getUntrackedFunds"
  },
  {
    "objectID": "/rsh/compute/#rsh_distinct",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "distinct"
  },
  {
    "objectID": "/rsh/compute/#term_single-line%20comment",
    "pt": "Computations",
    "t": 1,
    "c": "single-line comment"
  },
  {
    "objectID": "/rsh/compute/#term_multi-line%20comment",
    "pt": "Computations",
    "t": 1,
    "c": "multi-line comment"
  },
  {
    "objectID": "/rsh/compute/#term_block",
    "pt": "Computations",
    "t": 1,
    "c": "block"
  },
  {
    "objectID": "/rsh/compute/#term_statements",
    "pt": "Computations",
    "t": 1,
    "c": "statements"
  },
  {
    "objectID": "/rsh/compute/#term_tail",
    "pt": "Computations",
    "t": 1,
    "c": "tail"
  },
  {
    "objectID": "/rsh/compute/#term_continuations",
    "pt": "Computations",
    "t": 1,
    "c": "continuations"
  },
  {
    "objectID": "/rsh/compute/#term_terminator%20statement",
    "pt": "Computations",
    "t": 1,
    "c": "terminator statement"
  },
  {
    "objectID": "/rsh/compute/#term_identifier%20definition",
    "pt": "Computations",
    "t": 1,
    "c": "identifier definition"
  },
  {
    "objectID": "/rsh/compute/#term_bound%20identifier",
    "pt": "Computations",
    "t": 1,
    "c": "bound identifier"
  },
  {
    "objectID": "/rsh/compute/#term_identifiers",
    "pt": "Computations",
    "t": 1,
    "c": "identifiers"
  },
  {
    "objectID": "/rsh/compute/#term_value%20definition",
    "pt": "Computations",
    "t": 1,
    "c": "value definition"
  },
  {
    "objectID": "/rsh/compute/#term_function%20definition",
    "pt": "Computations",
    "t": 1,
    "c": "function definition"
  },
  {
    "objectID": "/rsh/compute/#term_function%20body",
    "pt": "Computations",
    "t": 1,
    "c": "function body"
  },
  {
    "objectID": "/rsh/compute/#term_rest%20parameter",
    "pt": "Computations",
    "t": 1,
    "c": "rest parameter"
  },
  {
    "objectID": "/rsh/compute/#term_unbound",
    "pt": "Computations",
    "t": 1,
    "c": "unbound"
  },
  {
    "objectID": "/rsh/compute/#term_return%20statement",
    "pt": "Computations",
    "t": 1,
    "c": "return statement"
  },
  {
    "objectID": "/rsh/compute/#term_tail%20position",
    "pt": "Computations",
    "t": 1,
    "c": "tail position"
  },
  {
    "objectID": "/rsh/compute/#term_conditional%20statement",
    "pt": "Computations",
    "t": 1,
    "c": "conditional statement"
  },
  {
    "objectID": "/rsh/compute/#term_switch%20statement",
    "pt": "Computations",
    "t": 1,
    "c": "switch statement"
  },
  {
    "objectID": "/rsh/compute/#term_block%20statement",
    "pt": "Computations",
    "t": 1,
    "c": "block statement"
  },
  {
    "objectID": "/rsh/compute/#term_try%20statement",
    "pt": "Computations",
    "t": 1,
    "c": "try statement"
  },
  {
    "objectID": "/rsh/compute/#term_throw%20statement",
    "pt": "Computations",
    "t": 1,
    "c": "throw statement"
  },
  {
    "objectID": "/rsh/compute/#term_strict%20mode",
    "pt": "Computations",
    "t": 1,
    "c": "strict mode"
  },
  {
    "objectID": "/rsh/compute/#term_expressions",
    "pt": "Computations",
    "t": 1,
    "c": "expressions"
  },
  {
    "objectID": "/rsh/compute/#term_function%20application",
    "pt": "Computations",
    "t": 1,
    "c": "function application"
  },
  {
    "objectID": "/rsh/compute/#term_type",
    "pt": "Computations",
    "t": 1,
    "c": "type"
  },
  {
    "objectID": "/rsh/compute/#term_function%20type",
    "pt": "Computations",
    "t": 1,
    "c": "function type"
  },
  {
    "objectID": "/rsh/compute/#term_unconstrained%20domain%20function%20type",
    "pt": "Computations",
    "t": 1,
    "c": "unconstrained domain function type"
  },
  {
    "objectID": "/rsh/compute/#term_negative%20position",
    "pt": "Computations",
    "t": 1,
    "c": "negative position"
  },
  {
    "objectID": "/rsh/compute/#term_positive%20position",
    "pt": "Computations",
    "t": 1,
    "c": "positive position"
  },
  {
    "objectID": "/rsh/compute/#term_literal%20value",
    "pt": "Computations",
    "t": 1,
    "c": "literal value"
  },
  {
    "objectID": "/rsh/compute/#term_null%20literal",
    "pt": "Computations",
    "t": 1,
    "c": "null literal"
  },
  {
    "objectID": "/rsh/compute/#term_Numeric%20literal",
    "pt": "Computations",
    "t": 1,
    "c": "Numeric literal"
  },
  {
    "objectID": "/rsh/compute/#term_bit%20width",
    "pt": "Computations",
    "t": 1,
    "c": "bit width"
  },
  {
    "objectID": "/rsh/compute/#term_Boolean%20literal",
    "pt": "Computations",
    "t": 1,
    "c": "Boolean literal"
  },
  {
    "objectID": "/rsh/compute/#term_String%20literal",
    "pt": "Computations",
    "t": 1,
    "c": "String literal"
  },
  {
    "objectID": "/rsh/compute/#term_operator",
    "pt": "Computations",
    "t": 1,
    "c": "operator"
  },
  {
    "objectID": "/rsh/compute/#term_unary%20expression",
    "pt": "Computations",
    "t": 1,
    "c": "unary expression"
  },
  {
    "objectID": "/rsh/compute/#term_unary%20operator",
    "pt": "Computations",
    "t": 1,
    "c": "unary operator"
  },
  {
    "objectID": "/rsh/compute/#term_binary%20expression",
    "pt": "Computations",
    "t": 1,
    "c": "binary expression"
  },
  {
    "objectID": "/rsh/compute/#term_binary%20operator",
    "pt": "Computations",
    "t": 1,
    "c": "binary operator"
  },
  {
    "objectID": "/rsh/compute/#term_padded",
    "pt": "Computations",
    "t": 1,
    "c": "padded"
  },
  {
    "objectID": "/rsh/compute/#term_tuple",
    "pt": "Computations",
    "t": 1,
    "c": "tuple"
  },
  {
    "objectID": "/rsh/compute/#term_array",
    "pt": "Computations",
    "t": 1,
    "c": "array"
  },
  {
    "objectID": "/rsh/compute/#term_reference",
    "pt": "Computations",
    "t": 1,
    "c": "reference"
  },
  {
    "objectID": "/rsh/compute/#term_object",
    "pt": "Computations",
    "t": 1,
    "c": "object"
  },
  {
    "objectID": "/rsh/compute/#term_object%20splice",
    "pt": "Computations",
    "t": 1,
    "c": "object splice"
  },
  {
    "objectID": "/rsh/compute/#term_struct",
    "pt": "Computations",
    "t": 1,
    "c": "struct"
  },
  {
    "objectID": "/rsh/compute/#term_object%20reference",
    "pt": "Computations",
    "t": 1,
    "c": "object reference"
  },
  {
    "objectID": "/rsh/compute/#term_field",
    "pt": "Computations",
    "t": 1,
    "c": "field"
  },
  {
    "objectID": "/rsh/compute/#term_data%20instance",
    "pt": "Computations",
    "t": 1,
    "c": "data instance"
  },
  {
    "objectID": "/rsh/compute/#term_match%20expression",
    "pt": "Computations",
    "t": 1,
    "c": "match expression"
  },
  {
    "objectID": "/rsh/compute/#term_conditional%20expression",
    "pt": "Computations",
    "t": 1,
    "c": "conditional expression"
  },
  {
    "objectID": "/rsh/compute/#term_arrow%20expression",
    "pt": "Computations",
    "t": 1,
    "c": "arrow expression"
  },
  {
    "objectID": "/rsh/compute/#term_enumeration",
    "pt": "Computations",
    "t": 1,
    "c": "enumeration"
  },
  {
    "objectID": "/rsh/compute/#term_enum",
    "pt": "Computations",
    "t": 1,
    "c": "enum"
  },
  {
    "objectID": "/rsh/compute/#term_balance",
    "pt": "Computations",
    "t": 1,
    "c": "balance"
  },
  {
    "objectID": "/rsh/compute/#term_getContract",
    "pt": "Computations",
    "t": 1,
    "c": "getContract"
  },
  {
    "objectID": "/rsh/compute/#term_getAddress",
    "pt": "Computations",
    "t": 1,
    "c": "getAddress"
  },
  {
    "objectID": "/rsh/compute/#term_lastConsensusTime",
    "pt": "Computations",
    "t": 1,
    "c": "lastConsensusTime"
  },
  {
    "objectID": "/rsh/compute/#term_lastConsensusSecs",
    "pt": "Computations",
    "t": 1,
    "c": "lastConsensusSecs"
  },
  {
    "objectID": "/rsh/compute/#term_thisConsensusTime",
    "pt": "Computations",
    "t": 1,
    "c": "thisConsensusTime"
  },
  {
    "objectID": "/rsh/compute/#term_thisConsensusSecs",
    "pt": "Computations",
    "t": 1,
    "c": "thisConsensusSecs"
  },
  {
    "objectID": "/rsh/compute/#term_time%20arguments",
    "pt": "Computations",
    "t": 1,
    "c": "time arguments"
  },
  {
    "objectID": "/rsh/compute/#ref-programs-compute",
    "pt": "Computations",
    "t": 2,
    "c": "Computations"
  },
  {
    "objectID": "/rsh/compute/#comments",
    "pt": "Computations",
    "t": 2,
    "c": "Comments"
  },
  {
    "objectID": "/rsh/compute/#blocks",
    "pt": "Computations",
    "t": 2,
    "c": "Blocks"
  },
  {
    "objectID": "/rsh/compute/#ref-programs-compute-stmts",
    "pt": "Computations",
    "t": 2,
    "c": "Statements"
  },
  {
    "objectID": "/rsh/compute/#const--and--function",
    "pt": "Computations",
    "t": 2,
    "c": "const and function"
  },
  {
    "objectID": "/rsh/compute/#return",
    "pt": "Computations",
    "t": 2,
    "c": "return"
  },
  {
    "objectID": "/rsh/compute/#if",
    "pt": "Computations",
    "t": 2,
    "c": "if"
  },
  {
    "objectID": "/rsh/compute/#switch",
    "pt": "Computations",
    "t": 2,
    "c": "switch"
  },
  {
    "objectID": "/rsh/compute/#block-statements",
    "pt": "Computations",
    "t": 2,
    "c": "Block statements"
  },
  {
    "objectID": "/rsh/compute/#trycatch--throw-statements",
    "pt": "Computations",
    "t": 2,
    "c": "Try/Catch & Throw Statements"
  },
  {
    "objectID": "/rsh/compute/#use-strict",
    "pt": "Computations",
    "t": 2,
    "c": "'use strict'"
  },
  {
    "objectID": "/rsh/compute/#expression-statements",
    "pt": "Computations",
    "t": 2,
    "c": "Expression statements"
  },
  {
    "objectID": "/rsh/compute/#ref-programs-compute-exprs",
    "pt": "Computations",
    "t": 2,
    "c": "Expressions"
  },
  {
    "objectID": "/rsh/compute/#unstrict",
    "pt": "Computations",
    "t": 2,
    "c": "unstrict"
  },
  {
    "objectID": "/rsh/compute/#identifier-reference",
    "pt": "Computations",
    "t": 2,
    "c": "Identifier reference"
  },
  {
    "objectID": "/rsh/compute/#function-application",
    "pt": "Computations",
    "t": 2,
    "c": "Function application"
  },
  {
    "objectID": "/rsh/compute/#ref-programs-types",
    "pt": "Computations",
    "t": 2,
    "c": "Types"
  },
  {
    "objectID": "/rsh/compute/#literal-values",
    "pt": "Computations",
    "t": 2,
    "c": "Literal values"
  },
  {
    "objectID": "/rsh/compute/#operator-expression",
    "pt": "Computations",
    "t": 2,
    "c": "Operator expression"
  },
  {
    "objectID": "/rsh/compute/#numeric-casting",
    "pt": "Computations",
    "t": 2,
    "c": "Numeric Casting"
  },
  {
    "objectID": "/rsh/compute/#contract-and-address-comparisons",
    "pt": "Computations",
    "t": 2,
    "c": "Contract and Address Comparisons"
  },
  {
    "objectID": "/rsh/compute/#boolxor",
    "pt": "Computations",
    "t": 2,
    "c": "boolXor"
  },
  {
    "objectID": "/rsh/compute/#padding",
    "pt": "Computations",
    "t": 2,
    "c": "Padding"
  },
  {
    "objectID": "/rsh/compute/#parenthesized-expression",
    "pt": "Computations",
    "t": 2,
    "c": "Parenthesized expression"
  },
  {
    "objectID": "/rsh/compute/#ref-programs-tuples",
    "pt": "Computations",
    "t": 2,
    "c": "Tuples"
  },
  {
    "objectID": "/rsh/compute/#ref-programs-arrays",
    "pt": "Computations",
    "t": 2,
    "c": "Arrays"
  },
  {
    "objectID": "/rsh/compute/#element-reference",
    "pt": "Computations",
    "t": 2,
    "c": "Element reference"
  },
  {
    "objectID": "/rsh/compute/#array--tuple-length--tuplelength---arraylength--and--length",
    "pt": "Computations",
    "t": 2,
    "c": "Array & tuple length: Tuple.length, Array.length, and .length"
  },
  {
    "objectID": "/rsh/compute/#array--tuple-update--tupleset---arrayset--and--set",
    "pt": "Computations",
    "t": 2,
    "c": "Array & tuple update: Tuple.set, Array.set, and .set"
  },
  {
    "objectID": "/rsh/compute/#array-element-type--arrayelemtype--and--elemtype",
    "pt": "Computations",
    "t": 2,
    "c": "Array element type: Array.elemType and .elemType"
  },
  {
    "objectID": "/rsh/compute/#foldable-operations",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable operations"
  },
  {
    "objectID": "/rsh/compute/#foldableforeach----foreach",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.forEach && .forEach"
  },
  {
    "objectID": "/rsh/compute/#foldableall----all",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.all && .all"
  },
  {
    "objectID": "/rsh/compute/#foldableany----any",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.any && .any"
  },
  {
    "objectID": "/rsh/compute/#foldableor----or",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.or && .or"
  },
  {
    "objectID": "/rsh/compute/#foldableand----and",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.and && .and"
  },
  {
    "objectID": "/rsh/compute/#foldableincludes----includes",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.includes && .includes"
  },
  {
    "objectID": "/rsh/compute/#foldablecount----count",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.count && .count"
  },
  {
    "objectID": "/rsh/compute/#foldablesize----size",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.size && .size"
  },
  {
    "objectID": "/rsh/compute/#foldablemin----min",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.min && .min"
  },
  {
    "objectID": "/rsh/compute/#foldablemax----max",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.max && .max"
  },
  {
    "objectID": "/rsh/compute/#foldablesum----sum",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.sum && .sum"
  },
  {
    "objectID": "/rsh/compute/#foldableproduct----product",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.product && .product"
  },
  {
    "objectID": "/rsh/compute/#foldableaverage----average",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.average && .average"
  },
  {
    "objectID": "/rsh/compute/#foldableimin----foldableimax",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.imin && Foldable.imax"
  },
  {
    "objectID": "/rsh/compute/#array-group-operations",
    "pt": "Computations",
    "t": 2,
    "c": "Array group operations"
  },
  {
    "objectID": "/rsh/compute/#arrayiota",
    "pt": "Computations",
    "t": 2,
    "c": "Array.iota"
  },
  {
    "objectID": "/rsh/compute/#arrayreplicate",
    "pt": "Computations",
    "t": 2,
    "c": "Array.replicate"
  },
  {
    "objectID": "/rsh/compute/#arrayconcat----concat",
    "pt": "Computations",
    "t": 2,
    "c": "Array.concat && .concat"
  },
  {
    "objectID": "/rsh/compute/#arrayempty",
    "pt": "Computations",
    "t": 2,
    "c": "Array.empty"
  },
  {
    "objectID": "/rsh/compute/#arrayzip----zip",
    "pt": "Computations",
    "t": 2,
    "c": "Array.zip && .zip"
  },
  {
    "objectID": "/rsh/compute/#arraymap----map",
    "pt": "Computations",
    "t": 2,
    "c": "Array.map && .map"
  },
  {
    "objectID": "/rsh/compute/#arraymapwithindex----mapwithindex",
    "pt": "Computations",
    "t": 2,
    "c": "Array.mapWithIndex && .mapWithIndex"
  },
  {
    "objectID": "/rsh/compute/#arrayforeachwithindex----foreachwithindex",
    "pt": "Computations",
    "t": 2,
    "c": "Array.forEachWithIndex && .forEachWithIndex"
  },
  {
    "objectID": "/rsh/compute/#arrayreduce----reduce",
    "pt": "Computations",
    "t": 2,
    "c": "Array.reduce && .reduce"
  },
  {
    "objectID": "/rsh/compute/#arrayreducewithindex----reducewithindex",
    "pt": "Computations",
    "t": 2,
    "c": "Array.reduceWithIndex && .reduceWithIndex"
  },
  {
    "objectID": "/rsh/compute/#arrayindexof----indexof",
    "pt": "Computations",
    "t": 2,
    "c": "Array.indexOf && .indexOf"
  },
  {
    "objectID": "/rsh/compute/#arrayfindindex----findindex",
    "pt": "Computations",
    "t": 2,
    "c": "Array.findIndex && .findIndex"
  },
  {
    "objectID": "/rsh/compute/#arrayfind----find",
    "pt": "Computations",
    "t": 2,
    "c": "Array.find && .find"
  },
  {
    "objectID": "/rsh/compute/#arraywithindex----withindex",
    "pt": "Computations",
    "t": 2,
    "c": "Array.withIndex && .withIndex"
  },
  {
    "objectID": "/rsh/compute/#arrayslice----slice",
    "pt": "Computations",
    "t": 2,
    "c": "Array.slice && .slice"
  },
  {
    "objectID": "/rsh/compute/#mapping-group-operations",
    "pt": "Computations",
    "t": 2,
    "c": "Mapping group operations"
  },
  {
    "objectID": "/rsh/compute/#mapreduce----reduce",
    "pt": "Computations",
    "t": 2,
    "c": "Map.reduce && .reduce"
  },
  {
    "objectID": "/rsh/compute/#ref-programs-objects",
    "pt": "Computations",
    "t": 2,
    "c": "Objects"
  },
  {
    "objectID": "/rsh/compute/#ref-programs-structs",
    "pt": "Computations",
    "t": 2,
    "c": "Structs"
  },
  {
    "objectID": "/rsh/compute/#field-reference",
    "pt": "Computations",
    "t": 2,
    "c": "Field reference"
  },
  {
    "objectID": "/rsh/compute/#objectset",
    "pt": "Computations",
    "t": 2,
    "c": "Object.set"
  },
  {
    "objectID": "/rsh/compute/#objectsetifunset",
    "pt": "Computations",
    "t": 2,
    "c": "Object.setIfUnset"
  },
  {
    "objectID": "/rsh/compute/#objecthas",
    "pt": "Computations",
    "t": 2,
    "c": "Object.has"
  },
  {
    "objectID": "/rsh/compute/#ref-programs-data",
    "pt": "Computations",
    "t": 2,
    "c": "Data"
  },
  {
    "objectID": "/rsh/compute/#maybe",
    "pt": "Computations",
    "t": 2,
    "c": "Maybe"
  },
  {
    "objectID": "/rsh/compute/#either",
    "pt": "Computations",
    "t": 2,
    "c": "Either"
  },
  {
    "objectID": "/rsh/compute/#match",
    "pt": "Computations",
    "t": 2,
    "c": "match"
  },
  {
    "objectID": "/rsh/compute/#conditional-expression",
    "pt": "Computations",
    "t": 2,
    "c": "Conditional expression"
  },
  {
    "objectID": "/rsh/compute/#arrow-expression",
    "pt": "Computations",
    "t": 2,
    "c": "Arrow expression"
  },
  {
    "objectID": "/rsh/compute/#makeenum",
    "pt": "Computations",
    "t": 2,
    "c": "makeEnum"
  },
  {
    "objectID": "/rsh/compute/#assert",
    "pt": "Computations",
    "t": 2,
    "c": "assert"
  },
  {
    "objectID": "/rsh/compute/#check",
    "pt": "Computations",
    "t": 2,
    "c": "check"
  },
  {
    "objectID": "/rsh/compute/#forall",
    "pt": "Computations",
    "t": 2,
    "c": "forall"
  },
  {
    "objectID": "/rsh/compute/#possible",
    "pt": "Computations",
    "t": 2,
    "c": "possible"
  },
  {
    "objectID": "/rsh/compute/#digest",
    "pt": "Computations",
    "t": 2,
    "c": "digest"
  },
  {
    "objectID": "/rsh/compute/#balance",
    "pt": "Computations",
    "t": 2,
    "c": "balance"
  },
  {
    "objectID": "/rsh/compute/#getcontract",
    "pt": "Computations",
    "t": 2,
    "c": "getContract"
  },
  {
    "objectID": "/rsh/compute/#getaddress",
    "pt": "Computations",
    "t": 2,
    "c": "getAddress"
  },
  {
    "objectID": "/rsh/compute/#getcompanion",
    "pt": "Computations",
    "t": 2,
    "c": "getCompanion"
  },
  {
    "objectID": "/rsh/compute/#lastconsensustime--and--lastconsensussecs",
    "pt": "Computations",
    "t": 2,
    "c": "lastConsensusTime and lastConsensusSecs"
  },
  {
    "objectID": "/rsh/compute/#thisconsensustime--and--thisconsensussecs",
    "pt": "Computations",
    "t": 2,
    "c": "thisConsensusTime and thisConsensusSecs"
  },
  {
    "objectID": "/rsh/compute/#basewaittime--and--basewaitsecs",
    "pt": "Computations",
    "t": 2,
    "c": "baseWaitTime and baseWaitSecs"
  },
  {
    "objectID": "/rsh/compute/#time-arguments----relativetime---absolutetime---relativesecs---absolutesecs",
    "pt": "Computations",
    "t": 2,
    "c": "Time arguments - relativeTime, absoluteTime, relativeSecs, absoluteSecs"
  },
  {
    "objectID": "/rsh/compute/#time-verification----verifyrelativetime---verifyabsolutetime---verifyrelativesecs---verifyabsolutesecs",
    "pt": "Computations",
    "t": 2,
    "c": "Time verification - verifyRelativeTime, verifyAbsoluteTime, verifyRelativeSecs, verifyAbsoluteSecs"
  },
  {
    "objectID": "/rsh/compute/#makedeadline",
    "pt": "Computations",
    "t": 2,
    "c": "makeDeadline"
  },
  {
    "objectID": "/rsh/compute/#implies",
    "pt": "Computations",
    "t": 2,
    "c": "implies"
  },
  {
    "objectID": "/rsh/compute/#ensure",
    "pt": "Computations",
    "t": 2,
    "c": "ensure"
  },
  {
    "objectID": "/rsh/compute/#hasrandom",
    "pt": "Computations",
    "t": 2,
    "c": "hasRandom"
  },
  {
    "objectID": "/rsh/compute/#hasconsolelogger",
    "pt": "Computations",
    "t": 2,
    "c": "hasConsoleLogger"
  },
  {
    "objectID": "/rsh/compute/#compose",
    "pt": "Computations",
    "t": 2,
    "c": "compose"
  },
  {
    "objectID": "/rsh/compute/#muldiv",
    "pt": "Computations",
    "t": 2,
    "c": "muldiv"
  },
  {
    "objectID": "/rsh/compute/#verifymuldiv",
    "pt": "Computations",
    "t": 2,
    "c": "verifyMuldiv"
  },
  {
    "objectID": "/rsh/compute/#sqrt",
    "pt": "Computations",
    "t": 2,
    "c": "sqrt"
  },
  {
    "objectID": "/rsh/compute/#sqrtapprox",
    "pt": "Computations",
    "t": 2,
    "c": "sqrtApprox"
  },
  {
    "objectID": "/rsh/compute/#pow",
    "pt": "Computations",
    "t": 2,
    "c": "pow"
  },
  {
    "objectID": "/rsh/compute/#signed-integers",
    "pt": "Computations",
    "t": 2,
    "c": "Signed Integers"
  },
  {
    "objectID": "/rsh/compute/#fixed-point-numbers",
    "pt": "Computations",
    "t": 2,
    "c": "Fixed-Point Numbers"
  },
  {
    "objectID": "/rsh/compute/#anybody",
    "pt": "Computations",
    "t": 2,
    "c": "Anybody"
  },
  {
    "objectID": "/rsh/compute/#intervals",
    "pt": "Computations",
    "t": 2,
    "c": "Intervals"
  },
  {
    "objectID": "/rsh/compute/#constructors",
    "pt": "Computations",
    "t": 2,
    "c": "Constructors"
  },
  {
    "objectID": "/rsh/compute/#accessors",
    "pt": "Computations",
    "t": 2,
    "c": "Accessors"
  },
  {
    "objectID": "/rsh/compute/#relational-operations",
    "pt": "Computations",
    "t": 2,
    "c": "Relational Operations"
  },
  {
    "objectID": "/rsh/compute/#arithmetic-operations",
    "pt": "Computations",
    "t": 2,
    "c": "Arithmetic Operations"
  },
  {
    "objectID": "/rsh/compute/#other-operations",
    "pt": "Computations",
    "t": 2,
    "c": "Other Operations"
  },
  {
    "objectID": "/rsh/compute/#getuntrackedfunds",
    "pt": "Computations",
    "t": 2,
    "c": "getUntrackedFunds"
  },
  {
    "objectID": "/rsh/compute/#distinct",
    "pt": "Computations",
    "t": 2,
    "c": "distinct"
  },
  {
    "objectID": "/rsh/compute/#p_0",
    "pt": "Computations",
    "t": 3,
    "c": "This section describes the common features available in all Reach contexts."
  },
  {
    "objectID": "/rsh/compute/#p_1",
    "pt": "Computations",
    "t": 3,
    "c": "Comments are text that is ignored by the compiler. Text starting with // up until the end of the line forms a single-line comment. Text enclosed with /* and */ forms a multi-line comment. It is invalid to nest a multi-line comment within a multi-line comment."
  },
  {
    "objectID": "/rsh/compute/#p_2",
    "pt": "Computations",
    "t": 3,
    "c": "A block is a sequence of statements surrounded by braces, i.e. { and }."
  },
  {
    "objectID": "/rsh/compute/#p_3",
    "pt": "Computations",
    "t": 3,
    "c": "This section describes the statements which are allowed in any Reach context."
  },
  {
    "objectID": "/rsh/compute/#p_4",
    "pt": "Computations",
    "t": 3,
    "c": "Each statement affects the meaning of the subsequent statements, which is called its tail. For example, if {!rsh} {X; Y; Z;} is a block, then {!rsh} X's tail is {!rsh} {Y; Z;} and {!rsh} Y's tail is {!rsh} {Z;}."
  },
  {
    "objectID": "/rsh/compute/#p_5",
    "pt": "Computations",
    "t": 3,
    "c": "Distinct from tails are continuations which include everything after the statement. For example, in {!rsh} { {X; Y;}; Z;}, {!rsh} X's tail is just {!rsh} Y, but its continuation is {!rsh} {Y;}; Z;."
  },
  {
    "objectID": "/rsh/compute/#p_6",
    "pt": "Computations",
    "t": 3,
    "c": "Tails are statically apparent from the structure of the program source code, while continuations are influenced by function calls."
  },
  {
    "objectID": "/rsh/compute/#p_7",
    "pt": "Computations",
    "t": 3,
    "c": "A sequence of statements that does not end in a terminator statement (a statement with no tail), such as a return statement, continue statement, or exit statement is treated as if it ended with {!rsh} return null;."
  },
  {
    "objectID": "/rsh/compute/#p_8",
    "pt": "Computations",
    "t": 3,
    "c": "The remainder of this section enumerates each kind of statement."
  },
  {
    "objectID": "/rsh/compute/#p_9",
    "pt": "Computations",
    "t": 3,
    "c": "An identifier definition is either a value definition or a function definition. Each of these introduces one or more bound identifiers."
  },
  {
    "objectID": "/rsh/compute/#p_10",
    "pt": "Computations",
    "t": 3,
    "c": "Valid identifiers follow the same rules as JavaScript identifiers: they may consist of Unicode alphanumeric characters, or {!rsh} _ or {!rsh} $, but may not begin with a digit."
  },
  {
    "objectID": "/rsh/compute/#p_11",
    "pt": "Computations",
    "t": 3,
    "c": "A value definition is written {!rsh} const LHS = RHS;."
  },
  {
    "objectID": "/rsh/compute/#p_12",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} LHS must obey the grammar:"
  },
  {
    "objectID": "/rsh/compute/#p_13",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} RHS must be compatible with the given {!rsh} LHS. That is, if a {!rsh} LHS is an LHS-tuple-seq, then the corresponding {!rsh} RHS must be a tuple with the correct number of elements. If a {!rsh} LHS is an LHS-obj-seq, then the corresponding {!rsh} RHS must be an object with the correct fields."
  },
  {
    "objectID": "/rsh/compute/#p_14",
    "pt": "Computations",
    "t": 3,
    "c": "Those values are available as their corresponding bound identifiers in the statement's tail."
  },
  {
    "objectID": "/rsh/compute/#p_15",
    "pt": "Computations",
    "t": 3,
    "c": "A function definition, written {!rsh} function FUN(LHS_0, ..., LHS_n) BLOCK;, defines {!rsh} FUN as a function which abstracts its function body, the block {!rsh} BLOCK, over the left-hand sides {!rsh} LHS_0 through {!rsh} LHS_n."
  },
  {
    "objectID": "/rsh/compute/#p_16",
    "pt": "Computations",
    "t": 3,
    "c": "Function parameters may specify default arguments. The expressions used to instantiate these parameters have access to any variables in the scope of which the function was defined. Additionally, these expressions may reference previous arguments of the function definition. Parameters with default arguments must come after all other parameters."
  },
  {
    "objectID": "/rsh/compute/#p_17",
    "pt": "Computations",
    "t": 3,
    "c": "The last parameter of a function may be a rest parameter, which allows the function to be called with an arbitrary number of arguments. A rest parameter is specified via {!rsh} ...IDENT, where {!rsh} IDENT is bound to a {!rsh} Tuple containing all the remaining arguments."
  },
  {
    "objectID": "/rsh/compute/#p_18",
    "pt": "Computations",
    "t": 3,
    "c": "All identifiers in Reach programs must be unbound at the position of the program where they are bound, i.e., it is invalid to shadow identifiers with new definitions. For example,"
  },
  {
    "objectID": "/rsh/compute/#p_19",
    "pt": "Computations",
    "t": 3,
    "c": "is invalid. This restriction is independent of whether a binding is only known to a single participant. For example,"
  },
  {
    "objectID": "/rsh/compute/#p_20",
    "pt": "Computations",
    "t": 3,
    "c": "is invalid."
  },
  {
    "objectID": "/rsh/compute/#p_21",
    "pt": "Computations",
    "t": 3,
    "c": "The special identifier {!rsh} _ is an exception to this rule. The {!rsh} _ binding is always considered to be unbound. This means means that {!rsh} _ is both an identifier that can never be read, as well as an identifier that may be bound many times. This may be useful for ignoring unwanted values, for example:"
  },
  {
    "objectID": "/rsh/compute/#p_22",
    "pt": "Computations",
    "t": 3,
    "c": "A return statement, written {!rsh} return EXPR;, where {!rsh} EXPR is an expression, evaluates to the same value as {!rsh} EXPR. As a special case, {!rsh} return; is interpreted the same as {!rsh} return null;."
  },
  {
    "objectID": "/rsh/compute/#p_23",
    "pt": "Computations",
    "t": 3,
    "c": "A return statement returns its value to the surrounding function application."
  },
  {
    "objectID": "/rsh/compute/#p_24",
    "pt": "Computations",
    "t": 3,
    "c": "A return statement is a terminator statement, so it must have an empty tail. For example,"
  },
  {
    "objectID": "/rsh/compute/#p_25",
    "pt": "Computations",
    "t": 3,
    "c": "is invalid, because the first {!rsh} return's tail is not empty."
  },
  {
    "objectID": "/rsh/compute/#p_26",
    "pt": "Computations",
    "t": 3,
    "c": "Furthermore, a {!rsh} return must have an empty continuation (i.e. it must be in tail position.)"
  },
  {
    "objectID": "/rsh/compute/#p_27",
    "pt": "Computations",
    "t": 3,
    "c": "A conditional statement, written {!rsh} if (COND) NOT_FALSE else FALSE, where {!rsh} COND is an expression and {!rsh} NOT_FALSE and {!rsh} FALSE as statements (potentially block statements), selects between the {!rsh} NOT_FALSE statement and {!rsh} FALSE statement based on whether {!rsh} COND evaluates to {!rsh} false."
  },
  {
    "objectID": "/rsh/compute/#p_28",
    "pt": "Computations",
    "t": 3,
    "c": "Both {!rsh} NOT_FALSE and {!rsh} FALSE have empty tails, i.e. the tail of the conditional statement is not propagated. For example,"
  },
  {
    "objectID": "/rsh/compute/#p_29",
    "pt": "Computations",
    "t": 3,
    "c": "is erroneous, because the identifier {!rsh} z is not bound outside the conditional statement."
  },
  {
    "objectID": "/rsh/compute/#p_30",
    "pt": "Computations",
    "t": 3,
    "c": "A conditional statement may only include a consensus transfer in {!rsh} NOT_FALSE or {!rsh} FALSE if it is within a consensus step, because its statements are in the same context as the conditional statement itself."
  },
  {
    "objectID": "/rsh/compute/#p_31",
    "pt": "Computations",
    "t": 3,
    "c": "If one branch of a conditional contains a {!rsh} return, then both must."
  },
  {
    "objectID": "/rsh/compute/#p_32",
    "pt": "Computations",
    "t": 3,
    "c": "A switch statement, written {!rsh} switch (VAR) { CASE ... }, where {!rsh} VAR is a variable bound to a data instance and {!rsh} CASE is either {!rsh} case VARIANT: STMT ..., where {!rsh} VARIANT is a variant, or {!rsh} default: STMT ..., and {!rsh} STMT is a sequence of statements, selects the appropriate sequence of statements based on which variant {!rsh} VAR holds. Within the body of a {!rsh} switch case, {!rsh} VAR has the type of variant; i.e. in a {!rsh} Some case of a {!rsh} Maybe(UInt) {!rsh} switch, the variable is bound to an integer."
  },
  {
    "objectID": "/rsh/compute/#p_33",
    "pt": "Computations",
    "t": 3,
    "c": "All cases have empty tails, i.e. the tail of the switch statement is not propagated."
  },
  {
    "objectID": "/rsh/compute/#p_34",
    "pt": "Computations",
    "t": 3,
    "c": "A switch statement may only include a consensus transfer in its cases if it is within a consensus step, because its statements are in the same context as the conditional statement itself."
  },
  {
    "objectID": "/rsh/compute/#p_35",
    "pt": "Computations",
    "t": 3,
    "c": "It is invalid for a case to appear multiple times, or be missing, or to be superfluous (i.e. for a variant that does not exist in the {!rsh} Data type of {!rsh} VAR)."
  },
  {
    "objectID": "/rsh/compute/#p_36",
    "pt": "Computations",
    "t": 3,
    "c": "If one case of a {!rsh} switch contains a {!rsh} return, then all must."
  },
  {
    "objectID": "/rsh/compute/#p_37",
    "pt": "Computations",
    "t": 3,
    "c": "A block statement is when a block occurs in a statement position, then it establishes a local, separate scope for the definitions of identifiers within that block. In other words, the block is evaluated for effect, but the tail of the statements within the block are isolated from the surrounding tail. For example,"
  },
  {
    "objectID": "/rsh/compute/#p_38",
    "pt": "Computations",
    "t": 3,
    "c": "evaluates to {!rsh} 4, but"
  },
  {
    "objectID": "/rsh/compute/#p_39",
    "pt": "Computations",
    "t": 3,
    "c": "is erroneous, because the identifier {!rsh} x is not bound outside the block statement."
  },
  {
    "objectID": "/rsh/compute/#p_40",
    "pt": "Computations",
    "t": 3,
    "c": "A try statement, written {!rsh} try BLOCK catch (VAR) BLOCK, allows a block of code to execute with a specified handler should an exception be thrown."
  },
  {
    "objectID": "/rsh/compute/#p_41",
    "pt": "Computations",
    "t": 3,
    "c": "A throw statement, written {!rsh} throw EXPR, will transfer control flow to the exception handler, binding EXPR to VAR. Any value that is able to exist at runtime may be thrown. For example, {!rsh} Ints and {!rsh} Arrays are valid values to throw, but a function is not. A {!rsh} throw must have an empty tail."
  },
  {
    "objectID": "/rsh/compute/#p_42",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} 'use strict' enables unused variables checks for all subsequent declarations within the current scope. If a variable is declared, but never used, there will be an error emitted at compile time."
  },
  {
    "objectID": "/rsh/compute/#p_43",
    "pt": "Computations",
    "t": 3,
    "c": "strict mode will reject some code that is normally valid and limit how dynamic Reach's type system is. For example, normally Reach will permit expressions like the following to be evaluated:"
  },
  {
    "objectID": "/rsh/compute/#p_44",
    "pt": "Computations",
    "t": 3,
    "c": "Reach allows {!rsh} o to be either an object with a {!rsh} b field or {!rsh} false because it partially evaluates the program at compile time. So, without {!rsh} 'use strict', Reach will not evaluate {!rsh} o.b when {!rsh} o = false and this code will compile successfully."
  },
  {
    "objectID": "/rsh/compute/#p_45",
    "pt": "Computations",
    "t": 3,
    "c": "But, in strict mode, Reach will ensure that this program treats {!rsh} o as having a single type and detect an error in the program as follows:"
  },
  {
    "objectID": "/rsh/compute/#p_46",
    "pt": "Computations",
    "t": 3,
    "c": "The correct way to write a program like this in strict mode is to use {!rsh} Maybe. Like this:"
  },
  {
    "objectID": "/rsh/compute/#p_47",
    "pt": "Computations",
    "t": 3,
    "c": "An expression, {!rsh} E, in a statement position is equivalent to the block statement {!rsh} { return E; }."
  },
  {
    "objectID": "/rsh/compute/#p_48",
    "pt": "Computations",
    "t": 3,
    "c": "This section describes the expressions which are allowed in any Reach context. There are a large variety of different expressions in Reach programs."
  },
  {
    "objectID": "/rsh/compute/#p_49",
    "pt": "Computations",
    "t": 3,
    "c": "The remainder of this section enumerates each kind of expression."
  },
  {
    "objectID": "/rsh/compute/#p_50",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} unstrict applies a thunk, ignoring any usage of strict mode. This can be useful when dealing with libraries that are written in strict mode."
  },
  {
    "objectID": "/rsh/compute/#p_51",
    "pt": "Computations",
    "t": 3,
    "c": "An identifier, written {!rsh} ID, is an expression that evaluates to the value of the bound identifier."
  },
  {
    "objectID": "/rsh/compute/#p_52",
    "pt": "Computations",
    "t": 3,
    "c": "The identifier {!rsh} this has a special meaning inside of a local step (i.e. the body of an {!rsh} only or {!rsh} each expression), as well as in a consensus step (i.e. the tail of {!rsh} publish or {!rsh} pay statement and before a {!rsh} commit statement). For details, see this and this."
  },
  {
    "objectID": "/rsh/compute/#p_53",
    "pt": "Computations",
    "t": 3,
    "c": "A function application, written {!rsh} EXPR_rator(EXPR_rand_0, ..., EXPR_rand_n), is an expression where {!rsh} EXPR_rator and {!rsh} EXPR_rand_0 through {!rsh} EXPR_rand_n are expressions that evaluate to one value. {!rsh} EXPR_rator must evaluate to an abstraction over {!rsh} n values or a primitive of arity {!rsh} n. A spread expression ({!rsh} ...expr) may appear in the list of operands to a function application, in which case the elements of the expr are spliced in place. {!rsh} EXPR_rator and {!rsh} EXPR_rand_n are evaluated in left-to-right order, starting with {!rsh} EXPR_rator, then {!rsh} EXPR_rand_0, {!rsh} EXPR_rand_1, etc."
  },
  {
    "objectID": "/rsh/compute/#p_54",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} new f(a) is equivalent to {!rsh} f.new(a) and is a convenient short-hand for writing class-oriented programs."
  },
  {
    "objectID": "/rsh/compute/#p_55",
    "pt": "Computations",
    "t": 3,
    "c": "Reach's types are represented in programs by the following identifiers and constructors:"
  },
  {
    "objectID": "/rsh/compute/#p_56",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Null."
  },
  {
    "objectID": "/rsh/compute/#p_57",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Bool, which denotes a boolean."
  },
  {
    "objectID": "/rsh/compute/#p_58",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} UInt, which denotes an unsigned integer. {!rsh} UInt.max is the largest value that may be assigned to a {!rsh} UInt."
  },
  {
    "objectID": "/rsh/compute/#p_59",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} UInt256, which denotes an unsigned integer with 256 bits. {!rsh} UInt256.max is the largest value that may be assigned to a {!rsh} UInt256."
  },
  {
    "objectID": "/rsh/compute/#p_60",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Int, which denotes a signed integer."
  },
  {
    "objectID": "/rsh/compute/#p_61",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} FixedPoint, which denotes a fractional number."
  },
  {
    "objectID": "/rsh/compute/#p_62",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Bytes(length), which denotes a string of bytes of length at most {!rsh} length. Bytes of different lengths are not compatible; however the shorter bytes may be padded."
  },
  {
    "objectID": "/rsh/compute/#p_63",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Digest, which denotes a digest."
  },
  {
    "objectID": "/rsh/compute/#p_64",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Address, which denotes an account address."
  },
  {
    "objectID": "/rsh/compute/#p_65",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Contract, which denotes the identifying information of a contract."
  },
  {
    "objectID": "/rsh/compute/#p_66",
    "pt": "Computations",
    "t": 3,
    "c": "Reach has different representations of contracts across connectors. For example, on Algorand a {!rsh} Contract is an Application ID, but on Ethereum it is an Address."
  },
  {
    "objectID": "/rsh/compute/#p_67",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Token, which denotes a non-network token. Networks discusses how {!rsh} Tokens are represented on specific networks."
  },
  {
    "objectID": "/rsh/compute/#p_68",
    "pt": "Computations",
    "t": 3,
    "c": "Reach assumes that every {!rsh} Token in your program refers to a different non-network token. It will automatically insert {!rsh} require statements that enforce this constraint."
  },
  {
    "objectID": "/rsh/compute/#p_69",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Fun([Domain_0, ..., Domain_N], Range), which denotes a function type, when {!rsh} Domain_i and {!rsh} Range are types. The domain of a function is negative position. The range of a function is positive position."
  },
  {
    "objectID": "/rsh/compute/#p_70",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Fun(true, Range), which denotes an unconstrained domain function type, when {!rsh} Range is a type. These functions may only appear in participant interact interfaces."
  },
  {
    "objectID": "/rsh/compute/#p_71",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Tuple(Field_0, ..., FieldN), which denotes a tuple. (Refer to Tuples for constructing tuples.)"
  },
  {
    "objectID": "/rsh/compute/#p_72",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Object({key_0: Type_0, ..., key_N: Type_N}), which denotes an object. (Refer to Objects for constructing objects.)"
  },
  {
    "objectID": "/rsh/compute/#p_73",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Struct([[key_0, Type_0], ..., [key_N, Type_N]]), which denotes a struct. (Refer to Structs for constructing structs.)"
  },
  {
    "objectID": "/rsh/compute/#p_74",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array(Type_0, size), which denotes a statically-sized array. {!rsh} Type_0 must be a type that can exist at runtime (i.e., not a function type.) (Refer to Arrays for constructing arrays.)"
  },
  {
    "objectID": "/rsh/compute/#p_75",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Data({variant_0: Type_0, ..., variant_N: Type_N}), which denotes a tagged union (or sum type). (Refer to Data for constructing data instances.)"
  },
  {
    "objectID": "/rsh/compute/#p_76",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Refine(Type_0, Predicate, ?Message), where {!rsh} Predicate is a unary function returning a boolean, which denotes a refinement type, that is instances of {!rsh} Type_0 that satisfy {!rsh} Predicate. When a refinement type appears in a negative position (such as in an {!rsh} is or in the domain of a {!rsh} Fun of a participant interact interface), it introduces an {!rsh} assert; while when it is in a positive position, it introduces an {!rsh} assume. {!rsh} Message is an optional string to display if the predicate fails verification."
  },
  {
    "objectID": "/rsh/compute/#p_77",
    "pt": "Computations",
    "t": 3,
    "c": "For example, if {!rsh} f had type"
  },
  {
    "objectID": "/rsh/compute/#p_78",
    "pt": "Computations",
    "t": 3,
    "c": "then {!rsh} const z = f(y) is equivalent to"
  },
  {
    "objectID": "/rsh/compute/#p_79",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Refine(Type_0, PreCondition, PostCondition, ?Messages), where {!rsh} Type_0 is a function type, {!rsh} PreCondition is a unary function that accepts a tuple of the domain and returns a boolean, and {!rsh} PostCondition is a binary function that accepts a tuple of the domain and the range and returns a boolean, denotes a function type with a precondition and postcondition. Preconditions are enforced with {!rsh} assert and postconditions are enforced with {!rsh} assume. {!rsh} Messages is an optional two-tuple of {!rsh} Bytes. The first message will be displayed when the precondition fails verification and the second when the postcondition fails verification."
  },
  {
    "objectID": "/rsh/compute/#p_80",
    "pt": "Computations",
    "t": 3,
    "c": "For example, {!rsh} Refine(Fun([UInt, UInt], UInt), ([x, y] => x < y), (([x, y], z) => x + y < z)) is a function that requires its second argument to be larger than its first and its result to be larger than its input."
  },
  {
    "objectID": "/rsh/compute/#p_81",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Object and {!rsh} Data are commonly used to implemented algebraic data types in Reach."
  },
  {
    "objectID": "/rsh/compute/#p_82",
    "pt": "Computations",
    "t": 3,
    "c": "The {!rsh} typeOf primitive function is the same as {!rsh} typeof: it returns the type of its argument."
  },
  {
    "objectID": "/rsh/compute/#p_83",
    "pt": "Computations",
    "t": 3,
    "c": "The {!rsh} isType function returns {!rsh} true if its argument is a type. Any expression satisfying {!rsh} isType is compiled away and does not exist at runtime."
  },
  {
    "objectID": "/rsh/compute/#p_84",
    "pt": "Computations",
    "t": 3,
    "c": "The {!rsh} is function returns its first argument if it satisfies the type specified by the second argument. If it is not, then the program is invalid. For example, {!rsh} is(5, UInt) returns {!rsh} 5, while {!rsh} is(5, Bool) is an invalid program. The value returned by {!rsh} is may not be identical to the input, because in some cases, such as for functions, it will record the applied to type and enforce it on future invocations. These applications are considered negative positions for {!rsh} Refine."
  },
  {
    "objectID": "/rsh/compute/#p_85",
    "pt": "Computations",
    "t": 3,
    "c": "A literal value, written {!rsh} VALUE, is an expression that evaluates to the given value."
  },
  {
    "objectID": "/rsh/compute/#p_86",
    "pt": "Computations",
    "t": 3,
    "c": "The null literal may be written as {!rsh} null."
  },
  {
    "objectID": "/rsh/compute/#p_87",
    "pt": "Computations",
    "t": 3,
    "c": "Numeric literals may be written in decimal, hexadecimal, or octal. They may not be written with scientific (exponential) notation. Numeric literals must obey the bit width of {!rsh} UInt if they are used as {!rsh} UInt values at runtime, but if they only appear at compile-time, then they may be any positive number. Reach provides abstractions for working with {!rsh} Ints and signed {!rsh} FixedPoint numbers. {!rsh} Ints may be defined by applying the unary {!rsh} + and {!rsh} - operators to values of type {!rsh} UInt. Reach provides syntactic sugar for defining signed {!rsh} FixedPoint numbers, in base 10, with decimal syntax. Numeric literals may contain underscore separators as a visual aid (e.g. {!rsh} 123_456 is the same as {!rsh} 123456)."
  },
  {
    "objectID": "/rsh/compute/#p_88",
    "pt": "Computations",
    "t": 3,
    "c": "Boolean literals may be written as {!rsh} true or {!rsh} false."
  },
  {
    "objectID": "/rsh/compute/#p_89",
    "pt": "Computations",
    "t": 3,
    "c": "String literals (aka byte strings) may be written between double or single quotes (with no distinction between the different styles) and use the same escaping rules as JavaScript. Since {!rsh} Bytes types are specialized in their length, literals typically need to be padded to be useful."
  },
  {
    "objectID": "/rsh/compute/#p_90",
    "pt": "Computations",
    "t": 3,
    "c": "An operator is a special identifier, which is either a unary operator, or a binary operator."
  },
  {
    "objectID": "/rsh/compute/#p_91",
    "pt": "Computations",
    "t": 3,
    "c": "A unary expression, written {!rsh} UNAOP EXPR_rhs, where {!rsh} EXPR_rhs is an expression and {!rsh} UNAOP is one of the unary operators: ! - + typeof void. All the unary operators, besides {!rsh} typeof, have a corresponding named version in the standard library."
  },
  {
    "objectID": "/rsh/compute/#p_92",
    "pt": "Computations",
    "t": 3,
    "c": "It is invalid to use unary operations on the wrong types of values."
  },
  {
    "objectID": "/rsh/compute/#p_93",
    "pt": "Computations",
    "t": 3,
    "c": "When applied to values of type {!rsh} UInt, unary {!rsh} - and {!rsh} + operators will cast their arguments to type {!rsh} Int. The unary {!rsh} - and {!rsh} + operations are defined for values of type: {!rsh} Int, and {!rsh} FixedPoint."
  },
  {
    "objectID": "/rsh/compute/#p_94",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} void a evaluates to {!rsh} null for all arguments."
  },
  {
    "objectID": "/rsh/compute/#p_95",
    "pt": "Computations",
    "t": 3,
    "c": "Bitwise operations are not supported by all consensus networks and greatly decrease the efficiency of verification."
  },
  {
    "objectID": "/rsh/compute/#p_96",
    "pt": "Computations",
    "t": 3,
    "c": "A binary expression is written {!rsh} EXPR_lhs BINOP EXPR_rhs, where {!rsh} EXPR_lhs and {!rsh} EXPR_rhs are expressions and {!rsh} BINOP is one of the binary operators: && || + - * / % | & ^ << >> == != === !== > >= <= <. Numeric operations, like {!rsh} + and {!rsh} >, only operate on numbers. Since all numbers in Reach are integers, operations like {!rsh} / truncate their result. Boolean operations, like {!rsh} &&, only operate on booleans. {!rsh} xor operates on {!rsh} UInts, {!rsh} UInt256s, {!rsh} Bools, {!rsh} Digests, and {!rsh} Bytes of the same length. {!rsh} polyMod operates on {!rsh} UInts and {!rsh} UInt256. The first argument may be a {!rsh} Digest or {!rsh} Bytes. It is invalid to use binary operations on the wrong types of values."
  },
  {
    "objectID": "/rsh/compute/#p_97",
    "pt": "Computations",
    "t": 3,
    "c": "All binary expression operators have a corresponding named function in the standard library. While {!rsh} && and {!rsh} || may not evaluate their second argument, their corresponding named functions {!rsh} and, {!rsh} or, and {!rsh} xor, always do."
  },
  {
    "objectID": "/rsh/compute/#p_98",
    "pt": "Computations",
    "t": 3,
    "c": "Equality functions, like {!rsh} ==, {!rsh} ===, {!rsh} !=, and {!rsh} !==, operate on all types. However, values with different types are always not equal. Both arguments must be of the same type. Specialized functions exist for equality checking on each supported type."
  },
  {
    "objectID": "/rsh/compute/#p_99",
    "pt": "Computations",
    "t": 3,
    "c": "If {!rsh} verifyArithmetic is {!rsh} true, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks. If it is {!rsh} false, then the connector will ensure this dynamically."
  },
  {
    "objectID": "/rsh/compute/#p_100",
    "pt": "Computations",
    "t": 3,
    "c": "Reach has different unsigned integer types, {!rsh} UInt and {!rsh} UInt256. These values can be casted from one to the other by calling the type as a function with a value."
  },
  {
    "objectID": "/rsh/compute/#p_101",
    "pt": "Computations",
    "t": 3,
    "c": "For example, if x is a {!rsh} UInt, then {!rsh} UInt256(x) is x zero-extended to 256 bits. This is demonstrated in the code below:"
  },
  {
    "objectID": "/rsh/compute/#p_102",
    "pt": "Computations",
    "t": 3,
    "c": "However, if y is a {!rsh} UInt256, then {!rsh} UInt(y) is y with as many bits as {!rsh} UInt has. This is demonstrated in the code below:"
  },
  {
    "objectID": "/rsh/compute/#p_103",
    "pt": "Computations",
    "t": 3,
    "c": "In the second case above, where {!rsh} UInt256 is casted to {!rsh} UInt, if {!rsh} UInt256 has any non-zero bits that would be lost by the truncation, then the cast will fail at runtime. This is guaranteed to not happen when you compile with {!rsh} verifyArithmetic."
  },
  {
    "objectID": "/rsh/compute/#p_104",
    "pt": "Computations",
    "t": 3,
    "c": "If you wish to explicitly truncate a {!rsh} UInt* type into a smaller size, you can pass a second, {!rsh} Bool argument to the cast call. Passing {!rsh} true truncates the number. Passing {!rsh} false causes the cast to fail, as describe above. This is the default behavior."
  },
  {
    "objectID": "/rsh/compute/#p_105",
    "pt": "Computations",
    "t": 3,
    "c": "Numeric literals in your program are considered {!rsh} UInt. If they are cast to {!rsh} UInt256, then your program can contain constant {!rsh} UInt256 values."
  },
  {
    "objectID": "/rsh/compute/#p_106",
    "pt": "Computations",
    "t": 3,
    "c": "Although {!rsh} Contract and {!rsh} Address are not necessarily the same type, they often have a connection. {!rsh} Contract.addressEq(ctc, addr) returns a boolean that is {!rsh} true if {!rsh} ctc refers to the same contract as {!rsh} addr."
  },
  {
    "objectID": "/rsh/compute/#p_107",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} boolXor(Bool, Bool) returns {!rsh} true only when the inputs differ in value. This function is specialized to {!rsh} Bools; {!rsh} xor supports more types."
  },
  {
    "objectID": "/rsh/compute/#p_108",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Bytes are like {!rsh} Arrays in that they are fixed and exactly sized. This means that two {!rsh} Bytes of different lengths are not interchangeable."
  },
  {
    "objectID": "/rsh/compute/#p_109",
    "pt": "Computations",
    "t": 3,
    "c": "For example, {!rsh} 'You win!' and {!rsh} 'You lose!' cannot both be provided to an {!rsh} interact function, because the second is one character longer. Most of the time this is good, because it is a signal that you should use a {!rsh} Data type instead, so that the formatting and display logic is entirely controlled by the frontend."
  },
  {
    "objectID": "/rsh/compute/#p_110",
    "pt": "Computations",
    "t": 3,
    "c": "But, sometimes it is necessary and useful to extend one byte string into a larger size. Each {!rsh} Bytes type has a pad field that is bound to a function that extends its argument to the needed size. A byte string extended in this way is called padded, because it is extended with additional NUL bytes at the end of the string."
  },
  {
    "objectID": "/rsh/compute/#p_111",
    "pt": "Computations",
    "t": 3,
    "c": "The code below shows how {!rsh} Padding can be done:"
  },
  {
    "objectID": "/rsh/compute/#p_112",
    "pt": "Computations",
    "t": 3,
    "c": "An expression may be parenthesized, as in {!rsh} (EXPR)."
  },
  {
    "objectID": "/rsh/compute/#p_113",
    "pt": "Computations",
    "t": 3,
    "c": "A tuple literal, written {!rsh} [ EXPR_0, ..., EXPR_n ], is an expression which evaluates to a tuple of {!rsh} n values, where {!rsh} EXPR_0 through {!rsh} EXPR_n are expressions."
  },
  {
    "objectID": "/rsh/compute/#p_114",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} ...expr may appear inside tuple expressions, in which case the spreaded expression must evaluate to a tuple or array, which is spliced in place."
  },
  {
    "objectID": "/rsh/compute/#p_115",
    "pt": "Computations",
    "t": 3,
    "c": "Converts a tuple of homogeneous values of the specific type into an array."
  },
  {
    "objectID": "/rsh/compute/#p_116",
    "pt": "Computations",
    "t": 3,
    "c": "A reference, written {!rsh} REF_EXPR[IDX_EXPR], where {!rsh} REF_EXPR is an expression that evaluates to an array, a tuple, an object, or a struct and {!rsh} IDX_EXPR is an expression that evaluates to a natural number which is less than the size of the array, selects the element at the given index of the array. Indices start at zero."
  },
  {
    "objectID": "/rsh/compute/#p_117",
    "pt": "Computations",
    "t": 3,
    "c": "If {!rsh} REF_EXPR is a tuple, then {!rsh} IDX_EXPR must be a compile-time constant, because tuples do not support dynamic access, because each element may be a different type."
  },
  {
    "objectID": "/rsh/compute/#p_118",
    "pt": "Computations",
    "t": 3,
    "c": "If {!rsh} REF_EXPR is a mapping and {!rsh} IDX_EXPR evaluates to an address, then this reference evaluates to a value of type {!rsh} Maybe(TYPE), where {!rsh} TYPE is the type of the mapping."
  },
  {
    "objectID": "/rsh/compute/#p_119",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Tuple.length Returns the length of the given tuple."
  },
  {
    "objectID": "/rsh/compute/#p_120",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.length Returns the length of the given array."
  },
  {
    "objectID": "/rsh/compute/#p_121",
    "pt": "Computations",
    "t": 3,
    "c": "Both may be abbreviated as {!rsh} expr.length where {!rsh} expr evaluates to a tuple or an array."
  },
  {
    "objectID": "/rsh/compute/#p_122",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Tuple.set Returns a new tuple identical to {!rsh} tup, except that index {!rsh} idx is replaced with {!rsh} val. The {!rsh} idx must be a compile-time constant, because tuples do not support dynamic access, because each element may be a different type."
  },
  {
    "objectID": "/rsh/compute/#p_123",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.set Returns a new array identical to {!rsh} arr, except that index {!rsh} idx is replaced with {!rsh} val."
  },
  {
    "objectID": "/rsh/compute/#p_124",
    "pt": "Computations",
    "t": 3,
    "c": "Both may be abbreviated as {!rsh} expr.set(idx, val) where {!rsh} expr evaluates to a tuple or an array."
  },
  {
    "objectID": "/rsh/compute/#p_125",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.elemType Returns the {!rsh} Type of elements that the array contains."
  },
  {
    "objectID": "/rsh/compute/#p_126",
    "pt": "Computations",
    "t": 3,
    "c": "The following methods are available on any {!rsh} Foldable containers, such as: {!rsh} Arrays and {!rsh} Maps."
  },
  {
    "objectID": "/rsh/compute/#p_127",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.forEach(c, f) iterates the function {!rsh} f over the elements of a container {!rsh} c, discarding the result. This may be abbreviated as {!rsh} c.forEach(f)."
  },
  {
    "objectID": "/rsh/compute/#p_128",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.all(c, f) determines whether the predicate, f, is satisfied by every element of the container, c."
  },
  {
    "objectID": "/rsh/compute/#p_129",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.any(c, f) determines whether the predicate, f, is satisfied by at least one element of the container, c."
  },
  {
    "objectID": "/rsh/compute/#p_130",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.or(c) returns the disjunction of a container of {!rsh} Bools."
  },
  {
    "objectID": "/rsh/compute/#p_131",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.and(c) returns the conjunction of a container of {!rsh} Bools."
  },
  {
    "objectID": "/rsh/compute/#p_132",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.includes(c, x) determines whether the container includes the element, x."
  },
  {
    "objectID": "/rsh/compute/#p_133",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.count(c, f) returns the number of elements in c that satisfy the predicate, f."
  },
  {
    "objectID": "/rsh/compute/#p_134",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.size(c) returns the number of elements in c."
  },
  {
    "objectID": "/rsh/compute/#p_135",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.min(c) returns the lowest number in a container of UInts."
  },
  {
    "objectID": "/rsh/compute/#p_136",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.max(c) returns the largest number in a container of UInts."
  },
  {
    "objectID": "/rsh/compute/#p_137",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.sum(c) returns the sum of a container of UInts."
  },
  {
    "objectID": "/rsh/compute/#p_138",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.product(c) returns the product of a container of UInts."
  },
  {
    "objectID": "/rsh/compute/#p_139",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.average(c) returns the mean of a container of UInts. Note that because this uses integer division, the result is effectively truncated."
  },
  {
    "objectID": "/rsh/compute/#p_140",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.imin(c) and {!rsh} Foldable.imax(c) return the minimum and maximum of a container of Ints, respectively."
  },
  {
    "objectID": "/rsh/compute/#p_141",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array is a {!rsh} Foldable container. Along with the methods of {!rsh} Foldable, the following methods may be used with {!rsh} Arrays."
  },
  {
    "objectID": "/rsh/compute/#p_142",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.iota(len) returns an array of length {!rsh} len, where each element is the same as its index. For example, {!rsh} Array.iota(4) returns {!rsh} [0, 1, 2, 3]. The given {!rsh} len must evaluate to an integer at compile-time."
  },
  {
    "objectID": "/rsh/compute/#p_143",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.replicate(len, val) returns an array of length {!rsh} len, where each element is {!rsh} val. For example, {!rsh} Array.replicate(4, \"four\") returns {!rsh} [\"four\", \"four\", \"four\", \"four\"]. The given {!rsh} len must evaluate to an integer at compile-time."
  },
  {
    "objectID": "/rsh/compute/#p_144",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.concat(x, y) concatenates the two arrays {!rsh} x and {!rsh} y. This may be abbreviated as {!rsh} x.concat(y)."
  },
  {
    "objectID": "/rsh/compute/#p_145",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.empty is an array with no elements. It is the identity element of {!rsh} Array.concat. It may also be written {!rsh} Array_empty."
  },
  {
    "objectID": "/rsh/compute/#p_146",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.zip(x, y) returns a new array the same size as {!rsh} x and {!rsh} y (which must be the same size) whose elements are tuples of the elements of {!rsh} x and {!rsh} y. This may be abbreviated as {!rsh} x.zip(y). This function is generalized to an arbitrary number of arrays of the same size."
  },
  {
    "objectID": "/rsh/compute/#p_147",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.map(arr, f) returns a new array, {!rsh} arr_mapped, the same size as {!rsh} arr, where {!rsh} arr_mapped[i] = f(arr[i]) for all {!rsh} i. For example, {!rsh} Array.iota(4).map(x => x+1) returns {!rsh} [1, 2, 3, 4]. This may be abbreviated as {!rsh} arr.map(f)."
  },
  {
    "objectID": "/rsh/compute/#p_148",
    "pt": "Computations",
    "t": 3,
    "c": "This function is generalized to an arbitrary number of arrays of the same size, which are provided before the {!rsh} f argument. For example, {!rsh} Array.iota(4).map(Array.iota(4), add) returns {!rsh} [0, 2, 4, 6]."
  },
  {
    "objectID": "/rsh/compute/#p_149",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.mapWithIndex(arr, f) is similar to {!rsh} Array.map, except it provides {!rsh} f with an additional argument, which is the index of the current element in {!rsh} arr. The index argument is the last argument of the given function {!rsh} f."
  },
  {
    "objectID": "/rsh/compute/#p_150",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.forEachWithIndex(arr, f) is similar to {!rsh} Array.forEach, except it provides {!rsh} f with an additional argument, which is the index of the current element in {!rsh} arr. Unlike {!rsh} Array.forEach, this function is not generalized to an arbitrary number of arrays; it only accepts one array."
  },
  {
    "objectID": "/rsh/compute/#p_151",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.reduce(arr, z, f) returns the left fold of the function {!rsh} f over the given array with the initial value {!rsh} z. For example, {!rsh} Array.iota(4).reduce(0, add) returns {!rsh} ((0 + 1) + 2) + 3 = 6. This may be abbreviated as {!rsh} arr.reduce(z, f)."
  },
  {
    "objectID": "/rsh/compute/#p_152",
    "pt": "Computations",
    "t": 3,
    "c": "This function is generalized to an arbitrary number of arrays of the same size, which are provided before the {!rsh} z argument. For example, {!rsh} Array.iota(4).reduce(Array.iota(4), 0, (x, y, z) => (z + x + y)) returns {!rsh} ((((0 + 0 + 0) + 1 + 1) + 2 + 2) + 3 + 3)."
  },
  {
    "objectID": "/rsh/compute/#p_153",
    "pt": "Computations",
    "t": 3,
    "c": "The supplied function {!rsh} f is in the form {!rsh} (ACCUM, A0_i, A1_i, ...) => BODY. In the example {!rsh} a1.reduce(a2, a3, 0, (accum, v1, v2, v3) => 0), the {!rsh} vN values are drawn from the corresponding {!rsh} aN arrays."
  },
  {
    "objectID": "/rsh/compute/#p_154",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.reduceWithIndex(arr, z, f) is similar to {!rsh} Array.reduce, except it provides {!rsh} f with an additional argument, which is the index of the current element in {!rsh} arr. The index argument is the last argument of the given function {!rsh} f."
  },
  {
    "objectID": "/rsh/compute/#p_155",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.indexOf(arr, x) returns the index of the first element in the given array that is equal to x. The return value is of type {!rsh} Maybe(UInt). If the value is not present in the array, {!rsh} None is returned."
  },
  {
    "objectID": "/rsh/compute/#p_156",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.findIndex(arr, f) returns the index of the first element in the given array that satisfies the predicate f. The return value is of type {!rsh} Maybe(UInt). If no value in the array satisfies the predicate, {!rsh} None is returned."
  },
  {
    "objectID": "/rsh/compute/#p_157",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.find(arr, f) returns the first element in the array, {!rsh} arr, that satisfies the predicate {!rsh} f. The return value is of type {!rsh} Maybe. If no value in the array satisfies the predicate, {!rsh} None is returned."
  },
  {
    "objectID": "/rsh/compute/#p_158",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.withIndex(arr) returns an array where every element of {!rsh} arr is paired with its index. For example, {!rsh} array(Bool, [false, true]).withIndex() returns {!rsh} array(Tuple(Bool, UInt), [[false, 0], [true, 1]])."
  },
  {
    "objectID": "/rsh/compute/#p_159",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.slice(arr, start, length) returns a portion of {!rsh} arr, starting from the {!rsh} start index, up to the {!rsh} start + length index."
  },
  {
    "objectID": "/rsh/compute/#p_160",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Map is a {!rsh} Foldable container. Mappings may be aggregated with the following operations and those of {!rsh} Foldable within the {!rsh} invariant of a {!rsh} while loop."
  },
  {
    "objectID": "/rsh/compute/#p_161",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Map.reduce(map, z, f) returns the left fold of the function {!rsh} f over the given mapping with the initial value {!rsh} z. For example, {!rsh} m.reduce(0, add) sums the elements of the mapping. This may be abbreviated as {!rsh} map.reduce(z, f)."
  },
  {
    "objectID": "/rsh/compute/#p_162",
    "pt": "Computations",
    "t": 3,
    "c": "The function {!rsh} f must satisfy the property, for all {!rsh} z, {!rsh} a, {!rsh} b, {!rsh} f(f(z, b), a) == f(f(z, a), b), because the order of evaluation is unpredictable."
  },
  {
    "objectID": "/rsh/compute/#p_163",
    "pt": "Computations",
    "t": 3,
    "c": "An object, typically written {!rsh} { KEY_0: EXPR_0, ..., KEY_n: EXPR_n }, where {!rsh} KEY_0 through {!rsh} KEY_n are identifiers or string literals and {!rsh} EXPR_0 through {!rsh} EXPR_n are expressions, is an expression which evaluates to an object with fields {!rsh} KEY_0 through {!rsh} KEY_n."
  },
  {
    "objectID": "/rsh/compute/#p_164",
    "pt": "Computations",
    "t": 3,
    "c": "Additional object literal syntax exists for convenience, such as:"
  },
  {
    "objectID": "/rsh/compute/#p_165",
    "pt": "Computations",
    "t": 3,
    "c": "An object splice, where all fields from {!rsh} obj are copied into the object; these fields may be accompanied by additional fields specified afterwards."
  },
  {
    "objectID": "/rsh/compute/#p_166",
    "pt": "Computations",
    "t": 3,
    "c": "Shorthand for {!rsh} { x: x, z: 5}, where {!rsh} x is any bound identifier."
  },
  {
    "objectID": "/rsh/compute/#p_167",
    "pt": "Computations",
    "t": 3,
    "c": "A struct is a combination of a tuple and an object. It has named elements, like an object, but is ordered like a tuple, so its elements may be accessed by either name or position. Structs exist for interfacing with non-Reach remote objects, where both parties must agree to the runtime representation of the values."
  },
  {
    "objectID": "/rsh/compute/#p_168",
    "pt": "Computations",
    "t": 3,
    "c": "A struct instance may be constructed by calling the {!rsh} fromTuple method of a struct type instance (like {!rsh} Posn) with a tuple of the appropriate length."
  },
  {
    "objectID": "/rsh/compute/#p_169",
    "pt": "Computations",
    "t": 3,
    "c": "A struct instance may be constructed by calling the {!rsh} fromObject method of a struct type instance (like {!rsh} Posn) with an object with the appropriate fields."
  },
  {
    "objectID": "/rsh/compute/#p_170",
    "pt": "Computations",
    "t": 3,
    "c": "Structs may be converted into a corresponding tuple or object via the {!rsh} toTuple and {!rsh} toObject methods on the {!rsh} Struct value (as well as struct type instances, like {!rsh} Posn in the example above):"
  },
  {
    "objectID": "/rsh/compute/#p_171",
    "pt": "Computations",
    "t": 3,
    "c": "The names of elements may be restricted to avoid conflicting with reserved words of the specified connectors."
  },
  {
    "objectID": "/rsh/compute/#p_172",
    "pt": "Computations",
    "t": 3,
    "c": "An object reference, written {!rsh} OBJ.FIELD, where {!rsh} OBJ is an expression that evaluates to an object or a struct, and {!rsh} FIELD is a valid identifier, accesses the FIELD field of object OBJ."
  },
  {
    "objectID": "/rsh/compute/#p_173",
    "pt": "Computations",
    "t": 3,
    "c": "Returns a new object identical to {!rsh} obj, except that field {!rsh} fld is replaced with {!rsh} val."
  },
  {
    "objectID": "/rsh/compute/#p_174",
    "pt": "Computations",
    "t": 3,
    "c": "Returns a new object identical to {!rsh} obj, except that field {!rsh} fld is {!rsh} val if {!rsh} fld is not already present in {!rsh} obj."
  },
  {
    "objectID": "/rsh/compute/#p_175",
    "pt": "Computations",
    "t": 3,
    "c": "Returns a boolean indicating whether the object has the field {!rsh} fld. This is statically known."
  },
  {
    "objectID": "/rsh/compute/#p_176",
    "pt": "Computations",
    "t": 3,
    "c": "A data instance is written {!rsh} DATA.VARIANT(VALUE), where {!rsh} DATA is {!rsh} Data type, {!rsh} VARIANT is the name of one of {!rsh} DATA's variants, and {!rsh} VALUE is a value matching the type of the variant. As a special case, when the type of a variant is {!rsh} Null, the {!rsh} VALUE may be omitted, as shown in the definition of {!rsh} burger in the same above."
  },
  {
    "objectID": "/rsh/compute/#p_177",
    "pt": "Computations",
    "t": 3,
    "c": "Data instances are consumed by {!rsh} switch statements and {!rsh} match expressions."
  },
  {
    "objectID": "/rsh/compute/#p_178",
    "pt": "Computations",
    "t": 3,
    "c": "Option types are represented in Reach through the built-in {!rsh} Data type, {!rsh} Maybe, which has two variants: {!rsh} Some and {!rsh} None."
  },
  {
    "objectID": "/rsh/compute/#p_179",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Maybe is defined by"
  },
  {
    "objectID": "/rsh/compute/#p_180",
    "pt": "Computations",
    "t": 3,
    "c": "This means it is a function that returns a {!rsh} Data type specialized to a particular type in the {!rsh} Some variant."
  },
  {
    "objectID": "/rsh/compute/#p_181",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Maybe instances can be conveniently consumed by {!rsh} fromMaybe(mValue, onNone, onSome), where {!rsh} onNone is a function of no arguments which is called when {!rsh} mValue is {!rsh} None, {!rsh} onSome is a function of one argument which is called with the value when {!rsh} mValue is {!rsh} Some, and {!rsh} mValue is a data instance of {!rsh} Maybe."
  },
  {
    "objectID": "/rsh/compute/#p_182",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} isNone is a convenience method that determines whether the variant is {!rsh} None."
  },
  {
    "objectID": "/rsh/compute/#p_183",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} isSome is a convenience method that determines whether the variant is {!rsh} Some."
  },
  {
    "objectID": "/rsh/compute/#p_184",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fromSome receives a {!rsh} Maybe value and a default value as arguments and will return the value inside of the {!rsh} Some variant or the default value otherwise."
  },
  {
    "objectID": "/rsh/compute/#p_185",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} maybe(m, defaultVal, f) receives a {!rsh} Maybe value, a default value, and a unary function as arguments. The function will either return the application of the function, {!rsh} f, to the {!rsh} Some value or return the default value provided."
  },
  {
    "objectID": "/rsh/compute/#p_186",
    "pt": "Computations",
    "t": 3,
    "c": "The following examples demonstrate different usage of {!rsh} Maybe:"
  },
  {
    "objectID": "/rsh/compute/#p_187",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Either is defined by"
  },
  {
    "objectID": "/rsh/compute/#p_188",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Either can be used to represent values with two possible types."
  },
  {
    "objectID": "/rsh/compute/#p_189",
    "pt": "Computations",
    "t": 3,
    "c": "Similar to Maybe, Either may be used to represent values that are correct or erroneous. A successful result is stored, by convention, in Right. Unlike None, Left may carry additional information about the error."
  },
  {
    "objectID": "/rsh/compute/#p_190",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} either(e, onLeft, onRight) will either apply the function onLeft or onRight depending on e."
  },
  {
    "objectID": "/rsh/compute/#p_191",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} isLeft is a convenience method that determines whether the variant is Left."
  },
  {
    "objectID": "/rsh/compute/#p_192",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} isRight is a convenience method that determines whether the variant is Right."
  },
  {
    "objectID": "/rsh/compute/#p_193",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fromLeft(e, default) is a convenience method that returns the value in Left, or default if the variant is Right."
  },
  {
    "objectID": "/rsh/compute/#p_194",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fromRight(e, default) is a convenience method that returns the value in Right, or default if the variant is Left."
  },
  {
    "objectID": "/rsh/compute/#p_195",
    "pt": "Computations",
    "t": 3,
    "c": "This snippet demonstrates the convenience methods:"
  },
  {
    "objectID": "/rsh/compute/#p_196",
    "pt": "Computations",
    "t": 3,
    "c": "A match expression, written {!rsh} VAR.match({ CASE ... }), where VAR is a variable bound to a data instance and CASE is VARIANT: FUNCTION, where VARIANT is a variant or {!rsh} default, and FUNCTION is a function that takes the same arguments as the variant constructor. If the variant has a type of {!rsh} Null, then the function is allowed to take no arguments. {!rsh} default functions must always take an argument, even if all defaulted variants have type {!rsh} Null."
  },
  {
    "objectID": "/rsh/compute/#p_197",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} match is similar to a switch statement, but since it is an expression, it can be conveniently used in places like the right hand side of an assignment statement."
  },
  {
    "objectID": "/rsh/compute/#p_198",
    "pt": "Computations",
    "t": 3,
    "c": "Similar to a switch statement, the cases are expected to be exhaustive and nonredundant, all cases have empty tails, and it may only include a consensus transfer in its cases if it is within a consensus step."
  },
  {
    "objectID": "/rsh/compute/#p_199",
    "pt": "Computations",
    "t": 3,
    "c": "A conditional expression, written {!rsh} COND_E ? NOT_FALSE_E : FALSE_E, where {!rsh} COND_E, {!rsh} NOT_FALSE_E, and {!rsh} FALSE_E are expressions, selects between the values which {!rsh} NOT_FALSE_E and {!rsh} FALSE_E evaluate to based on whether {!rsh} COND_E evaluates to {!rsh} false. This expression will evaluate both the false and not-false sides of the computation is they are considered pure. Arithmetic is considered pure if you do not enable {!rsh} verifyArithmetic}, but it is actually not because of arithmetic faults."
  },
  {
    "objectID": "/rsh/compute/#p_200",
    "pt": "Computations",
    "t": 3,
    "c": "Conditional expressions may also be written with the {!rsh} ite function, however, note that this function always evaluates both of its branches."
  },
  {
    "objectID": "/rsh/compute/#p_201",
    "pt": "Computations",
    "t": 3,
    "c": "An arrow expression, written {!rsh} (LHS_0, ..., LHS_n) => EXPR, where {!rsh} LHS_0 through {!rsh} LHS_n are left-hand sides and {!rsh} EXPR is an expression, evaluates to a function which is an abstraction of {!rsh} EXPR over {!rsh} n values compatible with the respective left-hand side. Like function definitions, arrow expressions may use default argument notation and rest parameters."
  },
  {
    "objectID": "/rsh/compute/#p_202",
    "pt": "Computations",
    "t": 3,
    "c": "An enumeration (or enum, for short), can be created by calling the {!rsh} makeEnum function, as in {!rsh} makeEnum(N), where {!rsh} N is the number of distinct values in the enum. This produces a tuple of {!rsh} N+1 values, where the first value is a {!rsh} Fun([UInt], Bool) which tells you if its argument is one of the enum's values, and the next N values are distinct {!rsh} UInts."
  },
  {
    "objectID": "/rsh/compute/#p_203",
    "pt": "Computations",
    "t": 3,
    "c": "isOutcome is a function that takes a {!rsh} UInt and returns {!rsh} true or {!rsh} false depending on if the {!rsh} UInt passed to it is a member of that enumeration or not. LENDER_TIMEOUT and BORROWER_TIMEOUT are {!rsh} UInts."
  },
  {
    "objectID": "/rsh/compute/#p_204",
    "pt": "Computations",
    "t": 3,
    "c": "So isOutcome(LENDER_TIMEOUT) would return {!rsh} true while isOutcome(SCISSORS) would return {!rsh} false."
  },
  {
    "objectID": "/rsh/compute/#p_205",
    "pt": "Computations",
    "t": 3,
    "c": "A static assertion which is only valid if {!rsh} claim always evaluates to {!rsh} true."
  },
  {
    "objectID": "/rsh/compute/#p_206",
    "pt": "Computations",
    "t": 3,
    "c": "For example, the following assertions were made in the Rock, Paper, Scissors tutorial:"
  },
  {
    "objectID": "/rsh/compute/#p_207",
    "pt": "Computations",
    "t": 3,
    "c": "The Reach compiler will produce a counter-example (i.e. an assignment of the identifiers in the program to falsify the {!rsh} claim) when an invalid {!rsh} claim is provided. It is possible to write a {!rsh} claim that actually always evaluates to {!rsh} true, but for which our current approach cannot prove always evaluates to {!rsh} true; if this is the case, Reach will fail to compile the program, reporting that its analysis is incomplete. Reach will never produce an erroneous counter-example."
  },
  {
    "objectID": "/rsh/compute/#p_208",
    "pt": "Computations",
    "t": 3,
    "c": "It accepts an optional bytes argument, which is included in any reported violation."
  },
  {
    "objectID": "/rsh/compute/#p_209",
    "pt": "Computations",
    "t": 3,
    "c": "See the guide section on verification to better understand how and what to verify in your program."
  },
  {
    "objectID": "/rsh/compute/#p_210",
    "pt": "Computations",
    "t": 3,
    "c": "A dynamic assertion that {!rsh} claim evaluates to {!rsh} true, which expands to either a {!rsh} require or {!rsh} assume depending on where it is used in a program. It accepts an optional bytes argument, which is included in any reported violation."
  },
  {
    "objectID": "/rsh/compute/#p_211",
    "pt": "Computations",
    "t": 3,
    "c": "For example, A makes the following {!rsh} check with a second (optional) argument on line 21:"
  },
  {
    "objectID": "/rsh/compute/#p_212",
    "pt": "Computations",
    "t": 3,
    "c": "While the {!rsh} check in the following example, takes just the first argument on line 62:"
  },
  {
    "objectID": "/rsh/compute/#p_213",
    "pt": "Computations",
    "t": 3,
    "c": "The single argument version returns an abstract value of the given type. It may only be referenced inside of assertions; any other reference is invalid."
  },
  {
    "objectID": "/rsh/compute/#p_214",
    "pt": "Computations",
    "t": 3,
    "c": "The two argument version is an abbreviation of calling the second argument with the result of {!rsh} forall(Type). This is convenient for writing general claims about expressions, such as"
  },
  {
    "objectID": "/rsh/compute/#p_215",
    "pt": "Computations",
    "t": 3,
    "c": "The following code sample uses a couple of {!rsh} forall arguments to assert that winner always provides a valid outcome."
  },
  {
    "objectID": "/rsh/compute/#p_216",
    "pt": "Computations",
    "t": 3,
    "c": "A possibility assertion which is only valid if it is possible for {!rsh} claim to evaluate to {!rsh} true with honest frontends and participants. It accepts an optional bytes argument, which is included in any reported violation."
  },
  {
    "objectID": "/rsh/compute/#p_217",
    "pt": "Computations",
    "t": 3,
    "c": "The digest primitive performs a cryptographic hash of the binary encoding of the given arguments. This returns a {!rsh} Digest value. The exact algorithm used depends on the connector."
  },
  {
    "objectID": "/rsh/compute/#p_218",
    "pt": "Computations",
    "t": 3,
    "c": "This sample digests password, _pass into a hash, passDigest, so that it can be shared safely on the consensus network without eavesdroppers learning the password."
  },
  {
    "objectID": "/rsh/compute/#p_219",
    "pt": "Computations",
    "t": 3,
    "c": "The balance primitive returns the balance of the contract account for the DApp. It takes an optional non-network token value, in which case it returns the balance of the given token."
  },
  {
    "objectID": "/rsh/compute/#p_220",
    "pt": "Computations",
    "t": 3,
    "c": "The example below shows non-network tokens being passed as arguments to the {!rsh} balance primitives:"
  },
  {
    "objectID": "/rsh/compute/#p_221",
    "pt": "Computations",
    "t": 3,
    "c": "While in the following example, {!rsh} balance takes no argument:"
  },
  {
    "objectID": "/rsh/compute/#p_222",
    "pt": "Computations",
    "t": 3,
    "c": "The getContract primitive returns the {!rsh} Contract value for the deployed contract. This function may not be called until after the first publication (which creates the contract)."
  },
  {
    "objectID": "/rsh/compute/#p_223",
    "pt": "Computations",
    "t": 3,
    "c": "In line 26, D publishes the values for x and tok. After the {!rsh} publish, {!rsh} getContract returns the value x in token tok."
  },
  {
    "objectID": "/rsh/compute/#p_224",
    "pt": "Computations",
    "t": 3,
    "c": "The getAddress primitive returns the {!rsh} Address value of the deployed contract's account. This function may not be called until after the first publication (which creates the contract)."
  },
  {
    "objectID": "/rsh/compute/#p_225",
    "pt": "Computations",
    "t": 3,
    "c": "In the sample above, Alice publishes to create the contract. Then, an object named info references {!rsh} getContract which pulls in the contract information. Another object, addr, references {!rsh} getAddress to obtain the address of Alice. Both {!rsh} info and {!rsh} addr are then used in the local step of Alice in her {!rsh} interact object."
  },
  {
    "objectID": "/rsh/compute/#p_226",
    "pt": "Computations",
    "t": 3,
    "c": "The {!rsh} getCompanion primitive returns the {!rsh} Contract value of the deployed contract's companion, wrapped in a {!rsh} Maybe value, because not all contracts have a companion."
  },
  {
    "objectID": "/rsh/compute/#p_227",
    "pt": "Computations",
    "t": 3,
    "c": "This is useful on Algorand if contract A calls contract B and contract B needs a companion. Contract A will need to use the {!rsh} REMOTE_FUN.ALGO.apps options and include B's companion in the call."
  },
  {
    "objectID": "/rsh/compute/#p_228",
    "pt": "Computations",
    "t": 3,
    "c": "The lastConsensusTime primitive returns the network time of the last publication of the DApp. This may not be available if there was no such previous publication, such as at the beginning of an application before the first publication."
  },
  {
    "objectID": "/rsh/compute/#p_229",
    "pt": "Computations",
    "t": 3,
    "c": "In this code, {!rsh} lastConsensusTime is called on line 17 after the publication on line 12. The entry function on line 15 takes step as an argument and produces an array. The array contains the destructured step, lab that was passed into the parent function (aStep), {!rsh} lastConsensusTime() and {!rsh} lastConsensusSecs()."
  },
  {
    "objectID": "/rsh/compute/#p_230",
    "pt": "Computations",
    "t": 3,
    "c": "lastConsensusSecs is like {!rsh} lastConsensusTime, except it returns the network seconds."
  },
  {
    "objectID": "/rsh/compute/#p_231",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} lastConsensusSecs is used to make a check on line 14. This happened after the publication on line 9."
  },
  {
    "objectID": "/rsh/compute/#p_232",
    "pt": "Computations",
    "t": 3,
    "c": "The thisConsensusTime primitive returns the network time of the current publication of the DApp."
  },
  {
    "objectID": "/rsh/compute/#p_233",
    "pt": "Computations",
    "t": 3,
    "c": "Some networks do not support observing the time of a consensus operation until after it has finalized."
  },
  {
    "objectID": "/rsh/compute/#p_234",
    "pt": "Computations",
    "t": 3,
    "c": "thisConsensusSecs is like {!rsh} thisConsensusTime, except it returns the network seconds."
  },
  {
    "objectID": "/rsh/compute/#p_235",
    "pt": "Computations",
    "t": 3,
    "c": "In this code, three variables are created that set lastTime to {!rsh} thisConsensusTime, lastSecs to {!rsh} thisConsensusSecs and i to 0. Then, an invariant is set to make sure that lastTime is greater than {!rsh} lastConsensusTime, lastTime is equal to {!rsh} thisConsensusTime, lastSecs is either equal or greater than {!rsh} lastConsensusSecs and that the {!rsh} balance is equal to 0. This makes sure that the order of blocks matches the order of time."
  },
  {
    "objectID": "/rsh/compute/#p_236",
    "pt": "Computations",
    "t": 3,
    "c": "These primitives return the network time (network seconds) that a relative time argument refers to. This is either the same as {!rsh} lastConsensusTime ({!rsh} lastConsensusSecs) or the deadline of the previous {!rsh} wait or {!rsh} .timeout."
  },
  {
    "objectID": "/rsh/compute/#p_237",
    "pt": "Computations",
    "t": 3,
    "c": "These functions return time arguments, which are instances of the type {!rsh} Either(UInt, UInt), where {!rsh} Left variants refer to absolute network time and {!rsh} Right variants refer to absolute network seconds."
  },
  {
    "objectID": "/rsh/compute/#p_238",
    "pt": "Computations",
    "t": 3,
    "c": "These functions take an optional function argument, claim, which will be used to verify arithmetic when necessary. In most cases, one would pass {!rsh} assume, {!rsh} require, or {!rsh} assert. This argument is only needed when verifyArithmetic is enabled. The default value of this argument is a no-op."
  },
  {
    "objectID": "/rsh/compute/#p_239",
    "pt": "Computations",
    "t": 3,
    "c": "The {!rsh} absoluteTime and {!rsh} absoluteSecs are equivalent to {!rsh} Left and {!rsh} Right variant tags."
  },
  {
    "objectID": "/rsh/compute/#p_240",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_241",
    "pt": "Computations",
    "t": 3,
    "c": "This code takes {!rsh} absoluteTime as the {!rsh} Left variant tag or the first argument for the {!rsh} timeout method while {!rsh} absoluteSecs is used in the anonymous {!rsh} function called on the {!rsh} Right hand side of the aStep {!rsh} function in the code below:"
  },
  {
    "objectID": "/rsh/compute/#p_242",
    "pt": "Computations",
    "t": 3,
    "c": "The {!rsh} relativeTime and {!rsh} relativeSecs functions add {!rsh} baseWaitTime and {!rsh} baseWaitSecs to their arguments before tagging with the appropriate variant."
  },
  {
    "objectID": "/rsh/compute/#p_243",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_244",
    "pt": "Computations",
    "t": 3,
    "c": "This code adds deadline (i.e {!rsh} baseWaitTime) to the {!rsh} timeout method using {!rsh} relativeTime while the code below adds 25 seconds (i.e {!rsh} baseWaitSecs) to the {!rsh} timeout method using {!rsh} relativeSecs:"
  },
  {
    "objectID": "/rsh/compute/#p_245",
    "pt": "Computations",
    "t": 3,
    "c": "If a time argument is required, an integer value is allowed and is interpreted as a {!rsh} relativeTime, but this behavior is deprecated and you will see a warning."
  },
  {
    "objectID": "/rsh/compute/#p_246",
    "pt": "Computations",
    "t": 3,
    "c": "When using verifyArithmetic and a dynamic timeout argument, it will be necessary to verify that the timeout calculation will not overflow. When producing the interact timeout value, you will want to use these functions to make assume and require claims about the value. For example:"
  },
  {
    "objectID": "/rsh/compute/#p_247",
    "pt": "Computations",
    "t": 3,
    "c": "Use the identity function as the claim for use inside of invariants."
  },
  {
    "objectID": "/rsh/compute/#p_248",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} makeDeadline(deadline) takes a {!rsh} UInt as an argument and returns a pair of functions that can be used for dealing with absolute deadlines. It internally determines the end time based off of the deadline and the last consensus time—at the time of calling {!rsh} makeDeadline. timeRemaining will calculate the difference between the end time and the current last consensus time. keepGoing determines whether the current last consensus time is less than the end time. It is typical to use the two fields for the while and timeout field of a {!rsh} parallelReduce expression. For example:"
  },
  {
    "objectID": "/rsh/compute/#p_249",
    "pt": "Computations",
    "t": 3,
    "c": "This pattern is so common that it can be abbreviated as {!rsh} .timeRemaining."
  },
  {
    "objectID": "/rsh/compute/#p_250",
    "pt": "Computations",
    "t": 3,
    "c": "As can be seen in this code block from the Raffle example, {!rsh} makeDeadline is being used to set the {!rsh} deadline to double the original amount of network blocks if someone returns a ticket."
  },
  {
    "objectID": "/rsh/compute/#p_251",
    "pt": "Computations",
    "t": 3,
    "c": "Returns {!rsh} true if {!rsh} x is {!rsh} false or {!rsh} y is {!rsh} true."
  },
  {
    "objectID": "/rsh/compute/#p_252",
    "pt": "Computations",
    "t": 3,
    "c": "On line 54, {!rsh} implies would return {!rsh} true if {!rsh} when is {!rsh} false or {!rsh} isNone(randomsM[this]) evaluates to {!rsh} true."
  },
  {
    "objectID": "/rsh/compute/#p_253",
    "pt": "Computations",
    "t": 3,
    "c": "Makes a static assertion that {!rsh} pred(x) is {!rsh} true and returns {!rsh} x."
  },
  {
    "objectID": "/rsh/compute/#p_254",
    "pt": "Computations",
    "t": 3,
    "c": "A participant interact interface which specifies random as a function that takes no arguments and returns an unsigned integer of bit width bits. Reach provides a default frontend implementation via hasRandom (Frontend)."
  },
  {
    "objectID": "/rsh/compute/#p_255",
    "pt": "Computations",
    "t": 3,
    "c": "This code section gives the {!rsh} Player object the method {!rsh} hasRandom so that a random number is used to select a hand in the Rock, Paper, Scissors! tutorial."
  },
  {
    "objectID": "/rsh/compute/#p_256",
    "pt": "Computations",
    "t": 3,
    "c": "A participant interact interface which specifies log with an unconstrained domain function type that returns {!rsh} Null. Reach provides a default frontend implementation via {!js} stdlib.hasConsoleLogger."
  },
  {
    "objectID": "/rsh/compute/#p_257",
    "pt": "Computations",
    "t": 3,
    "c": "In this project, notice how {!rsh} hasConsoleLogger is accessed through the standard library on line 8 of the frontend. It is then passed to the backend on line 6."
  },
  {
    "objectID": "/rsh/compute/#p_258",
    "pt": "Computations",
    "t": 3,
    "c": "Creates a new function that applies its argument to g, then pipes the result to the function f. The argument type of f must be the return type of g."
  },
  {
    "objectID": "/rsh/compute/#p_259",
    "pt": "Computations",
    "t": 3,
    "c": "Currently, wide arithmetic operations are only suported on Algorand."
  },
  {
    "objectID": "/rsh/compute/#p_260",
    "pt": "Computations",
    "t": 3,
    "c": "Multiplies {!rsh} a by {!rsh} b, then immediately divides the product by {!rsh} c. The intermediate value may be larger than {!rsh} UInt.max if the connector supports wide arithmetic operations. The resulting quotient must be less than {!rsh} UInt.max."
  },
  {
    "objectID": "/rsh/compute/#p_261",
    "pt": "Computations",
    "t": 3,
    "c": "On line 31, totalAmount would be multiplied by the result of (curTime - start). The output would then be divided by duration immediately."
  },
  {
    "objectID": "/rsh/compute/#p_262",
    "pt": "Computations",
    "t": 3,
    "c": "verifyMuldiv is required to verify {!rsh} muldiv when using verifyArithmetic"
  },
  {
    "objectID": "/rsh/compute/#p_263",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} verifyMuldiv generates a claim that the result of applying the same arguments to {!rsh} muldiv will not overflow. When used inside of a local step or export, it will generate an {!rsh} assume claim. When used inside of a consensus step, it will generate a {!rsh} require claim. When used inside of any other step, it will generate an {!rsh} assert claim."
  },
  {
    "objectID": "/rsh/compute/#p_264",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} muldiv is used on line 36 to multiply x and y. After which, the product of x and y is immediately divided by the product of cx and cy. On line 41, {!rsh} verifyMuldiv is used with the same arguments passed to {!rsh} muldiv on line 36. In this case, however, it is used to generate a claim that the result of applying the same arguments to {!rsh} muldiv will not overflow."
  },
  {
    "objectID": "/rsh/compute/#p_265",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} sqrt(x) returns the largest integer i such that i * i <= x."
  },
  {
    "objectID": "/rsh/compute/#p_266",
    "pt": "Computations",
    "t": 3,
    "c": "This code checks if z is equivalent to the square root of x on line 18. For example, if z is 9 and x is 81, that line would return {!rsh} true."
  },
  {
    "objectID": "/rsh/compute/#p_267",
    "pt": "Computations",
    "t": 3,
    "c": "Calculates an approximate square root of the first argument. This method utilizes the Babylonian Method for computing the square root. The second argument must be a {!rsh} UInt whose value is known at compile time, which represents the number of iterations the algorithm should perform."
  },
  {
    "objectID": "/rsh/compute/#p_268",
    "pt": "Computations",
    "t": 3,
    "c": "For reference, when performing {!rsh} 5 iterations, the algorithm can reliably calculate the square root up to 32 squared, or 1,024. When performing {!rsh} 10 iterations, the algorithm can reliably calculate the square root up to 580 squared, or 336,400."
  },
  {
    "objectID": "/rsh/compute/#p_269",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} pow(base, power, precision) calculates the approximate value of raising base to power. The third argument must be a {!rsh} UInt whose value is known at compile time, which represents the number of iterations the algorithm should perform."
  },
  {
    "objectID": "/rsh/compute/#p_270",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_271",
    "pt": "Computations",
    "t": 3,
    "c": "This code computes the finalOutcome of the Rock, Paper, Scissors game using the {!rsh} pow method. It takes outcome as the base, the sum of handAlice and handBob as the power, and 10 as the precision."
  },
  {
    "objectID": "/rsh/compute/#p_272",
    "pt": "Computations",
    "t": 3,
    "c": "For reference, 6 iterations provides enough accuracy to calculate up to 2^64 - 1, so the largest power it can compute is 2^63. If the number of iterations is not large enough to compute the power, then the result is completely inaccurate. It is recommended to create {!rsh} assert tests to ensure the possible values your program can compute are accurate."
  },
  {
    "objectID": "/rsh/compute/#p_273",
    "pt": "Computations",
    "t": 3,
    "c": "The standard library provides abstractions for dealing with signed integers. The following definitions are used to represent {!rsh} Ints:"
  },
  {
    "objectID": "/rsh/compute/#p_274",
    "pt": "Computations",
    "t": 3,
    "c": "Int is represented as an object, as opposed to a scalar value, because some platforms that Reach targets do not provide native support for signed integers."
  },
  {
    "objectID": "/rsh/compute/#p_275",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} int(Bool, UInt) is shorthand for defining an {!rsh} Int record. You may also use the {!rsh} + and {!rsh} - unary operators to declare integers instead of {!rsh} UInts."
  },
  {
    "objectID": "/rsh/compute/#p_276",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} iadd(x, y) adds the {!rsh} Int x and the {!rsh} Int y."
  },
  {
    "objectID": "/rsh/compute/#p_277",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} isub(x, y) subtracts the {!rsh} Int y from the {!rsh} Int x."
  },
  {
    "objectID": "/rsh/compute/#p_278",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} imul(x, y) multiplies the {!rsh} Int x and the {!rsh} Int y."
  },
  {
    "objectID": "/rsh/compute/#p_279",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} idiv(x, y) divides the {!rsh} Int x by the {!rsh} Int y."
  },
  {
    "objectID": "/rsh/compute/#p_280",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} imod(x, y) finds the remainder of dividing the {!rsh} Int x by the {!rsh} Int y."
  },
  {
    "objectID": "/rsh/compute/#p_281",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} ilt(x, y) determines whether x is less than y."
  },
  {
    "objectID": "/rsh/compute/#p_282",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} ile(x, y) determines whether x is less than or equal to y."
  },
  {
    "objectID": "/rsh/compute/#p_283",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} igt(x, y) determines whether x is greather than y."
  },
  {
    "objectID": "/rsh/compute/#p_284",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} ige(x, y) determines whether x is greater than or equal to y."
  },
  {
    "objectID": "/rsh/compute/#p_285",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} ieq(x, y) determines whether x is equal to y."
  },
  {
    "objectID": "/rsh/compute/#p_286",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} ine(x, y) determines whether x is not equal to y."
  },
  {
    "objectID": "/rsh/compute/#p_287",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} imax(x, y) returns the larger of two {!rsh} Ints."
  },
  {
    "objectID": "/rsh/compute/#p_288",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} abs(i) returns the absolute value of an {!rsh} Int. The return value is of type {!rsh} UInt."
  },
  {
    "objectID": "/rsh/compute/#p_289",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} FixedPoint is defined by"
  },
  {
    "objectID": "/rsh/compute/#p_290",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} FixedPoint can be used to represent numbers with a fixed number of digits after the decimal point. They are handy for representing fractional values, especially in base 10. The value of a fixed point number is determined by dividing the underlying integer value, i, by its scale factor, scale. For example, we could represent the value {!rsh} 1.234 with {!rsh} { sign: Pos, i: { scale: 1000, i : 1234 } } or {!rsh} fx(1000)(Pos, 1234). Alternatively, Reach provides syntactic sugar for defining {!rsh} FixedPoint numbers. One can simply write {!rsh} 1.234, which will assume the value is in base 10. A scale factor of 1000 correlates to 3 decimal places of precision. Similarly, a scale factor of 100 would have 2 decimal places of precision."
  },
  {
    "objectID": "/rsh/compute/#p_291",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fx(scale)(i) will return a function that can be used to instantiate fixed point numbers with a particular scale factor."
  },
  {
    "objectID": "/rsh/compute/#p_292",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxint(Int) will cast the {!rsh} Int arg as a {!rsh} FixedPoint number with a scale of 1."
  },
  {
    "objectID": "/rsh/compute/#p_293",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxrescale(x, scale) will convert a fixed point number from using one scale to another. This operation can result in loss of precision, as demonstrated in the above example."
  },
  {
    "objectID": "/rsh/compute/#p_294",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxunify(x, y) will convert the fixed point numbers to use the same scale. The larger scale of the two arguments will be chosen. The function will return a 3-tuple consisting of the common scale and the newly scaled values."
  },
  {
    "objectID": "/rsh/compute/#p_295",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxadd(x, y) adds two fixed point numbers."
  },
  {
    "objectID": "/rsh/compute/#p_296",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxsub(x, y) subtracts two fixed point numbers."
  },
  {
    "objectID": "/rsh/compute/#p_297",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxmul(x, y) multiplies two fixed point numbers."
  },
  {
    "objectID": "/rsh/compute/#p_298",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxdiv(x, y, scale_factor) divides two fixed point numbers. The numerator, x, will be multiplied by the scale factor to provide a more precise answer. For example,"
  },
  {
    "objectID": "/rsh/compute/#p_299",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxmod(x, y) finds the remainder of dividing x by y."
  },
  {
    "objectID": "/rsh/compute/#p_300",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxfloor(x) returns the greatest integer not greater than x."
  },
  {
    "objectID": "/rsh/compute/#p_301",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxsqrt(x, k) returns the square root of the fixed number, x."
  },
  {
    "objectID": "/rsh/compute/#p_302",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxsqrtApprox(x, k) approximates the square root of the fixed number, x, using k iterations of the {!rsh} sqrtApprox algorithm."
  },
  {
    "objectID": "/rsh/compute/#p_303",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} const base = 2.0; const power = 0.33; fxpow(base, power, 10, 1000); // 1.260 fxpow(base, power, 10, 10000); // 1.2599 fxpow(base, power, 10, 1000000); // 1.259921 "
  },
  {
    "objectID": "/rsh/compute/#p_304",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxpow(base, power, precision, scalePrecision) approximates the power of the fixed number, base, raised to the fixed point number, power. The third argument must be a {!rsh} UInt whose value is known at compile time, which represents the number of iterations the algorithm should perform. The scalePrecision argument must be a UInt and represents the scale of the return value. Choosing a larger scalePrecision allows for more precision when approximating the power, as demonstrated in the example below:"
  },
  {
    "objectID": "/rsh/compute/#p_305",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxpowi(base, power, precision) approximates the power of the fixed number, base, raised to the {!rsh} Int, power. The third argument must be a {!rsh} UInt whose value is known at compile time, which represents the number of iterations the algorithm should perform. For reference, 6 iterations provides enough accuracy to calculate up to 2^64 - 1, so the largest power it can compute is 63."
  },
  {
    "objectID": "/rsh/compute/#p_306",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxpowui(5.8, 3, 10); // 195.112 "
  },
  {
    "objectID": "/rsh/compute/#p_307",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxpowui(base, power, precision) approximates the power of the fixed number, base, raised to the {!rsh} UInt, power. The third argument must be a {!rsh} UInt whose value is known at compile time."
  },
  {
    "objectID": "/rsh/compute/#p_308",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxcmp(op, x, y) applies the comparison operator to the two fixed point numbers after unifying their scales."
  },
  {
    "objectID": "/rsh/compute/#p_309",
    "pt": "Computations",
    "t": 3,
    "c": "There are convenience methods defined for comparing fixed point numbers:"
  },
  {
    "objectID": "/rsh/compute/#p_310",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxlt(x, y) tests whether x is less than y."
  },
  {
    "objectID": "/rsh/compute/#p_311",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxle(x, y) tests whether x is less than or equal to y."
  },
  {
    "objectID": "/rsh/compute/#p_312",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxgt(x, y) tests whether x is greater than y."
  },
  {
    "objectID": "/rsh/compute/#p_313",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxge(x, y) tests whether x is greater than or equal to y."
  },
  {
    "objectID": "/rsh/compute/#p_314",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxeq(x, y) tests whether x is equal to y."
  },
  {
    "objectID": "/rsh/compute/#p_315",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxne(x, y) tests whether x is not equal to y."
  },
  {
    "objectID": "/rsh/compute/#p_316",
    "pt": "Computations",
    "t": 3,
    "c": "Reach provides a shorthand, {!rsh} Anybody, which serves as a {!rsh} race between all participants. This shorthand can be useful for situations where it does not matter who {!rsh} publishes, such as in a {!rsh} timeout."
  },
  {
    "objectID": "/rsh/compute/#p_317",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Anybody is strictly an abbreviation of a {!rsh} race involving all of the named participants of the application."
  },
  {
    "objectID": "/rsh/compute/#p_318",
    "pt": "Computations",
    "t": 3,
    "c": "In this code, the {!rsh} Participants are defined on lines 11 and 12. At the moment of {!rsh} timeout, line 47 permits any of the {!rsh} Participants to make a publication."
  },
  {
    "objectID": "/rsh/compute/#p_319",
    "pt": "Computations",
    "t": 3,
    "c": "In an application with a participant class, this means any principal at all, because there is no restriction on which principals (i.e. addresses) may serve as a member of that class. In an application without any participant classes, {!rsh} Anybody instead would mean only the actual previously-bound participants."
  },
  {
    "objectID": "/rsh/compute/#p_320",
    "pt": "Computations",
    "t": 3,
    "c": "An {!rsh} Interval is defined by"
  },
  {
    "objectID": "/rsh/compute/#p_321",
    "pt": "Computations",
    "t": 3,
    "c": "where {!rsh} IntervalType is defined by"
  },
  {
    "objectID": "/rsh/compute/#p_322",
    "pt": "Computations",
    "t": 3,
    "c": "An interval may be constructed with its tuple notation or by function:"
  },
  {
    "objectID": "/rsh/compute/#p_323",
    "pt": "Computations",
    "t": 3,
    "c": "For convenience, Reach provides a number of functions for constructing intervals:"
  },
  {
    "objectID": "/rsh/compute/#p_324",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} interval(IntervalType, Int, Int, IntervalType) constructs an interval where the first and second argument represent the left endpoint and whether it's open or closed; the third and fourth argument represent the right endpoint and whether it's open or closed."
  },
  {
    "objectID": "/rsh/compute/#p_325",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalCC(l, r) constructs a closed interval from two endpoints of type {!rsh} Int."
  },
  {
    "objectID": "/rsh/compute/#p_326",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_327",
    "pt": "Computations",
    "t": 3,
    "c": "This code creates an interval that is closed on both sides using +43 and +14 for the left and right endpoints respectively on line 39."
  },
  {
    "objectID": "/rsh/compute/#p_328",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalCO(l, r) constructs a half-open interval from two endpoints of type {!rsh} Int where the left endpoint is closed and the right endpoint is open."
  },
  {
    "objectID": "/rsh/compute/#p_329",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_330",
    "pt": "Computations",
    "t": 3,
    "c": "This code creates an interval that is closed on the left and opened on the right. It uses +7 and +9 for the left and right endpoints respectively on line 15."
  },
  {
    "objectID": "/rsh/compute/#p_331",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalOC(l, r) constructs a half-open interval from two endpoints of type {!rsh} Int where the left endpoint is open and the right endpoint is closed."
  },
  {
    "objectID": "/rsh/compute/#p_332",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_333",
    "pt": "Computations",
    "t": 3,
    "c": "This code creates an interval that is opened on the left and closed on the right. It uses +3 and +11 for the left and right endpoints respectively on line 23."
  },
  {
    "objectID": "/rsh/compute/#p_334",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalOO(l, r) constructs an open interval from two endpoints of type {!rsh} Int."
  },
  {
    "objectID": "/rsh/compute/#p_335",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_336",
    "pt": "Computations",
    "t": 3,
    "c": "This code creates an interval that is opened on both sides using +4 and +45 for the left and right endpoints respectively on line 28."
  },
  {
    "objectID": "/rsh/compute/#p_337",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} leftEndpoint(i) will return the {!rsh} Int that represents the left endpoint of an interval."
  },
  {
    "objectID": "/rsh/compute/#p_338",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_339",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that the {!rsh} leftEndpoint of y is equivalent to +2 on line 6."
  },
  {
    "objectID": "/rsh/compute/#p_340",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} rightEndpoint(i) will return the {!rsh} Int that represents the right endpoint of an interval."
  },
  {
    "objectID": "/rsh/compute/#p_341",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_342",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that the {!rsh} rightEndpoint of x is not equivalent to {!rsh} rightEndpoint of y on line 12."
  },
  {
    "objectID": "/rsh/compute/#p_343",
    "pt": "Computations",
    "t": 3,
    "c": "Intervals may be compared with the following functions:"
  },
  {
    "objectID": "/rsh/compute/#p_344",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalEq(l, r) tests whether the intervals are equal."
  },
  {
    "objectID": "/rsh/compute/#p_345",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_346",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that the result of testing whether {!rsh} intervalOO(+1, +1) and {!rsh} intervalOO(+1, +1) are eqaul, must evaluate to {!rsh} true on line 4."
  },
  {
    "objectID": "/rsh/compute/#p_347",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalNeq(l, r) tests whether the intervals are not equal."
  },
  {
    "objectID": "/rsh/compute/#p_348",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_349",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that the result of testing whether {!rsh} intervalCC(+1, +2)and {!rsh} intervalCC(+4, +5) are not eqaul, must evaluate to {!rsh} true on line 10."
  },
  {
    "objectID": "/rsh/compute/#p_350",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalLt(l, r) tests whether the left interval is less than the right interval."
  },
  {
    "objectID": "/rsh/compute/#p_351",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_352",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that the result of testing whether {!rsh} intervalCC(+1, +2)is less than {!rsh} intervalCC(+3, +5), must evaluate to {!rsh} true on line 15."
  },
  {
    "objectID": "/rsh/compute/#p_353",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalLte(l, r) tests whether the left interval is less than or equal to the right interval."
  },
  {
    "objectID": "/rsh/compute/#p_354",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_355",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that the result of testing whether {!rsh} intervalOO(+3, +4)is less than or equal to {!rsh} intervalOO(+5, +7), must evaluate to {!rsh} true on line 19."
  },
  {
    "objectID": "/rsh/compute/#p_356",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalGt(l, r) tests whether the left interval is greater than the right interval."
  },
  {
    "objectID": "/rsh/compute/#p_357",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_358",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that the result of testing whether {!rsh} intervalCC(+5, +7)is greater than {!rsh} intervalCC(+3, +4), must evaluate to {!rsh} true on line 25."
  },
  {
    "objectID": "/rsh/compute/#p_359",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalGte(l, r) tests whether the left interval is greater than or equal to the right interval."
  },
  {
    "objectID": "/rsh/compute/#p_360",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_361",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that the result of testing whether {!rsh} intervalCC(+2, +2)is greater than or equal to {!rsh} intervalCC(+2, +2), must evaluate to {!rsh} true on line 30."
  },
  {
    "objectID": "/rsh/compute/#p_362",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalAdd(l, r) adds the two intervals."
  },
  {
    "objectID": "/rsh/compute/#p_363",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_364",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that ex is equivalent to the sum of i1 and i2."
  },
  {
    "objectID": "/rsh/compute/#p_365",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalSub(l, r) subtracts the two intervals."
  },
  {
    "objectID": "/rsh/compute/#p_366",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_367",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that ex is equivalent to the difference of i1 and i2."
  },
  {
    "objectID": "/rsh/compute/#p_368",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalMul(l, r) multiplies the two intervals."
  },
  {
    "objectID": "/rsh/compute/#p_369",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_370",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that ex is equivalent to the product of i1 and i2."
  },
  {
    "objectID": "/rsh/compute/#p_371",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalDiv(l, r) divides the two intervals."
  },
  {
    "objectID": "/rsh/compute/#p_372",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_373",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that ex is equivalent to the outcome of the division of i1 and i2."
  },
  {
    "objectID": "/rsh/compute/#p_374",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalIntersection(x, y) returns the intersection of two intervals."
  },
  {
    "objectID": "/rsh/compute/#p_375",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_376",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that ii is equivalent to the intersection of i1 and i2."
  },
  {
    "objectID": "/rsh/compute/#p_377",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalUnion(x, y) returns the union of two intervals."
  },
  {
    "objectID": "/rsh/compute/#p_378",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_379",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that iu is equivalent to the union of i1 and i2."
  },
  {
    "objectID": "/rsh/compute/#p_380",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalWidth(i) returns the width of an interval."
  },
  {
    "objectID": "/rsh/compute/#p_381",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_382",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that +41 is equivalent to the width of interval i."
  },
  {
    "objectID": "/rsh/compute/#p_383",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalAbs(i) returns the absolute value of an interval."
  },
  {
    "objectID": "/rsh/compute/#p_384",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_385",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that +10 is equivalent to the absolute value of interval i."
  },
  {
    "objectID": "/rsh/compute/#p_386",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} getUntrackedFunds(?token) takes an optional {!rsh} Token argument and returns the difference between the actual balance of the contract and Reach's expectation of the balance for the given token, or network token if no argument is provided. For example, if funds were externally sent to the contract or rewards were earned, this function gives you access to them. Once this function is called, the amount returned is incorporated into Reach's expectation of the balance. So, the amount returned must eventually be transferred out of the contract to satisfy the token linearity property."
  },
  {
    "objectID": "/rsh/compute/#p_387",
    "pt": "Computations",
    "t": 3,
    "c": "If a contract were to have its funds improperly removed, through clawback or other means, and the actual balance is less than Reach's expectation, this function will return {!rsh} 0."
  },
  {
    "objectID": "/rsh/compute/#p_388",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_389",
    "pt": "Computations",
    "t": 3,
    "c": "The untracked tokens are set to x and then transferred to B."
  },
  {
    "objectID": "/rsh/compute/#p_390",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} distinct(...args) evaluates to {!rsh} true when all its arguments are distinct from each other."
  },
  {
    "objectID": "/rsh/compute/#p_391",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_392",
    "pt": "Computations",
    "t": 3,
    "c": "This code makes an assumption that all the {!rsh} tokens passed into the {!rsh} distinct method are clearly different from each other."
  },
  {
    "objectID": "/rsh/consensus/#rsh_commit",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "commit"
  },
  {
    "objectID": "/rsh/consensus/#rsh_Participant.set",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "Participant.set"
  },
  {
    "objectID": "/rsh/consensus/#rsh_while",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "while"
  },
  {
    "objectID": "/rsh/consensus/#rsh_var",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "var"
  },
  {
    "objectID": "/rsh/consensus/#rsh_invariant",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "invariant"
  },
  {
    "objectID": "/rsh/consensus/#rsh_continue",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "continue"
  },
  {
    "objectID": "/rsh/consensus/#rsh_parallelReduce",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "parallelReduce"
  },
  {
    "objectID": "/rsh/consensus/#rsh_parallelReduce.define",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "parallelReduce.define"
  },
  {
    "objectID": "/rsh/consensus/#rsh_parallelReduce.invariant",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "parallelReduce.invariant"
  },
  {
    "objectID": "/rsh/consensus/#rsh_parallelReduce.while",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "parallelReduce.while"
  },
  {
    "objectID": "/rsh/consensus/#rsh_parallelReduce.paySpec",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "parallelReduce.paySpec"
  },
  {
    "objectID": "/rsh/consensus/#rsh_parallelReduce.case",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "parallelReduce.case"
  },
  {
    "objectID": "/rsh/consensus/#rsh_parallelReduce.api",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "parallelReduce.api"
  },
  {
    "objectID": "/rsh/consensus/#rsh_parallelReduce.api_",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "parallelReduce.api_"
  },
  {
    "objectID": "/rsh/consensus/#rsh_parallelReduce.timeout",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "parallelReduce.timeout"
  },
  {
    "objectID": "/rsh/consensus/#rsh_parallelReduce.timeRemaining",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "parallelReduce.timeRemaining"
  },
  {
    "objectID": "/rsh/consensus/#rsh_parallelReduce.throwTimeout",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "parallelReduce.throwTimeout"
  },
  {
    "objectID": "/rsh/consensus/#rsh_transfer",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "transfer"
  },
  {
    "objectID": "/rsh/consensus/#rsh_transfer.to",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "transfer.to"
  },
  {
    "objectID": "/rsh/consensus/#rsh_require",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "require"
  },
  {
    "objectID": "/rsh/consensus/#rsh_checkCommitment",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "checkCommitment"
  },
  {
    "objectID": "/rsh/consensus/#rsh_burn",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "burn"
  },
  {
    "objectID": "/rsh/consensus/#rsh_Token.burn",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "Token.burn"
  },
  {
    "objectID": "/rsh/consensus/#rsh_destroy",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "destroy"
  },
  {
    "objectID": "/rsh/consensus/#rsh_Token.destroy",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "Token.destroy"
  },
  {
    "objectID": "/rsh/consensus/#rsh_supply",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "supply"
  },
  {
    "objectID": "/rsh/consensus/#rsh_Token.supply",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "Token.supply"
  },
  {
    "objectID": "/rsh/consensus/#rsh_destroyed",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "destroyed"
  },
  {
    "objectID": "/rsh/consensus/#rsh_Token.destroyed",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "Token.destroyed"
  },
  {
    "objectID": "/rsh/consensus/#rsh_remote",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "remote"
  },
  {
    "objectID": "/rsh/consensus/#rsh_REMOTE_FUN",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "REMOTE_FUN"
  },
  {
    "objectID": "/rsh/consensus/#rsh_bill",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "bill"
  },
  {
    "objectID": "/rsh/consensus/#rsh_withBill",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "withBill"
  },
  {
    "objectID": "/rsh/consensus/#rsh_remote.ALGO",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "remote.ALGO"
  },
  {
    "objectID": "/rsh/consensus/#rsh_Map",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "Map"
  },
  {
    "objectID": "/rsh/consensus/#rsh_Set",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "Set"
  },
  {
    "objectID": "/rsh/consensus/#rsh_Set.insert",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "Set.insert"
  },
  {
    "objectID": "/rsh/consensus/#rsh_Set.remove",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "Set.remove"
  },
  {
    "objectID": "/rsh/consensus/#rsh_Set.member",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "Set.member"
  },
  {
    "objectID": "/rsh/consensus/#rsh_Set.Map",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "Set.Map"
  },
  {
    "objectID": "/rsh/consensus/#rsh_new%20Contract",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "new Contract"
  },
  {
    "objectID": "/rsh/consensus/#rsh_Contract.new",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "Contract.new"
  },
  {
    "objectID": "/rsh/consensus/#term_commit%20statement",
    "pt": "Consensus Steps",
    "t": 1,
    "c": "commit statement"
  },
  {
    "objectID": "/rsh/consensus/#term_view%20object",
    "pt": "Consensus Steps",
    "t": 1,
    "c": "view object"
  },
  {
    "objectID": "/rsh/consensus/#term_event%20object",
    "pt": "Consensus Steps",
    "t": 1,
    "c": "event object"
  },
  {
    "objectID": "/rsh/consensus/#term_while%20statement",
    "pt": "Consensus Steps",
    "t": 1,
    "c": "while statement"
  },
  {
    "objectID": "/rsh/consensus/#term_loop%20invariant",
    "pt": "Consensus Steps",
    "t": 1,
    "c": "loop invariant"
  },
  {
    "objectID": "/rsh/consensus/#term_continue%20statement",
    "pt": "Consensus Steps",
    "t": 1,
    "c": "continue statement"
  },
  {
    "objectID": "/rsh/consensus/#term_parallel%20reduce%20statement",
    "pt": "Consensus Steps",
    "t": 1,
    "c": "parallel reduce statement"
  },
  {
    "objectID": "/rsh/consensus/#term_transfer%20expression",
    "pt": "Consensus Steps",
    "t": 1,
    "c": "transfer expression"
  },
  {
    "objectID": "/rsh/consensus/#term_token%20minting",
    "pt": "Consensus Steps",
    "t": 1,
    "c": "token minting"
  },
  {
    "objectID": "/rsh/consensus/#term_burn",
    "pt": "Consensus Steps",
    "t": 1,
    "c": "burn"
  },
  {
    "objectID": "/rsh/consensus/#term_remote%20object",
    "pt": "Consensus Steps",
    "t": 1,
    "c": "remote object"
  },
  {
    "objectID": "/rsh/consensus/#term_remote%20functions",
    "pt": "Consensus Steps",
    "t": 1,
    "c": "remote functions"
  },
  {
    "objectID": "/rsh/consensus/#ref-programs-consensus",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "Consensus Steps"
  },
  {
    "objectID": "/rsh/consensus/#ref-programs-consensus-stmts",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "Statements"
  },
  {
    "objectID": "/rsh/consensus/#commit",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "commit"
  },
  {
    "objectID": "/rsh/consensus/#ref-programs-only-consensus",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "only and each"
  },
  {
    "objectID": "/rsh/consensus/#ref-programs-consensus-view",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "View Objects"
  },
  {
    "objectID": "/rsh/consensus/#ref-programs-consensus-events",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "Event Objects"
  },
  {
    "objectID": "/rsh/consensus/#participantset--and--set",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "Participant.set and .set"
  },
  {
    "objectID": "/rsh/consensus/#while",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "while"
  },
  {
    "objectID": "/rsh/consensus/#continue",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "continue"
  },
  {
    "objectID": "/rsh/consensus/#parallelreduce",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "parallelReduce"
  },
  {
    "objectID": "/rsh/consensus/#timeremaining",
    "pt": "Consensus Steps",
    "t": 2,
    "c": ".timeRemaining"
  },
  {
    "objectID": "/rsh/consensus/#throwtimeout",
    "pt": "Consensus Steps",
    "t": 2,
    "c": ".throwTimeout"
  },
  {
    "objectID": "/rsh/consensus/#parallelreduce--intuition",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "parallelReduce intuition"
  },
  {
    "objectID": "/rsh/consensus/#ref-programs-consensus-exprs",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "Expressions"
  },
  {
    "objectID": "/rsh/consensus/#ref-programs-consensus-this",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "this"
  },
  {
    "objectID": "/rsh/consensus/#transfer",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "transfer"
  },
  {
    "objectID": "/rsh/consensus/#require",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "require"
  },
  {
    "objectID": "/rsh/consensus/#checkcommitment",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "checkCommitment"
  },
  {
    "objectID": "/rsh/consensus/#ref-programs-consensus-token-minting",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "Token minting"
  },
  {
    "objectID": "/rsh/consensus/#remote-objects",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "Remote objects"
  },
  {
    "objectID": "/rsh/consensus/#mappings-creation-and-modification",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "Mappings: creation and modification"
  },
  {
    "objectID": "/rsh/consensus/#sets-creation-and-modification",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "Sets: creation and modification"
  },
  {
    "objectID": "/rsh/consensus/#ref-programs-consensus-new-contract",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "Contract creation"
  },
  {
    "objectID": "/rsh/consensus/#p_0",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A Reach consensus step occurs in the continuation of a consensus transfer statement. It represents the actions taken by the consensus network contract of an application."
  },
  {
    "objectID": "/rsh/consensus/#p_1",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Any statements valid for a computation are valid for a consensus step. However, some additional statements are allowed."
  },
  {
    "objectID": "/rsh/consensus/#p_2",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A commit statement, written {!rsh} commit();, commits to statement's continuation as the next step of the DApp computation. In other words, it ends the current consensus step and allows more local steps."
  },
  {
    "objectID": "/rsh/consensus/#p_3",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "For example, in the code below, the {!rsh} commit(); on line 79 allows Alice to perform a local step after a consensus step:"
  },
  {
    "objectID": "/rsh/consensus/#p_4",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "only and each are allowed in consensus steps and are executed by backends once they observe the completion of the consensus step (i.e., after the associated commit statement.)"
  },
  {
    "objectID": "/rsh/consensus/#p_5",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Views are defined in application initialization in Reach. They are accessed by frontends by using the Reach standard library of the frontend language, such as JavaScript. This section is about defining the value of a view in your Reach program."
  },
  {
    "objectID": "/rsh/consensus/#p_6",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "If {!rsh} VIEW is a view object, then its fields are the elements of the associated view. Each of these fields are bound to an object with a set method that accepts the function or value to be bound to that view at the current step, and all steps dominated by the current step (unless otherwise overridden). If this function is not provided with an argument, then the corresponding view is unset."
  },
  {
    "objectID": "/rsh/consensus/#p_7",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "For example, consider the following program:"
  },
  {
    "objectID": "/rsh/consensus/#p_8",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "In this program, the Reach backend calls the frontend {!rsh} interact function, {!rsh} checkView with the expected value of the views at each point in the program. The frontend compares that value with what is returned by"
  },
  {
    "objectID": "/rsh/consensus/#p_9",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "When a view is bound to a function, it may inspect any values in its scope, including linear state."
  },
  {
    "objectID": "/rsh/consensus/#p_10",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "If {!rsh} EVENT is an event object, then its fields are the elements of the associated event. Each of these fields are a function, whose domain is specified by the {!rsh} Events interface."
  },
  {
    "objectID": "/rsh/consensus/#p_11",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "For example, consider the following program:"
  },
  {
    "objectID": "/rsh/consensus/#p_12",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "In this program, there is an announcement made every loop; an event is emitted with the published {!rsh} ctc and its corresponding index {!rsh} i. A frontend may observe the values of these events with {!js} await ctc.e.Announcer.announce.next() or {!js} await ctc.e.Announcer.announce.monitor(announceHandler) where {!js} announceHandler is a function."
  },
  {
    "objectID": "/rsh/consensus/#p_13",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "After execution, the given participant is fixed to the given address. It is invalid to attempt to {!rsh} .set a participant class. If a backend is running for this participant and its address does not match the given address, then it will abort. This may only occur within a consensus step."
  },
  {
    "objectID": "/rsh/consensus/#p_14",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Relay Account is a good introductory project that demonstrates how to use this feature of Reach."
  },
  {
    "objectID": "/rsh/consensus/#p_15",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/consensus/#p_16",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Alice first publishes the amount and the participant, relay, that will receive the amount, and then completes a {!rsh} pay action. Then, the address of Relay is {!rsh} set in the consensus step, to make sure it is remembered by the consensus. This code is also an assert that relay is the address of the participant Relay."
  },
  {
    "objectID": "/rsh/consensus/#p_17",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A while statement may occur within a consensus step and is written:"
  },
  {
    "objectID": "/rsh/consensus/#p_18",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "where {!rsh} LHS is a valid left-hand side of an identifier definition where the expression {!rsh} INIT_EXPR is the right-hand side, and {!rsh} DEFINE_BLOCK is an optional block that may define bindings that use the {!rsh} LHS values which are bound inside the rest of the {!rsh} while and its tail, and {!rsh} INVARIANT_EXPR is an expression, called the loop invariant, that must be true before and after every execution of the block {!rsh} BLOCK—it may be specified multiple times, INVARIANT_MSG is an optional bytes argument, which is included in any reported violation, and if {!rsh} COND_EXPR is true, then the block executes, and if not, then the loop terminates and control transfers to the continuation of the while statement. The identifiers bound by {!rsh} LHS are bound within {!rsh} DEFINE_BLOCK, {!rsh} INVARIANT_EXPR, {!rsh} COND_EXPR, {!rsh} BLOCK, and the tail of the while statement."
  },
  {
    "objectID": "/rsh/consensus/#p_19",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Read about finding loop invariants in the Reach guide."
  },
  {
    "objectID": "/rsh/consensus/#p_20",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A continue statement may occur within a while statement's block and is written:"
  },
  {
    "objectID": "/rsh/consensus/#p_21",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "where the identifiers bound by {!rsh} LHS are a subset of the variables bound by the nearest enclosing while statement and {!rsh} UPDATE_EXPR is an expression which may be bound by {!rsh} LHS."
  },
  {
    "objectID": "/rsh/consensus/#p_22",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A continue statement is a terminator statement, so it must have an empty tail."
  },
  {
    "objectID": "/rsh/consensus/#p_23",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A continue statement may be written without the preceding identifier update, which is equivalent to writing"
  },
  {
    "objectID": "/rsh/consensus/#p_24",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A continue statement must be dominated by a consensus transfer, which means that the body of a while statement must always {!rsh} commit(); before calling {!rsh} continue;. This restriction may be lifted in future versions of Reach, which will perform termination checking."
  },
  {
    "objectID": "/rsh/consensus/#p_25",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "As a special case, a continue statement may occur in a step, if the {!rsh} UPDATE_EXPR transitions to a consensus step. In other words, this is a valid program:"
  },
  {
    "objectID": "/rsh/consensus/#p_26",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The following example displays how a {!rsh} continue is used inside of a {!rsh} while loop that started in line 43. Bob and Alice race to be the first to {!rsh} publish and therefore be the round winner. When one of them publishes, the keepGoing function returns false, and the program hits {!rsh} continue where it exits the {!rsh} race and moves on with the rest of the program."
  },
  {
    "objectID": "/rsh/consensus/#p_27",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "If you're unsure of what kind of consensus transfer to use, you may want to read the explanation of the differences in the Guide."
  },
  {
    "objectID": "/rsh/consensus/#p_28",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A parallel reduce statement is written:"
  },
  {
    "objectID": "/rsh/consensus/#p_29",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The {!rsh} LHS and {!rsh} INIT_EXPR are like the initialization component of a {!rsh} while loop; and, the {!rsh} .invariant and {!rsh} .while components are like the invariant and condition of a {!rsh} while loop; multiple .invariants may be specified; the {!rsh} DEFINE_BLOCK is like the {!rsh} DEFINE_BLOCK of a {!rsh} while loop. It may be specified multiple times; while the {!rsh} .case, {!rsh} .api, {!rsh} .api_, {!rsh} .timeout, and {!rsh} .paySpec components are like the corresponding components of a {!rsh} fork statement."
  },
  {
    "objectID": "/rsh/consensus/#p_30",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The {!rsh} .case component may be repeated many times, just like in a {!rsh} fork statement."
  },
  {
    "objectID": "/rsh/consensus/#p_31",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The {!rsh} .define component may define bindings that reference the {!rsh} LHS values. These bindings are accessible from every component of the {!rsh} parallelReduce statement, except for the {!rsh} INIT_EXPR."
  },
  {
    "objectID": "/rsh/consensus/#p_32",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "When dealing with absolute deadlines in {!rsh} parallelReduce, there is a common pattern in the {!rsh} TIMEOUT_BLOCK to have participants {!rsh} race to {!rsh} publish and return the accumulator. There is a shorthand, {!rsh} .timeRemaining, available for this situation:"
  },
  {
    "objectID": "/rsh/consensus/#p_33",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "which will expand to:"
  },
  {
    "objectID": "/rsh/consensus/#p_34",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} .throwTimeout is a shorthand that will throw the accumulator as an exception when a timeout occurs. Therefore, a {!rsh} parallelReduce that uses this branch must be inside of a try statement. For example,"
  },
  {
    "objectID": "/rsh/consensus/#p_35",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "will expand {!rsh} throwTimeout to:"
  },
  {
    "objectID": "/rsh/consensus/#p_36",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A parallel reduce statement is essentially an abbreviation of pattern of a {!rsh} while loop combined with a {!rsh} fork statement that you could write yourself. This is an extremely common pattern in decentralized applications."
  },
  {
    "objectID": "/rsh/consensus/#p_37",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The idea is that there are some values (the {!rsh} LHS) which after intialization will be repeatedly updated uniquely by each of the racing participants until the condition does not hold."
  },
  {
    "objectID": "/rsh/consensus/#p_38",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Any expressions valid for a computation are valid for a consensus step. However, some additional expressions are allowed."
  },
  {
    "objectID": "/rsh/consensus/#p_39",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Inside of a consensus step, {!rsh} this refers to the address of the participant that performed the consensus transfer. This is useful when the consensus transfer was initiated by a {!rsh} race expression."
  },
  {
    "objectID": "/rsh/consensus/#p_40",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A transfer expression, written {!rsh} transfer(PAY_AMOUNT_EXPR).to(ADDR_EXPR), where {!rsh} PAY_AMOUNT_EXPR is an expression that evaluates to a pay amount, and {!rsh} ADDR_EXPR evaluates to an address, performs a transfer of network tokens or non-network tokens from the contract to the named participant. The amount transfered must evaluate to less than or equal to the balance of the network and non-network tokens in the contract account."
  },
  {
    "objectID": "/rsh/consensus/#p_41",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A transfer expression may only occur within a consensus step."
  },
  {
    "objectID": "/rsh/consensus/#p_42",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The first {!rsh} transfer example from the Simple NFT Auction pays the lastPrice to the NFT Creator. The second {!rsh} transfer example gives the sale quantity of the NFT to the {!rsh} Participant that bid the highest price."
  },
  {
    "objectID": "/rsh/consensus/#p_43",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A requirement where {!rsh} claim evaluates to {!rsh} true with honest participants. This may only appear in a consensus step. It accepts an optional bytes argument, which is included in any reported violation."
  },
  {
    "objectID": "/rsh/consensus/#p_44",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "If a publication would violate the requirement, the consensus network rejects the transaction."
  },
  {
    "objectID": "/rsh/consensus/#p_45",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The example above has Alice publish two tokens named token1 and token2 and the {!rsh} require statement checks if they are different tokens. If they are not different tokens, then the transaction is rejected."
  },
  {
    "objectID": "/rsh/consensus/#p_46",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Makes a requirement that {!rsh} commitment is the digest of {!rsh} salt and {!rsh} x. This is used in a consensus step after {!rsh} makeCommitment was used in a local step."
  },
  {
    "objectID": "/rsh/consensus/#p_47",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The example below shows {!rsh} checkCommitment being used in a consensus step on line 87 after {!rsh} makeCommitment was used in a local step on line 66:"
  },
  {
    "objectID": "/rsh/consensus/#p_48",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Networks discusses how Reach supports token minting on specific consensus networks."
  },
  {
    "objectID": "/rsh/consensus/#p_49",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "We refer to creation of a new non-network token as token minting. It is written with the expression {!rsh} new Token(PARAMS), where {!rsh} PARAMS is an object with the following keys:"
  },
  {
    "objectID": "/rsh/consensus/#p_50",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "name: A value of type {!rsh} Bytes(32); defaults to empty."
  },
  {
    "objectID": "/rsh/consensus/#p_51",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "symbol: A value of type {!rsh} Bytes(8); defaults to empty."
  },
  {
    "objectID": "/rsh/consensus/#p_52",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "url: A value of type {!rsh} Bytes(96); defaults to empty."
  },
  {
    "objectID": "/rsh/consensus/#p_53",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "metadata: A value of type {!rsh} Bytes(32); defaults to empty. This value is intended to be a digest of a larger metadata document."
  },
  {
    "objectID": "/rsh/consensus/#p_54",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "supply: A value of type {!rsh} UInt; defaults to {!rsh} UInt.max."
  },
  {
    "objectID": "/rsh/consensus/#p_55",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "decimals: A value of type {!rsh} UInt; defaults to {!rsh} 6 on Algorand, and {!rsh} 18 on Ethereum and Conflux."
  },
  {
    "objectID": "/rsh/consensus/#p_56",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The following examples demonstrate how the details above may be used:"
  },
  {
    "objectID": "/rsh/consensus/#p_57",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "This returns a {!rsh} Token value and deposits a {!rsh} supply amount of the new non-network tokens into the contract account associated with the DApp. These tokens must be destroyed by the end of the DApp."
  },
  {
    "objectID": "/rsh/consensus/#p_58",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Reach assumes that network tokens and non-network tokens behave identically, but often they do not; this article discusses the causes and consequences of this."
  },
  {
    "objectID": "/rsh/consensus/#p_59",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} Token.burn(tok, amt), or {!rsh} tok.burn(amt), where {!rsh} tok is a {!rsh} Token value and {!rsh} amt is a {!rsh} UInt value, may be used to burn tokens in the contract account, meaning that they are utterly destroyed and can never be recovered."
  },
  {
    "objectID": "/rsh/consensus/#p_60",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} Token.destroy(tok), or {!rsh} tok.destroy(), where {!rsh} tok is a {!rsh} Token value, may be used to destroy the token so that it may never be used again by any users on the consensus network. This must be called before the application exits."
  },
  {
    "objectID": "/rsh/consensus/#p_61",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} Token.destroyed(tok), or {!rsh} tok.destroyed(), where {!rsh} tok is a {!rsh} Token value, returns whether {!rsh} destroy has been called on {!rsh} tok yet."
  },
  {
    "objectID": "/rsh/consensus/#p_62",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} Token.supply(tok), or {!rsh} tok.supply(), where {!rsh} tok is a {!rsh} Token value, may be used to query the current supply of tokens, i.e. the number of tokens which have not been burnt."
  },
  {
    "objectID": "/rsh/consensus/#p_63",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Networks discusses how Reach supports remote objects on specific consensus networks."
  },
  {
    "objectID": "/rsh/consensus/#p_64",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A remote object represents a foreign contract in a Reach application. During a consensus step, a Reach computation may consensually communicate with such an object via a prescribed interface."
  },
  {
    "objectID": "/rsh/consensus/#p_65",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A remote object is constructed by calling the {!rsh} remote function with a {!rsh} Contract, an interface---an object where each key is bound to a function type, and an optional object of aliases. The alias object maps function names from the interface to function names on the remote contract. It allows users to bind specific instances of an overloaded remote function. For example:"
  },
  {
    "objectID": "/rsh/consensus/#p_66",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "In this example, the random oracle contract has an overloaded method, random. This random method accepts 0 or 1 parameters. We explicitly specify that getRandom refers to calling the random function with no arguments, and getRandom1 refers to calling the random function with 1 argument."
  },
  {
    "objectID": "/rsh/consensus/#p_67",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Once constructed, the fields of a remote object represent those remote contract interactions, referred to as remote functions. For example, {!rsh} randomOracle.getRandom, {!rsh} token.balanceOf, and {!rsh} token.transferTo are remote functions in the example."
  },
  {
    "objectID": "/rsh/consensus/#p_68",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A remote function may be invoked by calling it with the appropriate arguments, whereupon it returns the specified output. In addition, a remote function may be augmented with one of the following operations:"
  },
  {
    "objectID": "/rsh/consensus/#p_69",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} REMOTE_FUN.pay(AMT) --- Returns a remote function that receives a pay amount, {!rsh} AMT, from the caller when it is called."
  },
  {
    "objectID": "/rsh/consensus/#p_70",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} REMOTE_FUN.bill(AMT) --- Returns a remote function that provides a pay amount, {!rsh} AMT, to the caller when it returns."
  },
  {
    "objectID": "/rsh/consensus/#p_71",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} REMOTE_FUN.withBill() --- Returns a remote function that provides some number of network tokens and, possibly, non-network tokens to the caller when it returns. The exact amount is returned from the invocation by wrapping the original result in a tuple."
  },
  {
    "objectID": "/rsh/consensus/#p_72",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} REMOTE_FUN.ALGO(opts) --- Returns a remote function that records the need for additional resources on Algorand.72 {!rsh} opts.fees records extra fees. If this is needed, and not included, then the consensus transfer to the current consensus step will fail with an insufficient fee error.73 {!rsh} opts.assets records extra assets. If this is needed, and not included, then the consensus transfer to the current consensus step will fail with an invalid asset reference.74 {!rsh} opts.apps records extra applications. If this is needed, and not included, then the consensus transfer to the current consensus step will fail with an invalid application reference.75 {!rsh} opts.addressToAccount changes {!rsh} Address arguments to Account array references. If this is needed, and not included, then the consensus transfer to the current consensus step will fail because an incorrectly typed argument was provided to the remote object.76 {!rsh} opts.onCompletion sets the OnCompletion field of the transaction. The value is a string for the field value; e.g., {!rsh} 'DeleteApplication'. It is dangerous to call this with OptIn, because the minimum balance of the calling contract will increase and Reach cannot track that, because it is not statically available. The minimum balance will decrease on a CloseOut or ClearState transaction."
  },
  {
    "objectID": "/rsh/consensus/#p_73",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} opts.fees records extra fees. If this is needed, and not included, then the consensus transfer to the current consensus step will fail with an insufficient fee error."
  },
  {
    "objectID": "/rsh/consensus/#p_74",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} opts.assets records extra assets. If this is needed, and not included, then the consensus transfer to the current consensus step will fail with an invalid asset reference."
  },
  {
    "objectID": "/rsh/consensus/#p_75",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} opts.apps records extra applications. If this is needed, and not included, then the consensus transfer to the current consensus step will fail with an invalid application reference."
  },
  {
    "objectID": "/rsh/consensus/#p_76",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} opts.addressToAccount changes {!rsh} Address arguments to Account array references. If this is needed, and not included, then the consensus transfer to the current consensus step will fail because an incorrectly typed argument was provided to the remote object."
  },
  {
    "objectID": "/rsh/consensus/#p_77",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} opts.onCompletion sets the OnCompletion field of the transaction. The value is a string for the field value; e.g., {!rsh} 'DeleteApplication'. It is dangerous to call this with OptIn, because the minimum balance of the calling contract will increase and Reach cannot track that, because it is not statically available. The minimum balance will decrease on a CloseOut or ClearState transaction."
  },
  {
    "objectID": "/rsh/consensus/#p_78",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "If the remote contract is not expected to return non-network tokens then a pair is returned, where the amount of network tokens received is the first element, and the original result is the second element."
  },
  {
    "objectID": "/rsh/consensus/#p_79",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "If the remote contract is expected to return non-network tokens then a triple is returned, where the amount of network tokens received is the first element, a tuple of the non-network tokens received is the second element, and the original result is the third element. If the caller expects to receive non-network tokens, they must provide a tuple of tokens as an argument to {!rsh} withBill. The ordering of tokens in the argument is preserved when returning the amounts received. For example,"
  },
  {
    "objectID": "/rsh/consensus/#p_80",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "might be the way to communicate with a random oracle that receives a conservative approximation of its actual cost and returns what it does not use, along with some amount of network tokens, GIL, and ZMD. This operation may not be used with {!rsh} REMOTE_FUN.bill."
  },
  {
    "objectID": "/rsh/consensus/#p_81",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A new mapping of linear state may be constructed in a consensus step by writing {!rsh} new Map(VAL_TYPE_EXPR) or {!rsh} new Map(KEY_TYPE_EXPR, VAL_TYPE_EXPR), where {!rsh} KEY_TYPE_EXPR and {!rsh} VAL_TYPE_EXPR are types. If {!rsh} KEY_TYPE_EXPR is not specified, it will default to {!rsh} Address."
  },
  {
    "objectID": "/rsh/consensus/#p_82",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "For example the code below contains only the {!rsh} VAL_TYPE_EXPR:"
  },
  {
    "objectID": "/rsh/consensus/#p_83",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "While the following code contains both the {!rsh} KEY_TYPE_EXPR and {!rsh} VAL_TYPE_EXPR:"
  },
  {
    "objectID": "/rsh/consensus/#p_84",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "These examples return a value which may be used to dereference particular mappings via {!rsh} map[EXPR]. Such dereferences return a value of type {!rsh} Maybe(VAL_TYPE_EXPR), because the mapping may not contain a value for {!rsh} EXPR."
  },
  {
    "objectID": "/rsh/consensus/#p_85",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A mapping may be modified by writing {!rsh} map[EXPR] = VALUE_EXPR to install {!rsh} VALUE_EXPR (of type {!rsh} VAL_TYPE_EXPR) at {!rsh} EXPR, or by writing {!rsh} delete map[EXPR] to remove the mapping entry. Such modifications may only occur in a consensus step."
  },
  {
    "objectID": "/rsh/consensus/#p_86",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "N+2 relations can be created by using a {!rsh} Tuple as the Map key. For example, a nested mapping: {!rsh} Map(Address, Map(Address, UInt)), can be simulated by coalescing the Map keys into a {!rsh} Tuple: {!rsh} Map(Tuple(Address, Address), UInt)."
  },
  {
    "objectID": "/rsh/consensus/#p_87",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A {!rsh} Set is another container for linear state. It is simply a type alias of {!rsh} Map(Null); it is only useful for tracking {!rsh} Addresses. Because a {!rsh} Set is internally a {!rsh} Map, it may only be constructed in a consensus step."
  },
  {
    "objectID": "/rsh/consensus/#p_88",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A {!rsh} Set may be modified by writing {!rsh} s.insert(ADDRESS) to install {!rsh} ADDRESS in the set, {!rsh} s, or {!rsh} s.remove(ADDRESS) to remove the {!rsh} ADDRESS from the set. Such modifications may only occur in a consensus step."
  },
  {
    "objectID": "/rsh/consensus/#p_89",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The following example shows the usage of {!rsh} s.insert(ADDRESS):"
  },
  {
    "objectID": "/rsh/consensus/#p_90",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "While the example below shows the usage of {!rsh} s.remove(ADDRESS)"
  },
  {
    "objectID": "/rsh/consensus/#p_91",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "To check whether an address is in the set, {!rsh} s.member(ADDRESS) is used."
  },
  {
    "objectID": "/rsh/consensus/#p_92",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The following example shows the usage of {!rsh} s.member(ADDRESS)"
  },
  {
    "objectID": "/rsh/consensus/#p_93",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} s.Map will return the underlying {!rsh} Map, so you can use foldable instance methods."
  },
  {
    "objectID": "/rsh/consensus/#p_94",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Reach programs can create new child contracts based on predetermined, static code during compile time. This code is specified with {!rsh} ContractCode, which you can read about in Contract code definition."
  },
  {
    "objectID": "/rsh/consensus/#p_95",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Given some child contract code, indicated by the variable {!rsh} cc, you can create a constructor function with:"
  },
  {
    "objectID": "/rsh/consensus/#p_96",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "where opts is an optional object. Each enabled connector accepts its own options in a field with the name of the connector."
  },
  {
    "objectID": "/rsh/consensus/#p_97",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The {!rsh} ETH connector accepts no options."
  },
  {
    "objectID": "/rsh/consensus/#p_98",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The {!rsh} ALGO connector accepts the keys:"
  },
  {
    "objectID": "/rsh/consensus/#p_99",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} opts.globalUints --- The number of unsigned integers in the global storage of the contract."
  },
  {
    "objectID": "/rsh/consensus/#p_100",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} opts.globalBytes --- The number of byte strings in the global storage of the contract."
  },
  {
    "objectID": "/rsh/consensus/#p_101",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} opts.localUints --- The number of unsigned integers in the local storage of the contract."
  },
  {
    "objectID": "/rsh/consensus/#p_102",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} opts.localBytes --- The number of byte strings in the local storage of the contract."
  },
  {
    "objectID": "/rsh/consensus/#p_103",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "If these options are required, but not present, then the contract will behave incorrectly."
  },
  {
    "objectID": "/rsh/consensus/#p_104",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The constructor function must be called to actually create the contract. It is like a {!rsh} REMOTE_FUN}, but it cannot be augmented, nor can it receive payment. It returns a {!rsh} Contract value for the newly created contract."
  },
  {
    "objectID": "/rsh/consensus/#p_105",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Why can't you augment constructor calls?"
  },
  {
    "objectID": "/rsh/consensus/#p_106",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Some constructor augmentations, like those specific for a particular network, could work, but are not supported by Reach presently. Others, such as token payments, cannot work at all, because given that the contract doesn't exist yet, there's no way to know where to send the tokens to."
  },
  {
    "objectID": "/rsh/consensus/#p_107",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "On some connectors, like {!rsh} ALGO, it is necessary to delete child contracts before the parent exits. Reach does not yet enforce this property during verification, so if you fail to obey it, then your program will not be able to finish."
  },
  {
    "objectID": "/rsh/errors/#rsh_async",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "async"
  },
  {
    "objectID": "/rsh/errors/#rsh_await",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "await"
  },
  {
    "objectID": "/rsh/errors/#rsh_break",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "break"
  },
  {
    "objectID": "/rsh/errors/#rsh_catch",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "catch"
  },
  {
    "objectID": "/rsh/errors/#rsh_class",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "class"
  },
  {
    "objectID": "/rsh/errors/#rsh_debugger",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "debugger"
  },
  {
    "objectID": "/rsh/errors/#rsh_delete",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "delete"
  },
  {
    "objectID": "/rsh/errors/#rsh_do",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "do"
  },
  {
    "objectID": "/rsh/errors/#rsh_enum",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "enum"
  },
  {
    "objectID": "/rsh/errors/#rsh_extends",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "extends"
  },
  {
    "objectID": "/rsh/errors/#rsh_for",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "for"
  },
  {
    "objectID": "/rsh/errors/#rsh_in",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "in"
  },
  {
    "objectID": "/rsh/errors/#rsh_instanceOf",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "instanceOf"
  },
  {
    "objectID": "/rsh/errors/#rsh_let",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "let"
  },
  {
    "objectID": "/rsh/errors/#rsh_of",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "of"
  },
  {
    "objectID": "/rsh/errors/#rsh_static",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "static"
  },
  {
    "objectID": "/rsh/errors/#rsh_throw",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "throw"
  },
  {
    "objectID": "/rsh/errors/#rsh_try",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "try"
  },
  {
    "objectID": "/rsh/errors/#rsh_with",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "with"
  },
  {
    "objectID": "/rsh/errors/#rsh_yield",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "yield"
  },
  {
    "objectID": "/rsh/errors/#ref-error-codes",
    "pt": "Error Codes",
    "t": 2,
    "c": "Error Codes"
  },
  {
    "objectID": "/rsh/errors/#RA0000",
    "pt": "Error Codes",
    "t": 2,
    "c": "RA0000"
  },
  {
    "objectID": "/rsh/errors/#RA0001",
    "pt": "Error Codes",
    "t": 2,
    "c": "RA0001"
  },
  {
    "objectID": "/rsh/errors/#RC0000",
    "pt": "Error Codes",
    "t": 2,
    "c": "RC0000"
  },
  {
    "objectID": "/rsh/errors/#RE0000",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0000"
  },
  {
    "objectID": "/rsh/errors/#RE0001",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0001"
  },
  {
    "objectID": "/rsh/errors/#RE0002",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0002"
  },
  {
    "objectID": "/rsh/errors/#RE0003",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0003"
  },
  {
    "objectID": "/rsh/errors/#RE0004",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0004"
  },
  {
    "objectID": "/rsh/errors/#RE0005",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0005"
  },
  {
    "objectID": "/rsh/errors/#RE0006",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0006"
  },
  {
    "objectID": "/rsh/errors/#RE0007",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0007"
  },
  {
    "objectID": "/rsh/errors/#RE0008",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0008"
  },
  {
    "objectID": "/rsh/errors/#RE0009",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0009"
  },
  {
    "objectID": "/rsh/errors/#RE0010",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0010"
  },
  {
    "objectID": "/rsh/errors/#RE0011",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0011"
  },
  {
    "objectID": "/rsh/errors/#RE0012",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0012"
  },
  {
    "objectID": "/rsh/errors/#RE0013",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0013"
  },
  {
    "objectID": "/rsh/errors/#RE0014",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0014"
  },
  {
    "objectID": "/rsh/errors/#RE0015",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0015"
  },
  {
    "objectID": "/rsh/errors/#RE0016",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0016"
  },
  {
    "objectID": "/rsh/errors/#RE0017",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0017"
  },
  {
    "objectID": "/rsh/errors/#RE0018",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0018"
  },
  {
    "objectID": "/rsh/errors/#RE0019",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0019"
  },
  {
    "objectID": "/rsh/errors/#RE0020",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0020"
  },
  {
    "objectID": "/rsh/errors/#RE0021",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0021"
  },
  {
    "objectID": "/rsh/errors/#RE0022",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0022"
  },
  {
    "objectID": "/rsh/errors/#RE0023",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0023"
  },
  {
    "objectID": "/rsh/errors/#RE0024",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0024"
  },
  {
    "objectID": "/rsh/errors/#RE0025",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0025"
  },
  {
    "objectID": "/rsh/errors/#RE0026",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0026"
  },
  {
    "objectID": "/rsh/errors/#RE0027",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0027"
  },
  {
    "objectID": "/rsh/errors/#RE0028",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0028"
  },
  {
    "objectID": "/rsh/errors/#RE0029",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0029"
  },
  {
    "objectID": "/rsh/errors/#RE0030",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0030"
  },
  {
    "objectID": "/rsh/errors/#RE0031",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0031"
  },
  {
    "objectID": "/rsh/errors/#RE0032",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0032"
  },
  {
    "objectID": "/rsh/errors/#RE0033",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0033"
  },
  {
    "objectID": "/rsh/errors/#RE0034",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0034"
  },
  {
    "objectID": "/rsh/errors/#RE0035",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0035"
  },
  {
    "objectID": "/rsh/errors/#RE0036",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0036"
  },
  {
    "objectID": "/rsh/errors/#RE0037",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0037"
  },
  {
    "objectID": "/rsh/errors/#RE0038",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0038"
  },
  {
    "objectID": "/rsh/errors/#RE0039",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0039"
  },
  {
    "objectID": "/rsh/errors/#RE0040",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0040"
  },
  {
    "objectID": "/rsh/errors/#RE0041",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0041"
  },
  {
    "objectID": "/rsh/errors/#RE0042",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0042"
  },
  {
    "objectID": "/rsh/errors/#RE0043",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0043"
  },
  {
    "objectID": "/rsh/errors/#RE0044",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0044"
  },
  {
    "objectID": "/rsh/errors/#RE0045",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0045"
  },
  {
    "objectID": "/rsh/errors/#RE0046",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0046"
  },
  {
    "objectID": "/rsh/errors/#RE0047",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0047"
  },
  {
    "objectID": "/rsh/errors/#RE0048",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0048"
  },
  {
    "objectID": "/rsh/errors/#RE0049",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0049"
  },
  {
    "objectID": "/rsh/errors/#RE0050",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0050"
  },
  {
    "objectID": "/rsh/errors/#RE0051",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0051"
  },
  {
    "objectID": "/rsh/errors/#RE0052",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0052"
  },
  {
    "objectID": "/rsh/errors/#RE0053",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0053"
  },
  {
    "objectID": "/rsh/errors/#RE0054",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0054"
  },
  {
    "objectID": "/rsh/errors/#RE0055",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0055"
  },
  {
    "objectID": "/rsh/errors/#RE0056",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0056"
  },
  {
    "objectID": "/rsh/errors/#RE0057",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0057"
  },
  {
    "objectID": "/rsh/errors/#RE0058",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0058"
  },
  {
    "objectID": "/rsh/errors/#RE0059",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0059"
  },
  {
    "objectID": "/rsh/errors/#RE0060",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0060"
  },
  {
    "objectID": "/rsh/errors/#RE0061",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0061"
  },
  {
    "objectID": "/rsh/errors/#RE0062",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0062"
  },
  {
    "objectID": "/rsh/errors/#RE0063",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0063"
  },
  {
    "objectID": "/rsh/errors/#RE0064",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0064"
  },
  {
    "objectID": "/rsh/errors/#RE0065",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0065"
  },
  {
    "objectID": "/rsh/errors/#RE0066",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0066"
  },
  {
    "objectID": "/rsh/errors/#RE0067",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0067"
  },
  {
    "objectID": "/rsh/errors/#RE0068",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0068"
  },
  {
    "objectID": "/rsh/errors/#RE0069",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0069"
  },
  {
    "objectID": "/rsh/errors/#RE0070",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0070"
  },
  {
    "objectID": "/rsh/errors/#RE0071",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0071"
  },
  {
    "objectID": "/rsh/errors/#RE0072",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0072"
  },
  {
    "objectID": "/rsh/errors/#RE0073",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0073"
  },
  {
    "objectID": "/rsh/errors/#RE0074",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0074"
  },
  {
    "objectID": "/rsh/errors/#RE0075",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0075"
  },
  {
    "objectID": "/rsh/errors/#RE0076",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0076"
  },
  {
    "objectID": "/rsh/errors/#RE0077",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0077"
  },
  {
    "objectID": "/rsh/errors/#RE0078",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0078"
  },
  {
    "objectID": "/rsh/errors/#RE0079",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0079"
  },
  {
    "objectID": "/rsh/errors/#RE0080",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0080"
  },
  {
    "objectID": "/rsh/errors/#RE0081",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0081"
  },
  {
    "objectID": "/rsh/errors/#RE0082",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0082"
  },
  {
    "objectID": "/rsh/errors/#RE0083",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0083"
  },
  {
    "objectID": "/rsh/errors/#RE0084",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0084"
  },
  {
    "objectID": "/rsh/errors/#RE0085",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0085"
  },
  {
    "objectID": "/rsh/errors/#RE0086",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0086"
  },
  {
    "objectID": "/rsh/errors/#RE0087",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0087"
  },
  {
    "objectID": "/rsh/errors/#RE0088",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0088"
  },
  {
    "objectID": "/rsh/errors/#RE0089",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0089"
  },
  {
    "objectID": "/rsh/errors/#RE0090",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0090"
  },
  {
    "objectID": "/rsh/errors/#RE0091",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0091"
  },
  {
    "objectID": "/rsh/errors/#RE0092",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0092"
  },
  {
    "objectID": "/rsh/errors/#RE0093",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0093"
  },
  {
    "objectID": "/rsh/errors/#RE0094",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0094"
  },
  {
    "objectID": "/rsh/errors/#RE0095",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0095"
  },
  {
    "objectID": "/rsh/errors/#RE0096",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0096"
  },
  {
    "objectID": "/rsh/errors/#RE0097",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0097"
  },
  {
    "objectID": "/rsh/errors/#RE0098",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0098"
  },
  {
    "objectID": "/rsh/errors/#RE0099",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0099"
  },
  {
    "objectID": "/rsh/errors/#RE0100",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0100"
  },
  {
    "objectID": "/rsh/errors/#RE0101",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0101"
  },
  {
    "objectID": "/rsh/errors/#RE0102",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0102"
  },
  {
    "objectID": "/rsh/errors/#RE0103",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0103"
  },
  {
    "objectID": "/rsh/errors/#RE0104",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0104"
  },
  {
    "objectID": "/rsh/errors/#RE0105",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0105"
  },
  {
    "objectID": "/rsh/errors/#RE0106",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0106"
  },
  {
    "objectID": "/rsh/errors/#RE0107",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0107"
  },
  {
    "objectID": "/rsh/errors/#RE0108",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0108"
  },
  {
    "objectID": "/rsh/errors/#RE0109",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0109"
  },
  {
    "objectID": "/rsh/errors/#RE0110",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0110"
  },
  {
    "objectID": "/rsh/errors/#RE0111",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0111"
  },
  {
    "objectID": "/rsh/errors/#RE0112",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0112"
  },
  {
    "objectID": "/rsh/errors/#RE0113",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0113"
  },
  {
    "objectID": "/rsh/errors/#RE0114",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0114"
  },
  {
    "objectID": "/rsh/errors/#RE0115",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0115"
  },
  {
    "objectID": "/rsh/errors/#RE0116",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0116"
  },
  {
    "objectID": "/rsh/errors/#RE0117",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0117"
  },
  {
    "objectID": "/rsh/errors/#RE0118",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0118"
  },
  {
    "objectID": "/rsh/errors/#RE0119",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0119"
  },
  {
    "objectID": "/rsh/errors/#RE0120",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0120"
  },
  {
    "objectID": "/rsh/errors/#RE0121",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0121"
  },
  {
    "objectID": "/rsh/errors/#RE0122",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0122"
  },
  {
    "objectID": "/rsh/errors/#RE0123",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0123"
  },
  {
    "objectID": "/rsh/errors/#RE0124",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0124"
  },
  {
    "objectID": "/rsh/errors/#RE0125",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0125"
  },
  {
    "objectID": "/rsh/errors/#RE0126",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0126"
  },
  {
    "objectID": "/rsh/errors/#RE0127",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0127"
  },
  {
    "objectID": "/rsh/errors/#RE0128",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0128"
  },
  {
    "objectID": "/rsh/errors/#RE0129",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0129"
  },
  {
    "objectID": "/rsh/errors/#RE0130",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0130"
  },
  {
    "objectID": "/rsh/errors/#RE0131",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0131"
  },
  {
    "objectID": "/rsh/errors/#RE0132",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0132"
  },
  {
    "objectID": "/rsh/errors/#RE0133",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0133"
  },
  {
    "objectID": "/rsh/errors/#RE0134",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0134"
  },
  {
    "objectID": "/rsh/errors/#RE0135",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0135"
  },
  {
    "objectID": "/rsh/errors/#RE0136",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0136"
  },
  {
    "objectID": "/rsh/errors/#RE0137",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0137"
  },
  {
    "objectID": "/rsh/errors/#REP0000",
    "pt": "Error Codes",
    "t": 2,
    "c": "REP0000"
  },
  {
    "objectID": "/rsh/errors/#REP0001",
    "pt": "Error Codes",
    "t": 2,
    "c": "REP0001"
  },
  {
    "objectID": "/rsh/errors/#REP0002",
    "pt": "Error Codes",
    "t": 2,
    "c": "REP0002"
  },
  {
    "objectID": "/rsh/errors/#RI0000",
    "pt": "Error Codes",
    "t": 2,
    "c": "RI0000"
  },
  {
    "objectID": "/rsh/errors/#RI0001",
    "pt": "Error Codes",
    "t": 2,
    "c": "RI0001"
  },
  {
    "objectID": "/rsh/errors/#RI0002",
    "pt": "Error Codes",
    "t": 2,
    "c": "RI0002"
  },
  {
    "objectID": "/rsh/errors/#RI0003",
    "pt": "Error Codes",
    "t": 2,
    "c": "RI0003"
  },
  {
    "objectID": "/rsh/errors/#RI0004",
    "pt": "Error Codes",
    "t": 2,
    "c": "RI0004"
  },
  {
    "objectID": "/rsh/errors/#RL0000",
    "pt": "Error Codes",
    "t": 2,
    "c": "RL0000"
  },
  {
    "objectID": "/rsh/errors/#RP0000",
    "pt": "Error Codes",
    "t": 2,
    "c": "RP0000"
  },
  {
    "objectID": "/rsh/errors/#RP0001",
    "pt": "Error Codes",
    "t": 2,
    "c": "RP0001"
  },
  {
    "objectID": "/rsh/errors/#RP0002",
    "pt": "Error Codes",
    "t": 2,
    "c": "RP0002"
  },
  {
    "objectID": "/rsh/errors/#RP0003",
    "pt": "Error Codes",
    "t": 2,
    "c": "RP0003"
  },
  {
    "objectID": "/rsh/errors/#RP0004",
    "pt": "Error Codes",
    "t": 2,
    "c": "RP0004"
  },
  {
    "objectID": "/rsh/errors/#RP0005",
    "pt": "Error Codes",
    "t": 2,
    "c": "RP0005"
  },
  {
    "objectID": "/rsh/errors/#RP0006",
    "pt": "Error Codes",
    "t": 2,
    "c": "RP0006"
  },
  {
    "objectID": "/rsh/errors/#RP0007",
    "pt": "Error Codes",
    "t": 2,
    "c": "RP0007"
  },
  {
    "objectID": "/rsh/errors/#RP0008",
    "pt": "Error Codes",
    "t": 2,
    "c": "RP0008"
  },
  {
    "objectID": "/rsh/errors/#RP0009",
    "pt": "Error Codes",
    "t": 2,
    "c": "RP0009"
  },
  {
    "objectID": "/rsh/errors/#RP0010",
    "pt": "Error Codes",
    "t": 2,
    "c": "RP0010"
  },
  {
    "objectID": "/rsh/errors/#RP0011",
    "pt": "Error Codes",
    "t": 2,
    "c": "RP0011"
  },
  {
    "objectID": "/rsh/errors/#RP0012",
    "pt": "Error Codes",
    "t": 2,
    "c": "RP0012"
  },
  {
    "objectID": "/rsh/errors/#RX0000",
    "pt": "Error Codes",
    "t": 2,
    "c": "RX0000"
  },
  {
    "objectID": "/rsh/errors/#RAPI0000",
    "pt": "Error Codes",
    "t": 2,
    "c": "RAPI0000"
  },
  {
    "objectID": "/rsh/errors/#RAPI0001",
    "pt": "Error Codes",
    "t": 2,
    "c": "RAPI0001"
  },
  {
    "objectID": "/rsh/errors/#RAPI0002",
    "pt": "Error Codes",
    "t": 2,
    "c": "RAPI0002"
  },
  {
    "objectID": "/rsh/errors/#RAPI0003",
    "pt": "Error Codes",
    "t": 2,
    "c": "RAPI0003"
  },
  {
    "objectID": "/rsh/errors/#RAPI0004",
    "pt": "Error Codes",
    "t": 2,
    "c": "RAPI0004"
  },
  {
    "objectID": "/rsh/errors/#RW0000",
    "pt": "Error Codes",
    "t": 2,
    "c": "RW0000"
  },
  {
    "objectID": "/rsh/errors/#RW0001",
    "pt": "Error Codes",
    "t": 2,
    "c": "RW0001"
  },
  {
    "objectID": "/rsh/errors/#RW0002",
    "pt": "Error Codes",
    "t": 2,
    "c": "RW0002"
  },
  {
    "objectID": "/rsh/errors/#RW0003",
    "pt": "Error Codes",
    "t": 2,
    "c": "RW0003"
  },
  {
    "objectID": "/rsh/errors/#RW0004",
    "pt": "Error Codes",
    "t": 2,
    "c": "RW0004"
  },
  {
    "objectID": "/rsh/errors/#problematic-code",
    "pt": "Error Codes",
    "t": 2,
    "c": "Problematic code:"
  },
  {
    "objectID": "/rsh/errors/#correct-code",
    "pt": "Error Codes",
    "t": 2,
    "c": "Correct code:"
  },
  {
    "objectID": "/rsh/errors/#RW0005",
    "pt": "Error Codes",
    "t": 2,
    "c": "RW0005"
  },
  {
    "objectID": "/rsh/errors/#problematic-code-1",
    "pt": "Error Codes",
    "t": 2,
    "c": "Problematic code:"
  },
  {
    "objectID": "/rsh/errors/#correct-code-1",
    "pt": "Error Codes",
    "t": 2,
    "c": "Correct code:"
  },
  {
    "objectID": "/rsh/errors/#RW0006",
    "pt": "Error Codes",
    "t": 2,
    "c": "RW0006"
  },
  {
    "objectID": "/rsh/errors/#problematic-code-2",
    "pt": "Error Codes",
    "t": 2,
    "c": "Problematic code:"
  },
  {
    "objectID": "/rsh/errors/#correct-code-2",
    "pt": "Error Codes",
    "t": 2,
    "c": "Correct code:"
  },
  {
    "objectID": "/rsh/errors/#RV0000",
    "pt": "Error Codes",
    "t": 2,
    "c": "RV0000"
  },
  {
    "objectID": "/rsh/errors/#p_0",
    "pt": "Error Codes",
    "t": 3,
    "c": "This section provides an in depth explanation of the error codes produced from the Reach compiler."
  },
  {
    "objectID": "/rsh/errors/#p_1",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a program, targeting the Algorand connector, is attempting to transfer a {!rsh} Token in the same consensus step it was created in. It is impossible to perform this action because one must opt-in to receive a token on Algorand. To opt-in, one must know the id, however the id of the token cannot be known until after the transaction that created it."
  },
  {
    "objectID": "/rsh/errors/#p_2",
    "pt": "Error Codes",
    "t": 3,
    "c": "The following code erroneously tries to transfer a newly created {!rsh} Token:"
  },
  {
    "objectID": "/rsh/errors/#p_3",
    "pt": "Error Codes",
    "t": 3,
    "c": "This can be fixed by performing a {!rsh} commit after creating the token and transferring the token in the next consensus step:"
  },
  {
    "objectID": "/rsh/errors/#p_4",
    "pt": "Error Codes",
    "t": 3,
    "c": "The frontend can have {!rsh} Alice opt-in to the token in {!rsh} informOfTokenId by utilizing {!js} acc.tokenAccept()."
  },
  {
    "objectID": "/rsh/errors/#p_5",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a program, targeting the Algorand connector, is attempting to pay a {!rsh} Token at the same time it is published. It is impossible to perform this action because one must opt-in to receive a token on Algorand. To opt-in, one must know the id, however the application cannot learn the application until after it has received the publication, which must occur after all pay transactions."
  },
  {
    "objectID": "/rsh/errors/#p_6",
    "pt": "Error Codes",
    "t": 3,
    "c": "The following code has this error:"
  },
  {
    "objectID": "/rsh/errors/#p_7",
    "pt": "Error Codes",
    "t": 3,
    "c": "This can be fixed by performing the {!rsh} publish and {!rsh} pay in two steps: token in the next consensus step:"
  },
  {
    "objectID": "/rsh/errors/#p_8",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the program uses a number that is beyond the range of acceptable numbers for the given connector."
  },
  {
    "objectID": "/rsh/errors/#p_9",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below uses a value too large for the {!rsh} ALGO connector:"
  },
  {
    "objectID": "/rsh/errors/#p_10",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by having your frontend provide the value and accessing it via the participant interact interface:"
  },
  {
    "objectID": "/rsh/errors/#p_11",
    "pt": "Error Codes",
    "t": 3,
    "c": "Alternatively, you can fix this by not compiling to the given connector, in which case, your application will no longer be blockchain agnostic."
  },
  {
    "objectID": "/rsh/errors/#p_12",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you provided an incorrect number of arguments to a function."
  },
  {
    "objectID": "/rsh/errors/#p_13",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below applies one value to {!rsh} f:"
  },
  {
    "objectID": "/rsh/errors/#p_14",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by providing the same amount of arguments expected:"
  },
  {
    "objectID": "/rsh/errors/#p_15",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a program uses an invalid assignment operator. Reach only supports assignment using the {!rsh} = operator. Any other operator, such as {!rsh} +=, *=, ... is not allowed."
  },
  {
    "objectID": "/rsh/errors/#p_16",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously tries to re-assign {!rsh} x at the end of a {!rsh} while loop:"
  },
  {
    "objectID": "/rsh/errors/#p_17",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by explicitly writing out the operation on the right hand side of {!rsh} =:"
  },
  {
    "objectID": "/rsh/errors/#p_18",
    "pt": "Error Codes",
    "t": 3,
    "c": "Keep in mind, that the assignment operator is a form of mutation and is only allowed immediately before a {!rsh} continue."
  },
  {
    "objectID": "/rsh/errors/#p_19",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a program uses an invalid statement. Reach is a strict subset of JavaScript and does not accept every statement that is valid JavaScript. It may be necessary to express your program with different constructs than you would JavaScript."
  },
  {
    "objectID": "/rsh/errors/#p_20",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously uses a {!js} for loop, which is not supported in Reach:"
  },
  {
    "objectID": "/rsh/errors/#p_21",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by either using a {!rsh} while loop or a combination of {!rsh} Array.iota and {!rsh} Array.map/Array.forEach:"
  },
  {
    "objectID": "/rsh/errors/#p_22",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a statement block returns a non-null value although a {!rsh} null value is expected. The block should either use a {!rsh} return null; statement or no return statement at all."
  },
  {
    "objectID": "/rsh/errors/#p_23",
    "pt": "Error Codes",
    "t": 3,
    "c": "This statement block has a {!rsh} return of 1, but it should not have a {!rsh} return."
  },
  {
    "objectID": "/rsh/errors/#p_24",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error can be corrected by putting the {!rsh} return inside of a {!rsh} const statement block:"
  },
  {
    "objectID": "/rsh/errors/#p_25",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the program uses {!rsh} var incorrectly. In Reach, {!rsh} var is only allowed immediately before a while loop and its {!rsh} invariant."
  },
  {
    "objectID": "/rsh/errors/#p_26",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, this code erroneously tries to declare {!rsh} x as a mutable variable then re-assign it at some point:"
  },
  {
    "objectID": "/rsh/errors/#p_27",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by using {!rsh} const and either creating fresh variables or collapsing the logic if simple enough:"
  },
  {
    "objectID": "/rsh/errors/#p_28",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates an incorrect use of {!rsh} while. {!rsh} while must be immediately prefaced by a {!rsh} var and {!rsh} invariant declaration."
  },
  {
    "objectID": "/rsh/errors/#p_29",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, this code erroneously tries to run a continuous loop where Alice pays {!rsh} 1 network token per loop:"
  },
  {
    "objectID": "/rsh/errors/#p_30",
    "pt": "Error Codes",
    "t": 3,
    "c": "Reach requires the {!rsh} invariant to reason about the {!rsh} while loop during verification. You can fix this by adding a {!rsh} var and {!rsh} invariant declaration before the loop:"
  },
  {
    "objectID": "/rsh/errors/#p_31",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_32",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that {!rsh} return may not be used within the current statement block."
  },
  {
    "objectID": "/rsh/errors/#p_33",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the {!rsh} timeout branch of a statement such as {!rsh} publish, pay, fork has been given the wrong arguments."
  },
  {
    "objectID": "/rsh/errors/#p_34",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the following code erroneously attempts to {!rsh} closeTo(Bob) in the event that {!rsh} Alice does not publish in time:"
  },
  {
    "objectID": "/rsh/errors/#p_35",
    "pt": "Error Codes",
    "t": 3,
    "c": "However, the second argument of the {!rsh} timeout branch must be a syntactic thunk. You can fix this by wrapping {!rsh} closeTo(Bob) in an arrow expression:"
  },
  {
    "objectID": "/rsh/errors/#p_36",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a {!rsh} timeout branch of a statement such as {!rsh} publish, pay, fork has not been given a block of code to execute in the event of a {!rsh} timeout."
  },
  {
    "objectID": "/rsh/errors/#p_37",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously provides a {!rsh} timeout delay, but does not specify a function to run if the timeout occurs:"
  },
  {
    "objectID": "/rsh/errors/#p_38",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by providing a function as a second argument to {!rsh} timeout:"
  },
  {
    "objectID": "/rsh/errors/#p_39",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the pay amount provided states the amount of network tokens more than once."
  },
  {
    "objectID": "/rsh/errors/#p_40",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously provides two atomic values in the pay amount, which are both interpreted as the amount of network tokens to pay:"
  },
  {
    "objectID": "/rsh/errors/#p_41",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by deleting one of the atomic values:"
  },
  {
    "objectID": "/rsh/errors/#p_42",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1.8."
  },
  {
    "objectID": "/rsh/errors/#p_43",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the pay amount provided states the amount of a specific non-network token more than once."
  },
  {
    "objectID": "/rsh/errors/#p_44",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously provides two tuples in the pay amount, both of which specify the amount of the same token:"
  },
  {
    "objectID": "/rsh/errors/#p_45",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by deleting one of the tuples:"
  },
  {
    "objectID": "/rsh/errors/#p_46",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the pay amount provided does not provide values of the correct type."
  },
  {
    "objectID": "/rsh/errors/#p_47",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously provides a pay amount that consists of a one element tuple:"
  },
  {
    "objectID": "/rsh/errors/#p_48",
    "pt": "Error Codes",
    "t": 3,
    "c": "However, a tuple in a pay amount must specify the amount and the {!rsh} Token. You can fix this by adding the {!rsh} Token to the tuple:"
  },
  {
    "objectID": "/rsh/errors/#p_49",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a participant interact interface field has a type that is not first-order. That is, an interact function has a return type of a function, which is not allowed in Reach."
  },
  {
    "objectID": "/rsh/errors/#p_50",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously provides an interact function that returns another function:"
  },
  {
    "objectID": "/rsh/errors/#p_51",
    "pt": "Error Codes",
    "t": 3,
    "c": "the frontend may look like this:"
  },
  {
    "objectID": "/rsh/errors/#p_52",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by decoupling the functions and calling them sequentially. This technique requires changes to the frontend as well since we are changing the signature:"
  },
  {
    "objectID": "/rsh/errors/#p_53",
    "pt": "Error Codes",
    "t": 3,
    "c": "the frontend may look like this:"
  },
  {
    "objectID": "/rsh/errors/#p_54",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you provided an unrecognized option to {!rsh} setOptions. There is most likely a typo in your code."
  },
  {
    "objectID": "/rsh/errors/#p_55",
    "pt": "Error Codes",
    "t": 3,
    "c": "Please review the recognized options in the documentation for {!rsh} setOptions."
  },
  {
    "objectID": "/rsh/errors/#p_56",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you did not provide an acceptable value for a specific option in {!rsh} setOptions."
  },
  {
    "objectID": "/rsh/errors/#p_57",
    "pt": "Error Codes",
    "t": 3,
    "c": "Please review the eligible values listed in the documentation for {!rsh} setOptions."
  },
  {
    "objectID": "/rsh/errors/#p_58",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that your participant interact interface does not provide a {!rsh} Type for a given field."
  },
  {
    "objectID": "/rsh/errors/#p_59",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, in the erroneous code below, {!rsh} x is assigned {!rsh} 3 in the participant interact interface of {!rsh} Alice:"
  },
  {
    "objectID": "/rsh/errors/#p_60",
    "pt": "Error Codes",
    "t": 3,
    "c": "However, the interact interface specifies the type of values that will be provided at runtime. You can fix this by either making {!rsh} x a variable within Alice's scope inside the program:"
  },
  {
    "objectID": "/rsh/errors/#p_61",
    "pt": "Error Codes",
    "t": 3,
    "c": "or by putting {!rsh} 3 as the value of {!rsh} x in your frontend and adjusting the participant interact interface to list the type:"
  },
  {
    "objectID": "/rsh/errors/#p_62",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the arguments passed to {!rsh} Reach.App are incorrect. {!rsh} Reach.App accepts a single thunk as its argument."
  },
  {
    "objectID": "/rsh/errors/#p_63",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously declares a {!rsh} Reach.App without too many arguments:"
  },
  {
    "objectID": "/rsh/errors/#p_64",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by ensuring only one argument is passed to {!rsh} Reach.App, which is a function with no arguments:"
  },
  {
    "objectID": "/rsh/errors/#p_65",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the name of the {!rsh} Participant or {!rsh} View provided is invalid. These names must satisfy the regex {!rsh} [a-zA-Z][_a-zA-Z0-9]*."
  },
  {
    "objectID": "/rsh/errors/#p_66",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below provides a Participant name that is unsatisfactory:"
  },
  {
    "objectID": "/rsh/errors/#p_67",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by removing any illegal characters and replacing spaces with underscores:"
  },
  {
    "objectID": "/rsh/errors/#p_68",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that an invalid expression is used on the left hand side of an assignment."
  },
  {
    "objectID": "/rsh/errors/#p_69",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously puts an arithmetic expression on the left hand side of an assignment:"
  },
  {
    "objectID": "/rsh/errors/#p_70",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by moving all the arithmetic to the right hand side, leaving only the variable on the left:"
  },
  {
    "objectID": "/rsh/errors/#p_71",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that an object spread is occurring before the last position in a destructuring assignment. It must come last due to the fact it binds the remaining elements to the given variable."
  },
  {
    "objectID": "/rsh/errors/#p_72",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously attempts to destructure one element {!rsh} y and the remaining elements into {!rsh} x:"
  },
  {
    "objectID": "/rsh/errors/#p_73",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by moving {!rsh} ...x to the last position:"
  },
  {
    "objectID": "/rsh/errors/#p_74",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that an array spread is occurring before the last position in a destructuring assignment. It must come last due to the fact it binds the remaining elements to the given variable."
  },
  {
    "objectID": "/rsh/errors/#p_75",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously attempts to destructure one element {!rsh} y and the remaining elements into {!rsh} x:"
  },
  {
    "objectID": "/rsh/errors/#p_76",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by moving {!rsh} ...x to the last position:"
  },
  {
    "objectID": "/rsh/errors/#p_77",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the compiler expected to receive a closure, but it was given a different value."
  },
  {
    "objectID": "/rsh/errors/#p_78",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously attempts to provide a value for the {!rsh} match case of a nullary {!rsh} Data constructor:"
  },
  {
    "objectID": "/rsh/errors/#p_79",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by wrapping the value {!rsh} 0 in an arrow expression because {!rsh} match expects all cases to be bound to closures:"
  },
  {
    "objectID": "/rsh/errors/#p_80",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there was an invalid declaration. This error will occur when attempting to bind multiple variables within a single {!rsh} const."
  },
  {
    "objectID": "/rsh/errors/#p_81",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously attempts to bind {!rsh} x and {!rsh} y within one {!rsh} const assignment:"
  },
  {
    "objectID": "/rsh/errors/#p_82",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by breaking apart the declarations into two {!rsh} const statements:"
  },
  {
    "objectID": "/rsh/errors/#p_83",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_84",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there was an invalid declaration."
  },
  {
    "objectID": "/rsh/errors/#p_85",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is an attempt to unpack an {!rsh} array, but the binding does not expect the same amount of values that the {!rsh} array contains."
  },
  {
    "objectID": "/rsh/errors/#p_86",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously tries to unpack an {!rsh} array of 3 values into 2 variables:"
  },
  {
    "objectID": "/rsh/errors/#p_87",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by either binding or ignoring, via {!rsh} _, the last element of the {!rsh} array:"
  },
  {
    "objectID": "/rsh/errors/#p_88",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is an attempt to access a field of an {!rsh} object that does not exist. Ensure that you are referring to the correct name, or add the needed field to the {!rsh} object if necessary."
  },
  {
    "objectID": "/rsh/errors/#p_89",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the {!rsh} continue statement is used outside of a {!rsh} while loop."
  },
  {
    "objectID": "/rsh/errors/#p_90",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_91",
    "pt": "Error Codes",
    "t": 3,
    "c": "To fix this issue, delete the erroneous {!rsh} continue, or move it to the end of your {!rsh} while loop."
  },
  {
    "objectID": "/rsh/errors/#p_92",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_93",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is an attempt to consult the consensus time before the first publication. This situation is not allowed, because before the first publication, there is no consensual agreement on time in the decentralized computation."
  },
  {
    "objectID": "/rsh/errors/#p_94",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by having a {!rsh} Participant {!rsh} publish first:"
  },
  {
    "objectID": "/rsh/errors/#p_95",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a the variable update inside of a loop, e.g. {!rsh} while, is attempting to mutate variables that are not mutable. For a {!rsh} while loop, this means the variable was not declared with {!rsh} var prior to the loop."
  },
  {
    "objectID": "/rsh/errors/#p_96",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously attempts to mutate {!rsh} y which has not been defined via {!rsh} var:"
  },
  {
    "objectID": "/rsh/errors/#p_97",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by either deleting {!rsh} y or adding it to the variable list:"
  },
  {
    "objectID": "/rsh/errors/#p_98",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates an attempt to bind a {!rsh} ParticipantClass to a specific {!rsh} Address."
  },
  {
    "objectID": "/rsh/errors/#p_99",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the example code below erroneously tries to {!rsh} set a {!rsh} ParticipantClass to a specific address:"
  },
  {
    "objectID": "/rsh/errors/#p_100",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by using a {!rsh} Participant, which may be associated with a single address:"
  },
  {
    "objectID": "/rsh/errors/#p_101",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates an attempt to re-bind a {!rsh} Participant to another {!rsh} Address. Once a {!rsh} Participant is bound to an {!rsh} Address, either by making a publication or explicitly via {!rsh} Participant.set, they may not be re-bound."
  },
  {
    "objectID": "/rsh/errors/#p_102",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously has {!rsh} Bob make a publication, then later, attempts to bind him to a specific address:"
  },
  {
    "objectID": "/rsh/errors/#p_103",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by deleting one of the statements (depending on the logic of your application)."
  },
  {
    "objectID": "/rsh/errors/#p_104",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to use a specific statement or expression in the wrong mode. Consult the documentation for the specific keyword to learn more about what mode is expected. Additionally, see the figure on Language for a diagram regarding the modes of a Reach application."
  },
  {
    "objectID": "/rsh/errors/#p_105",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to mutate a variable in an inappropriate place. Variable mutation is only allowed to occur on variables declared via {!rsh} var and immediately before a {!rsh} continue statement of a loop."
  },
  {
    "objectID": "/rsh/errors/#p_106",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below attempts to mutate a loop variable improperly:"
  },
  {
    "objectID": "/rsh/errors/#p_107",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this issue by moving the mutation directly before the {!rsh} continue:"
  },
  {
    "objectID": "/rsh/errors/#p_108",
    "pt": "Error Codes",
    "t": 3,
    "c": ""
  },
  {
    "objectID": "/rsh/errors/#p_109",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates you are using an illegal JavaScript expression in Reach. Not all JavaScript expressions are valid Reach, as they are not applicable to the language."
  },
  {
    "objectID": "/rsh/errors/#p_110",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is nowhere to return to in the current statement block. This may occur if you write a {!rsh} return statement at the top level of a file or if you've already wrote a {!rsh} return statement."
  },
  {
    "objectID": "/rsh/errors/#p_111",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below has two {!rsh} return statements, the first of which will always occur, since it is not within a conditional:"
  },
  {
    "objectID": "/rsh/errors/#p_112",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by removing the second {!rsh} return which is dead code:"
  },
  {
    "objectID": "/rsh/errors/#p_113",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a value, which is not a function, is being applied as if it were a function. Ensure you are writing the correct name of the function you intend to use."
  },
  {
    "objectID": "/rsh/errors/#p_114",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below has two variables: {!rsh} f and {!rsh} g:"
  },
  {
    "objectID": "/rsh/errors/#p_115",
    "pt": "Error Codes",
    "t": 3,
    "c": "{!rsh} g is being applied as if it were a function, although we really intended on calling {!rsh} f. This can be fixed by ensuring we call a function:"
  },
  {
    "objectID": "/rsh/errors/#p_116",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1.9."
  },
  {
    "objectID": "/rsh/errors/#p_117",
    "pt": "Error Codes",
    "t": 3,
    "c": "It means the same thing as RE0035."
  },
  {
    "objectID": "/rsh/errors/#p_118",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a value, which is not an {!rsh} Object, is being treated as if it were an {!rsh} Object. This error occurs when you try to access a field of an erroneous value. This issue is most likely caused by a typo in your program."
  },
  {
    "objectID": "/rsh/errors/#p_119",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a value, which is not an {!rsh} Array or {!rsh} Tuple, is being treated as if it were. This error occurs when you try to access an element of an erroneous value. This issue is most likely caused by a typo in your program."
  },
  {
    "objectID": "/rsh/errors/#p_120",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is an attempt to dereference an {!rsh} Array or {!rsh} Tuple with a non-numerical value. You must use a value of type {!rsh} UInt to dereference an {!rsh} Array."
  },
  {
    "objectID": "/rsh/errors/#p_121",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are using a dynamic value to dereference a value which is not an {!rsh} Array. This issue is most likely caused by a typo. Please ensure you are dereferencing an {!rsh} Array."
  },
  {
    "objectID": "/rsh/errors/#p_122",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is an attempt to statically dereference an {!rsh} Array beyond its bounds. Ensure you are using an index that is between 0 and 1 less than the length of the {!rsh} Array."
  },
  {
    "objectID": "/rsh/errors/#p_123",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is an attempt to reference an identifier that is not in scope. This issue may be caused by a typo, a scoping issue, or a missing {!rsh} import."
  },
  {
    "objectID": "/rsh/errors/#p_124",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below declares a function with a variable {!rsh} x declared within it. Attempting to reference {!rsh} x outside of the function will result in an error:"
  },
  {
    "objectID": "/rsh/errors/#p_125",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this issue by returning the value of {!rsh} x from the function:"
  },
  {
    "objectID": "/rsh/errors/#p_126",
    "pt": "Error Codes",
    "t": 3,
    "c": "If you are attempting to use a value from a library, simply add the necessary {!rsh} import to the top of the Reach file."
  },
  {
    "objectID": "/rsh/errors/#p_127",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is a mismatch between the expected security levels of a variable and the actual one provided. This may happen if you use a public variable where a secret is expected, or vice versa."
  },
  {
    "objectID": "/rsh/errors/#p_128",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously declassifies the variable {!rsh} x, which is not secret:"
  },
  {
    "objectID": "/rsh/errors/#p_129",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this issue by simply assigning {!rsh} y to {!rsh} x."
  },
  {
    "objectID": "/rsh/errors/#p_130",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you provided an incorrect number of arguments to a function. You can fix this by providing the same amount of arguments expected."
  },
  {
    "objectID": "/rsh/errors/#p_131",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that an anonymous function was provided a name, which is not allowed."
  },
  {
    "objectID": "/rsh/errors/#p_132",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below names the anonymous function {!rsh} m:"
  },
  {
    "objectID": "/rsh/errors/#p_133",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by removing the function name:"
  },
  {
    "objectID": "/rsh/errors/#p_134",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there was an invalid syntax used for an {!rsh} import. The acceptable {!rsh} import formats are defined in the documentation for the keyword."
  },
  {
    "objectID": "/rsh/errors/#p_135",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously performs a default {!rsh} import:"
  },
  {
    "objectID": "/rsh/errors/#p_136",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by explicitly importing the bindings you want:"
  },
  {
    "objectID": "/rsh/errors/#p_137",
    "pt": "Error Codes",
    "t": 3,
    "c": "or by binding all the exports to an identifier:"
  },
  {
    "objectID": "/rsh/errors/#p_138",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_139",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there was a {!rsh} return statement at the top level."
  },
  {
    "objectID": "/rsh/errors/#p_140",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the Reach file does not have a header at the top of the file. The first top level statement of a Reach module must indicate what version of Reach the file uses."
  },
  {
    "objectID": "/rsh/errors/#p_141",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously exports an application without specifying what version of Reach it uses:"
  },
  {
    "objectID": "/rsh/errors/#p_142",
    "pt": "Error Codes",
    "t": 3,
    "c": "Fix this by adding a header to the file:"
  },
  {
    "objectID": "/rsh/errors/#p_143",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that an {!rsh} object has been given a field that is not an identifier or a {!rsh} string."
  },
  {
    "objectID": "/rsh/errors/#p_144",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously uses a dynamic string as an object key:"
  },
  {
    "objectID": "/rsh/errors/#p_145",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by using a static string as the key."
  },
  {
    "objectID": "/rsh/errors/#p_146",
    "pt": "Error Codes",
    "t": 3,
    "c": "This code snippet uses a static string as an object key instead of using a dynamic string. The object keys T and S are computable at compile time."
  },
  {
    "objectID": "/rsh/errors/#p_147",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_148",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates an {!rsh} Object has an incorrect number of values associated with a field."
  },
  {
    "objectID": "/rsh/errors/#p_149",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the field of an {!rsh} Object uses the incorrect syntax for defining a function."
  },
  {
    "objectID": "/rsh/errors/#p_150",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below declares a field as a function with the following syntax:"
  },
  {
    "objectID": "/rsh/errors/#p_151",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by using the following arrow expression syntax:"
  },
  {
    "objectID": "/rsh/errors/#p_152",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a {!rsh} UInt has been used as the key of an {!rsh} Object. However, only identifiers and values of type {!rsh} Bytes are valid object keys."
  },
  {
    "objectID": "/rsh/errors/#p_153",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this issue by replacing the erroneous key with a static string."
  },
  {
    "objectID": "/rsh/errors/#p_154",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to spread a value that is not an object. This issue is most likely caused by a typo in your program."
  },
  {
    "objectID": "/rsh/errors/#p_155",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the argument provided to {!rsh} Array.iota is not static. {!rsh} Array.iota requires its argument to be computable at compile time."
  },
  {
    "objectID": "/rsh/errors/#p_156",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this issue by providing a static {!rsh} UInt to the function."
  },
  {
    "objectID": "/rsh/errors/#p_157",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error occurs when you provide a primitive operation with the incorrect number of arguments or arguments of the wrong type. Please review the documentation for the function you are attempting to use and provide it with the correct arguments."
  },
  {
    "objectID": "/rsh/errors/#p_158",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to create a variable, although another variable in the scope uses the same name."
  },
  {
    "objectID": "/rsh/errors/#p_159",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_160",
    "pt": "Error Codes",
    "t": 3,
    "c": "In Reach, identifier shadowing is not allowed. You can fix this issue by renaming your variable or moving one of the variable declarations to another scope where it does not conflict with the other."
  },
  {
    "objectID": "/rsh/errors/#p_161",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_162",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the compiler expected the tail of a statement block to be empty, but it wasn't. This issue may arise if there are statements beyond a {!rsh} return or {!rsh} exit statement. These statements are dead code and you can fix this issue by deleting them."
  },
  {
    "objectID": "/rsh/errors/#p_163",
    "pt": "Error Codes",
    "t": 3,
    "c": "The {!rsh} return statement on line 19 will never be executed. The {!rsh} return statement in the {!rsh} if ... else ... block already handled what is needed for the g {!rsh} function."
  },
  {
    "objectID": "/rsh/errors/#p_164",
    "pt": "Error Codes",
    "t": 3,
    "c": "To fix the code remove line 19:"
  },
  {
    "objectID": "/rsh/errors/#p_165",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_166",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you tried to use the {!rsh} publish keyword twice in a publication."
  },
  {
    "objectID": "/rsh/errors/#p_167",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_168",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is a function at the top level without a name. You can fix this by naming your function."
  },
  {
    "objectID": "/rsh/errors/#p_169",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_170",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is an illegal {!rsh} while loop {!rsh} invariant. You can fix this issue by providing only one expression to {!rsh} invariant."
  },
  {
    "objectID": "/rsh/errors/#p_171",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_172",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that {!rsh} Participant.only was not supplied a single thunk as its argument."
  },
  {
    "objectID": "/rsh/errors/#p_173",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by providing the expected value to the function."
  },
  {
    "objectID": "/rsh/errors/#p_174",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_175",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that {!rsh} each was not given a {!rsh} Tuple of {!rsh} Participants as its first argument."
  },
  {
    "objectID": "/rsh/errors/#p_176",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by providing the expected value to the function."
  },
  {
    "objectID": "/rsh/errors/#p_177",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a given function expects a {!rsh} Participant or {!rsh} ParticipantClass as an argument, but it was given something else."
  },
  {
    "objectID": "/rsh/errors/#p_178",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously provides {!rsh} false instead of a {!rsh} Participant to {!rsh} unknowable:"
  },
  {
    "objectID": "/rsh/errors/#p_179",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by passing a {!rsh} Participant as the first argument to {!rsh} unknowable:"
  },
  {
    "objectID": "/rsh/errors/#p_180",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the program is attempting to transfer funds to a {!rsh} Participant that is not yet bound to an {!rsh} Address."
  },
  {
    "objectID": "/rsh/errors/#p_181",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below transfers funds to {!rsh} Bob before he has a set {!rsh} Address:"
  },
  {
    "objectID": "/rsh/errors/#p_182",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by using {!rsh} Participant.set first or having {!rsh} Bob publish before the {!rsh} transfer:"
  },
  {
    "objectID": "/rsh/errors/#p_183",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to {!rsh} transfer funds to a {!rsh} ParticipantClass. This is not possible because {!rsh} transfer expects a single {!rsh} Address to transfer to."
  },
  {
    "objectID": "/rsh/errors/#p_184",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously attempts to transfer the {!rsh} balance of the contract to a class:"
  },
  {
    "objectID": "/rsh/errors/#p_185",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by specifying a specific {!rsh} Address to use. For example, the class could {!rsh} race to specify their own address:"
  },
  {
    "objectID": "/rsh/errors/#p_186",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the state of the program differs in the continuation of a branching statement. That is, if a Reach program may execute multiple different code paths at runtime, the continuation of those branches must make the same assumption about state."
  },
  {
    "objectID": "/rsh/errors/#p_187",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, this error may be caused by having one branch end in consensus step and the other in a step. You can fix this by ensuring both branches end in the same mode."
  },
  {
    "objectID": "/rsh/errors/#p_188",
    "pt": "Error Codes",
    "t": 3,
    "c": "Another example is a {!rsh} Participant makes their first publication in the branch of a conditional. You can fix this by having the {!rsh} Participant make their first publication before the conditional statement."
  },
  {
    "objectID": "/rsh/errors/#p_189",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to bind a secret value to an identifier of the wrong format. secret identifiers must be prefixed with {!rsh} _."
  },
  {
    "objectID": "/rsh/errors/#p_190",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously assigns a secret value to a public identifier, {!rsh} x:"
  },
  {
    "objectID": "/rsh/errors/#p_191",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by either changing the identifier to start with {!rsh} _ or using {!rsh} declassify to make the value public:"
  },
  {
    "objectID": "/rsh/errors/#p_192",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to bind a public value to an identifier of the wrong format. public identifiers cannot be prefixed with {!rsh} _."
  },
  {
    "objectID": "/rsh/errors/#p_193",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously assigns a public value to a secret identifier, {!rsh} _x:"
  },
  {
    "objectID": "/rsh/errors/#p_194",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by removing the {!rsh} _ prefix:"
  },
  {
    "objectID": "/rsh/errors/#p_195",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to read the value of {!rsh} _. Any binding to {!rsh} _ is ignored and therefore cannot be read from."
  },
  {
    "objectID": "/rsh/errors/#p_196",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_197",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by using another identifier and referencing it as usual."
  },
  {
    "objectID": "/rsh/errors/#p_198",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to spread a value as if it were a {!rsh} Tuple, {!rsh} Array, or {!rsh} Struct, but it is not. This issue is likely caused by a typo in your code."
  },
  {
    "objectID": "/rsh/errors/#p_199",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously spreads the wrong values:"
  },
  {
    "objectID": "/rsh/errors/#p_200",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by spreading a tuple-like value for the second argument of {!rsh} add:"
  },
  {
    "objectID": "/rsh/errors/#p_201",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the two {!rsh} Arrays given to {!rsh} Array.zip are not of equal length. You can fix this error by providing two {!rsh} Arrays of equal length to the function."
  },
  {
    "objectID": "/rsh/errors/#p_202",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a {!rsh} switch statement was supplied with a value that is not a {!rsh} Data instance."
  },
  {
    "objectID": "/rsh/errors/#p_203",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below expects a {!rsh} Maybe type, but is erroneously provided with a {!rsh} UInt:"
  },
  {
    "objectID": "/rsh/errors/#p_204",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by providing a value with the correct {!rsh} Type to the {!rsh} switch statement:"
  },
  {
    "objectID": "/rsh/errors/#p_205",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there are multiple cases for the same variant in a {!rsh} switch statement or {!rsh} match expression."
  },
  {
    "objectID": "/rsh/errors/#p_206",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_207",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by deleting one of the branches, ensuring there is only one branch per variant."
  },
  {
    "objectID": "/rsh/errors/#p_208",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_209",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a {!rsh} switch statement or {!rsh} match expression does not have a case for every variant of a {!rsh} Data instance."
  },
  {
    "objectID": "/rsh/errors/#p_210",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_211",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this issue by adding the missing cases listed in the error message."
  },
  {
    "objectID": "/rsh/errors/#p_212",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_213",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a {!rsh} switch statement or {!rsh} match expression contains cases for unknown variants. These erroneous variants are not listed in the {!rsh} Data definition."
  },
  {
    "objectID": "/rsh/errors/#p_214",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_215",
    "pt": "Error Codes",
    "t": 3,
    "c": "Mone is not added to the {!rsh} Data field and so is an unknown variant. You can fix this issue by adding the unknown variant to the {!rsh} Data definition or removing the case."
  },
  {
    "objectID": "/rsh/errors/#p_216",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the {!rsh} Type of a value you provided to a function or operation does not match the expected {!rsh} Type."
  },
  {
    "objectID": "/rsh/errors/#p_217",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously provides a number as the second argument to {!rsh} assert:"
  },
  {
    "objectID": "/rsh/errors/#p_218",
    "pt": "Error Codes",
    "t": 3,
    "c": "However, the second argument of {!rsh} assert is expected to be of type {!rsh} Bytes. You can fix this issue by providing a value of the correct type:"
  },
  {
    "objectID": "/rsh/errors/#p_219",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the depth of recursion for a function call exceeded the limit allowed. This issue may indicate that the recursive function does not have a base case."
  },
  {
    "objectID": "/rsh/errors/#p_220",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_221",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this issue by rewriting the recursive function as an iterative set of statements, e.g. a {!rsh} while loop."
  },
  {
    "objectID": "/rsh/errors/#p_222",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the program is no longer live by the time it reaches a publication. That is, the program will have already {!rsh} exited before the given point."
  },
  {
    "objectID": "/rsh/errors/#p_223",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below will always {!rsh} exit before calling {!rsh} publish:"
  },
  {
    "objectID": "/rsh/errors/#p_224",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by wrapping the {!rsh} exit in a conditional:"
  },
  {
    "objectID": "/rsh/errors/#p_225",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_226",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a statement is being used in place of an expression. Refer to the documentation for the statement you are attempting to use for more information on how to use it."
  },
  {
    "objectID": "/rsh/errors/#p_227",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is an attempt to conditionally transition to consensus without a {!rsh} timeout. When making a conditional publication, such as {!rsh} A.publish(x).when(shouldPublish), there needs to be a timeout associated with the publication if {!rsh} shouldPublish is not statically {!rsh} true."
  },
  {
    "objectID": "/rsh/errors/#p_228",
    "pt": "Error Codes",
    "t": 3,
    "c": "In {!rsh} parallelReduce or {!rsh} fork, a {!rsh} timeout is required unless one {!rsh} Participant always races, the {!rsh} when field in their PUBLISH_EXPR is statically {!rsh} true, or if one {!rsh} ParticipantClass or {!rsh} API will attempt to race."
  },
  {
    "objectID": "/rsh/errors/#p_229",
    "pt": "Error Codes",
    "t": 3,
    "c": "Since {!rsh} ParticipantClass is being deprecated, it is preferable to use {!rsh} API."
  },
  {
    "objectID": "/rsh/errors/#p_230",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously attempts to publish a value if a certain condition holds:"
  },
  {
    "objectID": "/rsh/errors/#p_231",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this issue by providing a {!rsh} timeout case for"
  },
  {
    "objectID": "/rsh/errors/#p_232",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the result of PUBLISH_EXPR for a {!rsh} fork or {!rsh} parallelReduce is not of the right {!rsh} Type. It is expected to be an {!rsh} Object with a {!rsh} when field, and optionally a {!rsh} msg field."
  },
  {
    "objectID": "/rsh/errors/#p_233",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously tries to publish a value in a {!rsh} parallelReduce case:"
  },
  {
    "objectID": "/rsh/errors/#p_234",
    "pt": "Error Codes",
    "t": 3,
    "c": "This code can be fixed by using an {!rsh} Object and assigning the value to be published to the {!rsh} msg field of the object:"
  },
  {
    "objectID": "/rsh/errors/#p_235",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the parameters of a CONSENSUS_EXPR in a {!rsh} fork or {!rsh} parallelReduce are incorrect. The function provided should either accept zero parameters or one parameter, which represents the {!rsh} msg of the {!rsh} PUBLISH_EXPR."
  },
  {
    "objectID": "/rsh/errors/#p_236",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously tries to publish multiple values and bind them in the function provided to CONSENSUS_EXPR:"
  },
  {
    "objectID": "/rsh/errors/#p_237",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by changing the arrow expression to accept one parameter. You can either destructure the argument with a {!rsh} const assignment or as part of the function syntax:"
  },
  {
    "objectID": "/rsh/errors/#p_238",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that not all the components of the {!rsh} parallelReduce statement are provided. Please refer to the documentation of {!rsh} parallelReduce to see the required components."
  },
  {
    "objectID": "/rsh/errors/#p_239",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by adding any components the compiler has listed."
  },
  {
    "objectID": "/rsh/errors/#p_240",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example of the issue:"
  },
  {
    "objectID": "/rsh/errors/#p_241",
    "pt": "Error Codes",
    "t": 3,
    "c": "To fix this, make sure the {!rsh} parallelReduce has all required elements."
  },
  {
    "objectID": "/rsh/errors/#p_242",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you have provided the wrong number of arguments to a component of {!rsh} parallelReduce. Please refer to the documentation for the specific component you are trying to use."
  },
  {
    "objectID": "/rsh/errors/#p_243",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously supplies a closure as the second argument to {!rsh} timeRemaining."
  },
  {
    "objectID": "/rsh/errors/#p_244",
    "pt": "Error Codes",
    "t": 3,
    "c": "However, {!rsh} timeRemaining is a shorthand for a timeout which automatically publishes and returns the {!rsh} parallelReduce accumulator. The component only expects one argument. You can fix this code by removing the second argument supplied."
  },
  {
    "objectID": "/rsh/errors/#p_245",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that your program would contain a value at runtime which would not be allowed. This error usually stems from not fully applying a primitive function or using a value incorrectly, such as the participant interact interface of a {!rsh} Participant."
  },
  {
    "objectID": "/rsh/errors/#p_246",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously tries to publish {!rsh} Alice's interact interface:"
  },
  {
    "objectID": "/rsh/errors/#p_247",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by specifying a specific field of {!rsh} Alice's interact interface to {!rsh} publish:"
  },
  {
    "objectID": "/rsh/errors/#p_248",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the {!rsh} Type of a value cannot exist at runtime. This error may be caused by a {!rsh} Fun in a participant interact interface having a return type of another {!rsh} Fun."
  },
  {
    "objectID": "/rsh/errors/#p_249",
    "pt": "Error Codes",
    "t": 3,
    "c": "For examples of this error and how to fix it, see RE0012."
  },
  {
    "objectID": "/rsh/errors/#p_250",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_251",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to apply a non-function value as if it were a function. This issue is most likely caused by a typo with an identifier."
  },
  {
    "objectID": "/rsh/errors/#p_252",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is a mismatch between the actual {!rsh} Type of a value and the expected {!rsh} Type of a value."
  },
  {
    "objectID": "/rsh/errors/#p_253",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously returns a {!rsh} Bool when the type annotation states that the function should return a {!rsh} UInt."
  },
  {
    "objectID": "/rsh/errors/#p_254",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by returning a {!rsh} UInt from the function or changing the return type of the function."
  },
  {
    "objectID": "/rsh/errors/#p_255",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error may be caused by using a value of the incorrect type in an operation. The code below erroneously uses a {!rsh} Maybe value in a {!rsh} + expression:"
  },
  {
    "objectID": "/rsh/errors/#p_256",
    "pt": "Error Codes",
    "t": 3,
    "c": "In this code, {!rsh} mi is still of {!rsh} Maybe type. You can fix this code by changing {!rsh} default to {!rsh} case Some, which will re-bind {!rsh} mi to the value contained within {!rsh} Some:"
  },
  {
    "objectID": "/rsh/errors/#p_257",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a {!rsh} Map.reduce is being performed outside of an {!rsh} invariant, which is the only place map reductions are allowed to occur."
  },
  {
    "objectID": "/rsh/errors/#p_258",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously attempts to keep the sum of the {!rsh} Map as a loop variable:"
  },
  {
    "objectID": "/rsh/errors/#p_259",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by moving any {!rsh} Map reductions to inside the {!rsh} invariant:"
  },
  {
    "objectID": "/rsh/errors/#p_260",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a {!rsh} Map was expected in an expression, but a value of a different type was provided. This issue is most likely caused by a typo in an identifier."
  },
  {
    "objectID": "/rsh/errors/#p_261",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to create a {!rsh} Foldable value, which is not possible. {!rsh} Foldable is an interface that {!rsh} Array and {!rsh} Map implement."
  },
  {
    "objectID": "/rsh/errors/#p_262",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously tries to create a {!rsh} Foldable value:"
  },
  {
    "objectID": "/rsh/errors/#p_263",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by instead creating a {!rsh} Map or an {!rsh} Array."
  },
  {
    "objectID": "/rsh/errors/#p_264",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there are normal parameters listed after parameters with default arguments in a function definition. Parameters with default arguments must come after all other arguments."
  },
  {
    "objectID": "/rsh/errors/#p_265",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously lists its parameters:"
  },
  {
    "objectID": "/rsh/errors/#p_266",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by rearranging the parameters so that the ones with default arguments are last:"
  },
  {
    "objectID": "/rsh/errors/#p_267",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to bind an effect or statement, which is not allowed."
  },
  {
    "objectID": "/rsh/errors/#p_268",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below supplies a statement as an argument to a function:"
  },
  {
    "objectID": "/rsh/errors/#p_269",
    "pt": "Error Codes",
    "t": 3,
    "c": "The result of {!rsh} each cannot be bound as a function argument. You can fix this code by wrapping the statement in an arrow expression:"
  },
  {
    "objectID": "/rsh/errors/#p_270",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there are unused variables in your program. This error will only occur with {!rsh} 'use strict'."
  },
  {
    "objectID": "/rsh/errors/#p_271",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by either replacing the unused variable names with {!rsh} _ or subsequently using {!rsh} void(x)."
  },
  {
    "objectID": "/rsh/errors/#p_272",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a field in a {!rsh} Remote object is not a function. You can fix this by ensuring your {!rsh} Remote object only contains fields that are functions. This fix may require changes to the foreign contract you are attempting to connect to."
  },
  {
    "objectID": "/rsh/errors/#p_273",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the key supplied to a {!rsh} Struct does not match the required regex. {!rsh} Struct keys must satisfy the regex: [_a-zA-Z][_a-zA-Z0-9]*."
  },
  {
    "objectID": "/rsh/errors/#p_274",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below provides an erroneous key value:"
  },
  {
    "objectID": "/rsh/errors/#p_275",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by removing any illegal characters:"
  },
  {
    "objectID": "/rsh/errors/#p_276",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a key in a {!rsh} Struct has been used more than once. Every key must be unique in a {!rsh} Struct."
  },
  {
    "objectID": "/rsh/errors/#p_277",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously uses the same key twice:"
  },
  {
    "objectID": "/rsh/errors/#p_278",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by renaming one of the {!rsh} \"x\" fields:"
  },
  {
    "objectID": "/rsh/errors/#p_279",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to export a name that the Reach backend already produces. For example, the names provided in {!rsh} Participant, {!rsh} ParticipantClass, {!rsh} API, and {!rsh} View will be exported by the Reach backend."
  },
  {
    "objectID": "/rsh/errors/#p_280",
    "pt": "Error Codes",
    "t": 3,
    "c": "Reach exports a few names from the backend automatically, such as {!rsh} getExports. Therefore, you cannot export a {!rsh} Participant named {!rsh} getExports as such:"
  },
  {
    "objectID": "/rsh/errors/#p_281",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by choosing a different name."
  },
  {
    "objectID": "/rsh/errors/#p_282",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to use a value that is not a {!rsh} Bool in a condition, while using strict mode."
  },
  {
    "objectID": "/rsh/errors/#p_283",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously uses a number as the condition to {!rsh} if:"
  },
  {
    "objectID": "/rsh/errors/#p_284",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by using a {!rsh} Bool instead. The following code will consider any number that is not {!rsh} 0 {!rsh} true:"
  },
  {
    "objectID": "/rsh/errors/#p_285",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there are multiple {!rsh} throw statements inside a {!rsh} try block and the values thrown are of different {!rsh} Types."
  },
  {
    "objectID": "/rsh/errors/#p_286",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by ensuring that every value thrown is of the same type. It may be necessary to create a new {!rsh} Data instance that can handle different types."
  },
  {
    "objectID": "/rsh/errors/#p_287",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously throws a {!rsh} UInt and a {!rsh} Bool:"
  },
  {
    "objectID": "/rsh/errors/#p_288",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by abstracting the {!rsh} Types of values thrown into a new {!rsh} Data type:"
  },
  {
    "objectID": "/rsh/errors/#p_289",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error occurs when you attempt to use a {!rsh} throw statement outside of a {!rsh} try block."
  },
  {
    "objectID": "/rsh/errors/#p_290",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_291",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by moving your {!rsh} throw statement inside the appropriate block of code or wrapping the necessary code into a {!rsh} try/{!rsh} catch block."
  },
  {
    "objectID": "/rsh/errors/#p_292",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_293",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to {!rsh} pay on the first publication. This is not possible, because the contract will not yet exist, and receiving tokens depends on knowing the address of a contract first on those networks."
  },
  {
    "objectID": "/rsh/errors/#p_294",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_295",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by paying into the contract after the first publication."
  },
  {
    "objectID": "/rsh/errors/#p_296",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_297",
    "pt": "Error Codes",
    "t": 3,
    "c": "Alice creates the wager and the deadline, then declassifies them in the {!rsh} interact object to create the contract. Alice is then able to {!rsh} publish both wager and deadline, and pay the wager because the contract has already been created."
  },
  {
    "objectID": "/rsh/errors/#p_298",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to {!rsh} publish a {!rsh} Token within a {!rsh} while loop. This is not currently possible in Reach. You must publish {!rsh} Token values outside of loops."
  },
  {
    "objectID": "/rsh/errors/#p_299",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously publishes a {!rsh} Token inside a loop:"
  },
  {
    "objectID": "/rsh/errors/#p_300",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by publishing {!rsh} tok before the loop:"
  },
  {
    "objectID": "/rsh/errors/#p_301",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to reference a {!rsh} Token that was computed dynamically. Reach does not yet support this."
  },
  {
    "objectID": "/rsh/errors/#p_302",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below attempts to transfer the balance of an {!rsh} array of {!rsh} Tokens to a {!rsh} Participant:"
  },
  {
    "objectID": "/rsh/errors/#p_303",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can work around this issue by writing out the {!rsh} Token values explicitly:"
  },
  {
    "objectID": "/rsh/errors/#p_304",
    "pt": "Error Codes",
    "t": 3,
    "c": "Sometimes this is caused when you did not include {!rsh} paySpec in a use of {!rsh} fork or {!rsh} parallelReduce."
  },
  {
    "objectID": "/rsh/errors/#p_305",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the incorrect arguments were supplied to {!rsh} withBill. {!rsh} withBill either expects zero arguments, when only receiving network tokens, or a {!rsh} Tuple of {!rsh} Tokens when receiving non-network tokens."
  },
  {
    "objectID": "/rsh/errors/#p_306",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously provides multiple non-network tokens to {!rsh} withBill:"
  },
  {
    "objectID": "/rsh/errors/#p_307",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by wrapping all the arguments into a single {!rsh} Tuple:"
  },
  {
    "objectID": "/rsh/errors/#p_308",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a program declared multiple {!rsh} Views with the same name."
  },
  {
    "objectID": "/rsh/errors/#p_309",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by renaming the duplicate {!rsh} Views, ensuring that every name is unique."
  },
  {
    "objectID": "/rsh/errors/#p_310",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_311",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the value of a {!rsh} View cannot be exposed. This would only occur if the value cannot be represented at runtime."
  },
  {
    "objectID": "/rsh/errors/#p_312",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a {!rsh} View function has an unconstrained domain. Every {!rsh} View must explicitly state the {!rsh} Type of function arguments it accepts."
  },
  {
    "objectID": "/rsh/errors/#p_313",
    "pt": "Error Codes",
    "t": 3,
    "c": "If your {!rsh} View function relies on a varying number of arguments or {!rsh} Types, you can either abstract the arguments into a new {!rsh} Data type or make separate {!rsh} Views."
  },
  {
    "objectID": "/rsh/errors/#p_314",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_315",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there are multiple {!rsh} APIs, {!rsh} Participants or {!rsh} ParticipantClasses with the same name."
  },
  {
    "objectID": "/rsh/errors/#p_316",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_317",
    "pt": "Error Codes",
    "t": 3,
    "c": "Each participant name must be unique."
  },
  {
    "objectID": "/rsh/errors/#p_318",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by renaming the duplicate names."
  },
  {
    "objectID": "/rsh/errors/#p_319",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_320",
    "pt": "Error Codes",
    "t": 3,
    "c": "Since {!rsh} ParticipantClass is being deprecated, it is preferable to use {!rsh} API."
  },
  {
    "objectID": "/rsh/errors/#p_321",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a {!rsh} Struct contains an invalid field name. A field name may be invalid if it is a reserved word in the connector you are targeting."
  },
  {
    "objectID": "/rsh/errors/#p_322",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously uses the field name {!rsh} \"super\", which is reserved in the ETH connector:"
  },
  {
    "objectID": "/rsh/errors/#p_323",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by renaming the erroneous field names:"
  },
  {
    "objectID": "/rsh/errors/#p_324",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that an unexpected key was provided to the {!rsh} Token constructor. You may find the acceptable parameters in the following section: token minting."
  },
  {
    "objectID": "/rsh/errors/#p_325",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to perform an invalid operation on a {!rsh} Token. Some {!rsh} Token methods such as {!rsh} destroy, {!rsh} burn, and {!rsh} supply are only valid for tokens that were created in your program."
  },
  {
    "objectID": "/rsh/errors/#p_326",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by removing the erroneous statement."
  },
  {
    "objectID": "/rsh/errors/#p_327",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you provided an incorrect value to the {!rsh} .define component of a {!rsh} parallelReduce statement. The argument to {!rsh} .define should be of the form: {!rsh} () => DEFINE_BLOCK. Please review the {!rsh} parallelReduce documentation for information on how {!rsh} .define works."
  },
  {
    "objectID": "/rsh/errors/#p_328",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you provided an incorrect value to a function. The function expected to receive a {!rsh} Type, but received something else. This issue can arise when a {!rsh} Type constructor does not have any arguments applied to it."
  },
  {
    "objectID": "/rsh/errors/#p_329",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously creates an {!rsh} Object type with a field {!rsh} name:"
  },
  {
    "objectID": "/rsh/errors/#p_330",
    "pt": "Error Codes",
    "t": 3,
    "c": "This code is incorrect because {!rsh} Bytes is not a type; it is a function that accepts a {!rsh} UInt and returns a {!rsh} Type. This code can be fixed by providing an argument to {!rsh} Bytes that represents the length:"
  },
  {
    "objectID": "/rsh/errors/#p_331",
    "pt": "Error Codes",
    "t": 3,
    "c": "For more information about data types, visit Types."
  },
  {
    "objectID": "/rsh/errors/#p_332",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a time argument's type is not known at compile-time."
  },
  {
    "objectID": "/rsh/errors/#p_333",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, if {!rsh} x is not known at compile-time, then"
  },
  {
    "objectID": "/rsh/errors/#p_334",
    "pt": "Error Codes",
    "t": 3,
    "c": "results in this error."
  },
  {
    "objectID": "/rsh/errors/#p_335",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error means that a {!rsh} return statement, typically inside of an {!rsh} if statement, does not occur in tail position."
  },
  {
    "objectID": "/rsh/errors/#p_336",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, this function would have this error:"
  },
  {
    "objectID": "/rsh/errors/#p_337",
    "pt": "Error Codes",
    "t": 3,
    "c": "The third {!rsh} return can never be reached, so the way to correct the program is to remove it."
  },
  {
    "objectID": "/rsh/errors/#p_338",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error means that only one branch of a conditional ({!rsh} if or {!rsh} switch) contains a {!rsh} return statement."
  },
  {
    "objectID": "/rsh/errors/#p_339",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, this function would have this error:"
  },
  {
    "objectID": "/rsh/errors/#p_340",
    "pt": "Error Codes",
    "t": 3,
    "c": "It should be corrected by moving the tail of the {!rsh} if into the {!rsh} else branch:"
  },
  {
    "objectID": "/rsh/errors/#p_341",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a switch case is unreachable. This issue will occur when a {!rsh} case is listed after {!rsh} default."
  },
  {
    "objectID": "/rsh/errors/#p_342",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously puts a {!rsh} case after {!rsh} default:"
  },
  {
    "objectID": "/rsh/errors/#p_343",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error can be corrected by either removing the {!rsh} Some case or placing it before the {!rsh} default case:"
  },
  {
    "objectID": "/rsh/errors/#p_344",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you have inspected the details about a publication, such as via {!rsh} didPublish(), before there has been a publication. This is impossible, so the expression must be moved after the first publication."
  },
  {
    "objectID": "/rsh/errors/#p_345",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously puts {!rsh} didPublish() before {!rsh} publish:"
  },
  {
    "objectID": "/rsh/errors/#p_346",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error can be corrected by placing {!rsh} publish before {!rsh} didPublish():"
  },
  {
    "objectID": "/rsh/errors/#p_347",
    "pt": "Error Codes",
    "t": 3,
    "c": "Notice that the Sponsor {!rsh} published on line 35. On Line 62, {!rsh} didPublish() is used to make a check."
  },
  {
    "objectID": "/rsh/errors/#p_348",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that an actor who is not a {!rsh} Participant, e.g. a {!rsh} ParticipantClass, is attempting to make the first publication of a Reach program."
  },
  {
    "objectID": "/rsh/errors/#p_349",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by assigning the first publication to one of your {!rsh} Participants. Additionally, you can create a new {!rsh} Participant to specifically perform this action."
  },
  {
    "objectID": "/rsh/errors/#p_350",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that one of an API's interface members is not a function. For example:"
  },
  {
    "objectID": "/rsh/errors/#p_351",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version 0.1.7."
  },
  {
    "objectID": "/rsh/errors/#p_352",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the left-hand side of a {!rsh} call assignment is not a pair of the domain and a function to return a result to the function. For example:"
  },
  {
    "objectID": "/rsh/errors/#p_353",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the name provided to a {!rsh} Participant, {!rsh} ParticipantClass, {!rsh} API, or {!rsh} View is already in use. There is a single namespace for all of these entities."
  },
  {
    "objectID": "/rsh/errors/#p_354",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously uses the same name multiple times:"
  },
  {
    "objectID": "/rsh/errors/#p_355",
    "pt": "Error Codes",
    "t": 3,
    "c": "{!rsh} 'Flower_girl' is used multiple times because every method of an {!rsh} API will introduce a binding, of the format: <API name>_<method name>, into the namespace."
  },
  {
    "objectID": "/rsh/errors/#p_356",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by using different names:"
  },
  {
    "objectID": "/rsh/errors/#p_357",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is an attempt to make a publication in your program, but there are no {!rsh} Participants or {!rsh} ParticipantClasses declared."
  },
  {
    "objectID": "/rsh/errors/#p_358",
    "pt": "Error Codes",
    "t": 3,
    "c": "This issue can arise when you use {!rsh} Anybody.publish(). To fix this issue, ensure you declare a {!rsh} Participant or {!rsh} ParticipantClass."
  },
  {
    "objectID": "/rsh/errors/#p_359",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the program below erroneously uses {!rsh} Anybody.publish() without declaring any {!rsh} Participant or {!rsh} ParticipantClass:"
  },
  {
    "objectID": "/rsh/errors/#p_360",
    "pt": "Error Codes",
    "t": 3,
    "c": "However, the correct thing to do is to declare at least one {!rsh} Participant or {!rsh} ParticipantClass before using {!rsh} Anybody.publish() like in the program below:"
  },
  {
    "objectID": "/rsh/errors/#p_361",
    "pt": "Error Codes",
    "t": 3,
    "c": "Since {!rsh} ParticipantClass is being deprecated, it is preferable to use {!rsh} API."
  },
  {
    "objectID": "/rsh/errors/#p_362",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that an {!rsh} API is explicitly attempting to make a publication, e.g. {!rsh} api.publish(). An API may only make a publication through a {!rsh} fork, {!rsh} parallelReduce, or {!rsh} call."
  },
  {
    "objectID": "/rsh/errors/#p_363",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_364",
    "pt": "Error Codes",
    "t": 3,
    "c": "Depending on your program, you can fix this error by performing a {!rsh} call or adding an {!rsh} .api case to your {!rsh} fork or {!rsh} parallelReduce statement."
  },
  {
    "objectID": "/rsh/errors/#p_365",
    "pt": "Error Codes",
    "t": 3,
    "c": "This snippet {!rsh} calls the {!rsh} API instead of publishing."
  },
  {
    "objectID": "/rsh/errors/#p_366",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is a {!rsh} fork or {!rsh} parallelReduce in the program that does not specify a {!rsh} .case or {!rsh} .api component. At least one of these components must be specified."
  },
  {
    "objectID": "/rsh/errors/#p_367",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by adding a {!rsh} .case or {!rsh} .api component to your statement."
  },
  {
    "objectID": "/rsh/errors/#p_368",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the .paySpec component of a parallelReduce, or fork does not provide a syntactic tuple of identifiers."
  },
  {
    "objectID": "/rsh/errors/#p_369",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below provides .paySpec with a variable that is equal to a tuple of {!rsh} Token identifiers:"
  },
  {
    "objectID": "/rsh/errors/#p_370",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by inlining the tuple directly:"
  },
  {
    "objectID": "/rsh/errors/#p_371",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to update loop variables to a {!rsh} Tuple of different length. This error can occur in the assignments before a {!rsh} while loop's {!rsh} continue, or the {!rsh} return expression in a {!rsh} parallelReduce case."
  },
  {
    "objectID": "/rsh/errors/#p_372",
    "pt": "Error Codes",
    "t": 3,
    "c": "The code below erroneously attempts to update the loop variable to a 2-tuple in the timeout, although the loop variable is a 1-tuple:"
  },
  {
    "objectID": "/rsh/errors/#p_373",
    "pt": "Error Codes",
    "t": 3,
    "c": "Depending on the intended behavior of the program, you can fix this error in different ways:"
  },
  {
    "objectID": "/rsh/errors/#p_374",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can remove the unnecessary value {!rsh} 43 from the {!rsh} Tuple since you are only tracking one loop variable, {!rsh} a."
  },
  {
    "objectID": "/rsh/errors/#p_375",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can update the loop variable {!rsh} Tuple to track more variables:"
  },
  {
    "objectID": "/rsh/errors/#p_376",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to perform an {!rsh} xor operation on an unsupported type."
  },
  {
    "objectID": "/rsh/errors/#p_377",
    "pt": "Error Codes",
    "t": 3,
    "c": "Refer to the {!rsh} xor documentation to see what types are supported."
  },
  {
    "objectID": "/rsh/errors/#p_378",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to perform a {!rsh} mod operation on an unsupported type."
  },
  {
    "objectID": "/rsh/errors/#p_379",
    "pt": "Error Codes",
    "t": 3,
    "c": "Refer to the {!rsh} mod documentation to see what types are supported."
  },
  {
    "objectID": "/rsh/errors/#p_380",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to overload a method with multiple functions that have the same domain."
  },
  {
    "objectID": "/rsh/errors/#p_381",
    "pt": "Error Codes",
    "t": 3,
    "c": "This code overloads c by setting a, b, and d all to c."
  },
  {
    "objectID": "/rsh/errors/#p_382",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this issue by either removing one of the overloads or changing one of the domains. You can change the domain of a function by altering the type of its parameters or adding/removing parameters."
  },
  {
    "objectID": "/rsh/errors/#p_383",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates you had extra fields in {!rsh} REMOTE_FUN.ALGO that are not supported."
  },
  {
    "objectID": "/rsh/errors/#p_384",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a thunk, or function with no parameters, was expected but something else was provided."
  },
  {
    "objectID": "/rsh/errors/#p_385",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously provides a function with one parameter to the {!rsh} .check function:"
  },
  {
    "objectID": "/rsh/errors/#p_386",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by removing the unnecessary function parameter."
  },
  {
    "objectID": "/rsh/errors/#p_387",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you returned the wrong values in {!rsh} CHECKED_CONSENSUS_EXPR of an {!rsh} .api_ branch."
  },
  {
    "objectID": "/rsh/errors/#p_388",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously returns the new accumulator for {!rsh} parallelReduce:"
  },
  {
    "objectID": "/rsh/errors/#p_389",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by returning a function that accepts the API return function as a parameter."
  },
  {
    "objectID": "/rsh/errors/#p_390",
    "pt": "Error Codes",
    "t": 3,
    "c": "Alternatively, if you want the api B.setX to pay into the contract, you can specify the pay amount as the first element in the return value:"
  },
  {
    "objectID": "/rsh/errors/#p_391",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you attempted to create a {!rsh} Data instance with no variants. This is not allowed."
  },
  {
    "objectID": "/rsh/errors/#p_392",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are using a function, like {!rsh} ContractCode, that requires representing values as JSON, but giving it a value that cannot be represented as JSON."
  },
  {
    "objectID": "/rsh/errors/#p_393",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there was an error while parsing or compiling contract code for {!rsh} ContractCode."
  },
  {
    "objectID": "/rsh/errors/#p_394",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the body of a {!rsh} while loop does not make a publication before the {!rsh} continue statement."
  },
  {
    "objectID": "/rsh/errors/#p_395",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below does not make any publications before continuing the loop:"
  },
  {
    "objectID": "/rsh/errors/#p_396",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by making a publication within the {!rsh} loop:"
  },
  {
    "objectID": "/rsh/errors/#p_397",
    "pt": "Error Codes",
    "t": 3,
    "c": "Note that the body of a {!rsh} while starts in a consensus step so you must first {!rsh} commit before making a publication."
  },
  {
    "objectID": "/rsh/errors/#p_398",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the result of setting a {!rsh} View will never be observable. Either the set does not dominate any {!rsh} commits, or the program {!rsh} exits in the next step."
  },
  {
    "objectID": "/rsh/errors/#p_399",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below attempts to set a loop variable as the value of a {!rsh} View:"
  },
  {
    "objectID": "/rsh/errors/#p_400",
    "pt": "Error Codes",
    "t": 3,
    "c": "The effect of {!rsh} I.i.set(i) is only observable after the next {!rsh} commit in its scope. Since, there are no {!rsh} commits between {!rsh} I.i.set(i) and {!rsh} continue, which is the end of the lexical scope, there is no way to observe the effect of setting {!rsh} I.i."
  },
  {
    "objectID": "/rsh/errors/#p_401",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can generally fix this error by inserting a {!rsh} commit in the area where you'd like the effect of setting a {!rsh} View to be observable. In the case of a {!rsh} while loop, like the program above, it can be fixed the following way:"
  },
  {
    "objectID": "/rsh/errors/#p_402",
    "pt": "Error Codes",
    "t": 3,
    "c": "This change will ensure the {!rsh} View {!rsh} I.i is set to {!rsh} i on every iteration of the loop. Additionally, the continuation of the loop will have {!rsh} I.i set to the last value of the loop variable {!rsh} i."
  },
  {
    "objectID": "/rsh/errors/#p_403",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you called an API multiple times within the same consensus step."
  },
  {
    "objectID": "/rsh/errors/#p_404",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the erroneous code below calls the API, {!rsh} U.f, many times in the same {!rsh} parallelReduce."
  },
  {
    "objectID": "/rsh/errors/#p_405",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by removing the duplicate {!rsh} .api case. Alternatively, you can create a new API method and replace one of the offending cases."
  },
  {
    "objectID": "/rsh/errors/#p_406",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that git clone has failed when trying to download the dependencies of your project. This error will tell you the issue that was encountered."
  },
  {
    "objectID": "/rsh/errors/#p_407",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that git checkout has failed when trying to checkout the specific revision of your dependency. This error will tell you the issue that was encountered."
  },
  {
    "objectID": "/rsh/errors/#p_408",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the dependency required by your project does not contain either the branch specified, or a master/main branch."
  },
  {
    "objectID": "/rsh/errors/#p_409",
    "pt": "Error Codes",
    "t": 3,
    "c": "Please ensure you have specified the correct import."
  },
  {
    "objectID": "/rsh/errors/#p_410",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that your project dependencies need to be retrieved but you did not specify {!rsh} --install-pkgs with your reach command."
  },
  {
    "objectID": "/rsh/errors/#p_411",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by specifying the needed flag with your command."
  },
  {
    "objectID": "/rsh/errors/#p_412",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the syntax you used to specify your import is incorrect."
  },
  {
    "objectID": "/rsh/errors/#p_413",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by using the correct syntax. Please view the documentation for package imports."
  },
  {
    "objectID": "/rsh/errors/#p_414",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the given code must not be reachable because it would result in an error if reached. This error may be caused for different reasons, which will be explained if encountered."
  },
  {
    "objectID": "/rsh/errors/#p_415",
    "pt": "Error Codes",
    "t": 3,
    "c": "One reason this code could be encountered is if there is a branch within a {!rsh} while loop, which does not contain a {!rsh} continue statement when it is expected. You can fix this by explicitly adding the {!rsh} continue statement to the erroneous block of code."
  },
  {
    "objectID": "/rsh/errors/#p_416",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is a circular dependency in the {!rsh} imports of your application."
  },
  {
    "objectID": "/rsh/errors/#p_417",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by refactoring your code to remove the cyclic imports."
  },
  {
    "objectID": "/rsh/errors/#p_418",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_419",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you have specified a function without an argument list."
  },
  {
    "objectID": "/rsh/errors/#p_420",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by adding an argument list."
  },
  {
    "objectID": "/rsh/errors/#p_421",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_422",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that an identifier was expected during parsing, but an expression was received."
  },
  {
    "objectID": "/rsh/errors/#p_423",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a key or a key/value pair was expected in a destructuring assignment, but an object method was received."
  },
  {
    "objectID": "/rsh/errors/#p_424",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below creates a method within a destructuring assignment:"
  },
  {
    "objectID": "/rsh/errors/#p_425",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by simply specifying {!rsh} x in the assignment:"
  },
  {
    "objectID": "/rsh/errors/#p_426",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that an unsupported binary operator was encountered. Reach is a subset of JavaScript and does not support all of the binary operators JavaScript supports."
  },
  {
    "objectID": "/rsh/errors/#p_427",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by utilizing different operators or functions depending on the logic of your program."
  },
  {
    "objectID": "/rsh/errors/#p_428",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_429",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that an unsupported literal was encountered. Reach is a subset of JavaScript and does not support all of the literals that JavaScript supports."
  },
  {
    "objectID": "/rsh/errors/#p_430",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that an unsupported unary operator was encountered. Reach is a subset of JavaScript and does not support all of the unary operators JavaScript supports."
  },
  {
    "objectID": "/rsh/errors/#p_431",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by utilizing different operators or functions depending on the logic of your program."
  },
  {
    "objectID": "/rsh/errors/#p_432",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to {!rsh} import a file using an absolute path which is not supported."
  },
  {
    "objectID": "/rsh/errors/#p_433",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by using a relative path for your {!rsh} import."
  },
  {
    "objectID": "/rsh/errors/#p_434",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are trying to {!rsh} import a path that is accessing its parent directory via {!rsh} ... This type of import is not allowed. Please view the documentation for package imports."
  },
  {
    "objectID": "/rsh/errors/#p_435",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously {!rsh} imports a file from its parent directory:"
  },
  {
    "objectID": "/rsh/errors/#p_436",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by moving your file, {!rsh} \"../a.rsh\", to the same directory your program is in. Then, reference it using a relative import:"
  },
  {
    "objectID": "/rsh/errors/#p_437",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_438",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the Reach file could not be parsed as a module."
  },
  {
    "objectID": "/rsh/errors/#p_439",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a call-like expression was expected, but another value was provided."
  },
  {
    "objectID": "/rsh/errors/#p_440",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously passes {!rsh} _x, a secret value of {!rsh} Bob, to {!rsh} unknowable:"
  },
  {
    "objectID": "/rsh/errors/#p_441",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by providing a call-like expression to the function:"
  },
  {
    "objectID": "/rsh/errors/#p_442",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_443",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that Reach expected to parse an identifier, but none was given."
  },
  {
    "objectID": "/rsh/errors/#p_444",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by adding an identifier name to the erroneous location."
  },
  {
    "objectID": "/rsh/errors/#p_445",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is a syntax error in your program. This error will provide the specific token that is erroneous."
  },
  {
    "objectID": "/rsh/errors/#p_446",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously provides an extra comma after the last argument of a function call:"
  },
  {
    "objectID": "/rsh/errors/#p_447",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by removing the unnecessary trailing comma:"
  },
  {
    "objectID": "/rsh/errors/#p_448",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are trying to inspect or use the value produced from {!rsh} forall outside of an {!rsh} assert."
  },
  {
    "objectID": "/rsh/errors/#p_449",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below attempts to verify that all {!rsh} UInts are greater than or equal to zero via a {!rsh} require:"
  },
  {
    "objectID": "/rsh/errors/#p_450",
    "pt": "Error Codes",
    "t": 3,
    "c": "This is invalid because the result of {!rsh} forall is an abstract value, which cannot exist at runtime. You can fix this code by verifying the claim via an {!rsh} assert:"
  },
  {
    "objectID": "/rsh/errors/#p_451",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error means that you defined an API but did not actually use it in your prorgam."
  },
  {
    "objectID": "/rsh/errors/#p_452",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error means that you returned the result to an API without calling it. This is generally not possible unless you directly use the internal representation of APIs."
  },
  {
    "objectID": "/rsh/errors/#p_453",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1.10."
  },
  {
    "objectID": "/rsh/errors/#p_454",
    "pt": "Error Codes",
    "t": 3,
    "c": "The error means that you use an API in two places in your program, which is not allowed."
  },
  {
    "objectID": "/rsh/errors/#p_455",
    "pt": "Error Codes",
    "t": 3,
    "c": "This might look like the following in the {!rsh} API_CONSENSUS_EXPR:"
  },
  {
    "objectID": "/rsh/errors/#p_456",
    "pt": "Error Codes",
    "t": 3,
    "c": "You cannot return from an API call twice."
  },
  {
    "objectID": "/rsh/errors/#p_457",
    "pt": "Error Codes",
    "t": 3,
    "c": "Sometimes the second instance is a by-product of an effect duplicating a continuation, such as:"
  },
  {
    "objectID": "/rsh/errors/#p_458",
    "pt": "Error Codes",
    "t": 3,
    "c": "This is because this is equivalent to:"
  },
  {
    "objectID": "/rsh/errors/#p_459",
    "pt": "Error Codes",
    "t": 3,
    "c": "Instead, the effect should happen after the return:"
  },
  {
    "objectID": "/rsh/errors/#p_460",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error means that you did not return a result from an API call."
  },
  {
    "objectID": "/rsh/errors/#p_461",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error means that an API caller relies on non-consensus state to operate. Typically, this is because the {!rsh} assume uses a value not needed by the consensus. This is likely a sign of a bigger error, because a {!rsh} assume that does not have a \"matching\" {!rsh} require in the consensus is not useful."
  },
  {
    "objectID": "/rsh/errors/#p_462",
    "pt": "Error Codes",
    "t": 3,
    "c": "This warning means the syntax or function you are trying to use is deprecated. It is still supported by the Reach compiler, but future versions of Reach may stop supporting it."
  },
  {
    "objectID": "/rsh/errors/#p_463",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this warning by using the new syntax or function the message suggests."
  },
  {
    "objectID": "/rsh/errors/#p_464",
    "pt": "Error Codes",
    "t": 3,
    "c": "This warning indicates there is an issue with the Solidity compiler. The message provided can be reported to Solidity."
  },
  {
    "objectID": "/rsh/errors/#p_465",
    "pt": "Error Codes",
    "t": 3,
    "c": "This warning indicates that your program either uses a feature that is not yet supported on Algorand or surpasses Algorand's limit on resources."
  },
  {
    "objectID": "/rsh/errors/#p_466",
    "pt": "Error Codes",
    "t": 3,
    "c": "This warning indicates your program will not run on Algorand for the listed reasons. These reasons include a limit on the total computation cost."
  },
  {
    "objectID": "/rsh/errors/#p_467",
    "pt": "Error Codes",
    "t": 3,
    "c": "This warning indicates that your program does not contain any publications."
  },
  {
    "objectID": "/rsh/errors/#p_468",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this issue by making sure at least one {!rsh} Participant performs a {!rsh} publish."
  },
  {
    "objectID": "/rsh/errors/#p_469",
    "pt": "Error Codes",
    "t": 3,
    "c": "This warning indicates that a {!rsh} View or {!rsh} API produces or consumes an {!rsh} Object, which is a type internal to Reach. It has an opaque and unspecified representation that can only be automatically consumed by other Reach programs, so it is probably a bad choice for general purpose interfaces."
  },
  {
    "objectID": "/rsh/errors/#p_470",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can remove this warning by using a {!rsh} Struct instead of the {!rsh} Object."
  },
  {
    "objectID": "/rsh/errors/#p_471",
    "pt": "Error Codes",
    "t": 3,
    "c": "This warning indicates that you referenced network seconds in your program."
  },
  {
    "objectID": "/rsh/errors/#p_472",
    "pt": "Error Codes",
    "t": 3,
    "c": "On most consensus networks, network seconds are completely unrelated to reality. The only invariant about these timestamps are that they never go down and they never increase by more than a fixed amont of seconds at each increment. (For example, on Ethereum, the fixed amount is 15, and on Algorand the amount is 25. Typically these are configurable parameters of the consensus, but have never actually been changed.)"
  },
  {
    "objectID": "/rsh/errors/#p_473",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, time 20 could actually occur on Monday at 17:45:00, but be assigned the timestamp of Sunday at 05:08:32, because that's when time 19 was and there was network downtime. Furthermore, if time 21 was \"on time\" and actually occurred on Monday at 17:45:05, it would be assigned to Sunday at 05:08:57 (25 seconds after time 20's assignment)."
  },
  {
    "objectID": "/rsh/errors/#p_474",
    "pt": "Error Codes",
    "t": 3,
    "c": "This process would slowly \"resychronize\"; on Algorand, it would gain 20 seconds on the \"actual time\" every 5 second round. This means it would take roughly 5 hours to resychronize after a day of downtime. However, this is not guaranteed to occur at any particular time, because block proposers (on Algorand, at least) are free to leave the timestamp unchanged from the last block (i.e. there is no minimum increment), so it is possible that time would never be synchronized with reality at all."
  },
  {
    "objectID": "/rsh/errors/#p_475",
    "pt": "Error Codes",
    "t": 3,
    "c": "Thus, it is unsafe to rely on network seconds for most purposes (such as interest on loans, time limits on auctions, and so forth), because network downtime (even intermitten) and adversarial block proposers (acting alone) can delay and influence the block time."
  },
  {
    "objectID": "/rsh/errors/#p_476",
    "pt": "Error Codes",
    "t": 3,
    "c": "This code uses {!rsh} relativeTime instead of {!rsh} relativeSecs to use real time instead of network time."
  },
  {
    "objectID": "/rsh/errors/#p_477",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates your program has failed verification. This error code is nonspecific, and is invoked for any verification error."
  },
  {
    "objectID": "/rsh/local/#rsh_interact",
    "pt": "Local Steps",
    "t": 0,
    "s": "rsh",
    "c": "interact"
  },
  {
    "objectID": "/rsh/local/#rsh_assume",
    "pt": "Local Steps",
    "t": 0,
    "s": "rsh",
    "c": "assume"
  },
  {
    "objectID": "/rsh/local/#rsh_fail",
    "pt": "Local Steps",
    "t": 0,
    "s": "rsh",
    "c": "fail"
  },
  {
    "objectID": "/rsh/local/#rsh_declassify",
    "pt": "Local Steps",
    "t": 0,
    "s": "rsh",
    "c": "declassify"
  },
  {
    "objectID": "/rsh/local/#rsh_makeCommitment",
    "pt": "Local Steps",
    "t": 0,
    "s": "rsh",
    "c": "makeCommitment"
  },
  {
    "objectID": "/rsh/local/#rsh_didPublish",
    "pt": "Local Steps",
    "t": 0,
    "s": "rsh",
    "c": "didPublish"
  },
  {
    "objectID": "/rsh/local/#term_interaction%20expression",
    "pt": "Local Steps",
    "t": 1,
    "c": "interaction expression"
  },
  {
    "objectID": "/rsh/local/#term_declassify",
    "pt": "Local Steps",
    "t": 1,
    "c": "declassify"
  },
  {
    "objectID": "/rsh/local/#ref-programs-local",
    "pt": "Local Steps",
    "t": 2,
    "c": "Local Steps"
  },
  {
    "objectID": "/rsh/local/#ref-programs-local-stmts",
    "pt": "Local Steps",
    "t": 2,
    "c": "Statements"
  },
  {
    "objectID": "/rsh/local/#ref-programs-local-exprs",
    "pt": "Local Steps",
    "t": 2,
    "c": "Expressions"
  },
  {
    "objectID": "/rsh/local/#ref-programs-local-this",
    "pt": "Local Steps",
    "t": 2,
    "c": "this"
  },
  {
    "objectID": "/rsh/local/#interact",
    "pt": "Local Steps",
    "t": 2,
    "c": "interact"
  },
  {
    "objectID": "/rsh/local/#assume",
    "pt": "Local Steps",
    "t": 2,
    "c": "assume"
  },
  {
    "objectID": "/rsh/local/#fail",
    "pt": "Local Steps",
    "t": 2,
    "c": "fail"
  },
  {
    "objectID": "/rsh/local/#declassify",
    "pt": "Local Steps",
    "t": 2,
    "c": "declassify"
  },
  {
    "objectID": "/rsh/local/#makecommitment",
    "pt": "Local Steps",
    "t": 2,
    "c": "makeCommitment"
  },
  {
    "objectID": "/rsh/local/#didpublish",
    "pt": "Local Steps",
    "t": 2,
    "c": "didPublish"
  },
  {
    "objectID": "/rsh/local/#p_0",
    "pt": "Local Steps",
    "t": 3,
    "c": "A Reach local step occurs in the body of {!rsh} only or {!rsh} each statements. It represents the actions taken by a single participant in an application."
  },
  {
    "objectID": "/rsh/local/#p_1",
    "pt": "Local Steps",
    "t": 3,
    "c": "Any statements valid for a computation are valid for a local step."
  },
  {
    "objectID": "/rsh/local/#p_2",
    "pt": "Local Steps",
    "t": 3,
    "c": "Any expressions valid for a computation are valid for a local step. However, some additional expressions are allowed."
  },
  {
    "objectID": "/rsh/local/#p_3",
    "pt": "Local Steps",
    "t": 3,
    "c": "Inside of a local step, {!rsh} this refers to the participant performing the step. This is useful when the local step was initiated by an {!rsh} each expression."
  },
  {
    "objectID": "/rsh/local/#p_4",
    "pt": "Local Steps",
    "t": 3,
    "c": "An interaction expression, written {!rsh} interact.METHOD(EXPR_0, ..., EXPR_n), where {!rsh} METHOD is an identifier bound in the participant interact interface to a function type, and {!rsh} EXPR_0 through {!rsh} EXPR_n are expressions that evaluate to the result of an interaction with a frontend that receives the evaluation of the {!rsh} n expressions and sends a value."
  },
  {
    "objectID": "/rsh/local/#p_5",
    "pt": "Local Steps",
    "t": 3,
    "c": "An interaction expression may also be written {!rsh} interact.KEY, where {!rsh} KEY is bound in the participant interact interface to a non-function type."
  },
  {
    "objectID": "/rsh/local/#p_6",
    "pt": "Local Steps",
    "t": 3,
    "c": "An interaction expression may only occur in a local step."
  },
  {
    "objectID": "/rsh/local/#p_7",
    "pt": "Local Steps",
    "t": 3,
    "c": "In this example from the Rock, Paper Scissors tutorial, the program is in the local step of Alice. It has Alice {!rsh} declassify the {!rsh} interact object for both the wager and the deadline for Bob, so that Bob can accept them."
  },
  {
    "objectID": "/rsh/local/#p_8",
    "pt": "Local Steps",
    "t": 3,
    "c": "An assumption where {!rsh} claim evaluates to {!rsh} true with honest frontends. This may only appear in a local step. It accepts an optional bytes argument, which is included in any reported violation."
  },
  {
    "objectID": "/rsh/local/#p_9",
    "pt": "Local Steps",
    "t": 3,
    "c": "If the claim dynamically evaluates to false, the frontend will raise an exception."
  },
  {
    "objectID": "/rsh/local/#p_10",
    "pt": "Local Steps",
    "t": 3,
    "c": "In this example, the claim is that the two tokens, tokenA and tokenB, are not the same, and there is no message that displays."
  },
  {
    "objectID": "/rsh/local/#p_11",
    "pt": "Local Steps",
    "t": 3,
    "c": "is a convenience method equivalent to {!rsh} assume(false). This may only appear in a local step."
  },
  {
    "objectID": "/rsh/local/#p_12",
    "pt": "Local Steps",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/local/#p_13",
    "pt": "Local Steps",
    "t": 3,
    "c": "This code calls {!rsh} fail inside of A's {!rsh} only block on line 16. It evaluates to {!rsh} assume(false)."
  },
  {
    "objectID": "/rsh/local/#p_14",
    "pt": "Local Steps",
    "t": 3,
    "c": "The declassify primitive performs a declassification of the given argument."
  },
  {
    "objectID": "/rsh/local/#p_15",
    "pt": "Local Steps",
    "t": 3,
    "c": "In this statement, Alice declassifies the wager and then publishes it so that Bob can know the wager."
  },
  {
    "objectID": "/rsh/local/#p_16",
    "pt": "Local Steps",
    "t": 3,
    "c": "Returns two values, {!rsh} [ commitment, salt ], where {!rsh} salt is the result of calling {!rsh} interact.random(), and {!rsh} commitment is the digest of {!rsh} salt and {!rsh} x. This is used in a local step before {!rsh} checkCommitment is used in a consensus step."
  },
  {
    "objectID": "/rsh/local/#p_17",
    "pt": "Local Steps",
    "t": 3,
    "c": "This is demonstrated in the example below. {!rsh} makeCommitment is used on line 18 before {!rsh} checkCommitment on line 21:"
  },
  {
    "objectID": "/rsh/local/#p_18",
    "pt": "Local Steps",
    "t": 3,
    "c": "Returns a boolean that indicates whether the last publication was made by this principal. A {!rsh} didPublish call must be inside an {!rsh} only block of code and be after a {!rsh} publish call."
  },
  {
    "objectID": "/rsh/local/#p_19",
    "pt": "Local Steps",
    "t": 3,
    "c": "For example, in the code below, a {!rsh} didPublish call is made on line 62 in an {!rsh} only block of code after a {!rsh} publish call was made on line 35:"
  },
  {
    "objectID": "/rsh/module/#rsh_export",
    "pt": "Modules",
    "t": 0,
    "s": "rsh",
    "c": "export"
  },
  {
    "objectID": "/rsh/module/#rsh_import",
    "pt": "Modules",
    "t": 0,
    "s": "rsh",
    "c": "import"
  },
  {
    "objectID": "/rsh/module/#rsh_from",
    "pt": "Modules",
    "t": 0,
    "s": "rsh",
    "c": "from"
  },
  {
    "objectID": "/rsh/module/#rsh_Reach",
    "pt": "Modules",
    "t": 0,
    "s": "rsh",
    "c": "Reach"
  },
  {
    "objectID": "/rsh/module/#rsh_App",
    "pt": "Modules",
    "t": 0,
    "s": "rsh",
    "c": "App"
  },
  {
    "objectID": "/rsh/module/#rsh_Reach.App",
    "pt": "Modules",
    "t": 0,
    "s": "rsh",
    "c": "Reach.App"
  },
  {
    "objectID": "/rsh/module/#term_source%20file",
    "pt": "Modules",
    "t": 1,
    "c": "source file"
  },
  {
    "objectID": "/rsh/module/#term_module",
    "pt": "Modules",
    "t": 1,
    "c": "module"
  },
  {
    "objectID": "/rsh/module/#term_export",
    "pt": "Modules",
    "t": 1,
    "c": "export"
  },
  {
    "objectID": "/rsh/module/#term_imports",
    "pt": "Modules",
    "t": 1,
    "c": "imports"
  },
  {
    "objectID": "/rsh/module/#term_local%20import",
    "pt": "Modules",
    "t": 1,
    "c": "local import"
  },
  {
    "objectID": "/rsh/module/#term_Package%20imports",
    "pt": "Modules",
    "t": 1,
    "c": "Package imports"
  },
  {
    "objectID": "/rsh/module/#term_Reach.App",
    "pt": "Modules",
    "t": 1,
    "c": "Reach.App"
  },
  {
    "objectID": "/rsh/module/#ref-programs-module",
    "pt": "Modules",
    "t": 2,
    "c": "Modules"
  },
  {
    "objectID": "/rsh/module/#ref-programs-module-stmts",
    "pt": "Modules",
    "t": 2,
    "c": "Statements"
  },
  {
    "objectID": "/rsh/module/#ref-programs-export",
    "pt": "Modules",
    "t": 2,
    "c": "export"
  },
  {
    "objectID": "/rsh/module/#ref-programs-import",
    "pt": "Modules",
    "t": 2,
    "c": "import"
  },
  {
    "objectID": "/rsh/module/#ref-programs-import-local",
    "pt": "Modules",
    "t": 2,
    "c": "Local imports"
  },
  {
    "objectID": "/rsh/module/#ref-programs-import-package",
    "pt": "Modules",
    "t": 2,
    "c": "Package imports"
  },
  {
    "objectID": "/rsh/module/#ref-programs-module-exprs",
    "pt": "Modules",
    "t": 2,
    "c": "Expressions"
  },
  {
    "objectID": "/rsh/module/#ref-programs-reachapp",
    "pt": "Modules",
    "t": 2,
    "c": "Reach.App"
  },
  {
    "objectID": "/rsh/module/#deprecated-long-form",
    "pt": "Modules",
    "t": 2,
    "c": "Deprecated long-form"
  },
  {
    "objectID": "/rsh/module/#p_0",
    "pt": "Modules",
    "t": 3,
    "c": "A Reach source file is a textual file which specifies a Reach module. It is traditionally given the file extension rsh, e.g. dao.rsh."
  },
  {
    "objectID": "/rsh/module/#p_1",
    "pt": "Modules",
    "t": 3,
    "c": "A module starts with {!rsh} 'reach 0.1'; followed by a sequence of imports and identifier definitions."
  },
  {
    "objectID": "/rsh/module/#p_2",
    "pt": "Modules",
    "t": 3,
    "c": "See the guide section on versions to understand how Reach uses version numbers like this."
  },
  {
    "objectID": "/rsh/module/#p_3",
    "pt": "Modules",
    "t": 3,
    "c": "Any statements valid for a computation are valid for a module. However, some additional statements are allowed."
  },
  {
    "objectID": "/rsh/module/#p_4",
    "pt": "Modules",
    "t": 3,
    "c": "Module-level identifier definitions may be exported by writing {!rsh} export in front of them. For example,"
  },
  {
    "objectID": "/rsh/module/#p_5",
    "pt": "Modules",
    "t": 3,
    "c": "are valid exports."
  },
  {
    "objectID": "/rsh/module/#p_6",
    "pt": "Modules",
    "t": 3,
    "c": "Module-level identifiers may also be exported after the fact, and may be renamed during export. For example:"
  },
  {
    "objectID": "/rsh/module/#p_7",
    "pt": "Modules",
    "t": 3,
    "c": "Identifiers from other modules may be re-exported (and renamed), even if they are not imported in the current module. For example:"
  },
  {
    "objectID": "/rsh/module/#p_8",
    "pt": "Modules",
    "t": 3,
    "c": "In this case, there is a module with a name of other-module.rsh which contains u and x. Identifier u is exported as u, and x is exported and renamed to be other_x. An exported identifier in a given module may be imported by other modules. Both u and other_x can be imported from the current module instead of importing them from other-module.rsh."
  },
  {
    "objectID": "/rsh/module/#p_9",
    "pt": "Modules",
    "t": 3,
    "c": "Exports are also exposed to the frontend via {!js} getExports. For more information on {!js} getExports and exposing exports to the frontend, refer to JavaScript."
  },
  {
    "objectID": "/rsh/module/#p_10",
    "pt": "Modules",
    "t": 3,
    "c": "Functions are only exposed if they are typed, that is, if they are constructed with {!rsh} is. Refer to Types for more information."
  },
  {
    "objectID": "/rsh/module/#p_11",
    "pt": "Modules",
    "t": 3,
    "c": "Reach supports two types of module imports: local imports, which refer to modules that exist within your project, and package imports, which refer to remote libraries that may be fetched from external sources such as GitHub."
  },
  {
    "objectID": "/rsh/module/#p_12",
    "pt": "Modules",
    "t": 3,
    "c": "Read the guide section on packages for more details."
  },
  {
    "objectID": "/rsh/module/#p_13",
    "pt": "Modules",
    "t": 3,
    "c": "Package imports are easily distinguished from local imports by a mandatory @ character at the beginning of the path string."
  },
  {
    "objectID": "/rsh/module/#p_14",
    "pt": "Modules",
    "t": 3,
    "c": "When a module, X, contains a local import, written {!rsh} import \"LIB.rsh\";, then the path LIB.rsh must resolve to another Reach source file. The exports from the module defined by LIB.rsh are included in the set of bound identifiers in X."
  },
  {
    "objectID": "/rsh/module/#p_15",
    "pt": "Modules",
    "t": 3,
    "c": "Import statements may limit or rename the imported identifiers."
  },
  {
    "objectID": "/rsh/module/#p_16",
    "pt": "Modules",
    "t": 3,
    "c": "Imports may instead bind the entire module to a single identifier, which is an object with fields corresponding to that module's exports."
  },
  {
    "objectID": "/rsh/module/#p_17",
    "pt": "Modules",
    "t": 3,
    "c": "Import cycles are invalid."
  },
  {
    "objectID": "/rsh/module/#p_18",
    "pt": "Modules",
    "t": 3,
    "c": "The path given to an import may not include .. to specify files outside the current directory nor may it be an absolute path."
  },
  {
    "objectID": "/rsh/module/#p_19",
    "pt": "Modules",
    "t": 3,
    "c": "It must be a relative path, which is resolved relative to the parent directory of the source file in which they appear."
  },
  {
    "objectID": "/rsh/module/#p_20",
    "pt": "Modules",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/module/#p_21",
    "pt": "Modules",
    "t": 3,
    "c": "This code imports all the contents of lib.rsh and renames it to lib on line 3 while line 4 imports only a few of lib.rsh's contents."
  },
  {
    "objectID": "/rsh/module/#p_22",
    "pt": "Modules",
    "t": 3,
    "c": "Package imports obey the same rules as local imports but support an extended path syntax which allows Reach programmers to seamlessly plug into third-party libraries hosted on the internet."
  },
  {
    "objectID": "/rsh/module/#p_23",
    "pt": "Modules",
    "t": 3,
    "c": "All package imports begin with the @ character."
  },
  {
    "objectID": "/rsh/module/#p_24",
    "pt": "Modules",
    "t": 3,
    "c": "Package import paths are comprised of the following components:"
  },
  {
    "objectID": "/rsh/module/#p_25",
    "pt": "Modules",
    "t": 3,
    "c": "This component must be followed by a : character."
  },
  {
    "objectID": "/rsh/module/#p_26",
    "pt": "Modules",
    "t": 3,
    "c": "This component defaults to GitHub (i.e. github.com) if no site is specified."
  },
  {
    "objectID": "/rsh/module/#p_27",
    "pt": "Modules",
    "t": 3,
    "c": "Examples: github.com:, bitbucket.org:."
  },
  {
    "objectID": "/rsh/module/#p_28",
    "pt": "Modules",
    "t": 3,
    "c": "This component must be followed by a / character."
  },
  {
    "objectID": "/rsh/module/#p_29",
    "pt": "Modules",
    "t": 3,
    "c": "Examples: reach-sh/, jeapostrophe/."
  },
  {
    "objectID": "/rsh/module/#p_30",
    "pt": "Modules",
    "t": 3,
    "c": "Examples: reach-example-package, nfts."
  },
  {
    "objectID": "/rsh/module/#p_31",
    "pt": "Modules",
    "t": 3,
    "c": "If no ref is specified, Reach first tries to find the requested module on the repository's master branch, and if that fails then on the main branch once more."
  },
  {
    "objectID": "/rsh/module/#p_32",
    "pt": "Modules",
    "t": 3,
    "c": "git refs are discussed in further detail here."
  },
  {
    "objectID": "/rsh/module/#p_33",
    "pt": "Modules",
    "t": 3,
    "c": "Read this guide to learn more about how git tags work."
  },
  {
    "objectID": "/rsh/module/#p_34",
    "pt": "Modules",
    "t": 3,
    "c": "This component must be preceded by a # character."
  },
  {
    "objectID": "/rsh/module/#p_35",
    "pt": "Modules",
    "t": 3,
    "c": "Example: #v3.0.6."
  },
  {
    "objectID": "/rsh/module/#p_36",
    "pt": "Modules",
    "t": 3,
    "c": "This component must be preceded by a : character and must end with a /."
  },
  {
    "objectID": "/rsh/module/#p_37",
    "pt": "Modules",
    "t": 3,
    "c": "Example: :src/lib/."
  },
  {
    "objectID": "/rsh/module/#p_38",
    "pt": "Modules",
    "t": 3,
    "c": "Defaults to index.rsh."
  },
  {
    "objectID": "/rsh/module/#p_39",
    "pt": "Modules",
    "t": 3,
    "c": "If the module exists within a subdirectory it must be preceded by a / character."
  },
  {
    "objectID": "/rsh/module/#p_40",
    "pt": "Modules",
    "t": 3,
    "c": "Example: @reach-sh/example#v1.01:parent/child/pkg.rsh."
  },
  {
    "objectID": "/rsh/module/#p_41",
    "pt": "Modules",
    "t": 3,
    "c": "However, if the module is stored in the root of the repository, it must instead be preceded by a : character."
  },
  {
    "objectID": "/rsh/module/#p_42",
    "pt": "Modules",
    "t": 3,
    "c": "Example: @reach-sh/example#v1.02:pkg.rsh."
  },
  {
    "objectID": "/rsh/module/#p_43",
    "pt": "Modules",
    "t": 3,
    "c": "The following forms are all syntactically valid package import expressions:"
  },
  {
    "objectID": "/rsh/module/#p_44",
    "pt": "Modules",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/module/#p_45",
    "pt": "Modules",
    "t": 3,
    "c": "This code imports bestNumber from @reach-sh/reach-example-package:index.rsh package and renames it to bn on line 6. Line 11 {!rsh} asserts that bn is equivalent to 1742."
  },
  {
    "objectID": "/rsh/module/#p_46",
    "pt": "Modules",
    "t": 3,
    "c": "Since git repositories evolve and change over time, Reach takes extra steps in order to pin a given module import's version to the specific SHA hash of the specified revision at the time the package is first installed. These pins are stored in a lockfile, which should be included in your source control system."
  },
  {
    "objectID": "/rsh/module/#p_47",
    "pt": "Modules",
    "t": 3,
    "c": "Any expressions valid for a computation are valid for a module. However, some additional expressions are allowed."
  },
  {
    "objectID": "/rsh/module/#p_48",
    "pt": "Modules",
    "t": 3,
    "c": "Reach.App accepts a no-argument function that specifies a DApp. This function is applied during compilation as an application initialization. It specifies the entire DApp in its body."
  },
  {
    "objectID": "/rsh/module/#p_49",
    "pt": "Modules",
    "t": 3,
    "c": "If the result of {!rsh} Reach.App is eventually bound to an identifier that is exported, then that identifier may be a target given to the compiler, as discussed in the section on usage."
  },
  {
    "objectID": "/rsh/module/#p_50",
    "pt": "Modules",
    "t": 3,
    "c": "Previous versions of Reach only allowed a form of Reach.App which accepted three arguments: an {!rsh} options object, an {!rsh} applicationArgs tuple, and a {!rsh} program arrow of the form {!rsh} (applicationIds) => body."
  },
  {
    "objectID": "/rsh/module/#p_51",
    "pt": "Modules",
    "t": 3,
    "c": "This form was equivalent to"
  },
  {
    "objectID": "/rsh/module/#p_52",
    "pt": "Modules",
    "t": 3,
    "c": "The current version of Reach will automatically transform these \"ternary\" {!rsh} Reach.App instances into the above form."
  },
  {
    "objectID": "/rsh/module/#p_53",
    "pt": "Modules",
    "t": 3,
    "c": "Future versions of Reach will deprecate this transform and such programs will be invalid."
  },
  {
    "objectID": "/rsh/step/#rsh_only",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "only"
  },
  {
    "objectID": "/rsh/step/#rsh_each",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "each"
  },
  {
    "objectID": "/rsh/step/#rsh_publish",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "publish"
  },
  {
    "objectID": "/rsh/step/#rsh_pay",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "pay"
  },
  {
    "objectID": "/rsh/step/#rsh_when",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "when"
  },
  {
    "objectID": "/rsh/step/#rsh_timeout",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "timeout"
  },
  {
    "objectID": "/rsh/step/#rsh_throwTimeout",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "throwTimeout"
  },
  {
    "objectID": "/rsh/step/#rsh_fork",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "fork"
  },
  {
    "objectID": "/rsh/step/#rsh_fork.case",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "fork.case"
  },
  {
    "objectID": "/rsh/step/#rsh_paySpec",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "paySpec"
  },
  {
    "objectID": "/rsh/step/#rsh_fork.paySpec",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "fork.paySpec"
  },
  {
    "objectID": "/rsh/step/#rsh_fork.api",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "fork.api"
  },
  {
    "objectID": "/rsh/step/#rsh_fork.api_",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "fork.api_"
  },
  {
    "objectID": "/rsh/step/#rsh_fork.timeout",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "fork.timeout"
  },
  {
    "objectID": "/rsh/step/#rsh_fork.throwTimeout",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "fork.throwTimeout"
  },
  {
    "objectID": "/rsh/step/#rsh_wait",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "wait"
  },
  {
    "objectID": "/rsh/step/#rsh_exit",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "exit"
  },
  {
    "objectID": "/rsh/step/#rsh_race",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "race"
  },
  {
    "objectID": "/rsh/step/#rsh_unknowable",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "unknowable"
  },
  {
    "objectID": "/rsh/step/#rsh_closeTo",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "closeTo"
  },
  {
    "objectID": "/rsh/step/#rsh_call",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "call"
  },
  {
    "objectID": "/rsh/step/#rsh_call.pay",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "call.pay"
  },
  {
    "objectID": "/rsh/step/#rsh_call.assume",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "call.assume"
  },
  {
    "objectID": "/rsh/step/#rsh_call.check",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "call.check"
  },
  {
    "objectID": "/rsh/step/#rsh_call.throwTimeout",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "call.throwTimeout"
  },
  {
    "objectID": "/rsh/step/#term_interact%20shorthand",
    "pt": "Steps",
    "t": 1,
    "c": "interact shorthand"
  },
  {
    "objectID": "/rsh/step/#term_each",
    "pt": "Steps",
    "t": 1,
    "c": "each"
  },
  {
    "objectID": "/rsh/step/#term_pay%20amount",
    "pt": "Steps",
    "t": 1,
    "c": "pay amount"
  },
  {
    "objectID": "/rsh/step/#term_token%20amount",
    "pt": "Steps",
    "t": 1,
    "c": "token amount"
  },
  {
    "objectID": "/rsh/step/#term_pure",
    "pt": "Steps",
    "t": 1,
    "c": "pure"
  },
  {
    "objectID": "/rsh/step/#term_fork%20statement",
    "pt": "Steps",
    "t": 1,
    "c": "fork statement"
  },
  {
    "objectID": "/rsh/step/#term_wait%20statement",
    "pt": "Steps",
    "t": 1,
    "c": "wait statement"
  },
  {
    "objectID": "/rsh/step/#term_exit%20statement",
    "pt": "Steps",
    "t": 1,
    "c": "exit statement"
  },
  {
    "objectID": "/rsh/step/#term_race%20expression",
    "pt": "Steps",
    "t": 1,
    "c": "race expression"
  },
  {
    "objectID": "/rsh/step/#term_call",
    "pt": "Steps",
    "t": 1,
    "c": "call"
  },
  {
    "objectID": "/rsh/step/#ref-programs-step",
    "pt": "Steps",
    "t": 2,
    "c": "Steps"
  },
  {
    "objectID": "/rsh/step/#ref-programs-step-stmts",
    "pt": "Steps",
    "t": 2,
    "c": "Statements"
  },
  {
    "objectID": "/rsh/step/#ref-programs-only-step",
    "pt": "Steps",
    "t": 2,
    "c": "only and each"
  },
  {
    "objectID": "/rsh/step/#payAmt",
    "pt": "Steps",
    "t": 2,
    "c": "Pay Amounts"
  },
  {
    "objectID": "/rsh/step/#publish---pay---when--and--timeout",
    "pt": "Steps",
    "t": 2,
    "c": "publish, pay, when, and timeout"
  },
  {
    "objectID": "/rsh/step/#fork",
    "pt": "Steps",
    "t": 2,
    "c": "fork"
  },
  {
    "objectID": "/rsh/step/#fork--intuition",
    "pt": "Steps",
    "t": 2,
    "c": "fork intuition"
  },
  {
    "objectID": "/rsh/step/#wait",
    "pt": "Steps",
    "t": 2,
    "c": "wait"
  },
  {
    "objectID": "/rsh/step/#exit",
    "pt": "Steps",
    "t": 2,
    "c": "exit"
  },
  {
    "objectID": "/rsh/step/#ref-programs-step-exprs",
    "pt": "Steps",
    "t": 2,
    "c": "Expressions"
  },
  {
    "objectID": "/rsh/step/#race",
    "pt": "Steps",
    "t": 2,
    "c": "race"
  },
  {
    "objectID": "/rsh/step/#unknowable",
    "pt": "Steps",
    "t": 2,
    "c": "unknowable"
  },
  {
    "objectID": "/rsh/step/#closeto",
    "pt": "Steps",
    "t": 2,
    "c": "closeTo"
  },
  {
    "objectID": "/rsh/step/#call",
    "pt": "Steps",
    "t": 2,
    "c": "call"
  },
  {
    "objectID": "/rsh/step/#p_0",
    "pt": "Steps",
    "t": 3,
    "c": "A Reach step occurs in the continuation of an init statement or commit statement. It represents the actions taken by each of the participants in an application."
  },
  {
    "objectID": "/rsh/step/#p_1",
    "pt": "Steps",
    "t": 3,
    "c": "Any statements valid for a computation are valid for a step. However, some additional statements are allowed."
  },
  {
    "objectID": "/rsh/step/#p_2",
    "pt": "Steps",
    "t": 3,
    "c": "A local step statement is written {!rsh} PART.only(() => BLOCK), where {!rsh} PART is a participant identifier and {!rsh} BLOCK is a block. Within {!rsh} BLOCK, {!rsh} PART is bound to the address of the participant. Any bindings defined within the block of a local step are available in the statement's tail as new local state. For example,"
  },
  {
    "objectID": "/rsh/step/#p_3",
    "pt": "Steps",
    "t": 3,
    "c": "is a valid program where {!rsh} Alice's local state includes the private values {!rsh} x (bound to {!rsh} 3) and {!rsh} y (bound to {!rsh} 4). However, such bindings are not consensus state, so they are purely local state. For example,"
  },
  {
    "objectID": "/rsh/step/#p_4",
    "pt": "Steps",
    "t": 3,
    "c": "is an invalid program, because {!rsh} Bob does not know {!rsh} x."
  },
  {
    "objectID": "/rsh/step/#p_5",
    "pt": "Steps",
    "t": 3,
    "c": "The interact shorthand, written {!rsh} PART.interact.METHOD(EXPR_0, ..., EXPR_n), is available for calling an {!rsh} interact function from outside of an {!rsh} only block. Such functions must return {!rsh} Null; therefore, they are only useful if they produce side-effects, such as logging on the frontend. For example, the function {!rsh} log in the participant interact interface of {!rsh} Alice may be called via:"
  },
  {
    "objectID": "/rsh/step/#p_6",
    "pt": "Steps",
    "t": 3,
    "c": "An each local step statement can be written as {!rsh} each(PART_TUPLE () => BLOCK), where {!rsh} PART_TUPLE is a tuple of participants and {!rsh} BLOCK is a block. It is an abbreviation of many local step statements that could have been written with {!rsh} only."
  },
  {
    "objectID": "/rsh/step/#p_7",
    "pt": "Steps",
    "t": 3,
    "c": "A pay amount is either:"
  },
  {
    "objectID": "/rsh/step/#p_8",
    "pt": "Steps",
    "t": 3,
    "c": "An integer, denoting an amount of network tokens; or,"
  },
  {
    "objectID": "/rsh/step/#p_9",
    "pt": "Steps",
    "t": 3,
    "c": "A tuple of token amounts."
  },
  {
    "objectID": "/rsh/step/#p_10",
    "pt": "Steps",
    "t": 3,
    "c": "A token amount is either:"
  },
  {
    "objectID": "/rsh/step/#p_11",
    "pt": "Steps",
    "t": 3,
    "c": "An integer, denoting an amount of network tokens; or,"
  },
  {
    "objectID": "/rsh/step/#p_12",
    "pt": "Steps",
    "t": 3,
    "c": "A tuple with two elements, where the first is an integer, denoting an amount of non-network tokens, and the second is {!rsh} Token, specifying a particular non-network token."
  },
  {
    "objectID": "/rsh/step/#p_13",
    "pt": "Steps",
    "t": 3,
    "c": "For example, these are all pay amounts:"
  },
  {
    "objectID": "/rsh/step/#p_14",
    "pt": "Steps",
    "t": 3,
    "c": "It is invalid for a pay amount to specify an amount of tokens multiple times. For example, these are invalid pay amounts:"
  },
  {
    "objectID": "/rsh/step/#p_15",
    "pt": "Steps",
    "t": 3,
    "c": "The ordering of a pay amount is only significant when used within a fork statement or parallel reduce statement that specifies a {!rsh} paySpec. In this case, payments are expected to be a tuple where the first element is an integer pay amount, and the rest of the elements are token amount tuples. The ordering of the token amount elements should match the ordering in {!rsh} paySpec. For example,"
  },
  {
    "objectID": "/rsh/step/#p_16",
    "pt": "Steps",
    "t": 3,
    "c": "will indicate that {!rsh} fork payments should be of the format:"
  },
  {
    "objectID": "/rsh/step/#p_17",
    "pt": "Steps",
    "t": 3,
    "c": "Reach assumes that network tokens and non-network tokens behave identically, but often they do not; this article discusses the causes and consequences of this."
  },
  {
    "objectID": "/rsh/step/#p_18",
    "pt": "Steps",
    "t": 3,
    "c": "If you're unsure of what kind of consensus transfer to use, you may want to read the explanation of the differences in the Guide."
  },
  {
    "objectID": "/rsh/step/#p_19",
    "pt": "Steps",
    "t": 3,
    "c": "A consensus transfer is written"
  },
  {
    "objectID": "/rsh/step/#p_20",
    "pt": "Steps",
    "t": 3,
    "c": "where {!rsh} PART_EXPR is an expression that evaluates to a participant or race expression, {!rsh} ID_0 through {!rsh} ID_n are identifiers for {!rsh} PART's public local state, {!rsh} PAY_EXPR is a public expression that evaluates to a pay amount. {!rsh} PAY_REQUIRE_EXPR is an optional nullary function that can be used to make {!rsh} require claims about the PAY_EXPR. {!rsh} WHEN_EXPR is a public expression evaluating to a boolean and determines if the consensus transfer takes place, {!rsh} DELAY_EXPR is a public expression that depends on only consensus state and evaluates to a time argument, {!rsh} TIMEOUT_BLOCK is a timeout block, which will be executed after the {!rsh} DELAY_EXPR time argument passes without {!rsh} PART executing this consensus transfer."
  },
  {
    "objectID": "/rsh/step/#p_21",
    "pt": "Steps",
    "t": 3,
    "c": "All of the expressions within a consensus transfer are evaluated in a pure context, which may not alter the state of the application. The {!rsh} PAY_EXPR, {!rsh} WHEN_EXPR, and {!rsh} DELAY_EXPR expressions must refer only to the consensus state, including the new data published via the {!rsh} .publish component."
  },
  {
    "objectID": "/rsh/step/#p_22",
    "pt": "Steps",
    "t": 3,
    "c": "The continuation of a consensus transfer statement is a consensus step, which is finalized with a commit statement. The continuation of a timeout block is the same as the continuation of the function the timeout occurs within."
  },
  {
    "objectID": "/rsh/step/#p_23",
    "pt": "Steps",
    "t": 3,
    "c": "See the guide section on non-participation to understand when to use timeouts and how to use them most effectively."
  },
  {
    "objectID": "/rsh/step/#p_24",
    "pt": "Steps",
    "t": 3,
    "c": "The {!rsh} publish component exclusive-or the {!rsh} pay component may be omitted, if either there is no publication or no transfer of network tokens to accompany this consensus transfer. The {!rsh} when component may always be omitted, in which case it is assumed to be {!rsh} true. {!rsh} publish or {!rsh} pay must occur first, after which components may occur in any order. For example, the following are all valid:"
  },
  {
    "objectID": "/rsh/step/#p_25",
    "pt": "Steps",
    "t": 3,
    "c": "The {!rsh} timeout component must be included if {!rsh} when is not statically {!rsh} true. This ensures that your clients will eventually complete the program. If a consensus transfer is a guaranteed race between non-class participants and a participant class that may attempt to transfer (i.e. {!rsh} when is not statically {!rsh} false), then a {!rsh} timeout may be explicitly omitted by writing {!rsh} .timeout(false)."
  },
  {
    "objectID": "/rsh/step/#p_26",
    "pt": "Steps",
    "t": 3,
    "c": "{!rsh} .throwTimeout may be used in place of {!rsh} .timeout. It accepts a {!rsh} DELAY_EXPR and an {!rsh} EXPR, which will be thrown if a timeout should occur. If an {!rsh} EXPR is not provided, then {!rsh} null will be thrown. If a consensus transfer uses {!rsh} .throwTimeout, it must be within a try statement."
  },
  {
    "objectID": "/rsh/step/#p_27",
    "pt": "Steps",
    "t": 3,
    "c": "If a consensus transfer specifies a single participant, which has not yet been fixed in the application and is not a participant class, then this statement does so; therefore, after it the {!rsh} PART may be used as an address."
  },
  {
    "objectID": "/rsh/step/#p_28",
    "pt": "Steps",
    "t": 3,
    "c": "If a consensus transfer specificies a single participant class, then all members of that class will attempt to perform the transfer, but only one will succeed."
  },
  {
    "objectID": "/rsh/step/#p_29",
    "pt": "Steps",
    "t": 3,
    "c": "A consensus transfer binds the identifiers {!rsh} ID_0 through {!rsh} ID_n for all participants to the values included in the consensus transfer, overwriting any bindings that already exist for those identifiers. If an existing participant, not included in {!rsh} PART_EXPR, has previously bound one of these identifiers, then the program is not valid. In other words, the following program is not valid:"
  },
  {
    "objectID": "/rsh/step/#p_30",
    "pt": "Steps",
    "t": 3,
    "c": "because {!rsh} Claire is not included in the {!rsh} race. However, if we were to rename {!rsh} Claire's {!rsh} x into {!rsh} y, then it would be valid, because although {!rsh} Alice and {!rsh} Bob both bind {!rsh} x, they participate in the {!rsh} race, so it is allowed. In the tail of this program, {!rsh} x is bound to either {!rsh} 1 or {!rsh} 2, i.e., either {!rsh} Alice or {!rsh} Bob's value is overwritten. This overwriting applies even if {!rsh} Alice wins and {!rsh} Alice is a participant class, i.e., the value of {!rsh} x in the tail is guaranteed to be the single value that was agreed upon in the consensus."
  },
  {
    "objectID": "/rsh/step/#p_31",
    "pt": "Steps",
    "t": 3,
    "c": "If you're unsure of what kind of consensus transfer to use, you may want to read the explanation of the differences in the Guide."
  },
  {
    "objectID": "/rsh/step/#p_32",
    "pt": "Steps",
    "t": 3,
    "c": "A fork statement is written:"
  },
  {
    "objectID": "/rsh/step/#p_33",
    "pt": "Steps",
    "t": 3,
    "c": "where:"
  },
  {
    "objectID": "/rsh/step/#p_34",
    "pt": "Steps",
    "t": 3,
    "c": "{!rsh} TOKENS_EXPR is a syntactic tuple of {!rsh} Token identifiers, or a static ternary expression that evaluates to one;"
  },
  {
    "objectID": "/rsh/step/#p_35",
    "pt": "Steps",
    "t": 3,
    "c": "{!rsh} PART_EXPR is an expression that evaluates to a participant;"
  },
  {
    "objectID": "/rsh/step/#p_36",
    "pt": "Steps",
    "t": 3,
    "c": "(optional) {!rsh} CHECK_EXPR is a syntactic arrow expression that is evaluated in both the local step and consensus step. This block can be used to specify {!rsh} checks and declare variable bindings. If it is present, then {!rsh} PAY_EXPR must be included;"
  },
  {
    "objectID": "/rsh/step/#p_37",
    "pt": "Steps",
    "t": 3,
    "c": "{!rsh} PUBLISH_EXPR is a syntactic arrow expression that is evaluated in a local step for the specified participant and must evaluate to an object that may contain a msg field, which may be of any type, a when field, which must be a boolean, and a _local field, which may be of any type;"
  },
  {
    "objectID": "/rsh/step/#p_38",
    "pt": "Steps",
    "t": 3,
    "c": "(optional) {!rsh} PAY_EXPR is an expression that evaluates to a function parameterized over the msg value and returns a pay amount; if this component is left-out, it is synthesized to zero;"
  },
  {
    "objectID": "/rsh/step/#p_39",
    "pt": "Steps",
    "t": 3,
    "c": "(optional) {!rsh} PAY_REQUIRE_EXPR is a function parameterized over the msg value which is evaluated for effect in a consensus step; thus it may be used to add {!rsh} require constraints on the value used for payment. If this is absent, then it is synthesized to an empty function."
  },
  {
    "objectID": "/rsh/step/#p_40",
    "pt": "Steps",
    "t": 3,
    "c": "{!rsh} CONSENSUS_EXPR is a syntactic arrow expression parameterized over the msg and _local values which is evaluated in a consensus step;"
  },
  {
    "objectID": "/rsh/step/#p_41",
    "pt": "Steps",
    "t": 3,
    "c": "{!rsh} API_EXPR is an expression that evaluates to an API member function;"
  },
  {
    "objectID": "/rsh/step/#p_42",
    "pt": "Steps",
    "t": 3,
    "c": "(optional) {!rsh} API_ASSUME_EXPR is a function parameterized over the input to the API member function which is evaluated for effect in a local step; thus it may be used to add {!rsh} assume constraints on the values given by the API; if this is absent, then it is synthesized to an empty function; if it is present, then {!rsh} API_PAY_EXPR must be included;"
  },
  {
    "objectID": "/rsh/step/#p_43",
    "pt": "Steps",
    "t": 3,
    "c": "(optional) {!rsh} API_PAY_EXPR is a function parameterized over the input to the API member function which is evaluated to determine the pay amount, like {!rsh} PAY_EXPR;"
  },
  {
    "objectID": "/rsh/step/#p_44",
    "pt": "Steps",
    "t": 3,
    "c": "{!rsh} API_CONSENSUS_EXPR is a function parameterized over the input to the API member function and a function that returns a value to the API call; this function must be called;"
  },
  {
    "objectID": "/rsh/step/#p_45",
    "pt": "Steps",
    "t": 3,
    "c": "{!rsh} API_CHECKED_CONSENSUS_EXPR is a function parameterized over the input to the API member function. It must return either a pair of {!rsh} [ PAY_EXPR, CONSENSUS_RET_EXPR ] or {!rsh} [ CONSENSUS_RET_EXPR ], where {!rsh} CONSENSUS_RET_EXPR is a function parameterized over the function that returns a value to the API call. The parameter of {!rsh} CONSENSUS_RET_EXPR must be called. Any {!rsh} checks performed before the {!rsh} return statement will be applied in the local step, during payment, and the consensus step of the API call."
  },
  {
    "objectID": "/rsh/step/#p_46",
    "pt": "Steps",
    "t": 3,
    "c": "the {!rsh} timeout and {!rsh} throwTimeout parameter are as in an consensus transfer."
  },
  {
    "objectID": "/rsh/step/#p_47",
    "pt": "Steps",
    "t": 3,
    "c": "In the discussion of {!rsh} .api component, the phrase \"parameterized over the input\" means that if an API function has two arguments, such as {!rsh} Fun([UInt, UInt], Null), then the corresponding expression must receive two arguments. For example, the {!rsh} API_PAY_EXPR component would be a function that accepts two arguments, while the {!rsh} API_CONSENSUS_EXPR would be a function that acccepts three arguments---the two for the API and the function used to return a value. All API functions must rely only on consensus state and the function domain."
  },
  {
    "objectID": "/rsh/step/#p_48",
    "pt": "Steps",
    "t": 3,
    "c": "If the msg field is absent from the object returned from {!rsh} PUBLISH_EXPR, then it is treated as if it were {!rsh} null."
  },
  {
    "objectID": "/rsh/step/#p_49",
    "pt": "Steps",
    "t": 3,
    "c": "If the when field is absent from the object returned from {!rsh} PUBLISH_EXPR, then it is treated as if it were {!rsh} true."
  },
  {
    "objectID": "/rsh/step/#p_50",
    "pt": "Steps",
    "t": 3,
    "c": "If the _local field is absent from the object returned from {!rsh} PUBLISH_EXPR, then it is treated as if it were {!rsh} null."
  },
  {
    "objectID": "/rsh/step/#p_51",
    "pt": "Steps",
    "t": 3,
    "c": "If the {!rsh} PAY_EXPR is absent, then it is treated as if it were {!rsh} (_) => 0."
  },
  {
    "objectID": "/rsh/step/#p_52",
    "pt": "Steps",
    "t": 3,
    "c": "The {!rsh} TOKENS_EXPR and {!rsh} PAY_EXPR have the same restrictions as the {!rsh} .pay component of a consensus transfer: i.e., they must be pure and can only refer to consensus state."
  },
  {
    "objectID": "/rsh/step/#p_53",
    "pt": "Steps",
    "t": 3,
    "c": "The {!rsh} .case and {!rsh} .api components may be repeated many times."
  },
  {
    "objectID": "/rsh/step/#p_54",
    "pt": "Steps",
    "t": 3,
    "c": "The same participant may specify multiple cases. In this situation, the order of the cases is significant. That is, a subsequent case will only be evaluated if the prior case's when field is {!rsh} false."
  },
  {
    "objectID": "/rsh/step/#p_55",
    "pt": "Steps",
    "t": 3,
    "c": "If the participant specified by {!rsh} PART_EXPR is not already fixed (in the sense of {!rsh} Participant.set), then if it wins the {!rsh} race, it is fixed, provided it is not a participant class."
  },
  {
    "objectID": "/rsh/step/#p_56",
    "pt": "Steps",
    "t": 3,
    "c": "A fork statement is an abbreviation of a common {!rsh} race and {!rsh} switch pattern you could write yourself."
  },
  {
    "objectID": "/rsh/step/#p_57",
    "pt": "Steps",
    "t": 3,
    "c": "The idea is that each of the participants in the {!rsh} case components do an independent local step evaluation of a value they would like to {!rsh} publish and then all {!rsh} race to {!rsh} publish their value. The one that \"wins\" the {!rsh} race then determines not only the value (& {!rsh} pay expression), but also what consensus step code runs to consume the value."
  },
  {
    "objectID": "/rsh/step/#p_58",
    "pt": "Steps",
    "t": 3,
    "c": "The sample {!rsh} fork statement linked to the {!rsh} fork keyword is roughly equivalent to:"
  },
  {
    "objectID": "/rsh/step/#p_59",
    "pt": "Steps",
    "t": 3,
    "c": "This pattern is tedious to write and error-prone, so the {!rsh} fork statement abbreviates it for Reach programmers. When a participant specifies multiple cases, the msg field of the participant will be wrapped with an additional variant signifying what case was chosen."
  },
  {
    "objectID": "/rsh/step/#p_60",
    "pt": "Steps",
    "t": 3,
    "c": "A wait statement, written {!rsh} wait(TIME);, delays the computation until the {!rsh} TIME time argument passes. {!rsh} TIME must be pure and may only reference values known by the consensus state."
  },
  {
    "objectID": "/rsh/step/#p_61",
    "pt": "Steps",
    "t": 3,
    "c": "In this example, {!rsh} wait is used so Bob doesn't have an advantage over Alice by making two separate {!rsh} publish statements at the same time. {!rsh} wait ensures that Alice has enough time to verify that Bob accepted the {!rsh} wager before beginning a {!rsh} race."
  },
  {
    "objectID": "/rsh/step/#p_62",
    "pt": "Steps",
    "t": 3,
    "c": "Learn more about the {!rsh} race expression in the guide, Racing non-determinism in decentralized applications."
  },
  {
    "objectID": "/rsh/step/#p_63",
    "pt": "Steps",
    "t": 3,
    "c": "{!rsh} wait does not execute on chain, instead, it constrains the next action that may occur on chain. Thus, {!rsh} wait may only occur in a step."
  },
  {
    "objectID": "/rsh/step/#p_64",
    "pt": "Steps",
    "t": 3,
    "c": "An exit statement, written {!rsh} exit();, halts the computation. It is a terminator statement, so it must have an empty tail. It may only occur in a step."
  },
  {
    "objectID": "/rsh/step/#p_65",
    "pt": "Steps",
    "t": 3,
    "c": "Any expressions valid for a computation are valid for a step. However, some additional expressions are allowed."
  },
  {
    "objectID": "/rsh/step/#p_66",
    "pt": "Steps",
    "t": 3,
    "c": "If you're unsure of what kind of consensus transfer to use, you may want to read the explanation of the differences in the Guide."
  },
  {
    "objectID": "/rsh/step/#p_67",
    "pt": "Steps",
    "t": 3,
    "c": "A race expression, written {!rsh} race(PARTICIPANT_0, ..., PARTICIPANT_n);, constructs a participant that may be used in a consensus transfer statement, such as {!rsh} publish or {!rsh} pay, where the various participants race to be the first one to perform the consensus transfer."
  },
  {
    "objectID": "/rsh/step/#p_68",
    "pt": "Steps",
    "t": 3,
    "c": "Reach provides a shorthand, {!rsh} Anybody, which serves as a {!rsh} race between all the participants."
  },
  {
    "objectID": "/rsh/step/#p_69",
    "pt": "Steps",
    "t": 3,
    "c": "See the guide section on races to understand the benefits and dangers of using {!rsh} race."
  },
  {
    "objectID": "/rsh/step/#p_70",
    "pt": "Steps",
    "t": 3,
    "c": "In this example, Bob and Alice are doing a race and whoever publishes first is the winner. Once the first publish is completed, the outcome is decided by checking if ALICE_WINS is true or false. If ALICE_WINS evaluates to true, Alice is declared the winner and the balance of the wager is then transferred to her."
  },
  {
    "objectID": "/rsh/step/#p_71",
    "pt": "Steps",
    "t": 3,
    "c": "A knowledge assertion that the participant {!rsh} Notter does not know the results of the variables {!rsh} var_0 through {!rsh} var_N, but that the participant {!rsh} Knower does know those values. It accepts an optional bytes argument, which is included in any reported violation."
  },
  {
    "objectID": "/rsh/step/#p_72",
    "pt": "Steps",
    "t": 3,
    "c": "This example from the Rock, Paper, Scissors! tutorial checks that both Alice's hand and salt are unknowable to ensure Bob cannot cheat."
  },
  {
    "objectID": "/rsh/step/#p_73",
    "pt": "Steps",
    "t": 3,
    "c": "Has participant {!rsh} Anybody make a publication, then transfer the {!rsh} balance() and the non-network pay amount to {!rsh} Who and end the DApp after executing the function {!rsh} after in a step."
  },
  {
    "objectID": "/rsh/step/#p_74",
    "pt": "Steps",
    "t": 3,
    "c": "As an example, codifying the prose above would look like:"
  },
  {
    "objectID": "/rsh/step/#p_75",
    "pt": "Steps",
    "t": 3,
    "c": "By comparing this example to {!rsh} closeTo, you can see that using this Reach standard library function helps save thinking, as well as additional lines of code, reducing the chances of introducing new errors."
  },
  {
    "objectID": "/rsh/step/#p_76",
    "pt": "Steps",
    "t": 3,
    "c": "The {!rsh} nonNetPayAmt parameter should be a pay amount. For example, when closing a program that uses a {!rsh} Token {!rsh} token, the argument would be {!rsh} [ [balance(tok), tok] ]."
  },
  {
    "objectID": "/rsh/step/#p_77",
    "pt": "Steps",
    "t": 3,
    "c": "The {!rsh} after and {!rsh} nonNetPayAmt arguments are optional."
  },
  {
    "objectID": "/rsh/step/#p_78",
    "pt": "Steps",
    "t": 3,
    "c": "A call is written:"
  },
  {
    "objectID": "/rsh/step/#p_79",
    "pt": "Steps",
    "t": 3,
    "c": "where:"
  },
  {
    "objectID": "/rsh/step/#p_80",
    "pt": "Steps",
    "t": 3,
    "c": "DOMAIN is the the domain of the API member function."
  },
  {
    "objectID": "/rsh/step/#p_81",
    "pt": "Steps",
    "t": 3,
    "c": "RET_FUN is a function that returns a value to the API call. This function must be called."
  },
  {
    "objectID": "/rsh/step/#p_82",
    "pt": "Steps",
    "t": 3,
    "c": "API_EXPR is an expression that evaluates to an API member function."
  },
  {
    "objectID": "/rsh/step/#p_83",
    "pt": "Steps",
    "t": 3,
    "c": "API_CHECK_EXPR is a function parameterized over the domain of the API function. This function can be used to add {!rsh} checks involving the domain. These checks will be applied as assumptions and requirements."
  },
  {
    "objectID": "/rsh/step/#p_84",
    "pt": "Steps",
    "t": 3,
    "c": "API_PAY_EXPR and API_ASSUME_EXPR are like the corresponding parts in a {!rsh} fork statement, and {!rsh} call.throwTimeout is like in {!rsh} fork.throwTimeout. They are optional."
  },
  {
    "objectID": "/rsh/step/#p_85",
    "pt": "Steps",
    "t": 3,
    "c": "{!rsh} call will call the given API member function, returning a pair, {!rsh} [DOMAIN, RET_FUN]. {!rsh} call will publish the domain of the API member function, transferring the program from a step to consensus step."
  },
  {
    "objectID": "/guide/ctransfers/#guide-ctransfers",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 2,
    "c": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?"
  },
  {
    "objectID": "/guide/ctransfers/#is-a-single-participant-responsible-for-the-transfer",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 2,
    "c": "Is a single participant responsible for the transfer?"
  },
  {
    "objectID": "/guide/ctransfers/#are-multiple-participants-able-to-cause-the-transfer-but-each-will-provide-different-data",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 2,
    "c": "Are multiple participants able to cause the transfer, but each will provide different data?"
  },
  {
    "objectID": "/guide/ctransfers/#are-there-multiple-participants-that-each-want-to-do-different-things",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 2,
    "c": "Are there multiple participants that each want to do different things?"
  },
  {
    "objectID": "/guide/ctransfers/#will-these-different-things-happen-over-and-over-until-some-condition-is-met",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 2,
    "c": "Will these different things happen over and over until some condition is met?"
  },
  {
    "objectID": "/guide/ctransfers/#summary",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 2,
    "c": "Summary"
  },
  {
    "objectID": "/guide/ctransfers/#p_0",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "A fundamental concept in Reach is that the application starts in a detached birds-eye perspective called a step where each of the participants are acting completely independently. These independent steps are punctuated by consensus transfers which cause all of the participants to come together and agree on the computation, which is called a consensus step."
  },
  {
    "objectID": "/guide/ctransfers/#p_1",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "These consensus steps are what happen \"on-chain\" and are executed by a so-called \"smart contract\"."
  },
  {
    "objectID": "/guide/ctransfers/#p_2",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "There are many ways to perform a consensus transfer in Reach and each is used for different reasons. The variety can feel a bit bewildering for new users, but here is an intuitive guide to help you decide which you need for any given situation."
  },
  {
    "objectID": "/guide/ctransfers/#p_3",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "If the entire DApp is waiting for a single participant to act, such as when at a play the entire theatre waits in anticipation for the stage hands to draw the curtains, then you either need a {!rsh} pay or {!rsh} publish. If the single participant is sharing information, then you need a {!rsh} publish; but if they are only paying a previously known amount, then you need a {!rsh} pay. This kind of transfer always explicitly names the party acting, as in:"
  },
  {
    "objectID": "/guide/ctransfers/#p_4",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "{!rsh} pay and {!rsh} publish without a {!rsh} race are for when one participant wants to do one thing."
  },
  {
    "objectID": "/guide/ctransfers/#p_5",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "If the entire DApp has a clear \"next step\", but multiple participants are able to provide the values used in that step, then you need a {!rsh} race to determine the participant used for a {!rsh} publish or {!rsh} pay. For example, in a radio call-in contest, there is one chance for a listener to call-in first and win the prize. If a participant value is participant class, then all of its actions are {!rsh} races, because the Reach identifier does not represent a specific principal, but a member of a large class."
  },
  {
    "objectID": "/guide/ctransfers/#p_6",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "{!rsh} race, and participant classes are for when many participants want to do one thing."
  },
  {
    "objectID": "/guide/ctransfers/#p_7",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "If the DApp doesn't have a clear next step, but multiple participants each have a different option for what the next step should be, then you need a {!rsh} fork. For example, a sale DApp might have a buy option and a bid option where the first immediately ends the computation, while the second moves it to an auction."
  },
  {
    "objectID": "/guide/ctransfers/#p_8",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "{!rsh} fork is for when many participants want to each do a different thing."
  },
  {
    "objectID": "/guide/ctransfers/#p_9",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "If you are in a situation where a {!rsh} race or {!rsh} fork is needed, and the options are available repeatedly after small diversions, then you need a {!rsh} parallelReduce. For example, in an auction, bidders repeatedly provide new bids as they compete to be the highest bidder before a time limit is reached."
  },
  {
    "objectID": "/guide/ctransfers/#p_10",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "The main questions are:"
  },
  {
    "objectID": "/guide/ctransfers/#p_11",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "How many participants can act? One or many?"
  },
  {
    "objectID": "/guide/ctransfers/#p_12",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "How many things can be done? One or many?"
  },
  {
    "objectID": "/guide/ctransfers/#p_13",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "How many times can this be done? Once or many?"
  },
  {
    "objectID": "/guide/ctransfers/#p_14",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "If it happens many times, you want {!rsh} parallelReduce. If many things could happen, you want {!rsh} fork. If many participants can act, you want {!rsh} race. Otherwise, you want {!rsh} publish or {!rsh} pay."
  },
  {
    "objectID": "/guide/ctransfers/#p_15",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "The above article uses the word \"need\" when talking about {!rsh} fork and {!rsh} parallelReduce, but actually you never need these, because they are just abbreviations of particular patterns of using the other features. {!rsh} fork works by having each participant {!rsh} race to provide a {!rsh} Data instance, where the single consensus step does a case analysis on the {!rsh} Data to determine which code to run. Similarly, {!rsh} parallelReduce is just an abbreviation of a {!rsh} fork within a {!rsh} while loop."
  },
  {
    "objectID": "/guide/editor-support/#guide-editor-support",
    "pt": "IDE/Text Editor Support",
    "t": 2,
    "c": "IDE/Text Editor Support"
  },
  {
    "objectID": "/guide/editor-support/#guide-install-VSCode",
    "pt": "IDE/Text Editor Support",
    "t": 2,
    "c": "Install VSCode"
  },
  {
    "objectID": "/guide/editor-support/#guide-install-Atom",
    "pt": "IDE/Text Editor Support",
    "t": 2,
    "c": "Install Atom"
  },
  {
    "objectID": "/guide/editor-support/#guide-install-Sublime",
    "pt": "IDE/Text Editor Support",
    "t": 2,
    "c": "Install Sublime"
  },
  {
    "objectID": "/guide/editor-support/#p_0",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "There are a number of text editor plugins available to provide a better development experience for Reach. These plugins provide syntax highlighting, build commands, key mappings, snippets, and more. The following plugins are available:"
  },
  {
    "objectID": "/guide/editor-support/#p_1",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Visual Studio Code: Reach IDE"
  },
  {
    "objectID": "/guide/editor-support/#p_2",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Atom: Reach Language Support, Reach IDE"
  },
  {
    "objectID": "/guide/editor-support/#p_3",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Sublime Text: Reach IDE"
  },
  {
    "objectID": "/guide/editor-support/#p_4",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "We highly recommend using Visual Studio Code IDE, it is the most advanced Reach extension."
  },
  {
    "objectID": "/guide/editor-support/#p_5",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Visual Studio Code (VSCode) enables users to both write and compile Reach code. With the Reach IDE VSCode extension installed, VSCode compiles automatically in the background and alerts users of coding errors in seconds when the necessary prerequisites, such as Docker, are installed and running."
  },
  {
    "objectID": "/guide/editor-support/#p_6",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Download the VSCode IDE."
  },
  {
    "objectID": "/guide/editor-support/#p_7",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Double-click the file to install VSCode."
  },
  {
    "objectID": "/guide/editor-support/#p_8",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "In VSCode, click extensions in the left panel."
  },
  {
    "objectID": "/guide/editor-support/#p_9",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Search for Reach, and then install the most recent version of the Reach IDE extension."
  },
  {
    "objectID": "/guide/editor-support/#p_10",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Download and install Atom matching your system."
  },
  {
    "objectID": "/guide/editor-support/#p_11",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "In Atom, click File\\Settings."
  },
  {
    "objectID": "/guide/editor-support/#p_12",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Click Install."
  },
  {
    "objectID": "/guide/editor-support/#p_13",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Type Reach."
  },
  {
    "objectID": "/guide/editor-support/#p_14",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Install Reach IDE."
  },
  {
    "objectID": "/guide/editor-support/#p_15",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Install Reach Language Support."
  },
  {
    "objectID": "/guide/editor-support/#p_16",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Download and install Sublime."
  },
  {
    "objectID": "/guide/editor-support/#p_17",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Download the Reach-IDE."
  },
  {
    "objectID": "/guide/editor-support/#p_18",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Unzip the Reach-IDE into the \\Sublime Text\\Packages folder of your Sublime installation."
  },
  {
    "objectID": "/guide/editor-support/#p_19",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Open your project in Sublime."
  },
  {
    "objectID": "/guide/editor-support/#p_20",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Click Tools\\Command Palette, and then type Reach."
  },
  {
    "objectID": "/guide/editor-support/#p_21",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Click Set Syntax:Reach."
  },
  {
    "objectID": "/guide/editor-support/#p_22",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Repeat 5 and then select Reach - Compile to build with Reach."
  },
  {
    "objectID": "/guide/ganache/#guide-ganache",
    "pt": "How to use Ganache with Reach",
    "t": 2,
    "c": "How to use Ganache with Reach"
  },
  {
    "objectID": "/guide/ganache/#p_0",
    "pt": "How to use Ganache with Reach",
    "t": 3,
    "c": "Ganache is a very popular Ethereum personal blockchain for quick application development, deployment, and testing with a replica of the Ethereum mainnet. Ganache provides many customization options, such as control over the gas limit and price."
  },
  {
    "objectID": "/guide/ganache/#p_1",
    "pt": "How to use Ganache with Reach",
    "t": 3,
    "c": "There are two ways to use Ganache with Reach."
  },
  {
    "objectID": "/guide/ganache/#p_2",
    "pt": "How to use Ganache with Reach",
    "t": 3,
    "c": "First, you can run the Ganache desktop application and start a workspace, then connect to it using the Reach ETH-live connector mode. This requires specifying the node URI as well. For example, if you're running your Reach frontend from within Docker, and Ganache on your host machine, you might run:"
  },
  {
    "objectID": "/guide/ganache/#p_3",
    "pt": "How to use Ganache with Reach",
    "t": 3,
    "c": "This sets the Ethereum URI to the host machine's port and instructs Reach that the network is \"isolated\", which means it is for testing."
  },
  {
    "objectID": "/guide/ganache/#p_4",
    "pt": "How to use Ganache with Reach",
    "t": 3,
    "c": "Second, you can programmatically create a Ganache network from inside of your JavaScript frontend and set it as a provider for the Reach standard library. This requires some modification to your frontend."
  },
  {
    "objectID": "/guide/ganache/#p_5",
    "pt": "How to use Ganache with Reach",
    "t": 3,
    "c": "You need to add the ganache-core package as a dependency in your package.json file. If you don't already have one, then you'll want to use reach scaffold to set one up. You'll also need to add the ethers package, because you'll be directly interacting with the underlying network to set things up."
  },
  {
    "objectID": "/guide/ganache/#p_6",
    "pt": "How to use Ganache with Reach",
    "t": 3,
    "c": "After that, you need to import the two packages on the JavaScript side in your index.mjs file:"
  },
  {
    "objectID": "/guide/ganache/#p_7",
    "pt": "How to use Ganache with Reach",
    "t": 3,
    "c": "Next, you need to actually create the Ganache-based provider and connect it to Reach:"
  },
  {
    "objectID": "/guide/ganache/#p_8",
    "pt": "How to use Ganache with Reach",
    "t": 3,
    "c": "This will work, but Reach will not consider the network to be \"isolated\", which means that it won't be able to fund test accounts. You can enable this by setting the Reach faucet:"
  },
  {
    "objectID": "/guide/ganache/#p_9",
    "pt": "How to use Ganache with Reach",
    "t": 3,
    "c": "If you want to use some of the interesting customizations that Ganache provides, then refer to their documentation about what {!js} ganacheOptions may be set to."
  },
  {
    "objectID": "/guide/logging/#guide-logging",
    "pt": "How do I add tracing logs to my Reach program?",
    "t": 2,
    "c": "How do I add tracing logs to my Reach program?"
  },
  {
    "objectID": "/guide/logging/#p_0",
    "pt": "How do I add tracing logs to my Reach program?",
    "t": 3,
    "c": "Sometimes it is useful to add \"tracing logs\" to your program so you can see the values of variables and computations as the program is running. For example, if we were writing purely in JavaScript, we might write"
  },
  {
    "objectID": "/guide/logging/#p_1",
    "pt": "How do I add tracing logs to my Reach program?",
    "t": 3,
    "c": "And we'd see the output"
  },
  {
    "objectID": "/guide/logging/#p_2",
    "pt": "How do I add tracing logs to my Reach program?",
    "t": 3,
    "c": "How can we do something like this in Reach?"
  },
  {
    "objectID": "/guide/logging/#p_3",
    "pt": "How do I add tracing logs to my Reach program?",
    "t": 3,
    "c": "The key is to use participant interact interfaces to share arbitrary information with the frontend, which has the ability to log to a console or any other tracing service. For example:"
  },
  {
    "objectID": "/guide/logging/#p_4",
    "pt": "How do I add tracing logs to my Reach program?",
    "t": 3,
    "c": "However, as this example shows, it can be inconvenient to use this pattern, because {!rsh} Fun types constrain their domains to particular input data types, but we may need to log different kinds of data at different points in the program. Similarly, it is inconvenient to use an entire {!rsh} only block for a simple log."
  },
  {
    "objectID": "/guide/logging/#p_5",
    "pt": "How do I add tracing logs to my Reach program?",
    "t": 3,
    "c": "Reach provides two conveniences for this situation that taste great together: unconstrained domain function types and interact shorthand. The first allows a function in a participant interact interface to have a completely unconstrained domain. The second allows a call to a frontend from anywhere without an {!rsh} only, provided the function returns no value. If we re-write the above example using both of these patterns, it looks like:"
  },
  {
    "objectID": "/guide/logging/#p_6",
    "pt": "How do I add tracing logs to my Reach program?",
    "t": 3,
    "c": "Then, a JavaScript frontend can simply use {!js} console.log as the value of the log function."
  },
  {
    "objectID": "/guide/logging/#p_7",
    "pt": "How do I add tracing logs to my Reach program?",
    "t": 3,
    "c": "Reach provides {!rsh} hasConsoleLogger and hasConsoleLogger (Frontend) in the standard library for default implementations of logging to stdout. It can be used in Reach with:"
  },
  {
    "objectID": "/guide/logging/#p_8",
    "pt": "How do I add tracing logs to my Reach program?",
    "t": 3,
    "c": "and in the JavaScript frontend with:"
  },
  {
    "objectID": "/guide/logging/#p_9",
    "pt": "How do I add tracing logs to my Reach program?",
    "t": 3,
    "c": "The Reach development repository contains an example of this pattern: log/index.rsh and log/index.mjs."
  },
  {
    "objectID": "/guide/loop-invs/#guide-loop-invs",
    "pt": "Finding and using loop invariants",
    "t": 2,
    "c": "Finding and using loop invariants"
  },
  {
    "objectID": "/guide/loop-invs/#p_0",
    "pt": "Finding and using loop invariants",
    "t": 3,
    "c": "Reach requires that {!rsh} while loops are annotated with loop invariants. A loop invariant is a property {!rsh} INV which is true before the loop starts and is true after the loop ends."
  },
  {
    "objectID": "/guide/loop-invs/#p_1",
    "pt": "Finding and using loop invariants",
    "t": 3,
    "c": "Consider the following program fragment,"
  },
  {
    "objectID": "/guide/loop-invs/#p_2",
    "pt": "Finding and using loop invariants",
    "t": 3,
    "c": "We can summarize the properties that must be true about this code as follows:"
  },
  {
    "objectID": "/guide/loop-invs/#p_3",
    "pt": "Finding and using loop invariants",
    "t": 3,
    "c": "{!rsh} before and {!rsh} V = INIT implies {!rsh} INV --- The earlier part of the program must establish {!rsh} INV."
  },
  {
    "objectID": "/guide/loop-invs/#p_4",
    "pt": "Finding and using loop invariants",
    "t": 3,
    "c": "If {!rsh} COND and {!rsh} INV, then {!rsh} body and {!rsh} V = NEXT implies {!rsh} INV --- The loop body can make use of the truth of the condition and the invariant to re-establish the invariant after {!rsh} V is mutated to {!rsh} NEXT."
  },
  {
    "objectID": "/guide/loop-invs/#p_5",
    "pt": "Finding and using loop invariants",
    "t": 3,
    "c": "{!rsh} ! COND and {!rsh} INV and {!rsh} after implies {!rsh} P --- The later part of the program can make use of the negation of the condition and the invariant to establish any future assertions."
  },
  {
    "objectID": "/guide/loop-invs/#p_6",
    "pt": "Finding and using loop invariants",
    "t": 3,
    "c": "Loop invariants only need to mention values that can vary because of the execution of the loop. In Reach, all bindings are immutable, except for those bound by {!rsh} while, so they never need to be mentioned. However, Reach has two kinds of mutable bindings: loop variables and the contract balance (which is imperatively modified by {!rsh} pay and {!rsh} transfer). As such, both of these are typically mentioned in loop invariants."
  },
  {
    "objectID": "/guide/loop-invs/#p_7",
    "pt": "Finding and using loop invariants",
    "t": 3,
    "c": "Loop variables are mentioned if they occur in subsequent assertions, or if they are used to perform potentially unsafe actions, like an array dereference. But, since every Reach program terminates with the token linearity property, loop invariants always reference the contract balance."
  },
  {
    "objectID": "/guide/loop-invs/#p_8",
    "pt": "Finding and using loop invariants",
    "t": 3,
    "c": "When designing a loop invariant, first write down an equation for the contract balance before the loop. If the loop contains any transfers to the contract, then you must be able to track the amount and number of these. In the best case, you should be able to express the balance as an equation over the existing loop variables. In the worst case, you will have to add more loop variables to track some quantity, like the number of rounds of a game, that the balance is derived from."
  },
  {
    "objectID": "/guide/loop-invs/#p_9",
    "pt": "Finding and using loop invariants",
    "t": 3,
    "c": "After you've tracked the balance, you will need to add additional clauses that track whatever properties you rely on in the tail of the loop."
  },
  {
    "objectID": "/guide/loop-invs/#p_10",
    "pt": "Finding and using loop invariants",
    "t": 3,
    "c": "The most complex circumstance is when you have nested loops. In this situation, the inner loop's invariant will have to include clauses related to the outer loop's invariant."
  },
  {
    "objectID": "/guide/limits/#guide-limits",
    "pt": "What are Reach's limitations?",
    "t": 2,
    "c": "What are Reach's limitations?"
  },
  {
    "objectID": "/guide/limits/#p_0",
    "pt": "What are Reach's limitations?",
    "t": 3,
    "c": "Today, Reach is a powerful language for building decentralized applications, as demonstrated in the overview, the tutorial, and the workshop series. However, it has a lot of potential for growth. This section describes a few of these areas and gives brief sketches of our roadmap for directing this growth. We welcome your contributions on GitHub and in the Discord community to help bring these plans to fruition."
  },
  {
    "objectID": "/guide/limits/#p_1",
    "pt": "What are Reach's limitations?",
    "t": 3,
    "c": "Connectors. Foremost, Reach is a consensus network-agnostic language, so one of our highest priorities is supporting a wide variety of platforms, including layer-2 abstractions over other layer-1 networks. Presently, we have a robust Ethereum backend and Algorand backend."
  },
  {
    "objectID": "/guide/limits/#p_2",
    "pt": "What are Reach's limitations?",
    "t": 3,
    "c": "Backends. Presently, Reach has a robust backend for JavaScript that is well-suited for client-facing applications and JavaScript servers. However, we believe that many decentralized application developers would like to make use of languages like Go and Rust for their participants. Presently, this can be accomplished via the RPC server, but we'd like to build a dedicated backend for languages like these."
  },
  {
    "objectID": "/guide/limits/#p_3",
    "pt": "What are Reach's limitations?",
    "t": 3,
    "c": "Computation. Reach's computational language is based on JavaScript and contains many of JavaScript's most desirable features, like arrow expressions, free-form objects, destructuring bindings, robust {!rsh} import and {!rsh} export specificiers, and so on. However, there are some differences that represent limitations, such as the inability to use functions as values at runtime and the need to enforce finite limits on data."
  },
  {
    "objectID": "/guide/limits/#p_4",
    "pt": "What are Reach's limitations?",
    "t": 3,
    "c": "Verification. Reach's verifier is robust in the face of many complex and interesting theorems about decentralized application behavior, but it is inherently conservative and does not presently allow users to manually prove theorems that are conservatively rejected."
  },
  {
    "objectID": "/guide/limits/#p_5",
    "pt": "What are Reach's limitations?",
    "t": 3,
    "c": "Network Integration. Since Reach is consensus network-agnostic, it is not possible for Reach programs to directly integrate with network-specific features, such as observing the blockhash on Ethereum. Reach programs can instead interact with these low-level details of their chosen consensus network via remote object interaction."
  },
  {
    "objectID": "/guide/limits/#p_6",
    "pt": "What are Reach's limitations?",
    "t": 3,
    "c": "Communication. Reach's communication language has some limitations that we have plans to remove, which are discussed in roadmap, but there are some for which we do not have plans to remove. For example, we do not intend to support co-inductive or cyclic state, nor expose an arbitrary consensus heap to programmers."
  },
  {
    "objectID": "/guide/nntoks/#guide-nntoks",
    "pt": "How do network and non-network tokens differ?",
    "t": 2,
    "c": "How do network and non-network tokens differ?"
  },
  {
    "objectID": "/guide/nntoks/#how-do-network-tokens-behave",
    "pt": "How do network and non-network tokens differ?",
    "t": 2,
    "c": "How do network tokens behave?"
  },
  {
    "objectID": "/guide/nntoks/#how-do-non-network-tokens-violate-this",
    "pt": "How do network and non-network tokens differ?",
    "t": 2,
    "c": "How do non-network tokens violate this?"
  },
  {
    "objectID": "/guide/nntoks/#why-does-this-matter",
    "pt": "How do network and non-network tokens differ?",
    "t": 2,
    "c": "Why does this matter?"
  },
  {
    "objectID": "/guide/nntoks/#what-does-reach-do-about-this",
    "pt": "How do network and non-network tokens differ?",
    "t": 2,
    "c": "What does Reach do about this?"
  },
  {
    "objectID": "/guide/nntoks/#what-can-i-do-about-it",
    "pt": "How do network and non-network tokens differ?",
    "t": 2,
    "c": "What can I do about it?"
  },
  {
    "objectID": "/guide/nntoks/#p_0",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "Reach assumes that network tokens and non-network tokens behave identically on consensus networks, but this is not the case in practice."
  },
  {
    "objectID": "/guide/nntoks/#p_1",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "An account on a consensus network can hold network tokens and as long as the network is available, it may send these tokens to other accounts or receive tokens from other accounts without preapproval from recipients and without the interference of third-parties not involved in a particular transfer. Each network may prescribe fees on transfers or other similar constraints on transfers (such as a minimum balance holding to send funds) but may not restrict the reception of funds or arbitrarily hold or reclaim network tokens. All consensus networks that Reach supports obey these properties."
  },
  {
    "objectID": "/guide/nntoks/#p_2",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "In each of the networks supported by Reach, non-network tokens may violate these expectations."
  },
  {
    "objectID": "/guide/nntoks/#p_3",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "On Ethereum, and Ethereum-like networks, where non-network tokens are just particular patterns of smart contracts, the concrete behavior of abstract operations like \"Transfer 10 Zorkmids from John to Paul\" may have arbitrary semantics. For example, a smart contract insisting that Paul pre-approve the reception of Zorkmids; a smart contract could allow all transfers to be universally halted, like an old-fashioned bank closure; a smart contract could simply take John's Zorkmids away because the administrator of the token decides to; and so on. Smart contracts have power to implement arbitrary semantics and there is no guarantee that a smart contract that supplies a function with the name transfer and the signature function transfer(address _to, uint256 _value) public returns (bool success) has any particular behavior. Furthermore, you can send network tokens to a contract as you create it, but you cannot send non-network tokens, because sending non-network tokens (using ERC-20) requires knowing a contract's address, which you cannot know until after you create it (unless you use a particular low-level creation operation)."
  },
  {
    "objectID": "/guide/nntoks/#p_4",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "On Algorand, non-network tokens are built into the network, so they have a stable and predictable semantics, but that semantics is different than network tokens. For example, non-network token reception must be pre-approved so John cannot transfer to Paul unless Paul has predetermined he is willing to accept Zorkmids. Furthermore, non-network token creation supports options which have further differences: it may be possible to \"freeze\" all transfers, so that no one can make any transfers; and, it may be possible to \"clawback\" balances, so that John's Zorkmids can be removed from his account without his intervention."
  },
  {
    "objectID": "/guide/nntoks/#p_5",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "On each network, it is possible to minimize these differences---by disabling these options and obeying a standard semantics---but that behavior is not universal among all tokens."
  },
  {
    "objectID": "/guide/nntoks/#p_6",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "Non-network tokens minted by Reach always disable these options and behave as closely as possible to network tokens."
  },
  {
    "objectID": "/guide/nntoks/#p_7",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "These issues matter because developers and users of their applications need to understand that when they interact with a non-network token, they are interacting with a third party that can potentially control their application's behavior."
  },
  {
    "objectID": "/guide/nntoks/#p_8",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "For example, suppose George and Ringo decide to play poker on a consensus network and bet Zorkmids, rather than network tokens. If the manager of Zorkmids, Zorkmanager, freezes them, then the game must stop. If the game requires that hands be provided in a timely fashion, then George could bribe Zorkmanager to freeze them every time it is Ringo's turn, forcing him to forfeit a round."
  },
  {
    "objectID": "/guide/nntoks/#p_9",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "Suppose at the end of the game, there is a pot of 200 Zorkmids with 5 meant for George and 195 meant for Ringo. If Zorkmanager takes 1 Zorkmid from the pot via \"clawback\", then only one of the parties can be paid in full. What's worse, an application may be programmed to either transfer everything or nothing, so in this scenario if George extracts first, then Ringo will not be able to extract anything. Furthermore, suppose the application is programmed to clear the pot atomically, disbursing to each player in one single step; in this scenario, if recipients are required to pre-authorize holding a token, then George can revoke that permission to spite Ringo and prevent him from getting his allocation."
  },
  {
    "objectID": "/guide/nntoks/#p_10",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "In summary, non-network tokens' semantics are non-intuitive considering the power given to their creators."
  },
  {
    "objectID": "/guide/nntoks/#p_11",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "Reach uses a verification engine to model the semantics of Reach programs to predict and reason about their behavior. In particular, it tries to prove two theorems:"
  },
  {
    "objectID": "/guide/nntoks/#p_12",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "Honesty: Honest participants will not submit transactions that will be rejected."
  },
  {
    "objectID": "/guide/nntoks/#p_13",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "Progress: If honest participants submit transactions, the program will finish."
  },
  {
    "objectID": "/guide/nntoks/#p_14",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "If a program contains an operation such as \"Transfer 10 tokens to John\", then there are certain pre-conditions that must be true for this operation to succeed, such as \"The contract holds at least 10 tokens\". Reach will guarantee that every pre-condition in the program is entailed by the earlier parts of the program. When pre-conditions depend on user input, it will ensure that honest participants check that input before submitting the transaction."
  },
  {
    "objectID": "/guide/nntoks/#p_15",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "Non-network tokens, because they are arbitrary code on some networks and depend on transient state controlled by third-parties on other networks, have no semantics, and therefore, have no predictable pre-conditions. This means that it is impossible to predict whether an operation will succeed or fail simply by knowing it (for example) follows the ERC-20 specification or is an Algorand Standard Asset."
  },
  {
    "objectID": "/guide/nntoks/#p_16",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "In our design of Reach, we had three choices when contemplating how to manage such unpredictability."
  },
  {
    "objectID": "/guide/nntoks/#p_17",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "First, we could represent non-network token operations as free terms with no semantics, and thus unpredictable behavior. We did not do this, because users expect they'll have a particular behavior (most actually do!) and expect that Reach's token linearity verification will apply to non-network tokens as well."
  },
  {
    "objectID": "/guide/nntoks/#p_18",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "Second, we could explicitly represent the details of the power each network gives to non-network token creators and include their state space in the analysis of Reach programs. We did not do this, because it is impossible to write programs that are generic in the non-network tokens they use with this token. In other words, a Reach program that implemented a poker game couldn't be constructed to use some token. Rather, it would have to be a game that used Zorkmids, and you'd have to write (or verify) another program for a game that used Gil, and so on. Given that most tokens actually behave properly, this would be unnecessarily painful for productive programming."
  },
  {
    "objectID": "/guide/nntoks/#p_19",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "Third, we can assume that non-network tokens behave the same as network tokens and document the differences and educate developers and users about the consequences of this. Clearly, this is what we did."
  },
  {
    "objectID": "/guide/nntoks/#p_20",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "First, if you use non-network tokens, you need to understand that you are trusting the token issuer as much as you are trusting the consensus network itself. This means that you need to audit its code, or configuration, and decide if you can place trust in its manager."
  },
  {
    "objectID": "/guide/nntoks/#p_21",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "Second, if your token requires pre-authorization of receipt, and if this pre-authorization can be revoked, you need to remove atomic simultaneous transfers of non-network tokens from your program and replace them with phases where each party can receive their tokens individually, so that one party cannot maliciously opt-out to prevent the other party from receiving their funds."
  },
  {
    "objectID": "/guide/nntoks/#p_22",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "Finally, you can advocate, perhaps with your money and support, that consensus networks pursue giving non-network tokens feature parity with network tokens so that there will be a consensus network that can faithfully implement the token semantics users expect."
  },
  {
    "objectID": "/guide/packages/#guide-packages",
    "pt": "Sharing and discovering shared Reach packages",
    "t": 2,
    "c": "Sharing and discovering shared Reach packages"
  },
  {
    "objectID": "/guide/packages/#p_0",
    "pt": "Sharing and discovering shared Reach packages",
    "t": 3,
    "c": "Reach makes library packaging very easy: simply push your code to GitHub or BitBucket and tag it to mark a version number."
  },
  {
    "objectID": "/guide/packages/#p_1",
    "pt": "Sharing and discovering shared Reach packages",
    "t": 3,
    "c": "Packages on GitHub may also activate the reach-pkg topic by configuring it in their repo's \"About\" configuration to enjoy greater discoverability."
  },
  {
    "objectID": "/guide/packages/#p_2",
    "pt": "Sharing and discovering shared Reach packages",
    "t": 3,
    "c": "The package imports reference section details Reach's remote module import syntax, and the compile command reference describes the --install-pkgs command-line argument which allows remote packages to be fetched during compilation."
  },
  {
    "objectID": "/guide/race/#guide-race",
    "pt": "Racing non-determinism in decentralized applications",
    "t": 2,
    "c": "Racing non-determinism in decentralized applications"
  },
  {
    "objectID": "/guide/race/#p_0",
    "pt": "Racing non-determinism in decentralized applications",
    "t": 3,
    "c": "As discussed earlier in the guide, Reach computations have a deterministic structure, but non-deterministic values. This means that a program will always execute steps A, B, and then C, but the values manipulated by those steps may be different on every execution."
  },
  {
    "objectID": "/guide/race/#p_1",
    "pt": "Racing non-determinism in decentralized applications",
    "t": 3,
    "c": "The most common form of value non-determinism is through the {!rsh} interact expression and frontend-provided values. A Reach program merely specifies that a frontend must provide an unsigned integer that it will name {!rsh} bid, but not what value is actually provided."
  },
  {
    "objectID": "/guide/race/#p_2",
    "pt": "Racing non-determinism in decentralized applications",
    "t": 3,
    "c": "However, a more subtle form of value non-determinism occurs with the {!rsh} race expression. This expression allows multiple participants to all attempt to provide the same value for a publication. For example, consider a turn-based game, like Nim, where there is no a priori way to determine who goes first. We could write a Reach program like:"
  },
  {
    "objectID": "/guide/race/#p_3",
    "pt": "Racing non-determinism in decentralized applications",
    "t": 3,
    "c": "where a {!rsh} race determines the first player."
  },
  {
    "objectID": "/guide/race/#p_4",
    "pt": "Racing non-determinism in decentralized applications",
    "t": 3,
    "c": "This use-case demonstrates a major problem with {!rsh} races though. In the case of Nim, there is an advantage to whoever goes first: they can win if they choose the correct moves! Since Bob sent the previous publication, he will know about the opportunity to determine who goes first before Alice, so he can send both publications in back-to-back and be guaranteed to win."
  },
  {
    "objectID": "/guide/race/#p_5",
    "pt": "Racing non-determinism in decentralized applications",
    "t": 3,
    "c": "One strategy to avoid this would be to ensure that Alice and Bob both {!rsh} wait a pre-determined amount of time, after which they would each have a fair chance to race:"
  },
  {
    "objectID": "/guide/race/#p_6",
    "pt": "Racing non-determinism in decentralized applications",
    "t": 3,
    "c": "However, even this strategy is dangerous, because it just creates an arms race between Alice and Bob to acquire more computational and network resources to guarantee that they are the first one, because whoever is first is the actual winner of the game, whatever happens next. A classic example of a situation like this was the Fomo3D winner, who used their capital to acquire millions in ETH in 2018."
  },
  {
    "objectID": "/guide/race/#p_7",
    "pt": "Racing non-determinism in decentralized applications",
    "t": 3,
    "c": "A better strategy in this application would be to have each participant provide randomness using a commitment pattern (see {!rsh} makeCommitment and {!rsh} checkCommitment) then reveal that randomness to determine the winner. Or, to play a different game that is actually skill-based."
  },
  {
    "objectID": "/guide/race/#p_8",
    "pt": "Racing non-determinism in decentralized applications",
    "t": 3,
    "c": "This example demonstrates the crucial problem with the participant non-determinism enabled by {!rsh} race: it will always produce an arms race for resources if winning the race results in winning funds. It is only safe and acceptable if who the winner is has no bearing on the ultimate outcome of the computation."
  },
  {
    "objectID": "/guide/race/#p_9",
    "pt": "Racing non-determinism in decentralized applications",
    "t": 3,
    "c": "We can express this condition formally by saying that if {!rsh} A and {!rsh} B compete to provide value {!rsh} a and {!rsh} b respectively, then the computation should provide an opportunity for the first loser to provide their value later, such that it doesn't matter what order they are provided. Mathematically, we could say that the program should not be a one-parameter function f, where the computation is either f(a) or f(b). Instead, it should be a two-parameter function g, such that g(a, b) = g(b, a) (i.e. a commutative function)."
  },
  {
    "objectID": "/guide/reach/#guide-reach",
    "pt": "How does Reach work?",
    "t": 2,
    "c": "How does Reach work?"
  },
  {
    "objectID": "/guide/reach/#p_0",
    "pt": "How does Reach work?",
    "t": 3,
    "c": "It is not necessary to understand how Reach works to use it effectively, but many users are curious about how it works. The Reach compiler uses the following strategy for analysis and compiling programs:"
  },
  {
    "objectID": "/guide/reach/#p_1",
    "pt": "How does Reach work?",
    "t": 3,
    "c": "A partial evaluation of the source program that removes all function calls & compile-time values."
  },
  {
    "objectID": "/guide/reach/#p_2",
    "pt": "How does Reach work?",
    "t": 3,
    "c": "A linearization of the residual program that removes the need for a runtime stack to track any consensus state."
  },
  {
    "objectID": "/guide/reach/#p_3",
    "pt": "How does Reach work?",
    "t": 3,
    "c": "A conservative (sound) analysis of the knowledge of each participant."
  },
  {
    "objectID": "/guide/reach/#p_4",
    "pt": "How does Reach work?",
    "t": 3,
    "c": "A reduction of the program to an instance of an SMT (satisfiability modulo theories) theory of decentralized applications."
  },
  {
    "objectID": "/guide/reach/#p_5",
    "pt": "How does Reach work?",
    "t": 3,
    "c": "An end-point projection of the linearization to produce a perspective for each participant, as well as the consensus."
  },
  {
    "objectID": "/guide/reach/#p_6",
    "pt": "How does Reach work?",
    "t": 3,
    "c": "A single-pass top-down construction of backend and consensus programs."
  },
  {
    "objectID": "/guide/reach/#p_7",
    "pt": "How does Reach work?",
    "t": 3,
    "c": "Reach is proud to: be implemented in Haskell using the Glorious Haskell Compiler; use the Z3 theorem prover for verification; use Racket's Scribble tool for documentation; and use Docker for containerization."
  },
  {
    "objectID": "/guide/roadmap/#guide-roadmap",
    "pt": "Reach's Roadmap",
    "t": 2,
    "c": "Reach's Roadmap"
  },
  {
    "objectID": "/guide/roadmap/#p_0",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "This section describes in a vague way some of the bigger future plans for Reach's development. These are vague for expediency, but we're willing to elaborate if you ask in the Discord community. We welcome your contributions on GitHub and in the Discord community to help bring these plans to fruition."
  },
  {
    "objectID": "/guide/roadmap/#p_1",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Last updated: 2022/05/"
  },
  {
    "objectID": "/guide/roadmap/#p_2",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Short term:"
  },
  {
    "objectID": "/guide/roadmap/#p_3",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Language - {!rsh} interact continuations"
  },
  {
    "objectID": "/guide/roadmap/#p_4",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Networks - Participant fast catch-up"
  },
  {
    "objectID": "/guide/roadmap/#p_5",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Optimization - Unify view functions with identical bodies"
  },
  {
    "objectID": "/guide/roadmap/#p_6",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Frontends - Session resumption"
  },
  {
    "objectID": "/guide/roadmap/#p_7",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "General - Reach debugger"
  },
  {
    "objectID": "/guide/roadmap/#p_8",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Medium term:"
  },
  {
    "objectID": "/guide/roadmap/#p_9",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "IDE - Language Server Protocol implementation"
  },
  {
    "objectID": "/guide/roadmap/#p_10",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Language - threading / futures"
  },
  {
    "objectID": "/guide/roadmap/#p_11",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Language - {!rsh} for to {!rsh} while syntactic sugar"
  },
  {
    "objectID": "/guide/roadmap/#p_12",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Language - tail-recursive function to {!rsh} while"
  },
  {
    "objectID": "/guide/roadmap/#p_13",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Language - fixed range integer types"
  },
  {
    "objectID": "/guide/roadmap/#p_14",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Optimization - data-type coallescing"
  },
  {
    "objectID": "/guide/roadmap/#p_15",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Language - non-communicating guaranteed termination loops"
  },
  {
    "objectID": "/guide/roadmap/#p_16",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Verification - Constrain eventual use of values"
  },
  {
    "objectID": "/guide/roadmap/#p_17",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Verification - {!rsh} exit() reachability"
  },
  {
    "objectID": "/guide/roadmap/#p_18",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Verification - network analysis"
  },
  {
    "objectID": "/guide/roadmap/#p_19",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Language - Dynamic token tracking"
  },
  {
    "objectID": "/guide/roadmap/#p_20",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Long term:"
  },
  {
    "objectID": "/guide/roadmap/#p_21",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Language - substructural types to allow mutation"
  },
  {
    "objectID": "/guide/roadmap/#p_22",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Language - pay-as-you-go closures"
  },
  {
    "objectID": "/guide/roadmap/#p_23",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Language - general recursion through closure conversion of non-contifiable continuations"
  },
  {
    "objectID": "/guide/roadmap/#p_24",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Verification - game-theoretic property verification"
  },
  {
    "objectID": "/guide/roadmap/#p_25",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Verification - verified compiler"
  },
  {
    "objectID": "/guide/rpc/#guide-rpc",
    "pt": "Do I have to use JavaScript to write my frontend? What about Python, Go, or other languages?",
    "t": 2,
    "c": "Do I have to use JavaScript to write my frontend? What about Python, Go, or other languages?"
  },
  {
    "objectID": "/guide/rpc/#p_0",
    "pt": "Do I have to use JavaScript to write my frontend? What about Python, Go, or other languages?",
    "t": 3,
    "c": "Most Reach examples, tutorials, and workshops use JavaScript as the language of choice for frontend implementation, but Reach supports frontend development in any language via the Reach RPC Server. This server allows backends compiled to JavaScript to be provided to another language via a simple RPC protocol."
  },
  {
    "objectID": "/guide/rpc/#p_1",
    "pt": "Do I have to use JavaScript to write my frontend? What about Python, Go, or other languages?",
    "t": 3,
    "c": "Presently, Reach provides RPC client implementations for:"
  },
  {
    "objectID": "/guide/rpc/#p_2",
    "pt": "Do I have to use JavaScript to write my frontend? What about Python, Go, or other languages?",
    "t": 3,
    "c": "The tutorial section on RPC-based frontends provides a walkthrough of using these libraries."
  },
  {
    "objectID": "/guide/rpc/#p_3",
    "pt": "Do I have to use JavaScript to write my frontend? What about Python, Go, or other languages?",
    "t": 3,
    "c": "If your language of choice isn't available yet, it is very simple to implement one yourself if you've ever used a JSON-based RPC protocol before. Most implementations are less than 100 lines of code! Or, you could submit a request for Reach to build one on the Reach GitHub issue tracker or on the Discord community."
  },
  {
    "objectID": "/guide/solidity/#guide-solidity",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 2,
    "c": "How does Reach development compare to Solidity development?"
  },
  {
    "objectID": "/guide/solidity/#solidity-development",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 2,
    "c": "Solidity Development"
  },
  {
    "objectID": "/guide/solidity/#reach-development",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 2,
    "c": "Reach Development"
  },
  {
    "objectID": "/guide/solidity/#conclusion",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 2,
    "c": "Conclusion"
  },
  {
    "objectID": "/guide/solidity/#p_0",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "The Reach documentation is written from the perspective of a developer who has never done any DApp development of any kind before starting to use Reach. However, mastering Reach development is a valuable skill for those developers with experience using tools like Solidity. But, when these developers read the Reach documentation, they are often at loss to see how what they're reading relates to what they already know. This article attempts to bridge that gap and help Solidity-style developers understand Reach."
  },
  {
    "objectID": "/guide/solidity/#p_1",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "For the rest of this article, when we use the term \"Solidity development\", we're referring to blockchain development without Reach and not literally only the programming language Solidity. For example, \"Solidity development\" includes Vyper developers, as well as users of tools like Truffle Suite, web3.js, and so on. We're talking about a paradigm of DApp programming and not a specific tool."
  },
  {
    "objectID": "/guide/solidity/#p_2",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "A great Solidity project typically includes seven components:"
  },
  {
    "objectID": "/guide/solidity/#p_3",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Protocol Design --- A DApp starts with a protocol diagram, perhaps written using a pidgin UML format, where a developer thinks about the state space of an application and the valid transitions in that state space. This diagram includes annotations about typical use-cases and workflows for particular paths through the protocol."
  },
  {
    "objectID": "/guide/solidity/#p_4",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Smart Contract --- A developer studies the protocol design and defines a smart contract program whose implicit state space matches the protocol. For example, if a protocol has two nodes, A and B, connected by a transition labeled f, then the smart contract might have a Boolean storage variable with a name like inA and a method named f that checks if that variable is true and modifies it to be false---thus A in the diagram corresponds to inA = true and B in the diagram corresponds to inB = false. Part of the challenge of smart contract development is understanding the connection between the implicit state of the smart contract and the original protocol design."
  },
  {
    "objectID": "/guide/solidity/#p_5",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Middleware --- A developer builds a library in a language like JavaScript or Go that uses an SDK like web3.js or ethers to connect to their smart contract. This middleware is co-developed with the smart contract and duplicates details like the names of methods and their arguments. It abstracts these details into higher-level patterns of operation that roughly correspond to the use-cases and workflows in the protocol design."
  },
  {
    "objectID": "/guide/solidity/#p_6",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Frontend --- A developer builds a user interface that connects to the middleware and potentially a wallet, like MetaMask, and provides a high-level user-facing perspective on the software. This is mostly insulated from the details of the particular protocol and contract, but is typically specialized to the consensus network, because the user interface surfaces details about the underlying network."
  },
  {
    "objectID": "/guide/solidity/#p_7",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Testing --- Developers typically use tools like Truffle Suite or a developer instance of geth to launch a test consensus network and then build a suite of unit and end-to-end tests of their application, typically by either directly interacting with the middleware or the smart contract itself. This same testing environment may be used to back a sample version of the frontend."
  },
  {
    "objectID": "/guide/solidity/#p_8",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Verification --- High quality DApps are verified and audited for a variety of properties, from basic checking of things like integer and buffer overflows, to checking of the absence of famous attacks like reentrancy attacks, to more thorough checking of properties related to the particular domain of the application. There are a wide variety of tools and companies that provide this kind of verification as a service and the best DApps are not deployed until they pass these tests, sometimes multiple of them. Verification typically involves only the smart contract and the best versions often require a mechanical representation of the protocol design to analyze the behavior of the DApp across all its workflows."
  },
  {
    "objectID": "/guide/solidity/#p_9",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Deployment --- Once the DApp is ready to be released, it will either be embedded in the frontend, if users are expected to launch their own independent instances of the smart contract, or it is launched a single time (perhaps as a contract factory) at a well-publicized address that might be embedded in the frontend."
  },
  {
    "objectID": "/guide/solidity/#p_10",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Obviously, we've left out a lot of details, but this is a sketch of the typical components of Solidity-style development. There are a huge number of options and techniques for almost all of these components, with some being dropped or minimized depending on the needs of the particular application. For example, an extremely simple DApp might combine the middleware and frontend or embed a description of the protocol design as comments or some ASCII art in the smart contract source code."
  },
  {
    "objectID": "/guide/solidity/#p_11",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Reach development includes each one of these seven components. But rather than requiring the use of a variety of different tools, the difficulties associated with each component are solved by a different aspect of Reach."
  },
  {
    "objectID": "/guide/solidity/#p_12",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Protocol Design --- As a programming language, Reach operates at a different level of abstraction than a language like Solidity. Reach programs encode the same information that would be in the informal protocol design diagrams that often accompany smart contracts. A Reach program specifically names the various participants in a DApp and their individual workflows as a single chronological workflow that shows how and when the various individual workflows intertwine."
  },
  {
    "objectID": "/guide/solidity/#p_13",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Smart Contract --- By operating at this higher-level of abstraction, Reach developers are not responsible for determining the state space of the smart contract. Instead, the Reach compiler analyzes the structure of communication in the protocol design and derives the necessary state and transition functions. This doesn't mean that Reach developers don't think about \"consensus\"; indeed, the consensus step is a fundamental part of a Reach program. However, Reach developers can focus on the constraints on individual publications and the consensual actions of the computation, rather than the mechanics of ensuring the smart contract is in the appropriate state and transitions to the correct next state."
  },
  {
    "objectID": "/guide/solidity/#p_14",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Middleware --- Similarly, a Reach program includes a specification of the API of the middleware layer, via a participant interact interface. This part of a Reach program is particular to each participant and explicitly names the points of contact between the participant workflow (embedded in the Reach program) and the frontend. This means that Reach developers do not need to manually keep the middleware and smart contract in sync or update either as the protocol design changes: the Reach compiler does all of that for them."
  },
  {
    "objectID": "/guide/solidity/#p_15",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Frontend --- Reach programs do not embed the frontend, like they embed the protocol design, smart contract, and middleware. Reach developers design and build user interfaces just like they do in Solidity-style development, except that they tend to have an easier time, because the automatically-generated middleware layer thoroughly insulates them from the low-level details of the consensus network. Reach developers can easily build their interface with JavaScript using the Reach standard library; soon, they will be able to use the language of their choice using the Reach RPC server."
  },
  {
    "objectID": "/guide/solidity/#p_16",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Testing --- Reach facilitates testing in two ways. First, the Reach language embeds a high-quality property-based testing system via the {!rsh} assert and {!rsh} forall primitives, which can be used in a basic way to write simple test cases. Second, the Reach deployment tool, reach run, allows for the easy construction and running of automated test suites for the workflows of a DApp. In both cases, it is not necessary for Reach developers to directly manage their own development networks or otherwise interact with the consensus networks they're testing with in any way."
  },
  {
    "objectID": "/guide/solidity/#p_17",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Verification --- Every Reach compilation includes a thorough formal verification of the DApp using an SMT-based theorem prover. This theorem prover verifies general properties that all programs should exhibit, such as never overflowing finite memory bounds or accessing uninitialized memory. It verifies properties that all DApps should exhibit, such as token linearity property which guarantees that funds are not double-spent or forgotten about. Furthermore, it verifies bespoke properties that are unique to the particular DApp, as specified with the {!rsh} assert primitive."
  },
  {
    "objectID": "/guide/solidity/#p_18",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Deployment --- Some aspects of deployment decisions are embedded inside of Reach programs, such as whether to use a contract factory or whether to have each instance of the DApp use an independent smart contract deployed by one of the participants. Other aspects are part of the configuration of the Reach compiler, such as which consensus network will be targeted. Still others are part of the configuration of the Reach standard library and testing infrastructure, like which wallet the middleware should connect to or which kind of development node should be launched and managed by Reach."
  },
  {
    "objectID": "/guide/solidity/#p_19",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "In summary, a vibrant ecosystem of many tools, techniques, and traditions have grown up around the creation of DApps in the Solidity-style. Reach leverages the experience of that ecosystem and provides a total solution that incorporates all of the different components into one environment, so that it can provide more services with high quality and lower cost by integrating them together."
  },
  {
    "objectID": "/guide/staking/#guide-staking",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 2,
    "c": "Example: Staking and Unstaking Tokens"
  },
  {
    "objectID": "/guide/staking/#staking",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 2,
    "c": "Staking"
  },
  {
    "objectID": "/guide/staking/#unstaking",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 2,
    "c": "Unstaking"
  },
  {
    "objectID": "/guide/staking/#elided-reach",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 2,
    "c": "Elided Reach"
  },
  {
    "objectID": "/guide/staking/#connecting-from-javascript",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 2,
    "c": "Connecting from JavaScript"
  },
  {
    "objectID": "/guide/staking/#conclusion",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 2,
    "c": "Conclusion"
  },
  {
    "objectID": "/guide/staking/#p_0",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "Reach makes DApp development safer, faster, and more secure. This guide offers a real example of the advantages of using Reach."
  },
  {
    "objectID": "/guide/staking/#p_1",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "Here's an example provided by Austin Wilshire at xBacked. Follow Austin on Twitter @awoldes."
  },
  {
    "objectID": "/guide/staking/#p_2",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "Imagine you want to stake a token and at a later date unstake it with all the rewards. Let's look at a snippet from the perspective of a Deployer."
  },
  {
    "objectID": "/guide/staking/#p_3",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "As the deployer, you want to set the reward rate, {!rsh} Token being staked, the rewarded {!rsh} Token, and the initial supply of the reward token."
  },
  {
    "objectID": "/guide/staking/#p_4",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "After this, the contract is fully configured and deployed. The next step is to enable users to interact with it."
  },
  {
    "objectID": "/guide/staking/#p_5",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "First, we want to enable a user to add a stake. We do this by adding an API call so that when the user calls the function, they will pay {!rsh} tokenAmt of the {!rsh} stakeToken which the Deployer set."
  },
  {
    "objectID": "/guide/staking/#p_6",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "In a full implementation, we would enable users to stake multiple times and combine their stakes. (This version resets the stake each time, so it is dangerous and would lose track of a user's funds.)"
  },
  {
    "objectID": "/guide/staking/#p_7",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "Similarly, we want the user to be able to unstake and claim their rewards. We do this with an API call as well."
  },
  {
    "objectID": "/guide/staking/#p_8",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "In a full implementation, we would have to specify how the pendingRewards value was computed. We could make it automatic by connecting it to something like {!rsh} lastConsensusTime."
  },
  {
    "objectID": "/guide/staking/#p_9",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "We haven't shown the entire Reach program. We didn't show the definition of the participants, APIs, or Views. We didn't show the main {!rsh} parallelReduce or its invariants."
  },
  {
    "objectID": "/guide/staking/#p_10",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "Next, we'll want to use this program in a Web application. In this code, we assume that the Web application is written with React."
  },
  {
    "objectID": "/guide/staking/#p_11",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "We use the Reach standard library to connect to the contract, define the User's API calls, and the View."
  },
  {
    "objectID": "/guide/staking/#p_12",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "Next, we get the user's state by reading the view:"
  },
  {
    "objectID": "/guide/staking/#p_13",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "Then, create an event listener that connects to the API calls:"
  },
  {
    "objectID": "/guide/staking/#p_14",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "This demonstrates the essential (but not quite complete) elements of implementing a DApp with Reach. There's no magic involved, but it definitely feels like there is when you're building a Reach application. As a developer, you don't need to think about forming transaction groups, SDK calls, \"opting in\", or \"ASA ids\". Because you don't think about these things, your application works on multiple networks. You focus on the business logic of your DApp and plug into the consensus network of your choice."
  },
  {
    "objectID": "/guide/testing/#guide-testing",
    "pt": "How should I test a DApp?",
    "t": 2,
    "c": "How should I test a DApp?"
  },
  {
    "objectID": "/guide/testing/#p_0",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "When you are writing a DApp in Reach, you should test it thoroughly."
  },
  {
    "objectID": "/guide/testing/#p_1",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "You may think that because Reach has a verification engine you don't need to write tests. This is incorrect: The general verification checks that Reach performs ensure that your program does not do obviously bad things, like violate the linearity of tokens, but it does not check that you wrote the correct program. Furthermore, the specific verification checks that Reach allows you to write cannot specify every bad thing you want to avoid or every good thing that you want to happen. Therefore, you need to use a variety of quality assurance mechanisms."
  },
  {
    "objectID": "/guide/testing/#p_2",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "Your general philosophy for thinking about testing is that you write the program multiple times and make sure that each time you write the program, you write the same program:"
  },
  {
    "objectID": "/guide/testing/#p_3",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "You write the program in Reach."
  },
  {
    "objectID": "/guide/testing/#p_4",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "You write the program in Reach's {!rsh} assert and {!rsh} invariant forms."
  },
  {
    "objectID": "/guide/testing/#p_5",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "You write the program with an automated JavaScript test suite."
  },
  {
    "objectID": "/guide/testing/#p_6",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "You write the program with an interactive user interface."
  },
  {
    "objectID": "/guide/testing/#p_7",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "You write the program with an automated test suite over that user interface."
  },
  {
    "objectID": "/guide/testing/#p_8",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "The connection between any of these two versions of the program is good if whenever you change one, the other one breaks and detects the change. For example, if you change the program (#1) to use a non-network token, rather than the network token, then your test suite (#3) should reflect this, because your testing accounts will need to get a balance of this non-network token."
  },
  {
    "objectID": "/guide/testing/#p_9",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "Reach provides tools for writing #1, #2, and #3. You don't have to use our tool for #3 ({!js} test) and could use any testing framework you wanted. We don't provide tools for #4 or #5 and you can use any user interface toolkit or testing regime; we like to use React for #4 and Cypress for #5."
  },
  {
    "objectID": "/guide/testing/#p_10",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "At the micro-level, your testing outlook should be that tests either:"
  },
  {
    "objectID": "/guide/testing/#p_11",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "Establish that something bad does not happen. Or,"
  },
  {
    "objectID": "/guide/testing/#p_12",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "Establish that something good does happen."
  },
  {
    "objectID": "/guide/testing/#p_13",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "In order to build a large number of these tests succinctly, you should build a simple \"library\" that can succinctly initialize your DApp and then run a scenario. Like this:"
  },
  {
    "objectID": "/guide/testing/#p_14",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "Then, you can write lots of different scenarios:"
  },
  {
    "objectID": "/guide/testing/#p_15",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "The {!js} test.one function is designed for being used in contexts like this. Then you can use {!js} test.run and command-line arguments to select a particular test to run while developing."
  },
  {
    "objectID": "/guide/testing/#p_16",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "Finally, you should use \"standard\" software testing and quality assurance practices, like continuous integration. Wikipedia has a great article on Software Testing that is a good place to get started finding more resources."
  },
  {
    "objectID": "/guide/timeout/#guide-timeout",
    "pt": "Non-participation: What it is and how to protect against it",
    "t": 2,
    "c": "Non-participation: What it is and how to protect against it"
  },
  {
    "objectID": "/guide/timeout/#p_0",
    "pt": "Non-participation: What it is and how to protect against it",
    "t": 3,
    "c": "Non-participation refers to the act of one party ceasing to continue playing their role in an application."
  },
  {
    "objectID": "/guide/timeout/#p_1",
    "pt": "Non-participation: What it is and how to protect against it",
    "t": 3,
    "c": "In traditional client-server programs, like a Web server, this would be the case of a client stopping sending requests to the server, or the server stopping sending responses to the client. In these sorts of traditional programs, non-participation is an exceptional circumstance that normally leads to an error message for clients and, at most, a log entry for servers. Sometimes traditional programs will need to recycle resources, like network ports, on non-participation, but they would have also needed to do that if the transaction ended by normal means. In other words, for traditional client-server programs, it is not necessary for designers to meticulously consider the consequences of non-participation."
  },
  {
    "objectID": "/guide/timeout/#p_2",
    "pt": "Non-participation: What it is and how to protect against it",
    "t": 3,
    "c": "In contrast, decentralized applications must be carefully designed with an eye towards their behavior in the face of non-participation."
  },
  {
    "objectID": "/guide/timeout/#p_3",
    "pt": "Non-participation: What it is and how to protect against it",
    "t": 3,
    "c": "There are two general strategies for dealing with non-participation: punishment and disincentivizing."
  },
  {
    "objectID": "/guide/timeout/#p_4",
    "pt": "Non-participation: What it is and how to protect against it",
    "t": 3,
    "c": "Punishment. The punishment strategy entails allowing the remaining participants of the application to take all of the assets that would have gone to the non-participator and splitting them. This is the strategy used in the tutorial, where Alice's wager is lost if she fails to send her next publication."
  },
  {
    "objectID": "/guide/timeout/#p_5",
    "pt": "Non-participation: What it is and how to protect against it",
    "t": 3,
    "c": "Punishment is a dangerous strategy, because it is difficult to know a priori what the threshold of non-participation is. If you estimate too low, then you will inappropriately punish parties that are honestly delayed. In consensus networks where transactions bid for space in blocks, like Ethereum, low-value transactions may be starved when high-value activity is happening on the network concurrently. Reach allows timeout deadlines to be dynamically set, because the deadline expression of a {!rsh} timeout clause can be any equation over {!rsh} consensus state. This does, however, imply that the application must decide the deadline for a message before or during the immediately preceding message."
  },
  {
    "objectID": "/guide/timeout/#p_6",
    "pt": "Non-participation: What it is and how to protect against it",
    "t": 3,
    "c": "Disincentivizing. The disincentivizing strategy allows all participants to drop participation, but ensures that if they do so, they will punish themselves by forgoing some resource held in escrow by the application. This strategy is only effective if the escrow amount is significantly larger than the payout in a normal execution of the computation. For example, in the Rock, Paper, Scissors! tutorial, we could have had each participant contribute something on the order of ten times that wager into the application, which would not be reimbursed unless the game ended."
  },
  {
    "objectID": "/guide/timeout/#p_7",
    "pt": "Non-participation: What it is and how to protect against it",
    "t": 3,
    "c": "Disincentivizing has the advantage of allowing all programs to eventually finish, but the downside of allowing one participant to disrupt all participants by refusing to continue, thereby locking away the escrows of all parties. It is, therefore, better to only use such incentives when combined with judicious timeouts and asymmetry in the program."
  },
  {
    "objectID": "/guide/versions/#guide-versions",
    "pt": "How does Reach use version numbers?",
    "t": 2,
    "c": "How does Reach use version numbers?"
  },
  {
    "objectID": "/guide/versions/#p_0",
    "pt": "How does Reach use version numbers?",
    "t": 3,
    "c": "Reach uses semantic versioning, which means that given Reach version number MAJOR.MINOR.PATCH,"
  },
  {
    "objectID": "/guide/versions/#p_1",
    "pt": "How does Reach use version numbers?",
    "t": 3,
    "c": "MAJOR versions are incompatible."
  },
  {
    "objectID": "/guide/versions/#p_2",
    "pt": "How does Reach use version numbers?",
    "t": 3,
    "c": "MINOR versions are compatible, but have additional features relative to earlier versions."
  },
  {
    "objectID": "/guide/versions/#p_3",
    "pt": "How does Reach use version numbers?",
    "t": 3,
    "c": "PATCH versions are entirely compatible."
  },
  {
    "objectID": "/guide/versions/#p_4",
    "pt": "How does Reach use version numbers?",
    "t": 3,
    "c": "However, the major version 0.y.z is pre-stability and makes no promises about compatibility of any kind."
  },
  {
    "objectID": "/guide/versions/#p_5",
    "pt": "How does Reach use version numbers?",
    "t": 3,
    "c": "Reach source code starts with"
  },
  {
    "objectID": "/guide/versions/#p_6",
    "pt": "How does Reach use version numbers?",
    "t": 3,
    "c": "because this indicates that it relies on this major version and the features added in this minor version."
  },
  {
    "objectID": "/guide/versions/#p_7",
    "pt": "How does Reach use version numbers?",
    "t": 3,
    "c": "Reach tools are specified by the entire version number with a v at the front, vMAJOR.MINOR.PATCH, but are also available at all prefixes (i.e., vMAJOR.MINOR and vMAJOR). Additionally, there is a version stable which resolves to the most recent stable vMAJOR version."
  },
  {
    "objectID": "/guide/windows/#guide-windows",
    "pt": "Using Reach on Windows",
    "t": 2,
    "c": "Using Reach on Windows"
  },
  {
    "objectID": "/guide/windows/#p_0",
    "pt": "Using Reach on Windows",
    "t": 3,
    "c": "Reach assumes the presence of a POSIX-compliant shell, as well as Docker and Docker Compose."
  },
  {
    "objectID": "/guide/windows/#p_1",
    "pt": "Using Reach on Windows",
    "t": 3,
    "c": "The best way to get this set up on Windows is to"
  },
  {
    "objectID": "/guide/windows/#p_2",
    "pt": "Using Reach on Windows",
    "t": 3,
    "c": "Install Windows 10, version 2004 or higher."
  },
  {
    "objectID": "/guide/windows/#p_3",
    "pt": "Using Reach on Windows",
    "t": 3,
    "c": "Enable the Windows Subsystem for Linux feature, specifically the WSL 2 option."
  },
  {
    "objectID": "/guide/windows/#p_4",
    "pt": "Using Reach on Windows",
    "t": 3,
    "c": "Download and install Docker Desktop, and enable the Docker Desktop WSL 2 backend."
  },
  {
    "objectID": "/guide/windows/#p_5",
    "pt": "Using Reach on Windows",
    "t": 3,
    "c": "Follow the instructions from Docker on developing with Docker and WSL 2."
  },
  {
    "objectID": "/guide/windows/#p_6",
    "pt": "Using Reach on Windows",
    "t": 3,
    "c": "At this point, you'll have your VSCode IDE set up with a terminal in your Linux distribution."
  },
  {
    "objectID": "/guide/windows/#p_7",
    "pt": "Using Reach on Windows",
    "t": 3,
    "c": "You can now follow the instructions in the reference manual on installation or the first part of the tutorial to download, install, and execute all Reach commands."
  },
  {
    "objectID": "/guide/windows/#p_8",
    "pt": "Using Reach on Windows",
    "t": 3,
    "c": "You can watch a five minute video going through these steps on YouTube."
  },
  {
    "objectID": "/rpc/client/#ref-backends-rpc-client",
    "pt": "Client Walkthrough",
    "t": 2,
    "c": "Client Walkthrough"
  },
  {
    "objectID": "/rpc/client/#p_0",
    "pt": "Client Walkthrough",
    "t": 3,
    "c": "The Reach RPC Protocol is designed to be simple to implement in languages that support HTTP and JSON interaction. This document walks through the implementation of an RPC client in Python. An example use of this library is shown in the tutorial section on RPC-based frontends. The entire library is 80 lines of code."
  },
  {
    "objectID": "/rpc/client/#p_1",
    "pt": "Client Walkthrough",
    "t": 3,
    "c": "The library uses a few standard Python libraries for interacting with JSON, HTTP servers, and networking:"
  },
  {
    "objectID": "/rpc/client/#p_2",
    "pt": "Client Walkthrough",
    "t": 3,
    "c": "The library provides a single function, {!py} mk_rpc, that accepts the Reach RPC Client Standard Options."
  },
  {
    "objectID": "/rpc/client/#p_3",
    "pt": "Client Walkthrough",
    "t": 3,
    "c": "It starts by observing the verify option and informing the Python library it uses for HTTPS interaction to turn off warnings. It displays a warning to users that they should be nervous about using this setting."
  },
  {
    "objectID": "/rpc/client/#p_4",
    "pt": "Client Walkthrough",
    "t": 3,
    "c": "Next, it attempts to connect to the Reach RPC Server and throws an error if it does not respond quickly enough."
  },
  {
    "objectID": "/rpc/client/#p_5",
    "pt": "Client Walkthrough",
    "t": 3,
    "c": "It defines a function, {!py} rpc, which will be returned later on, that implements the protocol for synchronous value RPC methods. It formats a given request, posts it, and then returns the deserialized result. It prints debugging information for convenience."
  },
  {
    "objectID": "/rpc/client/#p_6",
    "pt": "Client Walkthrough",
    "t": 3,
    "c": "It defines a function, {!py} rpc_callbacks, which will be returned later on, that implements the protocol for interactive RPC methods. On lines 64 and 65, this function inspects its third argument, {!py} cbacks, and separates the {!py} callable arguments from the values and creates the intermediate objects, {!py} vals and {!py} meths, to provide the RPC invocation. After it makes the call, in the {!py} while loop starting on line 68, it inspects the result to determine if it is a final answer or an interactive RPC callback. If it is a callback, as indicated by the test on line 72, then it extracts the name of the method, {!py} p['m'], and invokes it in the original third argument, {!py} cbacks, with the provided arguments. It replaces the {!py} p value with the result of that continuation invocation and continues."
  },
  {
    "objectID": "/rpc/client/#p_7",
    "pt": "Client Walkthrough",
    "t": 3,
    "c": "Finally, it returns {!py} rpc and {!py} rpc_callbacks to the user."
  },
  {
    "objectID": "/rpc/cs/#ref-frontends-rpc-cs",
    "pt": "C#",
    "t": 2,
    "c": "C#"
  },
  {
    "objectID": "/rpc/cs/#p_0",
    "pt": "C#",
    "t": 3,
    "c": "This frontend library relies on the Reach RPC Server."
  },
  {
    "objectID": "/rpc/cs/#p_1",
    "pt": "C#",
    "t": 3,
    "c": "A C# client library for the Reach RPC protocol may be installed by copying the code at https://github.com/reach-sh/reach-lang/tree/master/rpc-client/cs."
  },
  {
    "objectID": "/rpc/cs/#p_2",
    "pt": "C#",
    "t": 3,
    "c": "Please inspect the tutorial example program for usage: https://github.com/reach-sh/reach-lang/blob/master/examples/rps-7-rpc/client-cs/index.cs."
  },
  {
    "objectID": "/rpc/go/#go_reachrpc.Mk",
    "pt": "Go",
    "t": 0,
    "s": "go",
    "c": "reachrpc.Mk"
  },
  {
    "objectID": "/rpc/go/#go_rpc",
    "pt": "Go",
    "t": 0,
    "s": "go",
    "c": "rpc"
  },
  {
    "objectID": "/rpc/go/#go_rpcCallbacks",
    "pt": "Go",
    "t": 0,
    "s": "go",
    "c": "rpcCallbacks"
  },
  {
    "objectID": "/rpc/go/#ref-frontends-rpc-go",
    "pt": "Go",
    "t": 2,
    "c": "Go"
  },
  {
    "objectID": "/rpc/go/#p_0",
    "pt": "Go",
    "t": 3,
    "c": "This frontend library relies on the Reach RPC Server."
  },
  {
    "objectID": "/rpc/go/#p_1",
    "pt": "Go",
    "t": 3,
    "c": "A Go client library for the Reach RPC protocol may be installed by running:"
  },
  {
    "objectID": "/rpc/go/#p_2",
    "pt": "Go",
    "t": 3,
    "c": "Once installed, add the following import line to your Go file which will connect to the RPC server:"
  },
  {
    "objectID": "/rpc/go/#p_3",
    "pt": "Go",
    "t": 3,
    "c": "The library provides the following bindings:"
  },
  {
    "objectID": "/rpc/go/#p_4",
    "pt": "Go",
    "t": 3,
    "c": "{!go} reachrpc.Mk accepts the Reach RPC Client Standard Options as a {!go} map and returns two functions, traditionally called {!go} rpc and {!go} rpcCallbacks."
  },
  {
    "objectID": "/rpc/go/#p_5",
    "pt": "Go",
    "t": 3,
    "c": "{!go} rpc is a function that invokes a synchronous value RPC method. It takes a string, naming the RPC method, and some JSON values to provide as arguments. It returns a single JSON value as the result."
  },
  {
    "objectID": "/rpc/go/#p_6",
    "pt": "Go",
    "t": 3,
    "c": "For example,"
  },
  {
    "objectID": "/rpc/go/#p_7",
    "pt": "Go",
    "t": 3,
    "c": "calls {!js} formatCurrency with some value {!go} i and {!go} 4 and returns the result as a string."
  },
  {
    "objectID": "/rpc/go/#p_8",
    "pt": "Go",
    "t": 3,
    "c": "{!go} rpcCallbacks is a function that invokes an interactive RPC method, such as for a backend. It takes a string, naming the RPC method, a JSON value as an argument, and map from strings to JSON values or functions. The functions will be provided as interactive RPC callbacks to the RPC method and should expect JSON values as arguments and return a JSON value as a result. It returns {!go} void."
  },
  {
    "objectID": "/rpc/go/#p_9",
    "pt": "Go",
    "t": 3,
    "c": "For example,"
  },
  {
    "objectID": "/rpc/go/#p_10",
    "pt": "Go",
    "t": 3,
    "c": "calls a backend named Alice with the contract {!go} ctc and a value named price and a method named showX that prints out a result from the Reach backend."
  },
  {
    "objectID": "/rpc/js/#js_mkRPC",
    "pt": "JavaScript",
    "t": 0,
    "s": "js",
    "c": "mkRPC"
  },
  {
    "objectID": "/rpc/js/#js_rpc",
    "pt": "JavaScript",
    "t": 0,
    "s": "js",
    "c": "rpc"
  },
  {
    "objectID": "/rpc/js/#js_rpcCallbacks",
    "pt": "JavaScript",
    "t": 0,
    "s": "js",
    "c": "rpcCallbacks"
  },
  {
    "objectID": "/rpc/js/#ref-frontends-rpc-js",
    "pt": "JavaScript",
    "t": 2,
    "c": "JavaScript"
  },
  {
    "objectID": "/rpc/js/#p_0",
    "pt": "JavaScript",
    "t": 3,
    "c": "This frontend library relies on the Reach RPC Server."
  },
  {
    "objectID": "/rpc/js/#p_1",
    "pt": "JavaScript",
    "t": 3,
    "c": "A JavaScript client library for the Reach RPC protocol may be installed by running:"
  },
  {
    "objectID": "/rpc/js/#p_2",
    "pt": "JavaScript",
    "t": 3,
    "c": "Once installed, add the following import line to your JavaScript file which will connect to the RPC server:"
  },
  {
    "objectID": "/rpc/js/#p_3",
    "pt": "JavaScript",
    "t": 3,
    "c": "The library provides the following bindings:"
  },
  {
    "objectID": "/rpc/js/#p_4",
    "pt": "JavaScript",
    "t": 3,
    "c": "{!js} mkRPC accepts the Reach RPC Client Standard Options as an object and returns a Promise of an object with two fields, {!js} rpc and {!js} rpcCallbacks."
  },
  {
    "objectID": "/rpc/js/#p_5",
    "pt": "JavaScript",
    "t": 3,
    "c": "{!js} rpc is a function that invokes a synchronous value RPC method. It takes a string, naming the RPC method, and some JSON values to provide as arguments. It returns a Promise of a single JSON value as the result."
  },
  {
    "objectID": "/rpc/js/#p_6",
    "pt": "JavaScript",
    "t": 3,
    "c": "For example,"
  },
  {
    "objectID": "/rpc/js/#p_7",
    "pt": "JavaScript",
    "t": 3,
    "c": "calls {!js} formatCurrency with some value {!js} i and {!js} 4."
  },
  {
    "objectID": "/rpc/js/#p_8",
    "pt": "JavaScript",
    "t": 3,
    "c": "{!js} rpcCallbacks is a function that invokes an interactive RPC method, such as for a backend. It takes a string, naming the RPC method, a JSON value as an argument, and dictionary from strings to JSON values or {!js} async functions. The functions will be provided as interactive RPC callbacks to the RPC method and should expect JSON values as arguments and return a Promise of a JSON value as a result. It returns a Promise that does not contain a value."
  },
  {
    "objectID": "/rpc/js/#p_9",
    "pt": "JavaScript",
    "t": 3,
    "c": "For example,"
  },
  {
    "objectID": "/rpc/js/#p_10",
    "pt": "JavaScript",
    "t": 3,
    "c": "calls a backend named Alice with the contract {!js} ctc and a value named price and a method named showX that prints out a result from the Reach backend."
  },
  {
    "objectID": "/rpc/proto/#term_API%20key",
    "pt": "Specification",
    "t": 1,
    "c": "API key"
  },
  {
    "objectID": "/rpc/proto/#term_RPC%20handles",
    "pt": "Specification",
    "t": 1,
    "c": "RPC handles"
  },
  {
    "objectID": "/rpc/proto/#term_Synchronous%20value%20RPC%20methods",
    "pt": "Specification",
    "t": 1,
    "c": "Synchronous value RPC methods"
  },
  {
    "objectID": "/rpc/proto/#term_Interactive%20RPC%20methods",
    "pt": "Specification",
    "t": 1,
    "c": "Interactive RPC methods"
  },
  {
    "objectID": "/rpc/proto/#term_interactive%20RPC%20callback",
    "pt": "Specification",
    "t": 1,
    "c": "interactive RPC callback"
  },
  {
    "objectID": "/rpc/proto/#term_interactive%20RPC%20continuation",
    "pt": "Specification",
    "t": 1,
    "c": "interactive RPC continuation"
  },
  {
    "objectID": "/rpc/proto/#ref-backends-rpc-proto",
    "pt": "Specification",
    "t": 2,
    "c": "Specification"
  },
  {
    "objectID": "/rpc/proto/#p_0",
    "pt": "Specification",
    "t": 3,
    "c": "The Reach RPC Protocol (hereafter, \"the protocol\" or \"it\") is an instance of JSON-based RPC protocol."
  },
  {
    "objectID": "/rpc/proto/#p_1",
    "pt": "Specification",
    "t": 3,
    "c": "It should be transported over HTTPS (i.e. HTTP over TLS)."
  },
  {
    "objectID": "/rpc/proto/#p_2",
    "pt": "Specification",
    "t": 3,
    "c": "Requests must include an X-API-Key header whose value is a shared secret between a server instance and an RPC client, referred to as the API key. Typically this value comes from the environment variable REACH_RPC_KEY and is the Base64 encoding of 24 random bytes."
  },
  {
    "objectID": "/rpc/proto/#p_3",
    "pt": "Specification",
    "t": 3,
    "c": "Requests must use the POST HTTP method."
  },
  {
    "objectID": "/rpc/proto/#p_4",
    "pt": "Specification",
    "t": 3,
    "c": "Requests specify the RPC method to be invoked via the HTTP request target."
  },
  {
    "objectID": "/rpc/proto/#p_5",
    "pt": "Specification",
    "t": 3,
    "c": "Requests must include a JSON-encoded array in their body. Requests should indicate this by setting the Content-Type header to application/json; charset=utf-8. This array is interpreted as the arguments to the RPC method."
  },
  {
    "objectID": "/rpc/proto/#p_6",
    "pt": "Specification",
    "t": 3,
    "c": "Responses must include a JSON-encoded value in their body. Responses should indicate this by setting the Content-Type header to application/json; charset=utf-8."
  },
  {
    "objectID": "/rpc/proto/#p_7",
    "pt": "Specification",
    "t": 3,
    "c": "Responses may include RPC handles, which are strings that represent intermediate resources held on the RPC server that cannot be serialized to JSON."
  },
  {
    "objectID": "/rpc/proto/#p_8",
    "pt": "Specification",
    "t": 3,
    "c": "RPC methods are either synchronous value RPC methods or interactive RPC methods."
  },
  {
    "objectID": "/rpc/proto/#p_9",
    "pt": "Specification",
    "t": 3,
    "c": "Synchronous value RPC methods consume arguments and produce a single result without further interaction with the client. The result is the body of the response."
  },
  {
    "objectID": "/rpc/proto/#p_10",
    "pt": "Specification",
    "t": 3,
    "c": "For example, {!js} formatCurrency is a synchronous value RPC method. A call to {!js} formatCurrency(\"19283.1035819471\", 4) would be represented by the following HTTP session, with request lines indicated by + and response lines indicated by -:"
  },
  {
    "objectID": "/rpc/proto/#p_11",
    "pt": "Specification",
    "t": 3,
    "c": "Interactive RPC methods consume arguments, including a specification of interactive RPC callbacks, and produce an interactive RPC continuation."
  },
  {
    "objectID": "/rpc/proto/#p_12",
    "pt": "Specification",
    "t": 3,
    "c": "An interactive RPC callback is a key of a JSON object, bound to {!js} true, that indicates that the initiator of an interactive RPC method responds to requests for further data during the execution of this call."
  },
  {
    "objectID": "/rpc/proto/#p_13",
    "pt": "Specification",
    "t": 3,
    "c": "An interactive RPC continuation is a JSON object that matches either:"
  },
  {
    "objectID": "/rpc/proto/#p_14",
    "pt": "Specification",
    "t": 3,
    "c": "{!js} {t: \"Done\", ans}, where {!js} ans is the final result of the original interactive RPC method."
  },
  {
    "objectID": "/rpc/proto/#p_15",
    "pt": "Specification",
    "t": 3,
    "c": "{!js} {t: \"Kont\", kid, m, args}, where {!js} kid is an RPC handle, {!js} m is a string naming one of the interactive RPC callback methods, and {!js} args is an array of the arguments to that method."
  },
  {
    "objectID": "/rpc/proto/#p_16",
    "pt": "Specification",
    "t": 3,
    "c": "When a {!js} Kont value is produced, then the interactive RPC method is suspended until the /kont RPC method is invoked with the continuation RPC handle and the return value of the interactive RPC callback. The result of the /kont RPC method is another interactive RPC continuation."
  },
  {
    "objectID": "/rpc/proto/#p_17",
    "pt": "Specification",
    "t": 3,
    "c": "Clients may perform any RPC methods while an interactive RPC method is suspended."
  },
  {
    "objectID": "/rpc/proto/#p_18",
    "pt": "Specification",
    "t": 3,
    "c": "The server may re-use the same interactive RPC continuation handle many times."
  },
  {
    "objectID": "/rpc/proto/#p_19",
    "pt": "Specification",
    "t": 3,
    "c": "For example, the execution of a backend is an interactive RPC method. An example interaction might be represented by the following HTTP session, with request lines indicated by + and response lines indicated by -:"
  },
  {
    "objectID": "/rpc/py/#py_mk_rpc",
    "pt": "Python",
    "t": 0,
    "s": "py",
    "c": "mk_rpc"
  },
  {
    "objectID": "/rpc/py/#py_rpc",
    "pt": "Python",
    "t": 0,
    "s": "py",
    "c": "rpc"
  },
  {
    "objectID": "/rpc/py/#py_rpc_callbacks",
    "pt": "Python",
    "t": 0,
    "s": "py",
    "c": "rpc_callbacks"
  },
  {
    "objectID": "/rpc/py/#ref-frontends-rpc-py",
    "pt": "Python",
    "t": 2,
    "c": "Python"
  },
  {
    "objectID": "/rpc/py/#p_0",
    "pt": "Python",
    "t": 3,
    "c": "This frontend library relies on the Reach RPC Server."
  },
  {
    "objectID": "/rpc/py/#p_1",
    "pt": "Python",
    "t": 3,
    "c": "A Python client library for the Reach RPC protocol may be installed by running:"
  },
  {
    "objectID": "/rpc/py/#p_2",
    "pt": "Python",
    "t": 3,
    "c": "Once installed, add the following import line to your Python file which will connect to the RPC server:"
  },
  {
    "objectID": "/rpc/py/#p_3",
    "pt": "Python",
    "t": 3,
    "c": "The library provides the following bindings:"
  },
  {
    "objectID": "/rpc/py/#p_4",
    "pt": "Python",
    "t": 3,
    "c": "{!py} mk_rpc accepts the Reach RPC Client Standard Options as a dictionary and returns two functions, traditionally called {!py} rpc and {!py} rpc_callbacks."
  },
  {
    "objectID": "/rpc/py/#p_5",
    "pt": "Python",
    "t": 3,
    "c": "{!py} rpc is a function that invokes a synchronous value RPC method. It takes a string, naming the RPC method, and some JSON values to provide as arguments. It returns a single JSON value as the result."
  },
  {
    "objectID": "/rpc/py/#p_6",
    "pt": "Python",
    "t": 3,
    "c": "For example,"
  },
  {
    "objectID": "/rpc/py/#p_7",
    "pt": "Python",
    "t": 3,
    "c": "calls {!js} formatCurrency with some value {!py} i and {!py} 4."
  },
  {
    "objectID": "/rpc/py/#p_8",
    "pt": "Python",
    "t": 3,
    "c": "{!py} rpc_callbacks is a function that invokes an interactive RPC method, such as for a backend. It takes a string, naming the RPC method, a JSON value as an argument, and dictionary from strings to JSON values or functions. The functions will be provided as interactive RPC callbacks to the RPC method and should expect JSON values as arguments and return a JSON value as a result. It does not return a value."
  },
  {
    "objectID": "/rpc/py/#p_9",
    "pt": "Python",
    "t": 3,
    "c": "For example,"
  },
  {
    "objectID": "/rpc/py/#p_10",
    "pt": "Python",
    "t": 3,
    "c": "calls a backend named Alice with the contract {!py} ctc and a value named price and a method named showX that prints out a result from the Reach backend."
  },
  {
    "objectID": "/tut/overview/#overview",
    "pt": "Overview",
    "t": 2,
    "c": "Overview"
  },
  {
    "objectID": "/tut/overview/#over-model",
    "pt": "Overview",
    "t": 2,
    "c": "Decentralized applications"
  },
  {
    "objectID": "/tut/overview/#over-minimal",
    "pt": "Overview",
    "t": 2,
    "c": "A minimal Reach program"
  },
  {
    "objectID": "/tut/overview/#over-compile",
    "pt": "Overview",
    "t": 2,
    "c": "Compile"
  },
  {
    "objectID": "/tut/overview/#over-verify",
    "pt": "Overview",
    "t": 2,
    "c": "Verify"
  },
  {
    "objectID": "/tut/overview/#over-interface",
    "pt": "Overview",
    "t": 2,
    "c": "Interface"
  },
  {
    "objectID": "/tut/overview/#over-execute",
    "pt": "Overview",
    "t": 2,
    "c": "Execute"
  },
  {
    "objectID": "/tut/overview/#over-react",
    "pt": "Overview",
    "t": 2,
    "c": "Web app"
  },
  {
    "objectID": "/tut/overview/#over-next",
    "pt": "Overview",
    "t": 2,
    "c": "Next steps"
  },
  {
    "objectID": "/tut/overview/#p_0",
    "pt": "Overview",
    "t": 3,
    "c": "This is an informal overview of Reach and the structure of a Reach program. The goal of this document is to give enough technical specifics to help you understand what Reach does, but it isn't intended as either a tutorial or a reference. When you're ready to really begin a project, you can start with one of those, or the workshop."
  },
  {
    "objectID": "/tut/overview/#p_1",
    "pt": "Overview",
    "t": 3,
    "c": "If you have experience with blockchain development using existing tools, we recommend reading this article and a comparison with other development platforms."
  },
  {
    "objectID": "/tut/overview/#p_2",
    "pt": "Overview",
    "t": 3,
    "c": "A recording of a live workshop that goes over this material is available on YouTube."
  },
  {
    "objectID": "/tut/overview/#p_3",
    "pt": "Overview",
    "t": 3,
    "c": "DApps are made of multiple agents interacting with each other through some backend consensus network, like Ethereum or Algorand. These agents act on behalf of principals that provide direction and authority through information. These principals might be humans or other autonomous agents or even committees and organizations with their own structure. The consensus network allows these agents to transfer and receive value in the form of network-specific tokens, like ETH or ALGO. The network also allows the creation of \"contracts\" that ensure that all agents follow the same rules as they take turns computing and publishing values and information. The details of these \"contracts\" are specific to each consensus network, but they are implicitly trusted by all agents and principals because their operation can be independently verified to match the previously agreed-upon rules."
  },
  {
    "objectID": "/tut/overview/#p_4",
    "pt": "Overview",
    "t": 3,
    "c": "A single Reach program incorporates all aspects of a DApp:"
  },
  {
    "objectID": "/tut/overview/#p_5",
    "pt": "Overview",
    "t": 3,
    "c": "Participant backends are the agents acting on behalf of the principals."
  },
  {
    "objectID": "/tut/overview/#p_6",
    "pt": "Overview",
    "t": 3,
    "c": "Frontends are the technical representation of the interface between the participants and the principals."
  },
  {
    "objectID": "/tut/overview/#p_7",
    "pt": "Overview",
    "t": 3,
    "c": "A contract enforces the rules of the program, including the order of operation."
  },
  {
    "objectID": "/tut/overview/#p_8",
    "pt": "Overview",
    "t": 3,
    "c": "In Reach, a programmer only needs to specify the actions of participants---what they do individually and what they do in unison. The Reach compiler automatically derives a contract for the consensus network via a connector that enforces these rules."
  },
  {
    "objectID": "/tut/overview/#p_9",
    "pt": "Overview",
    "t": 3,
    "c": "Let's look at a simple Reach program where two principals, Alice and Bob, interact. In this DApp, Alice has some information that Bob might want and she has an amount of network tokens in mind that she'd like to trade for it."
  },
  {
    "objectID": "/tut/overview/#p_10",
    "pt": "Overview",
    "t": 3,
    "c": "You can look at the entire example program by visiting overview/index.rsh."
  },
  {
    "objectID": "/tut/overview/#p_11",
    "pt": "Overview",
    "t": 3,
    "c": "Get language support for Reach in your editor by visiting the guide on editor support."
  },
  {
    "objectID": "/tut/overview/#p_12",
    "pt": "Overview",
    "t": 3,
    "c": "The main part of the program looks like this:"
  },
  {
    "objectID": "/tut/overview/#p_13",
    "pt": "Overview",
    "t": 3,
    "c": "Line 1 specifies that this is a Reach program."
  },
  {
    "objectID": "/tut/overview/#p_14",
    "pt": "Overview",
    "t": 3,
    "c": "Line 2 specifies that this program will be compiled with strict mode, which enables unused variable checks."
  },
  {
    "objectID": "/tut/overview/#p_15",
    "pt": "Overview",
    "t": 3,
    "c": "Line 4 defines the main export from this program. main is the default used by Reach."
  },
  {
    "objectID": "/tut/overview/#p_16",
    "pt": "Overview",
    "t": 3,
    "c": "Line 4 also specifies that it is an application."
  },
  {
    "objectID": "/tut/overview/#p_17",
    "pt": "Overview",
    "t": 3,
    "c": "Line 5 specifies that the program identifier {!rsh} A will represent the Alice participant."
  },
  {
    "objectID": "/tut/overview/#p_18",
    "pt": "Overview",
    "t": 3,
    "c": "Lines 6 and 7 specify the interface between Alice's participant and frontend. In this case, Alice's frontend must provide a number called request and a string called info."
  },
  {
    "objectID": "/tut/overview/#p_19",
    "pt": "Overview",
    "t": 3,
    "c": "Line 9 specifies that the program identifier {!rsh} B will represent the Bob participant."
  },
  {
    "objectID": "/tut/overview/#p_20",
    "pt": "Overview",
    "t": 3,
    "c": "Lines 10 and 11 specify the interface for Bob, which includes a function named want, that takes a number and returns {!rsh} null, as well as a function named got, that receives the information."
  },
  {
    "objectID": "/tut/overview/#p_21",
    "pt": "Overview",
    "t": 3,
    "c": "Finally, line 13, deploys the DApp."
  },
  {
    "objectID": "/tut/overview/#p_22",
    "pt": "Overview",
    "t": 3,
    "c": "The elided lines, 14 through 34, contain the body of the application, which we can divide into four parts."
  },
  {
    "objectID": "/tut/overview/#p_23",
    "pt": "Overview",
    "t": 3,
    "c": "Lines 15 and 16 specify that Alice takes a local step where she declassifies the amount of tokens requested. In Reach, all values from the frontend are secret until explicitly made public with declassify."
  },
  {
    "objectID": "/tut/overview/#p_24",
    "pt": "Overview",
    "t": 3,
    "c": "Line 17 has Alice join the application by publishing that value, and the logic of the program transitions to specifying what the contract does."
  },
  {
    "objectID": "/tut/overview/#p_25",
    "pt": "Overview",
    "t": 3,
    "c": "Line 18 has the contract commit to these values and continue the rest of the program."
  },
  {
    "objectID": "/tut/overview/#p_26",
    "pt": "Overview",
    "t": 3,
    "c": "At this point, Bob's backend has learned the value of {!rsh} request and can deliver it to Bob's frontend for his approval. This happens next."
  },
  {
    "objectID": "/tut/overview/#p_27",
    "pt": "Overview",
    "t": 3,
    "c": "Lines 20 and 21 have Bob perform that delivery. {!rsh} interact.want doesn't explicitly return a boolean because the frontend cannot return if Bob doesn't want to continue. A better version of this program might return {!rsh} false and have that communicated to Alice."
  },
  {
    "objectID": "/tut/overview/#p_28",
    "pt": "Overview",
    "t": 3,
    "c": "Lines 22 and 23 have Bob join the application and submit a payment matching the appropriate amount, and then the contract commits."
  },
  {
    "objectID": "/tut/overview/#p_29",
    "pt": "Overview",
    "t": 3,
    "c": "It's now Alice's turn again:"
  },
  {
    "objectID": "/tut/overview/#p_30",
    "pt": "Overview",
    "t": 3,
    "c": "Lines 25 and 26 specify that Alice declassifies the information."
  },
  {
    "objectID": "/tut/overview/#p_31",
    "pt": "Overview",
    "t": 3,
    "c": "Line 27 has her publish it."
  },
  {
    "objectID": "/tut/overview/#p_32",
    "pt": "Overview",
    "t": 3,
    "c": "Line 28 has the contract transfer the requested amount to her."
  },
  {
    "objectID": "/tut/overview/#p_33",
    "pt": "Overview",
    "t": 3,
    "c": "Line 29 commits the transactions on the consensus network."
  },
  {
    "objectID": "/tut/overview/#p_34",
    "pt": "Overview",
    "t": 3,
    "c": "The only thing left is for Bob's backend to deliver the information to his frontend."
  },
  {
    "objectID": "/tut/overview/#p_35",
    "pt": "Overview",
    "t": 3,
    "c": "Line 31 and 32 use an interaction expression to transfer the information to the frontend."
  },
  {
    "objectID": "/tut/overview/#p_36",
    "pt": "Overview",
    "t": 3,
    "c": "Line 33 exits the program."
  },
  {
    "objectID": "/tut/overview/#p_37",
    "pt": "Overview",
    "t": 3,
    "c": "Reach programmers don't need to think about details like contract storage, protocol diagrams, state validation, or network details; instead, they can focus exclusively on the business logic of their application."
  },
  {
    "objectID": "/tut/overview/#p_38",
    "pt": "Overview",
    "t": 3,
    "c": "After a Reach programmer writes this application in a file like overview/index.rsh, they could run"
  },
  {
    "objectID": "/tut/overview/#p_39",
    "pt": "Overview",
    "t": 3,
    "c": "and the build directory will contain a new file named index.main.mjs, which contains a JavaScript implementation of a backend for each participant, as well as the Ethereum bytecode for the contract."
  },
  {
    "objectID": "/tut/overview/#p_40",
    "pt": "Overview",
    "t": 3,
    "c": "If you are curious, you can take a look at this file by going to overview/build/index.main.mjs. The Ethereum bytecode is not readable, but if you understand Solidity, you may want to look at overview/build/index.main.sol to see the original Solidity source that it is compiled from. Reach can leave files like these in place when run with --intermediate-files."
  },
  {
    "objectID": "/tut/overview/#p_41",
    "pt": "Overview",
    "t": 3,
    "c": "The command line snippets in this overview make no assumption about where Reach is installed on your machine. If Reach is installed in the directory you're working in, point to it with ./reach; if it is in a parent directory use ../reach; if you installed it into your {!cmd} PATH, just type reach. Learn more about installing Reach in the Tools documentation or in our Tutorial."
  },
  {
    "objectID": "/tut/overview/#p_42",
    "pt": "Overview",
    "t": 3,
    "c": "For this thirty line application, the Reach compiler generated hundreds of lines of JavaScript code in two functions, one for Alice and one for Bob. Separately, it generated hundreds more lines of Solidity code to implement the contract. If a programmer wasn't using Reach, they would have to write all this code in these three modules individually and keep them synchronized at every step of the development process."
  },
  {
    "objectID": "/tut/overview/#p_43",
    "pt": "Overview",
    "t": 3,
    "c": "Moreover, Reach doesn't only work for Ethereum: it is blockchain agnostic and can be easily configured to use a different connector to target a different consensus network, like Algorand. Nor is Reach tied to JavaScript: it can be configured to target other backend languages, like Go, Python, and C#."
  },
  {
    "objectID": "/tut/overview/#p_44",
    "pt": "Overview",
    "t": 3,
    "c": "Reach doesn't just compile your program: it also verifies it and ensures that entire categories of errors don't occur. For example, it always guarantees that the balance in the contract at the end of the program is zero. This is important because if it were not true, then tokens would be locked away by the contract and inaccessible."
  },
  {
    "objectID": "/tut/overview/#p_45",
    "pt": "Overview",
    "t": 3,
    "c": "For this example program, it is obvious that when a single transfer of {!rsh} request goes in at line 22 and a single transfer of {!rsh} request goes out at line 28, then the balance is zero at the end of the program. We could make a small tweak, however, to demonstrate things going wrong."
  },
  {
    "objectID": "/tut/overview/#p_46",
    "pt": "Overview",
    "t": 3,
    "c": "Let's change the third step to leave a single unit in the balance:"
  },
  {
    "objectID": "/tut/overview/#p_47",
    "pt": "Overview",
    "t": 3,
    "c": "And then run the compiler:"
  },
  {
    "objectID": "/tut/overview/#p_48",
    "pt": "Overview",
    "t": 3,
    "c": "It will print out a detailed error message showing the violation."
  },
  {
    "objectID": "/tut/overview/#p_49",
    "pt": "Overview",
    "t": 3,
    "c": "Verification failures include a lot of information, such as a concrete counter-example showing values that could have been provided by frontends that would lead to the property failing to hold. In this case, it reports that if Alice were to pass an {!rsh} interact.request over {!rsh} 1 at the start of the program on line 5, then the balance of the contract would not be provably {!rsh} 0 at the end of the program."
  },
  {
    "objectID": "/tut/overview/#p_50",
    "pt": "Overview",
    "t": 3,
    "c": "Reach programmers don't need to worry about entire categories of errors because the compiler automatically checks their code and ensures that those errors aren't present. Of course, there's a lot more to say about the details of automatic verification; indeed, it is one of the most powerful features of Reach, but we'll leave it at that for now."
  },
  {
    "objectID": "/tut/overview/#p_51",
    "pt": "Overview",
    "t": 3,
    "c": "The backend produced by the Reach compiler isn't an application on its own. In particular, each participant needs a frontend to interact with. In a real deployment, this interfacing code would be tied to a GUI, like a Web or smartphone app. Let's look at a simple command-line version that demonstrates how it would work for testing on a private devnet."
  },
  {
    "objectID": "/tut/overview/#p_52",
    "pt": "Overview",
    "t": 3,
    "c": "You can look at the entire example interface program by visiting overview/index.mjs."
  },
  {
    "objectID": "/tut/overview/#p_53",
    "pt": "Overview",
    "t": 3,
    "c": "The program is just a few dozen lines long and the shell of it is quite simple:"
  },
  {
    "objectID": "/tut/overview/#p_54",
    "pt": "Overview",
    "t": 3,
    "c": "Lines 1 and 2 import the Reach standard library loader and the compiled app backend."
  },
  {
    "objectID": "/tut/overview/#p_55",
    "pt": "Overview",
    "t": 3,
    "c": "Line 4 dynamically loads the appropriate network-specific Reach standard library, based on the REACH_CONNECTOR_MODE environment variable. All of Reach's network-specific standard libraries adhere to a common interface allowing you to write programs that are network-agnostic."
  },
  {
    "objectID": "/tut/overview/#p_56",
    "pt": "Overview",
    "t": 3,
    "c": "Lines 6 and 7 initialize new test accounts for Alice and Bob."
  },
  {
    "objectID": "/tut/overview/#p_57",
    "pt": "Overview",
    "t": 3,
    "c": "Line 9 has Alice deploy the contract on the consensus network."
  },
  {
    "objectID": "/tut/overview/#p_58",
    "pt": "Overview",
    "t": 3,
    "c": "Line 10 has Bob attach to the contract. The value {!js} ctcAlice contains no secret information and could easily be printed out and shared with Bob outside of the consensus network."
  },
  {
    "objectID": "/tut/overview/#p_59",
    "pt": "Overview",
    "t": 3,
    "c": "Lines 12 through 21 launch the backends and wait for their completion. We'll look at the details in a moment."
  },
  {
    "objectID": "/tut/overview/#p_60",
    "pt": "Overview",
    "t": 3,
    "c": "This code, similar for all test programs, demonstrates how straightforward it is to scaffold a Reach application for testing."
  },
  {
    "objectID": "/tut/overview/#p_61",
    "pt": "Overview",
    "t": 3,
    "c": "Let's look at initializing and interfacing each participant, starting with Alice."
  },
  {
    "objectID": "/tut/overview/#p_62",
    "pt": "Overview",
    "t": 3,
    "c": "Line 13 uses the contract handle associated with Alice's account to run the Alice participant backend, passing an object which holds the interact functions."
  },
  {
    "objectID": "/tut/overview/#p_63",
    "pt": "Overview",
    "t": 3,
    "c": "Line 14 provides the {!rsh} request value."
  },
  {
    "objectID": "/tut/overview/#p_64",
    "pt": "Overview",
    "t": 3,
    "c": "Line 15 provides the {!rsh} info value."
  },
  {
    "objectID": "/tut/overview/#p_65",
    "pt": "Overview",
    "t": 3,
    "c": "Let's look at Bob next."
  },
  {
    "objectID": "/tut/overview/#p_66",
    "pt": "Overview",
    "t": 3,
    "c": "Line 17 initializes Bob just like Alice, although we use the {!js} p short-hand."
  },
  {
    "objectID": "/tut/overview/#p_67",
    "pt": "Overview",
    "t": 3,
    "c": "Line 18 provides his {!rsh} want function, which produces a log message and always accepts."
  },
  {
    "objectID": "/tut/overview/#p_68",
    "pt": "Overview",
    "t": 3,
    "c": "Line 19 provides his {!rsh} got function, which displays the secret on the console as well."
  },
  {
    "objectID": "/tut/overview/#p_69",
    "pt": "Overview",
    "t": 3,
    "c": "Reach completely abstracts all the details of the chosen consensus network from the programmer, except for those directly impinging on business decisions, like the amounts of currency transacted. Reach allows programmers to focus on the business logic of their application at every stage, from the core application to the interfacing elements."
  },
  {
    "objectID": "/tut/overview/#p_70",
    "pt": "Overview",
    "t": 3,
    "c": "It's now time to execute this test program and ensure that everything is working correctly. In this case, we've set up our application simply: there's one Reach file for the application and one JavaScript file for the interface. This is a common practice, so Reach comes with a simple wrapper script to build and execute such applications."
  },
  {
    "objectID": "/tut/overview/#p_71",
    "pt": "Overview",
    "t": 3,
    "c": "First, we connect Reach to a consensus network. We can connect to Ethereum's test environment by running:"
  },
  {
    "objectID": "/tut/overview/#p_72",
    "pt": "Overview",
    "t": 3,
    "c": "Then, we just run:"
  },
  {
    "objectID": "/tut/overview/#p_73",
    "pt": "Overview",
    "t": 3,
    "c": "And then Reach"
  },
  {
    "objectID": "/tut/overview/#p_74",
    "pt": "Overview",
    "t": 3,
    "c": "compiles overview/index.rsh;"
  },
  {
    "objectID": "/tut/overview/#p_75",
    "pt": "Overview",
    "t": 3,
    "c": "creates a temporary Node.js package;"
  },
  {
    "objectID": "/tut/overview/#p_76",
    "pt": "Overview",
    "t": 3,
    "c": "builds a Docker image based on Reach's standard image for the package; and,"
  },
  {
    "objectID": "/tut/overview/#p_77",
    "pt": "Overview",
    "t": 3,
    "c": "runs the application connected to the specified consensus network's devnet image."
  },
  {
    "objectID": "/tut/overview/#p_78",
    "pt": "Overview",
    "t": 3,
    "c": "On typical developer laptops, this entire process takes seconds and can be completely integrated into existing development IDEs, like VSCode, so Reach developers can compile, verify, build, launch, and test their Reach app with a single command."
  },
  {
    "objectID": "/tut/overview/#p_79",
    "pt": "Overview",
    "t": 3,
    "c": "Reach completely abstracts all the details of building and maintaining consensus network test environments and build scripts from the programmer, so they can focus exclusively on the business logic of their application. In fact, Reach works for multiple networks, so if we instead run"
  },
  {
    "objectID": "/tut/overview/#p_80",
    "pt": "Overview",
    "t": 3,
    "c": "then Reach will start up a private Algorand devnet and use the Algorand connector. The developer does not need to change anything about their program because Reach is entirely agnostic to the consensus network choice during deployment."
  },
  {
    "objectID": "/tut/overview/#p_81",
    "pt": "Overview",
    "t": 3,
    "c": "The same goes for Conflux:"
  },
  {
    "objectID": "/tut/overview/#p_82",
    "pt": "Overview",
    "t": 3,
    "c": "You can watch a 7-minute video on YouTube which demonstrates this section's code in action and provides a brief explanation of how it works."
  },
  {
    "objectID": "/tut/overview/#p_83",
    "pt": "Overview",
    "t": 3,
    "c": "The previous section uses Node.js to perform a test run at the command line. However, most Reach developers deploy their DApps via a Web application, as we describe below."
  },
  {
    "objectID": "/tut/overview/#p_84",
    "pt": "Overview",
    "t": 3,
    "c": "A Web deployment uses the exact same index.rsh file connected, this time, to a React-based index.js file. (It also uses some simple React views and css to go with it.) Let's take a look at some snippets from the React index.js and compare with the Node.js index.mjs from before:"
  },
  {
    "objectID": "/tut/overview/#p_85",
    "pt": "Overview",
    "t": 3,
    "c": "At the top of the file, we import the Reach-generated backend as {!js} backend and we load the standard library as {!js} reach."
  },
  {
    "objectID": "/tut/overview/#p_86",
    "pt": "Overview",
    "t": 3,
    "c": "We hook into the App component's lifecycle event {!js} componentDidMount in order to fetch the user's account. {!js} getDefaultAccount automatically interacts with browser extensions, like MetaMask, to get the user's currently-selected account. Reach is able to deploy contracts and send transactions to the consensus network by prompting the user directly through the extension's API, without additional assistance from the React frontend. This is just like how in the Node.js deployment, the Reach programmer does not need to decode the details of the underlying consensus network's interaction API."
  },
  {
    "objectID": "/tut/overview/#p_87",
    "pt": "Overview",
    "t": 3,
    "c": "Our React component has a method called {!js} deploy that actually deploys the contract on the network, using the same calls as in the test deployment: on line 72 we call the {!js} acc.deploy function, and on line 74, we call the {!js} ctc.getInfo function; exactly as we did for the Node.js program."
  },
  {
    "objectID": "/tut/overview/#p_88",
    "pt": "Overview",
    "t": 3,
    "c": "Similarly, we implement a {!js} runBackend method that executes the Reach program as Alice using information gathered from the React UI."
  },
  {
    "objectID": "/tut/overview/#p_89",
    "pt": "Overview",
    "t": 3,
    "c": "We implement a similar method in the {!js} Bob component that runs the backend as Bob."
  },
  {
    "objectID": "/tut/overview/#p_90",
    "pt": "Overview",
    "t": 3,
    "c": "We specify Alice's and Bob's respective participant interact interfaces just as we would in Node.js. In the React program, we have the ability to leverage Bob's {!rsh} interact functions as callbacks that can update the React state in order to display to, or harvest information from, the React user interface."
  },
  {
    "objectID": "/tut/overview/#p_91",
    "pt": "Overview",
    "t": 3,
    "c": "You can install the @reachsh/stdlib JavaScript library into your React project, or for convenience, instead of setting up a React project, you can simply use the command"
  },
  {
    "objectID": "/tut/overview/#p_92",
    "pt": "Overview",
    "t": 3,
    "c": "This command runs your DApp with the React development server in a Docker container which has Reach and React JavaScript dependencies pre-installed, so it starts up much faster than building them yourself."
  },
  {
    "objectID": "/tut/overview/#p_93",
    "pt": "Overview",
    "t": 3,
    "c": "As before, you can use REACH_CONNECTOR_MODE to choose your desired connector."
  },
  {
    "objectID": "/tut/overview/#p_94",
    "pt": "Overview",
    "t": 3,
    "c": "In this overview, we've briefly described the structure and fundamental concepts of a Reach application. We've shown how to construct a simple program, compile it, connect an interface, test at the command-line, and deploy it using a React Web application. Since this is only a brief overview of what Reach can do, we left a lot out. But even so, it should be clear why Reach is the easiest and safest programming language for decentralized application development."
  },
  {
    "objectID": "/tut/overview/#p_95",
    "pt": "Overview",
    "t": 3,
    "c": "Furthermore, this example program has many flaws and should not be used in practice. For example, it provides no protection to Bob in the event that Alice fails to deliver the information, and makes no attempt to ensure that the information is what he wants. Reach allows you to abstract away the low-level details of your decentralized program and focus on these sorts of bigger picture issues. In the rest of the guide, we discuss design issues like this. For example,"
  },
  {
    "objectID": "/tut/overview/#p_96",
    "pt": "Overview",
    "t": 3,
    "c": "Effectively using automatic verification to check your application;"
  },
  {
    "objectID": "/tut/overview/#p_97",
    "pt": "Overview",
    "t": 3,
    "c": "Fortifying your application against non-participation;"
  },
  {
    "objectID": "/tut/overview/#p_98",
    "pt": "Overview",
    "t": 3,
    "c": "Building interaction abstractions for related applications."
  },
  {
    "objectID": "/tut/overview/#p_99",
    "pt": "Overview",
    "t": 3,
    "c": "However, unless you're ready to dive deep now, the next steps for you are to:"
  },
  {
    "objectID": "/tut/overview/#p_100",
    "pt": "Overview",
    "t": 3,
    "c": "Install Reach;"
  },
  {
    "objectID": "/tut/overview/#p_101",
    "pt": "Overview",
    "t": 3,
    "c": "Work through the tutorial;"
  },
  {
    "objectID": "/tut/overview/#p_102",
    "pt": "Overview",
    "t": 3,
    "c": "Join the Discord community."
  },
  {
    "objectID": "/tut/overview/#p_103",
    "pt": "Overview",
    "t": 3,
    "c": "Thanks for being part of Reach!"
  },
  {
    "objectID": "/tut/rps/#tut",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Rock, Paper, Scissors!"
  },
  {
    "objectID": "/tut/rps/#tut-1",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Install and Initialize"
  },
  {
    "objectID": "/tut/rps/#tut-2",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Scaffolding and Setup"
  },
  {
    "objectID": "/tut/rps/#tut-3",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Rock, Paper, and Scissors"
  },
  {
    "objectID": "/tut/rps/#tut-4",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Bets and Wagers"
  },
  {
    "objectID": "/tut/rps/#tut-5",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Trust and Commitments"
  },
  {
    "objectID": "/tut/rps/#tut-6",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Timeouts and Participation"
  },
  {
    "objectID": "/tut/rps/#tut-7",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Play and Play Again"
  },
  {
    "objectID": "/tut/rps/#tut-8",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Interaction and Independence"
  },
  {
    "objectID": "/tut/rps/#tut-9",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Web Interaction"
  },
  {
    "objectID": "/tut/rps/#tut-9-App",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Application component"
  },
  {
    "objectID": "/tut/rps/#tut-9-ConnectAccount",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Connect Account dialog"
  },
  {
    "objectID": "/tut/rps/#tut-9-FundAccount",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Fund Account dialog"
  },
  {
    "objectID": "/tut/rps/#tut-9-DeployerOrAttacher",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Choose Role"
  },
  {
    "objectID": "/tut/rps/#tut-9-Player",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Player component"
  },
  {
    "objectID": "/tut/rps/#tut-9-GetHand",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Get Hand dialog"
  },
  {
    "objectID": "/tut/rps/#tut-9-WaitingForResults",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Waiting for results display"
  },
  {
    "objectID": "/tut/rps/#tut-9-Done",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Done display"
  },
  {
    "objectID": "/tut/rps/#tut-9-Timeout",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Timeout display"
  },
  {
    "objectID": "/tut/rps/#tut-9-Deployer",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Deployer component"
  },
  {
    "objectID": "/tut/rps/#tut-9-SetWager",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Set Wager dialog"
  },
  {
    "objectID": "/tut/rps/#tut-9-Deploy",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Deploy dialog"
  },
  {
    "objectID": "/tut/rps/#tut-9-Deploying",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Deploying display"
  },
  {
    "objectID": "/tut/rps/#tut-9-WaitingForAttacher",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Waiting for Attacher display"
  },
  {
    "objectID": "/tut/rps/#tut-9-Attacher",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Attacher component"
  },
  {
    "objectID": "/tut/rps/#tut-9-Attach",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Attach dialog"
  },
  {
    "objectID": "/tut/rps/#tut-9-Attaching",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Attaching display"
  },
  {
    "objectID": "/tut/rps/#tut-9-AcceptTerms",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Accept Terms dialog"
  },
  {
    "objectID": "/tut/rps/#tut-9-WaitingForTurn",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Waiting for Turn display"
  },
  {
    "objectID": "/tut/rps/#tut-9-Final",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Putting it all together"
  },
  {
    "objectID": "/tut/rps/#tut-10",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Onward and Further"
  },
  {
    "objectID": "/tut/rps/#p_0",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "This tutorial walks through the creation of a simple decentralized application. It contains everything you need to know to build and test this application and assumes no prior experience with DApp/blockchain development of any kind. If you want a broad overview before diving in it, we recommend reading the overview first. On the other hand, if this is too simple, then you may want to start the workshop for larger and less constrained projects or the reference manual for the minute details of Reach."
  },
  {
    "objectID": "/tut/rps/#p_1",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If you're ready, click through to the first step!"
  },
  {
    "objectID": "/tut/rps/#p_2",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Reach is designed to work on POSIX systems with make, Docker, and Docker Compose installed. The best way to install Docker on Mac and Windows is with Docker Desktop."
  },
  {
    "objectID": "/tut/rps/#p_3",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "You probably already have make installed. For example, OS X and many other POSIX systems come with make, but some versions of Linux do not include it by default and will require you to install it. If you're on Ubuntu, you can run sudo apt install make to get it."
  },
  {
    "objectID": "/tut/rps/#p_4",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "You'll know that you have everything installed if you can run the following three commands without errors"
  },
  {
    "objectID": "/tut/rps/#p_5",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If you're using Windows, consult the guide to using Reach on Windows."
  },
  {
    "objectID": "/tut/rps/#p_6",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Once you've confirmed that they are installed, choose a directory for this project. We recommend"
  },
  {
    "objectID": "/tut/rps/#p_7",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next, download Reach by running"
  },
  {
    "objectID": "/tut/rps/#p_8",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "You'll know that the download worked if you can run"
  },
  {
    "objectID": "/tut/rps/#p_9",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The recommended next step, although optional, is to set up your environment with"
  },
  {
    "objectID": "/tut/rps/#p_10",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "This will make subsequent uses of the reach script more convenient by tuning its runtime behavior to your specific needs and only downloading the dependencies you'll actually use."
  },
  {
    "objectID": "/tut/rps/#p_11",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "{!cmd} reach config sets overridable defaults for all Reach projects on your development machine and not just the current one, so feel free to skip this step if you'd prefer not to make your choices global."
  },
  {
    "objectID": "/tut/rps/#p_12",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Since Reach is Dockerized, when you first use it, you'll need to download the images it uses. Fetch them by running"
  },
  {
    "objectID": "/tut/rps/#p_13",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "You'll know that everything is in order if you can run"
  },
  {
    "objectID": "/tut/rps/#p_14",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Get language support for Reach in your editor by visiting IDE/Text Editor Support."
  },
  {
    "objectID": "/tut/rps/#p_15",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Now that your Reach installation is in order, you should open a text editor and get ready to write your first Reach application!"
  },
  {
    "objectID": "/tut/rps/#p_16",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In this tutorial, we'll be building a version of Rock, Paper, Scissors! where two players, Alice and Bob, can wager on the result of the game. We'll start simple and slowly make the application more fully-featured."
  },
  {
    "objectID": "/tut/rps/#p_17",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "You should follow along by copying each part of the program and seeing how things go. If you're like us, you may find it beneficial to type each line out, rather than copying & pasting so you can start building your muscle memory and begin to get a sense for each part of a Reach program."
  },
  {
    "objectID": "/tut/rps/#p_18",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Let's start by creating a file named index.rsh. It doesn't matter where you put this file, but we recommend putting it in the current directory, which would be ~/reach/tut if you're following along exactly. In all the subsequent code samples, we'll label the files based on the chapter of the tutorial you're reading. For example, start off by typing the following into index.rsh:"
  },
  {
    "objectID": "/tut/rps/#p_19",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Did you notice that rps-1-setup/index.rsh was a link in the box above the code sample? You can always click on these links to see the entire file in our GitHub repository."
  },
  {
    "objectID": "/tut/rps/#p_20",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Did you notice the attractive copy icon on the top the right of that box? You can click on it and the content of the code box will be copied onto your clipboard."
  },
  {
    "objectID": "/tut/rps/#p_21",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Did your text editor recognize index.rsh as a Reach program and give you proper syntax highlighting? If not, check if there's a plugin available for your editor by visiting IDE/Text Editor Support or manually configure it to treat Reach (.rsh) files as JavaScript and things will be mostly correct."
  },
  {
    "objectID": "/tut/rps/#p_22",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "This is just a shell of a program that doesn't do much, but it has a few important components."
  },
  {
    "objectID": "/tut/rps/#p_23",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 1 indicates that this is a Reach program. You'll always have this at the top of every program."
  },
  {
    "objectID": "/tut/rps/#p_24",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 3 defines the main export from the program. When you compile, this is what the compiler will look at."
  },
  {
    "objectID": "/tut/rps/#p_25",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 4 through 9 specify the two participants to this application, Alice and Bob."
  },
  {
    "objectID": "/tut/rps/#p_26",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 10 marks the deployment of the the Reach program, which allows the program to start doing things."
  },
  {
    "objectID": "/tut/rps/#p_27",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Before we go too much further, let's create a similar shell for our JavaScript frontend code. Open a new file named index.mjs and fill it with this:"
  },
  {
    "objectID": "/tut/rps/#p_28",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "This JavaScript code is similarly schematic and will be consistent across all of your test programs."
  },
  {
    "objectID": "/tut/rps/#p_29",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 1 imports the Reach standard library loader."
  },
  {
    "objectID": "/tut/rps/#p_30",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 2 imports your backend, which ./reach compile will produce."
  },
  {
    "objectID": "/tut/rps/#p_31",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 3 loads the standard library dynamically based on the REACH_CONNECTOR_MODE environment variable."
  },
  {
    "objectID": "/tut/rps/#p_32",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 5 defines a quantity of network tokens as the starting balance for each test account."
  },
  {
    "objectID": "/tut/rps/#p_33",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 6 and 7 create test accounts with initial endowments for Alice and Bob. This will only work on the Reach-provided developer testing network."
  },
  {
    "objectID": "/tut/rps/#p_34",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 9 has Alice deploy the application."
  },
  {
    "objectID": "/tut/rps/#p_35",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The program defined in rps-1-setup/index.rsh will only begin to run after it has been deployed via rps-1-setup/index.mjs."
  },
  {
    "objectID": "/tut/rps/#p_36",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 10 has Bob attach to it."
  },
  {
    "objectID": "/tut/rps/#p_37",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 13 through 15 initialize a backend for Alice."
  },
  {
    "objectID": "/tut/rps/#p_38",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 16 through 18 initialize a backend for Bob."
  },
  {
    "objectID": "/tut/rps/#p_39",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 12 waits for the backends to complete."
  },
  {
    "objectID": "/tut/rps/#p_40",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "This is now enough for Reach to compile and run our program. Let's try by running"
  },
  {
    "objectID": "/tut/rps/#p_41",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Reach should now build and launch a Docker container for this application. Since the application doesn't do anything, you'll just see a lot of diagnostic messages though, so that's not very exciting."
  },
  {
    "objectID": "/tut/rps/#p_42",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The entire process that we just went through can be automated by running"
  },
  {
    "objectID": "/tut/rps/#p_43",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "when you start your next project!"
  },
  {
    "objectID": "/tut/rps/#p_44",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In the next step, we'll implement the logic of Rock, Paper, Scissors! and our application will start doing something!"
  },
  {
    "objectID": "/tut/rps/#p_45",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "When you write a DApp using Reach, do you"
  },
  {
    "objectID": "/tut/rps/#p_46",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "write a smart contract in Solidity, a backend in JavaScript using the Ethereum SDK, and a frontend in JavaScript, then use Reach to test and deploy it;"
  },
  {
    "objectID": "/tut/rps/#p_47",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "write a program in Reach that generates a smart contract & a backend and a front-end in JavaScript, then use Reach to test and deploy it?"
  },
  {
    "objectID": "/tut/rps/#p_48",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "2; Reach abstracts away the details of the underlying consensus network"
  },
  {
    "objectID": "/tut/rps/#p_49",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In this section, we'll have Alice and Bob actually execute the game of Rock, Paper, Scissors!."
  },
  {
    "objectID": "/tut/rps/#p_50",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We have to decide how to represent the hands of the game. A simple way is to represent them as the numbers {!rsh} 0, {!rsh} 1, and {!rsh} 2, standing for Rock, Paper, and Scissors. However, Reach does not support unsigned integers of exactly two bits, so it is better to represent them as the equivalence class of integers modulo three, so we won't distinguish between {!rsh} 0 and {!rsh} 3 as Rock."
  },
  {
    "objectID": "/tut/rps/#p_51",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We'll use a similar strategy for representing the three outcomes of the game: B wins, Draw, and A wins."
  },
  {
    "objectID": "/tut/rps/#p_52",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The first step is to change the Reach program to specify that Alice and Bob's frontends can be interacted with to get the move that they will play, and later informed of the outcome of the game."
  },
  {
    "objectID": "/tut/rps/#p_53",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 3 through 6 define a participant interact interface that will be shared between the two players. In this case, it provides two methods: {!rsh} getHand, which returns a number; and {!rsh} seeOutcome, which receives a number."
  },
  {
    "objectID": "/tut/rps/#p_54",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 9 through 14 use this interface for both participants. Because of this line, {!rsh} interact in the rest of the program will be bound to an object with methods corresponding to these actions, which will connect to the frontend of the corresponding participant."
  },
  {
    "objectID": "/tut/rps/#p_55",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Before continuing with the Reach application, let's move over to the JavaScript interface and implement these methods in our frontend."
  },
  {
    "objectID": "/tut/rps/#p_56",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 12 and 13 define arrays to hold the meaning of the hands and outcomes."
  },
  {
    "objectID": "/tut/rps/#p_57",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 14 defines a constructor for the {!js} Player implementation."
  },
  {
    "objectID": "/tut/rps/#p_58",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 15 through 19 implement the {!js} getHand method."
  },
  {
    "objectID": "/tut/rps/#p_59",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 20 through 22 implement the {!js} seeOutcome method."
  },
  {
    "objectID": "/tut/rps/#p_60",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Finally, lines 27 and 30 instantiate the implementation once for Alice and once for Bob. These are the actual objects that will be bound to {!rsh} interact in the Reach program."
  },
  {
    "objectID": "/tut/rps/#p_61",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "There should be nothing interesting or controversial about these implementations; that's the point of Reach: we get to just write normal business logic without worrying about the details of the consensus network and decentralized application."
  },
  {
    "objectID": "/tut/rps/#p_62",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Let's return to the Reach program and look inside of the body of the program for what actions Alice and Bob take."
  },
  {
    "objectID": "/tut/rps/#p_63",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In a real-life game of Rock, Paper, Scissors!, Alice and Bob simultaneously decide what hand they will play and reveal it at the same time. \"Simultaneity\" is a complex concept that is hard to realize in practice. For example, if you've ever played against a little kid, you may notice them trying to see what you're going to choose and delaying until the last minute to show their hand so they will win. In a decentralized application, it is not possible to have simultaneity. Instead, we have to select a particular participant who will \"go first\". In this case, we'll choose Alice."
  },
  {
    "objectID": "/tut/rps/#p_64",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Does Alice go first, or do we call the player that goes first \"Alice\"? This might seem like an unnecessary distinction to make, but it is a very subtle point about the way that Reach works. In our frontend, we explicitly ran {!rsh} backend.Alice and {!rsh} backend.Bob. When we did that, we were committing that particular JavaScript thread to be either Alice or Bob. In our game, whoever chose to run the Alice backend is the one that will go first. In other words, Alice goes first. This will be more obvious at the end of the tutorial when we'll make the choice interactively about which role to play."
  },
  {
    "objectID": "/tut/rps/#p_65",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The game proceeds in three steps."
  },
  {
    "objectID": "/tut/rps/#p_66",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "First, the backend for Alice interacts with its frontend, gets Alice's hand, and publishes it."
  },
  {
    "objectID": "/tut/rps/#p_67",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 17 states that this block of code is something that only {!rsh} Alice performs."
  },
  {
    "objectID": "/tut/rps/#p_68",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "That means that the variable, {!rsh} handAlice, bound on line 18 is known only to Alice."
  },
  {
    "objectID": "/tut/rps/#p_69",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 18 binds that value to the result of interacting with Alice through the {!rsh} getHand method, which we wrote in JavaScript."
  },
  {
    "objectID": "/tut/rps/#p_70",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 18 also declassifies the value, because in Reach, all information from frontends is secret until it is explicitly made public."
  },
  {
    "objectID": "/tut/rps/#p_71",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 20 has Alice join the application by publishing the value to the consensus network, so it can be used to evaluate the outcome of the game. Once this happens, the code is in a \"consensus step\" where all participants act together."
  },
  {
    "objectID": "/tut/rps/#p_72",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 21 commits the state of the consensus network and returns to \"local step\" where individual participants can act alone."
  },
  {
    "objectID": "/tut/rps/#p_73",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The next step is similar, in that Bob publishes his hand; however, we don't immediately commit the state, instead we compute the outcome of the game."
  },
  {
    "objectID": "/tut/rps/#p_74",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 23 through 26 match Alice's similar local step and joining of the application through a consensus transfer publication."
  },
  {
    "objectID": "/tut/rps/#p_75",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "But, line 28 computes the outcome of the game before committing. ({!rsh} (handAlice + (4 - handBob)) % 3 is a clever equation to compute the winner of a game of Rock, Paper, Scissors! using modular arithmetic. Consider when {!rsh} handAlice is {!rsh} 0 (i.e., Rock) and {!rsh} handBob is {!rsh} 2 (i.e., Scissors), then this equation is {!rsh} ((handAlice + (4 - handBob)) % 3) = ((0 + (4 - 2)) % 3) = ((0 + 2) % 3) = (2 % 3) = 2, which is the last outcome, that is Alice wins, as we expect it to be.)"
  },
  {
    "objectID": "/tut/rps/#p_76",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Finally, we use the each form to have each of the participants send the final outcome to their frontends."
  },
  {
    "objectID": "/tut/rps/#p_77",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 31 states that this is a local step that each of the participants performs."
  },
  {
    "objectID": "/tut/rps/#p_78",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "At this point, we can run the program and see its output by running"
  },
  {
    "objectID": "/tut/rps/#p_79",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Since the players act randomly, the results will be different every time. When I ran the program three times, this is the output I got:"
  },
  {
    "objectID": "/tut/rps/#p_80",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Alice is pretty good at Rock, Paper, Scissors!!"
  },
  {
    "objectID": "/tut/rps/#p_81",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Consensus networks in general, and Reach specifically, guarantee that all participants agree on the outcome of their decentralized computation. Indeed, this is where the name consensus network comes from, as they enable these distributed, and untrusted, parties to come to a consensus, or agreement, about the intermediate states of a computation; and if they agree on the intermediate states, they will also agree on the output. That's why every time you run ./reach run, both Alice and Bob will see the same outcome!"
  },
  {
    "objectID": "/tut/rps/#p_82",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If your version isn't working, look at the complete versions of rps-2-rps/index.rsh and rps-2-rps/index.mjs to make sure you copied everything down correctly!"
  },
  {
    "objectID": "/tut/rps/#p_83",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In the next step, we'll add some stakes to the game, because Alice needs to take her skills to the bank!"
  },
  {
    "objectID": "/tut/rps/#p_84",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Reach programs allow interaction with a user interface through which of the following methods?"
  },
  {
    "objectID": "/tut/rps/#p_85",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "by forcing you to write a custom backend for the user interface that connects to the generated smart contract,"
  },
  {
    "objectID": "/tut/rps/#p_86",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "by allowing the frontends to provide values directly to the Reach application,"
  },
  {
    "objectID": "/tut/rps/#p_87",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "by allowing the Reach program to callback to the frontend via the interact object."
  },
  {
    "objectID": "/tut/rps/#p_88",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "2 and 3; Reach programs specify a two-way interface between the frontend and the backend via the participant interact interface."
  },
  {
    "objectID": "/tut/rps/#p_89",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "How do participants in a Reach application share information with each other and find out what others have shared?"
  },
  {
    "objectID": "/tut/rps/#p_90",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Reach generates a smart contract, but you need to implement a process to scan the blockchain for events that correspond to sharing;"
  },
  {
    "objectID": "/tut/rps/#p_91",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The Reach primitive {!rsh} publish allows a participant to share information with all other participants, which happens automatically without the other parties needing to do anything special;"
  },
  {
    "objectID": "/tut/rps/#p_92",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The Reach primitive {!rsh} publish allows a participant to share information with all other participants, but they need to explicitly run the receive primitive to receive published information."
  },
  {
    "objectID": "/tut/rps/#p_93",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "2; the {!rsh} publish primitive does everything for you."
  },
  {
    "objectID": "/tut/rps/#p_94",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Although it's fun to play Rock, Paper, Scissors! with friends for a laugh, it's even better to play it with enemies and your entire life-savings on the line! Let's change our program so that Alice can offer a wager to Bob and whoever wins will take the pot."
  },
  {
    "objectID": "/tut/rps/#p_95",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "This time, let's start with changes to the JavaScript frontend and then we'll go back into the Reach code and connect the new methods up."
  },
  {
    "objectID": "/tut/rps/#p_96",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Since we're going to be having funds get transferred, we'll record the balances of each participant before the game starts, so we can more clearly show what they won at the end. We'll add this code in between account creation and contract deployment."
  },
  {
    "objectID": "/tut/rps/#p_97",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 9 shows a helpful function for displaying currency amounts with up to 4 decimal places."
  },
  {
    "objectID": "/tut/rps/#p_98",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 10 shows a helpful function for getting the balance of a participant and displaying it with up to 4 decimal places."
  },
  {
    "objectID": "/tut/rps/#p_99",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 11 and 12 get the balance before the game starts for both Alice and Bob."
  },
  {
    "objectID": "/tut/rps/#p_100",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next, we'll update Alice's interface object to include her wager."
  },
  {
    "objectID": "/tut/rps/#p_101",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 32 splices the common {!js} Player interface into Alice's interface."
  },
  {
    "objectID": "/tut/rps/#p_102",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 33 defines her wager as 5 units of the network token. This is an example of using a concrete value, rather than a function, in a participant interact interface."
  },
  {
    "objectID": "/tut/rps/#p_103",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "For Bob, we'll modify his interface to show the wager and immediately accept it by returning."
  },
  {
    "objectID": "/tut/rps/#p_104",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 37 through 39 define the {!js} acceptWager function."
  },
  {
    "objectID": "/tut/rps/#p_105",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Finally, after the computation is over, we'll get the balance again and show a message summarizing the effect."
  },
  {
    "objectID": "/tut/rps/#p_106",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 44 and 45 get the balances afterwards."
  },
  {
    "objectID": "/tut/rps/#p_107",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 47 and 48 print out the effect."
  },
  {
    "objectID": "/tut/rps/#p_108",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "These changes to the frontend only deal with issues of presentation and interfacing. The actual business logic of making the wager and transferring the funds will happen in the Reach code."
  },
  {
    "objectID": "/tut/rps/#p_109",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Let's look at that now."
  },
  {
    "objectID": "/tut/rps/#p_110",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "First, we need to update the participant interact interface."
  },
  {
    "objectID": "/tut/rps/#p_111",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 9 through 12 define Alice's interface as the {!rsh} Player interface, plus an integer value called {!rsh} wager."
  },
  {
    "objectID": "/tut/rps/#p_112",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 13 through 16 do the same for Bob, where he has a method called {!rsh} acceptWager that can look at the wager value."
  },
  {
    "objectID": "/tut/rps/#p_113",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Each of the three parts of the application have to be updated to deal with the wager. Let's look at Alice's first step first."
  },
  {
    "objectID": "/tut/rps/#p_114",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 20 has Alice declassify the wager for transmission."
  },
  {
    "objectID": "/tut/rps/#p_115",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 23 is updated so that Alice shares the wager amount with Bob."
  },
  {
    "objectID": "/tut/rps/#p_116",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 24 has her transfer the amount as part of her publication. The Reach compiler would throw an exception if {!rsh} wager did not appear on line 23, but did appear on line 24. Change the program and try it. This is because the consensus network needs to be able to verify that the amount of network tokens included in Alice's publication match some computation available to consensus network."
  },
  {
    "objectID": "/tut/rps/#p_117",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next, Bob needs to be shown the wager and given the opportunity to accept it and transfer his funds."
  },
  {
    "objectID": "/tut/rps/#p_118",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 28 has Bob accept the wager. If he doesn't like the terms, his frontend can just not respond to this method and the DApp will stall."
  },
  {
    "objectID": "/tut/rps/#p_119",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 32 has Bob pay the wager as well."
  },
  {
    "objectID": "/tut/rps/#p_120",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The DApp is now running in a consensus step and the contract itself now holds twice the wager amount. Before, it would compute the outcome and then commit the state; but now, it needs to look at the outcome and use it to balance the account."
  },
  {
    "objectID": "/tut/rps/#p_121",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 35 through 38 compute the amounts given to each participant depending on the outcome by determining how many {!rsh} wager amounts each party gets. If the outcome is {!rsh} 2, Alice wins, then she gets two portions; while if it is {!rsh} 0, Bob wins, then he gets two portions; otherwise they each get one portion."
  },
  {
    "objectID": "/tut/rps/#p_122",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 39 and 40 transfer the corresponding amounts. This transfer takes place from the contract to the participants, not from the participants to each other, because all of the funds reside inside of the contract."
  },
  {
    "objectID": "/tut/rps/#p_123",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 41 commits the state of the application and allows the participants to see the outcome and complete."
  },
  {
    "objectID": "/tut/rps/#p_124",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "At this point, we can run the program and see its output by running"
  },
  {
    "objectID": "/tut/rps/#p_125",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Since the players act randomly, the results will be different every time. When I ran the program three times, this is the output I got:"
  },
  {
    "objectID": "/tut/rps/#p_126",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "How come Alice and Bob's balances go back to 100 every time? It's because each time we run ./reach run, it creates fresh accounts for both players."
  },
  {
    "objectID": "/tut/rps/#p_127",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "How come the balances aren't exactly 100, 105, and 95? It's because consensus network charge fees to run transactions."
  },
  {
    "objectID": "/tut/rps/#p_128",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If we had shown all the decimals, they'd look like this:"
  },
  {
    "objectID": "/tut/rps/#p_129",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Why does Alice win slightly less than Bob when she wins? She has to pay to deploy the contract, because she publishes the first message in her frontend."
  },
  {
    "objectID": "/tut/rps/#p_130",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Alice is doing okay - if she keeps this up, she'll make a fortune on Rock, Paper, Scissors!!"
  },
  {
    "objectID": "/tut/rps/#p_131",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If your version isn't working, look at the complete versions of rps-3-bets/index.rsh and rps-3-bets/index.mjs to make sure you copied everything down correctly!"
  },
  {
    "objectID": "/tut/rps/#p_132",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Now that there is a reason to play this game, it turns out that there's a major security vulnerability. We'll fix this in the next step; make sure you don't launch with this version, or Alice is going to go broke!"
  },
  {
    "objectID": "/tut/rps/#p_133",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "How do Reach programs manage token funds?"
  },
  {
    "objectID": "/tut/rps/#p_134",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "They don’t; you need to manage them explicitly in parallel to the Reach program;"
  },
  {
    "objectID": "/tut/rps/#p_135",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The {!rsh} pay primitive can be added to a {!rsh} publish primitive to send funds to the Reach program, which can then use the {!rsh} transfer primitive to send funds back to participants, and other addresses."
  },
  {
    "objectID": "/tut/rps/#p_136",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "2; the {!rsh} pay and {!rsh} transfer primitives do everything for you."
  },
  {
    "objectID": "/tut/rps/#p_137",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In the last section, we made it so that Alice and Bob can actually exchange currency when they play Rock, Paper, Scissors!. However, the version of the application we wrote has a fundamental flaw: Bob can win every game!"
  },
  {
    "objectID": "/tut/rps/#p_138",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "How is that possible? We showed executions of the game where Alice won, like the following"
  },
  {
    "objectID": "/tut/rps/#p_139",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The problem is that this version of the game only executed an honest version of Bob, that is, one that followed the Reach program exactly, including in his private local steps. It is possible for a deviant and dishonest version of a Bob backend to execute different code and always win by computing the appropriate guess based on what value Alice provided for {!rsh} handAlice."
  },
  {
    "objectID": "/tut/rps/#p_140",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If we change Bob's code to the following:"
  },
  {
    "objectID": "/tut/rps/#p_141",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "then he will ignore the frontend and just compute the correct value."
  },
  {
    "objectID": "/tut/rps/#p_142",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If we run this version of the program, we will see output like this:"
  },
  {
    "objectID": "/tut/rps/#p_143",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In this version, unlike the honest version, Bob never consults the frontend and so it never prints out the message of what hand Bob played. No matter what Alice chooses, Bob will always win."
  },
  {
    "objectID": "/tut/rps/#p_144",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Is it just a fluke of the random number generator that we observed Bob always winning? How would we know? Reach comes with an automatic verification engine that we can use to mathematically prove that this version will always result in the {!rsh} outcome variable equalling {!rsh} 0, which means Bob wins. We can instruct Reach to prove this theorem by adding these lines after computing the {!rsh} outcome:"
  },
  {
    "objectID": "/tut/rps/#p_145",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 35 requires that the dishonest version of Bob be used for the proof."
  },
  {
    "objectID": "/tut/rps/#p_146",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 36 conducts the proof by including an assert statement in the program."
  },
  {
    "objectID": "/tut/rps/#p_147",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Before we had this line in the file, when we ran ./reach compile, it would print out the message:"
  },
  {
    "objectID": "/tut/rps/#p_148",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "But now, it prints out"
  },
  {
    "objectID": "/tut/rps/#p_149",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 7 is different and shows that more theorems have been proven about our program. It prints out five more, rather than one more, because the theorem is proved differently in the different verification modes."
  },
  {
    "objectID": "/tut/rps/#p_150",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Many programming languages include assertions like this, but Reach is one of a small category where the compiler doesn't just insert a runtime check for the property, but actually conducts a mathematical proof at compile-time that the expression always evaluates to {!rsh} true."
  },
  {
    "objectID": "/tut/rps/#p_151",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In this case, we used Reach's automatic verification engine to prove that an attack did what we expected it would. But, it is better to use verification to show that no flaw exists and no attack is possible."
  },
  {
    "objectID": "/tut/rps/#p_152",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Reach includes some such assertions automatically in every program. That's why every version of Rock, Paper, Scissors! has said that a number of theorems were checked. We can see what these theorems do by deliberately inserting an error into the program."
  },
  {
    "objectID": "/tut/rps/#p_153",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Let's start by undoing the changes we made earlier by changing"
  },
  {
    "objectID": "/tut/rps/#p_154",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "back to"
  },
  {
    "objectID": "/tut/rps/#p_155",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "and removing"
  },
  {
    "objectID": "/tut/rps/#p_156",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Let's change the computation of the payout and make it so that if Alice wins, then she only gets her wager back, not Bob's."
  },
  {
    "objectID": "/tut/rps/#p_157",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We should now have something that looks like"
  },
  {
    "objectID": "/tut/rps/#p_158",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 36 has {!rsh} [1, 0], but should have {!rsh} [2, 0]."
  },
  {
    "objectID": "/tut/rps/#p_159",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "When we run ./reach compile (reachexlink rps-4-attack/index-bad.rsh), it gives details about the error:"
  },
  {
    "objectID": "/tut/rps/#p_160",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "There's a lot of information in the compiler output that can help an experienced programmer track down the problem. But the most important parts are"
  },
  {
    "objectID": "/tut/rps/#p_161",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 7 says that this is an attempt to prove the theorem that the balance at the end of the program is zero, which means that no network tokens are sealed in the contract forever."
  },
  {
    "objectID": "/tut/rps/#p_162",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 10-20 describe the values that could cause the theorem to fail."
  },
  {
    "objectID": "/tut/rps/#p_163",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 23-31 outline the theorem that failed."
  },
  {
    "objectID": "/tut/rps/#p_164",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "These kinds of automatic verifications are helpful for Reach programmers, because they don't need to remember to put them in their program, and they will still be protected from entire categories of errors."
  },
  {
    "objectID": "/tut/rps/#p_165",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "However, now let's add an assertion to the program that will ensure that every version of the program that allows Bob to know Alice's hand before he chooses his own will be rejected."
  },
  {
    "objectID": "/tut/rps/#p_166",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We'll go back to the version of rps-3-bets/index.rsh from the last section, which has an honest version of Bob. (Click on the preceding link if you need to see what it contained.)"
  },
  {
    "objectID": "/tut/rps/#p_167",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We'll add a single line to the program after Alice publishes, but before Bob takes a local step:"
  },
  {
    "objectID": "/tut/rps/#p_168",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 27 contains a knowledge assertion that Bob cannot know Alice's value {!rsh} handAlice at this point in the program. In this case, it is obvious that this is not true, because Alice shares {!rsh} handAlice at line 23. In many cases, this is not obvious and Reach's automatic verification engine has to reason about how values that Bob does know are connected to values that might be related to Alice's secret values."
  },
  {
    "objectID": "/tut/rps/#p_169",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "When we run ./reach run, it reports that this assertion is false:"
  },
  {
    "objectID": "/tut/rps/#p_170",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "It is not enough to correct failures and attacks when you discover them. You must always add an assertion to your program that would fail to hold if the attack or failure were present. This ensures that all similar attacks are not present and that they will not accidentally be reintroduced."
  },
  {
    "objectID": "/tut/rps/#p_171",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Let's use these insights into automatic verification and rewrite our Rock, Paper, Scissors! so that it is more trustworthy and secure."
  },
  {
    "objectID": "/tut/rps/#p_172",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Since we've been making lots of changes to the code, let's start fresh with a new version and we'll look at every single line again, to make sure that you aren't missing anything."
  },
  {
    "objectID": "/tut/rps/#p_173",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "First, we'll define the rules of Rock, Paper, Scissors! a little bit more abstractly, so we can separate the logic of the game from the details of the application:"
  },
  {
    "objectID": "/tut/rps/#p_174",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 1 is the usual Reach version header."
  },
  {
    "objectID": "/tut/rps/#p_175",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 3 and 4 define enumerations for the hands that may be played, as well as the outcomes of the game."
  },
  {
    "objectID": "/tut/rps/#p_176",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 6 and 7 define the function that computes the winner of the game."
  },
  {
    "objectID": "/tut/rps/#p_177",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "When we first wrote Rock, Paper, Scissors!, we asked you to trust that this formula for computing the winner is correct, but it is good to actually check. One way to check would be to implement a JavaScript frontend that didn't interact with a real user, nor would it randomly generate values, but instead, it would return specific testing scenario values and check that the output is as expected. That's a typical way to debug and is possible with Reach. However, Reach allows us to write such test cases directly into the Reach program as verification assertions."
  },
  {
    "objectID": "/tut/rps/#p_178",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 9 makes an assertion that when Alice plays Rock and Bob plays Paper, then Bob wins as expected."
  },
  {
    "objectID": "/tut/rps/#p_179",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "But, Reach's automatic verification allows us to express even more powerful statements about our program's behavior. For example, we can state that no matter what values are provided for {!rsh} handAlice and {!rsh} handBob, {!rsh} winner will always provide a valid outcome:"
  },
  {
    "objectID": "/tut/rps/#p_180",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "And we can specify that whenever the same value is provided for both hands, no matter what it is, {!rsh} winner always returns {!rsh} DRAW:"
  },
  {
    "objectID": "/tut/rps/#p_181",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "These examples both use {!rsh} forall, which allows Reach programmers to quantify over all possible values that might be provided to a part of their program. You might think that these theorems will take a very long time to prove, because they have to loop over all the billions and billions of possibilities (e.g., Ethereum uses 256-bits for its unsigned integers) for the bits of {!rsh} handAlice (twice!) and {!rsh} handBob. In fact, on rudimentary laptops, it takes less than half a second. That's because Reach uses an advanced symbolic execution engine to reason about this theorem abstractly without considering individual values."
  },
  {
    "objectID": "/tut/rps/#p_182",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Let's continue the program by specifying the participant interact interfaces for Alice and Bob. These will be mostly the same as before, except that we will also expect that each frontend can provide access to random numbers. We'll use these later on to protect Alice's hand."
  },
  {
    "objectID": "/tut/rps/#p_183",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The only line that is different is line 21, which includes {!rsh} hasRandom, from the Reach standard library, in the interface. We'll use this to generate a random number to protect Alice's hand."
  },
  {
    "objectID": "/tut/rps/#p_184",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Similarly, we only need to modify one line of our JavaScript frontend. Line 20 allows each participant's Reach code to generate random numbers as necessary."
  },
  {
    "objectID": "/tut/rps/#p_185",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "These two changes might look identical, but they mean very different things. The first, line 21 in the Reach program, adds {!rsh} hasRandom to the interface that the backend expects the frontend to provide. The second, line 20 in the JavaScript, adds {!rsh} hasRandom to the implementation that the frontend provides to the backend."
  },
  {
    "objectID": "/tut/rps/#p_186",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next, we'll create the Reach app and the participant interact interface for Alice and Bob. Nothing here is new."
  },
  {
    "objectID": "/tut/rps/#p_187",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We're now at the crucial juncture where we will implement the actual application and ensure that Alice's hand is protected until after Bob reveals his hand. The simplest thing would be to have Alice just publish the wager, but this, of course, would just leave Bob vulnerable. We need Alice to be able to publish her hand, but also keep it secret. This is a job for a cryptographic commitment scheme. Reach's standard library comes with {!rsh} makeCommitment to make this easier for you."
  },
  {
    "objectID": "/tut/rps/#p_188",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 39 has Alice compute her hand, but not declassify it."
  },
  {
    "objectID": "/tut/rps/#p_189",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 40 has her compute a commitment to the hand. It comes with a secret \"salt\" value that must be revealed later. This \"salt\" was generated by the {!rsh} random function inside of {!rsh} hasRandom and it's why we pass {!rsh} interact to this function."
  },
  {
    "objectID": "/tut/rps/#p_190",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 41 has Alice declassify the commitment."
  },
  {
    "objectID": "/tut/rps/#p_191",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 43 has her publish them, and line 44 has her include the wager funds in the publication."
  },
  {
    "objectID": "/tut/rps/#p_192",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "At this point, we can state the knowledge assertion that Bob can't know either the hand or the \"salt\" and continue with his part of the program."
  },
  {
    "objectID": "/tut/rps/#p_193",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "It is important to include the salt in the commitment, so that multiple commitments to the same value are not identical. Similarly, it is important not to share the salt until later, because if an attacker knows the set of possible values, they can enumerate them and compare with the result of the commitment and learn the value. That's why we use a randomly generated salt."
  },
  {
    "objectID": "/tut/rps/#p_194",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 47 states the knowledge assertion."
  },
  {
    "objectID": "/tut/rps/#p_195",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 48 through 53 are unchanged from the original version."
  },
  {
    "objectID": "/tut/rps/#p_196",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 54 has the transaction commit, without computing the payout, because we can't yet, because Alice's hand is not yet public."
  },
  {
    "objectID": "/tut/rps/#p_197",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We now return to Alice who can reveal her secrets."
  },
  {
    "objectID": "/tut/rps/#p_198",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 57 and 58 have Alice declassify the secret information."
  },
  {
    "objectID": "/tut/rps/#p_199",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 60 has her publish it."
  },
  {
    "objectID": "/tut/rps/#p_200",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 61 checks that the published values match the original values. This will always be the case with honest participants, but dishonest participants may violate this assumption."
  },
  {
    "objectID": "/tut/rps/#p_201",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The rest of the program is unchanged from the original version, except that it uses the new names for the outcomes:"
  },
  {
    "objectID": "/tut/rps/#p_202",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Since we didn't have to change the frontend in any meaningful way, the output of running ./reach run is still the same as it ever was:"
  },
  {
    "objectID": "/tut/rps/#p_203",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Except now, behind the scenes, and without any changes to the frontend, Alice takes two steps in our program and Bob only takes one, and she is protected against Bob finding her hand and using it to ensure he wins!"
  },
  {
    "objectID": "/tut/rps/#p_204",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "When we compile this version of the application, Reach's automatic formal verification engine proves many theorems and protects us against a plethora of mistakes one might make when writing even a simple application like this. Non-Reach programmers that try to write decentralized applications are on their own trying to ensure that these problems don't exist."
  },
  {
    "objectID": "/tut/rps/#p_205",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If your version isn't working, look at the complete versions of rps-5-trust/index.rsh and rps-5-trust/index.mjs to make sure you copied everything down correctly!"
  },
  {
    "objectID": "/tut/rps/#p_206",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Now our implementation of Rock, Paper, Scissors! is secure and doesn't contain any exploits for either Alice or Bob to guarantee a win. However, it still has a final category of mistake that is common in decentralized applications: non-participation. We'll fix this in the next step; make sure you don't launch with this version, or Alice may decide to back out of the game when she knows she's going to lose!"
  },
  {
    "objectID": "/tut/rps/#p_207",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Since blockchain programs run on a single, global, publicly-checked and certified consensus network, you don’t need to test them as much as normal software, which run on a wide variety of different platforms and operating systems."
  },
  {
    "objectID": "/tut/rps/#p_208",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "False"
  },
  {
    "objectID": "/tut/rps/#p_209",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "It is easy to write correct programs that handle financial information, and even if you make a mistake, blockchains support an \"Undo\" operation that allows you to rollback to earlier versions of the ledger to correct mistakes and recover lost funds."
  },
  {
    "objectID": "/tut/rps/#p_210",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "False"
  },
  {
    "objectID": "/tut/rps/#p_211",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Reach provides automatic verifications to ensure that your program does not lose, lock away, or overspend funds and guarantees that your applications are free from entire categories of errors."
  },
  {
    "objectID": "/tut/rps/#p_212",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "True"
  },
  {
    "objectID": "/tut/rps/#p_213",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Reach provides tools for you to add custom verifications to your program, like ensuring that information is known only to one party, or that your implementation of a sensitive algorithm is correct."
  },
  {
    "objectID": "/tut/rps/#p_214",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "True"
  },
  {
    "objectID": "/tut/rps/#p_215",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In the last section, we removed a security vulnerability from Rock, Paper, Scissors! that was a clear attack on the viability of the application. In this section, we'll focus on a more subtle issue that is important and unique to decentralized applications: non-participation."
  },
  {
    "objectID": "/tut/rps/#p_216",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Non-participation refers to the act of one party ceasing to continue playing their role in an application."
  },
  {
    "objectID": "/tut/rps/#p_217",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In traditional client-server programs, like a Web server, this would be the case of a client not sending any more requests to the server, or the server stopping sending responses to the client. In these sorts of traditional programs, non-participation is an exceptional circumstance that normally leads to an error message for clients and, at most, a log entry for servers. Sometimes traditional programs will need to recycle resources, like network ports, on non-participation, but they would have also needed to do that if the transaction ended by normal means. In other words, for traditional client-server programs, it is not necessary for designers to meticulously consider the consequences of non-participation."
  },
  {
    "objectID": "/tut/rps/#p_218",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In contrast, decentralized applications must be carefully designed with an eye towards their behavior in the face of non-participation. For example, consider what happens in our Rock, Paper, Scissors! game if after Alice has paid her wager, Bob never accepts and the application doesn't continue. In this case, Alice's network tokens would be locked inside of the contract and lost to her. Similarly, if after Bob accepted and paid his wager, Alice stopped participating and never submitted her hand, then both their funds would be locked away forever. In each of these cases, both parties would be greatly hurt and their fear of that outcome would introduce an additional cost to transacting, which would lower the value they got from participating in the application. Of course, in a situation like Rock, Paper, Scissors! this is unlikely to be an important matter, but recall that Rock, Paper, Scissors! is a microcosm of decentralized application design."
  },
  {
    "objectID": "/tut/rps/#p_219",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Technically, in the first case, when Bob fails to start the application, Alice is not locked away from her funds: since Bob's identity is not fixed until after his first message, she could start another instance of the game as the Bob role and then she'd win all of the funds, less any transaction costs of the consensus network. In the second case, however, there would be no recourse for either party."
  },
  {
    "objectID": "/tut/rps/#p_220",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In the rest of this section, we'll discuss how Reach helps address non-participation. For a longer discussion, refer to the guide chapter on non-participation."
  },
  {
    "objectID": "/tut/rps/#p_221",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In Reach, non-participation is handled through a \"timeout\" mechanism whereby each consensus transfer can be paired with a step that occurs for all participants if the originator of the consensus transfer fails to make the required publication before a particular network time. We'll integrate this mechanism into our version of Rock, Paper, Scissors! and deliberately insert non-participation into our JavaScript testing program to watch the consequences play out."
  },
  {
    "objectID": "/tut/rps/#p_222",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "First, we'll modify the participant interact interface to allow the frontend to be informed that a timeout occurred."
  },
  {
    "objectID": "/tut/rps/#p_223",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 24 introduces a new method, {!rsh} informTimeout, that receives no arguments and returns no information. We'll call this function when a timeout occurs."
  },
  {
    "objectID": "/tut/rps/#p_224",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We'll make a slight tweak to our JavaScript frontend to be able to receive this message and display it on the console."
  },
  {
    "objectID": "/tut/rps/#p_225",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Back in the Reach program, we'll declare a value to use as a standard deadline throughout the program. Similar to how she provides the wager, we will have Alice also provide the deadline."
  },
  {
    "objectID": "/tut/rps/#p_226",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 31 adds the {!js} deadline field to Alice's participant interact interface. It is defined as some number of time delta units, which are an abstraction of the underlying notion of network time in the consensus network. In many networks, like Ethereum, this number is a number of blocks."
  },
  {
    "objectID": "/tut/rps/#p_227",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next, at the start of the Reach application, we'll define a helper function to inform each of the participants of the timeout by calling this new method."
  },
  {
    "objectID": "/tut/rps/#p_228",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 39 defines the function as an arrow expression."
  },
  {
    "objectID": "/tut/rps/#p_229",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 40 has each of the participants perform a local step."
  },
  {
    "objectID": "/tut/rps/#p_230",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 41 has them call the new {!rsh} informTimeout method."
  },
  {
    "objectID": "/tut/rps/#p_231",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We will have Alice declassify and publish the {!rsh} deadline for later timeout clauses."
  },
  {
    "objectID": "/tut/rps/#p_232",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We won't add a timeout clause to Alice's first message, because there is no consequence to her non-participation: if she doesn't start the game, then no one is any worse off."
  },
  {
    "objectID": "/tut/rps/#p_233",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 50 has Alice declassify the {!rsh} deadline time delta."
  },
  {
    "objectID": "/tut/rps/#p_234",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 52 now has Alice publish the {!rsh} deadline."
  },
  {
    "objectID": "/tut/rps/#p_235",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "However, we will adjust Bob's first message, because if he fails to participate, then Alice's initial wager will be lost to her."
  },
  {
    "objectID": "/tut/rps/#p_236",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 63 adds a timeout handler to Bob's publication."
  },
  {
    "objectID": "/tut/rps/#p_237",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The timeout handler specifies that if Bob does not complete this action within a time delta of {!rsh} deadline, then the application transitions to the step given by the arrow expression. In this case, the timeout code is a call to {!rsh} closeTo, which is a Reach standard library function that allows anyone to send a message and transfer all of the funds in the contract to Alice, then call the given function afterwards. This means that if Bob fails to publish his hand, then Alice will take her network tokens back."
  },
  {
    "objectID": "/tut/rps/#p_238",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We will add a similar timeout handler to Alice's second message."
  },
  {
    "objectID": "/tut/rps/#p_239",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "But in this case, Bob will be able to claim all of the funds if Alice doesn't participate. You might think that it would be \"fair\" for Alice's funds to be returned to Alice and Bob's to Bob. However, if we implemented it that way, then Alice would be wise to always timeout if she were going to lose, which she knows will happen, because she knows her hand and Bob's hand."
  },
  {
    "objectID": "/tut/rps/#p_240",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "These are the only changes we need to make to the Reach program to make it robust against non-participation: eleven lines!"
  },
  {
    "objectID": "/tut/rps/#p_241",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Let's modify the JavaScript frontend to deliberately cause a timeout sometimes when Bob is supposed to accept the wager."
  },
  {
    "objectID": "/tut/rps/#p_242",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 38 has Alice specify a {!js} deadline of ten blocks."
  },
  {
    "objectID": "/tut/rps/#p_243",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 42 through 51 redefine Bob's {!js} acceptWager method as an asynchronous function, where half of the time it will take at least ten blocks on the Ethereum network by waiting for ten units of time to pass. We know that ten is the value of {!js} deadline, so this will cause a timeout."
  },
  {
    "objectID": "/tut/rps/#p_244",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Let's run the program and see what happens:"
  },
  {
    "objectID": "/tut/rps/#p_245",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Of course, when you run, you may not get two of the three times ending in a timeout."
  },
  {
    "objectID": "/tut/rps/#p_246",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If your version isn't working, look at the complete versions of rps-6-timeouts/index.rsh and rps-6-timeouts/index.mjs to make sure you copied everything down correctly!"
  },
  {
    "objectID": "/tut/rps/#p_247",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Now our implementation of Rock, Paper, Scissors! is robust against either participant dropping from the game. In the next step, we'll extend the application to disallow draws and have Alice and Bob play again until there is a winner."
  },
  {
    "objectID": "/tut/rps/#p_248",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "What happens in a decentralized application when one participant refuses to take the next step of the program? For example, if Alice refuses to share her hand with Bob in a game of ‘Rock, Paper, Scissors’."
  },
  {
    "objectID": "/tut/rps/#p_249",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "This is not possible, because the blockchain guarantees that each party performs a particular set of actions;"
  },
  {
    "objectID": "/tut/rps/#p_250",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The program hangs forever waiting for Alice to provide the value;"
  },
  {
    "objectID": "/tut/rps/#p_251",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Alice is punished and the program proceeds as-if Bob were the winner;"
  },
  {
    "objectID": "/tut/rps/#p_252",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "It depends on how the program was written; if the developer used Reach, the default is (2), but the developer could include a {!rsh} timeout block to implement the (3) behavior."
  },
  {
    "objectID": "/tut/rps/#p_253",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "4; Reach empowers programmers to design the application with the business logic they want."
  },
  {
    "objectID": "/tut/rps/#p_254",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In this section, we extend our application so that Alice and Bob will continue to play against each other until there is a clear winner, so if it is a draw they will continue playing."
  },
  {
    "objectID": "/tut/rps/#p_255",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "This will only require a change to the Reach program, not the JavaScript frontend, but we will take the opportunity to modify the frontend so that timeouts can happen to both parties when they are asked to submit their hands. Let's do that to get it out of the way and not distract from the main task of removing draws."
  },
  {
    "objectID": "/tut/rps/#p_256",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We'll modify the {!js} Player interact object so that it will have a different {!js} getHand method."
  },
  {
    "objectID": "/tut/rps/#p_257",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 24 through 29 moves the forced timeout code that we wrote for Bob's {!js} acceptWager function into this method. We also change the threshold so that timeouts only happen 1% of the time. This isn't a very interesting behavior, so we'll make it much less frequent."
  },
  {
    "objectID": "/tut/rps/#p_258",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We also adjust Bob's {!js} acceptWager function to remove the timeout code, since we're testing that differently now. It's just a matter of reverting to the simpler version from before."
  },
  {
    "objectID": "/tut/rps/#p_259",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 48 through 50 have the simpler {!js} acceptWager method for Bob."
  },
  {
    "objectID": "/tut/rps/#p_260",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Now, let's look at the Reach application. All of the details about the playing of the game and the interface to the players will remain the same. The only thing that's going to be different is the order the actions take place."
  },
  {
    "objectID": "/tut/rps/#p_261",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "It used to be that the steps were:"
  },
  {
    "objectID": "/tut/rps/#p_262",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Alice sends her wager and commitment."
  },
  {
    "objectID": "/tut/rps/#p_263",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Bob accepts the wager and sends his hand."
  },
  {
    "objectID": "/tut/rps/#p_264",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Alice reveals her hand."
  },
  {
    "objectID": "/tut/rps/#p_265",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The game ends."
  },
  {
    "objectID": "/tut/rps/#p_266",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "But, now because the players may submit many hands, but should only have a single wager, we'll break these steps up differently, as follows:"
  },
  {
    "objectID": "/tut/rps/#p_267",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Alice sends her wager."
  },
  {
    "objectID": "/tut/rps/#p_268",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Bob accepts the wager."
  },
  {
    "objectID": "/tut/rps/#p_269",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Alice sends her commitment."
  },
  {
    "objectID": "/tut/rps/#p_270",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Bob sends his hand."
  },
  {
    "objectID": "/tut/rps/#p_271",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Alice reveals her hand."
  },
  {
    "objectID": "/tut/rps/#p_272",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If it's draw, return to step 3; otherwise, the game ends."
  },
  {
    "objectID": "/tut/rps/#p_273",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Let's make these changes now."
  },
  {
    "objectID": "/tut/rps/#p_274",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 49 has Alice publish the wager and deadline."
  },
  {
    "objectID": "/tut/rps/#p_275",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 50 has Alice pay the wager."
  },
  {
    "objectID": "/tut/rps/#p_276",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 56 has Bob pay the wager."
  },
  {
    "objectID": "/tut/rps/#p_277",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 58 does not have this consensus step commit."
  },
  {
    "objectID": "/tut/rps/#p_278",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "It's now time to begin the repeatable section of the application, where each party will repeatedly submit hands until the the outcome is not a draw. In normal programming languages, such a circumstance would be implemented with a {!js} while loop, which is exactly what we'll do in Reach. However, {!rsh} while loops in Reach require extra care, as discussed in the guide on loops in Reach, so we'll take it slow."
  },
  {
    "objectID": "/tut/rps/#p_279",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In the rest of a Reach program, all identifier bindings are static and unchangeable, but if this were the case throughout all of Reach, then {!rsh} while loops would either never start or never terminate, because the loop condition would never change. So, a {!rsh} while loop in Reach can introduce a variable binding."
  },
  {
    "objectID": "/tut/rps/#p_280",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next, because of Reach's automatic verification engine, we must be able to make a statement about what properties of the program are invariant before and after a {!rsh} while loop body's execution, a so-called \"loop invariant\"."
  },
  {
    "objectID": "/tut/rps/#p_281",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Finally, such loops may only occur inside of consensus steps. That's why Bob's transaction was not committed, because we need to remain inside of the consensus to start the {!rsh} while loop. This is because all of the participants must agree on the direction of control flow in the application."
  },
  {
    "objectID": "/tut/rps/#p_282",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Here's what the structure looks like:"
  },
  {
    "objectID": "/tut/rps/#p_283",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 59 defines the loop variable, {!rsh} outcome."
  },
  {
    "objectID": "/tut/rps/#p_284",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 60 states the invariant that the body of the loop does not change the balance in the contract account and that {!rsh} outcome is a valid outcome."
  },
  {
    "objectID": "/tut/rps/#p_285",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 61 begins the loop with the condition that it continues as long as the outcome is a draw."
  },
  {
    "objectID": "/tut/rps/#p_286",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Now, let's look at the body of the loop for the remaining steps, starting with Alice's commitment to her hand."
  },
  {
    "objectID": "/tut/rps/#p_287",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 62 commits the last transaction, which at the start of the loop is Bob's acceptance of the wager, and at subsequent runs of the loop is Alice's publication of her hand."
  },
  {
    "objectID": "/tut/rps/#p_288",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 64 through 71 are almost identical to the older version, except the wager is already known and paid."
  },
  {
    "objectID": "/tut/rps/#p_289",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Similarly, Bob's code is almost identical to the prior version, except that he's already accepted and paid the wager."
  },
  {
    "objectID": "/tut/rps/#p_290",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Alice's next step is actually identical, because she is still revealing her hand in exactly the same way."
  },
  {
    "objectID": "/tut/rps/#p_291",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next is the end of the loop."
  },
  {
    "objectID": "/tut/rps/#p_292",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 89 updates the {!rsh} outcome loop variable with the new value."
  },
  {
    "objectID": "/tut/rps/#p_293",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 90 continues the loop. Unlike most programming languages, Reach requires that {!rsh} continue be explicitly written in the loop body."
  },
  {
    "objectID": "/tut/rps/#p_294",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The rest of the program could be exactly the same as it was before, except now it occurs outside of the loop, but we will simplify it, because we know that the outcome can never be a draw."
  },
  {
    "objectID": "/tut/rps/#p_295",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 93 asserts that the outcome is never draw, which is trivially true because otherwise the {!rsh} while loop would not have exited."
  },
  {
    "objectID": "/tut/rps/#p_296",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 94 transfers the funds to the winner."
  },
  {
    "objectID": "/tut/rps/#p_297",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Let's run the program and see what happens:"
  },
  {
    "objectID": "/tut/rps/#p_298",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "As usual, your results may differ, but you should be able to see single round victories like this, as well as multi-round fights and timeouts from either party."
  },
  {
    "objectID": "/tut/rps/#p_299",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If your version isn't working, look at the complete versions of rps-7-loops/index.rsh and rps-7-loops/index.mjs to make sure you copied everything down correctly!"
  },
  {
    "objectID": "/tut/rps/#p_300",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Now our implementation of Rock, Paper, Scissors! will always result in a pay-out, which is much more fun for everyone. In the next step, we'll show how to exit \"testing\" mode with Reach and turn our JavaScript into an interactive Rock, Paper, Scissors! game with real users."
  },
  {
    "objectID": "/tut/rps/#p_301",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "How do you write an application in Reach that runs arbitrarily long, like a game of Rock, Paper, Scissors that is guaranteed to not end in a draw?"
  },
  {
    "objectID": "/tut/rps/#p_302",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "This is not possible, because all Reach programs are finitely long;"
  },
  {
    "objectID": "/tut/rps/#p_303",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "You can use a {!rsh} while loop that runs until the outcome of the game is decided."
  },
  {
    "objectID": "/tut/rps/#p_304",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "2; Reach supports {!rsh} while loops."
  },
  {
    "objectID": "/tut/rps/#p_305",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "When you check if a program with a {!rsh} while loop is correct, you need to have a property called a loop invariant. Which of the following statements have to be true about the loop invariant?"
  },
  {
    "objectID": "/tut/rps/#p_306",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The part of the program before the {!rsh} while loop must establish the invariant."
  },
  {
    "objectID": "/tut/rps/#p_307",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The condition and the body of the loop must establish the invariant."
  },
  {
    "objectID": "/tut/rps/#p_308",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The negation of the condition and the invariant must establish any properties of the rest of the program."
  },
  {
    "objectID": "/tut/rps/#p_309",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "All of the above."
  },
  {
    "objectID": "/tut/rps/#p_310",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In the last section, we made our Rock, Paper, Scissors! run until there was a definitive winner. In this section, we won't be making any changes to the Reach program itself. Instead, we'll introduce customizations to the JavaScript frontend which facilitate interactivity and provide the option to connect to a real consensus network."
  },
  {
    "objectID": "/tut/rps/#p_311",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We'll start from scratch and show every line of the program again. You'll see a lot of similarity between this and the last version, but for completeness, we'll show every line."
  },
  {
    "objectID": "/tut/rps/#p_312",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 1 has been updated to import the ask object of @reach-sh/stdlib, the Reach standard library. We'll see how ask is used below."
  },
  {
    "objectID": "/tut/rps/#p_313",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 2, and 3 are the same as before: importing the standard library and the backend."
  },
  {
    "objectID": "/tut/rps/#p_314",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 5 through 8 ask the question whether they are playing as Alice and expect a \"Yes\" or \"No\" answer. {!js} ask.ask presents a prompt and collects a line of input until its argument does not error. {!js} ask.yesno errors if it is not given \"y\" or \"n\"."
  },
  {
    "objectID": "/tut/rps/#p_315",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 14 through 17 present the user with the choice of creating a test account if they can or inputting a secret to load an existing account."
  },
  {
    "objectID": "/tut/rps/#p_316",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 19 creates the test account as before."
  },
  {
    "objectID": "/tut/rps/#p_317",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 25 loads the existing account."
  },
  {
    "objectID": "/tut/rps/#p_318",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 29 branches based on whether the player is running as Alice, who must deploy the contract, or Bob, who must attach to it."
  },
  {
    "objectID": "/tut/rps/#p_319",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 30 through 32 deploy it and print out public information ({!js} ctc.getInfo) that can be given to the other player when it becomes available."
  },
  {
    "objectID": "/tut/rps/#p_320",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 34 through 39 request, parse, and process this information."
  },
  {
    "objectID": "/tut/rps/#p_321",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next we define a few helper functions and start the participant interaction interface."
  },
  {
    "objectID": "/tut/rps/#p_322",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Then we define a timeout handler."
  },
  {
    "objectID": "/tut/rps/#p_323",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next, we request the wager amount or define the {!js} acceptWager method, depending on if we are Alice or not."
  },
  {
    "objectID": "/tut/rps/#p_324",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next, we define the shared {!js} getHand method."
  },
  {
    "objectID": "/tut/rps/#p_325",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Finally, the {!js} seeOutcome method."
  },
  {
    "objectID": "/tut/rps/#p_326",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lastly, we choose the appropriate backend function and await its completion."
  },
  {
    "objectID": "/tut/rps/#p_327",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We can now run"
  },
  {
    "objectID": "/tut/rps/#p_328",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "in one terminal in this directory to play as Alice and"
  },
  {
    "objectID": "/tut/rps/#p_329",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "in another terminal in this directory to play as Bob."
  },
  {
    "objectID": "/tut/rps/#p_330",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Here's an example run:"
  },
  {
    "objectID": "/tut/rps/#p_331",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "and"
  },
  {
    "objectID": "/tut/rps/#p_332",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Of course, when you run the exact amounts and addresses may be different."
  },
  {
    "objectID": "/tut/rps/#p_333",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If your version isn't working, compare with rps-8-interact/index.rsh and rps-8-interact/index.mjs to ensure you've copied everything down correctly!"
  },
  {
    "objectID": "/tut/rps/#p_334",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If we were to instead run"
  },
  {
    "objectID": "/tut/rps/#p_335",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "in two terminals we'd see equivalent output from running our application on a private Algorand devnet."
  },
  {
    "objectID": "/tut/rps/#p_336",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Connecting to live consensus networks is similarly easy:"
  },
  {
    "objectID": "/tut/rps/#p_337",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Now our implementation of Rock, Paper, Scissors! is finished! We are protected against attacks, timeouts, and draws, and we can run interactively on non-test networks."
  },
  {
    "objectID": "/tut/rps/#p_338",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In this step, we made a command-line interface for our Reach program. In the next step, we'll replace this with a Web interface for the same Reach program."
  },
  {
    "objectID": "/tut/rps/#p_339",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Reach helps you build automated tests for your decentralized application, but it doesn’t support building interactive user-interfaces."
  },
  {
    "objectID": "/tut/rps/#p_340",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "False; Reach does not impose any constraints on what kind of frontend is attached to your Reach application."
  },
  {
    "objectID": "/tut/rps/#p_341",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In the last section, we made Rock, Paper, Scissors! run as a command-line application, without any changes to the Reach program. In this section, we again won't be making any changes to the Reach program. Instead, we'll replace the command-line interface with a Web interface."
  },
  {
    "objectID": "/tut/rps/#p_342",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We will use React.js for this tutorial, but the same principles apply to any Web framework."
  },
  {
    "objectID": "/tut/rps/#p_343",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If you've never used React before, here are some basics about how it works:"
  },
  {
    "objectID": "/tut/rps/#p_344",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "React programs are JavaScript programs that use a special library that allows you to mix HTML inside of the body of your JavaScript."
  },
  {
    "objectID": "/tut/rps/#p_345",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "React has a special compiler that combines a bundle of JavaScript programs, and all their dependencies, into one large file that can be deployed on a static Web server. This is called \"packing\"."
  },
  {
    "objectID": "/tut/rps/#p_346",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "When you're developing and testing with React, you run a special development Web server that watches and updates this packed file every time you modify a source file, so you don't have to constantly run the compiler."
  },
  {
    "objectID": "/tut/rps/#p_347",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Reach automates the process of starting this development server for you when you run ./reach react and gives you access to it at http://localhost:3000/."
  },
  {
    "objectID": "/tut/rps/#p_348",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Similarly, in this tutorial, we assume that we will be deploying (and testing) with Ethereum. Reach Web applications rely on the Web browser to provide access to a consensus network account and its associated wallet. On Ethereum, the standard wallet is MetaMask. If you want to test this code, you'll need to install it and set it up. Furthermore, MetaMask does not support multiple active accounts, so if you want to test Rock, Paper, Scissors! locally, you'll need to have two separate browser instances: one to act as Alice and another to act as Bob."
  },
  {
    "objectID": "/tut/rps/#p_349",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "To complete this section we'll use the index.rsh you've already written and create an index.js file from scratch which replaces index.mjs."
  },
  {
    "objectID": "/tut/rps/#p_350",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If you do not replace index.mjs, then you will get an error when you run reach react. You can avoid this error by renaming the file to index.mjs.bak, or by creating a totally new directory with a copy of the old index.rsh. We do the second option."
  },
  {
    "objectID": "/tut/rps/#p_351",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "This code is also supplemented with index.css and some views. These details are not specific to Reach, and are fairly trivial, so we will not explain the specifics of those files. If you run this locally, you'll want to download those files. Your directory should look like:"
  },
  {
    "objectID": "/tut/rps/#p_352",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We will focus on rps-9-web/index.js, because rps-9-web/index.rsh is the same as previous sections."
  },
  {
    "objectID": "/tut/rps/#p_353",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On lines 1 thru 6, we import our view code and CSS. On line 7, we import the compiled {!rsh} backend. On lines 8 and 9, we load the {!rsh} stdlib as {!rsh} reach."
  },
  {
    "objectID": "/tut/rps/#p_354",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "React compiles the Reach standard library in such a way that it does not have direct access to the environment variables which are used to select the desired standard library. This is why you need to pass {!js} process.env as an argument to achieve the desired effect."
  },
  {
    "objectID": "/tut/rps/#p_355",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On these lines we define a few helpful constants and defaults for later, some corresponding to the enumerations we defined in Reach."
  },
  {
    "objectID": "/tut/rps/#p_356",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We start defining the main application view, {!js} App, as a React component, and tell it what to do once it mounts, which is the React term for starting."
  },
  {
    "objectID": "/tut/rps/#p_357",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 19, we initialize the component state to display Connect Account dialog."
  },
  {
    "objectID": "/tut/rps/#p_358",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On lines 21 thru 31, we hook into React's {!js} componentDidMount lifecycle event, which is called when the component starts."
  },
  {
    "objectID": "/tut/rps/#p_359",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 22, we use {!js} getDefaultAccount, which accesses the default browser account. For example, when used with Ethereum, it can discover the currently-selected MetaMask account."
  },
  {
    "objectID": "/tut/rps/#p_360",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 26, we use {!js} canFundFromFaucet to see if we can access the Reach developer testing network faucet."
  },
  {
    "objectID": "/tut/rps/#p_361",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 27, if {!js} canFundFromFaucet was {!js} true, we set the component state to display Fund Account dialog."
  },
  {
    "objectID": "/tut/rps/#p_362",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 29, if {!js} canFundFromFaucet was {!js} false, we set the component state to skip to Choose Role."
  },
  {
    "objectID": "/tut/rps/#p_363",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 39, we render the appropriate view from rps-9-web/views/AppViews.js."
  },
  {
    "objectID": "/tut/rps/#p_364",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "When we combine the application component with the view (rps-9-web/views/AppViews.js) it will look like: "
  },
  {
    "objectID": "/tut/rps/#p_365",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next, we define callbacks on {!js} App for what to do when the user clicks certain buttons."
  },
  {
    "objectID": "/tut/rps/#p_366",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On lines 32 thru 35, we define what happens when the user clicks the Fund Account button."
  },
  {
    "objectID": "/tut/rps/#p_367",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 33, we transfer funds from the faucet to the user's account."
  },
  {
    "objectID": "/tut/rps/#p_368",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 34, we set the component state to display Choose Role."
  },
  {
    "objectID": "/tut/rps/#p_369",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 36, we define what to do when the user clicks the Skip button, which is to set the component state to display Choose Role."
  },
  {
    "objectID": "/tut/rps/#p_370",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "When we combine this with the view (rps-9-web/views/AppViews.js) it will look like: "
  },
  {
    "objectID": "/tut/rps/#p_371",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On lines 37 and 38, we set a sub-component based on whether the user clicks Deployer or Attacher."
  },
  {
    "objectID": "/tut/rps/#p_372",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "When we combine this with the view (rps-9-web/views/AppViews.js) it will look like: "
  },
  {
    "objectID": "/tut/rps/#p_373",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next, we will define {!js} Player as a React component, that will hold all of the behavior of the players and which will be extended by the specialized components for Alice and Bob."
  },
  {
    "objectID": "/tut/rps/#p_374",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Our Web frontend needs to implement the participant interact interface for players, which we defined as:"
  },
  {
    "objectID": "/tut/rps/#p_375",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We will provide these callbacks via the React component directly."
  },
  {
    "objectID": "/tut/rps/#p_376",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 43, we provide the {!js} random callback"
  },
  {
    "objectID": "/tut/rps/#p_377",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On lines 44 thru 50, we provide the {!js} getHand callback."
  },
  {
    "objectID": "/tut/rps/#p_378",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On lines 45 thru 47, we set the component state to display Get Hand dialog, and wait for a {!js} Promise which can be resolved via user interaction."
  },
  {
    "objectID": "/tut/rps/#p_379",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 48, which occurs after the {!js} Promise is resolved, we set the component state to display Waiting for results display."
  },
  {
    "objectID": "/tut/rps/#p_380",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On lines 51 and 52, we provide the {!js} seeOutcome and {!js} informTimeout callbacks, which set the component state to display Done display and Timeout display, respectively."
  },
  {
    "objectID": "/tut/rps/#p_381",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 53, we define what happens when the user clicks Rock, Paper, or Scissors: The {!js} Promise from line 45 is resolved."
  },
  {
    "objectID": "/tut/rps/#p_382",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The dialog used to get a hand from the player (rps-9-web/views/PlayerViews.js) looks like: "
  },
  {
    "objectID": "/tut/rps/#p_383",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The dialog used to get a hand from the player (rps-9-web/views/PlayerViews.js) looks like: "
  },
  {
    "objectID": "/tut/rps/#p_384",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The display when the player sees the end of the game (rps-9-web/views/PlayerViews.js) looks like: "
  },
  {
    "objectID": "/tut/rps/#p_385",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The display when the player sees a timeout (rps-9-web/views/PlayerViews.js) looks like: "
  },
  {
    "objectID": "/tut/rps/#p_386",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next, we will define {!js} Deployer as a React component for Alice, which extends {!js} Player."
  },
  {
    "objectID": "/tut/rps/#p_387",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Our Web frontend needs to implement the participant interact interface for Alice, which we defined as:"
  },
  {
    "objectID": "/tut/rps/#p_388",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We will provide the {!js} wager and {!js} deadline values, and define some button handlers in order to trigger the deployment of the contract."
  },
  {
    "objectID": "/tut/rps/#p_389",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 59, we set the component state to display Set Wager dialog."
  },
  {
    "objectID": "/tut/rps/#p_390",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 61, we define what to do when the user clicks the Set Wager button, which is to set the component state to display Deploy dialog."
  },
  {
    "objectID": "/tut/rps/#p_391",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On lines 62 thru 69, we define what to do when the user clicks the Deploy button."
  },
  {
    "objectID": "/tut/rps/#p_392",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 63, we call {!js} acc.deploy, which triggers a deploy of the contract."
  },
  {
    "objectID": "/tut/rps/#p_393",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 64, we set the component state to display Deploying display."
  },
  {
    "objectID": "/tut/rps/#p_394",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 65, we set the {!js} wager property."
  },
  {
    "objectID": "/tut/rps/#p_395",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 66, we set the {!js} deadline property based on which connector is being used."
  },
  {
    "objectID": "/tut/rps/#p_396",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 67, we start running the Reach program as Alice, using the {!js} this React component as the participant interact interface object."
  },
  {
    "objectID": "/tut/rps/#p_397",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On lines 68 and 69, we set the component state to display Waiting for Attacher display, which displays the deployed contract info as JSON."
  },
  {
    "objectID": "/tut/rps/#p_398",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 71, we render the appropriate view from rps-9-web/views/DeployerViews.js."
  },
  {
    "objectID": "/tut/rps/#p_399",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The dialog used to set the wager (rps-9-web/views/DeployerViews.js) looks like: "
  },
  {
    "objectID": "/tut/rps/#p_400",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The dialog used to deploy (rps-9-web/views/DeployerViews.js) looks like: "
  },
  {
    "objectID": "/tut/rps/#p_401",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The display shown while deploying (rps-9-web/views/DeployerViews.js) looks like: "
  },
  {
    "objectID": "/tut/rps/#p_402",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The display shown while waiting for the attacher (rps-9-web/views/DeployerViews.js) looks like: "
  },
  {
    "objectID": "/tut/rps/#p_403",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Our Web frontend needs to implement the participant interact interface for Bob, which we defined as:"
  },
  {
    "objectID": "/tut/rps/#p_404",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We will provide the {!js} acceptWager callback, and define some button handlers in order to attach to the deployed contract."
  },
  {
    "objectID": "/tut/rps/#p_405",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 76, we initialize the component state to display Attach dialog."
  },
  {
    "objectID": "/tut/rps/#p_406",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On lines 78 thru 82, we define what happens when the user clicks the Attach button."
  },
  {
    "objectID": "/tut/rps/#p_407",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 79, we call {!js} acc.attach"
  },
  {
    "objectID": "/tut/rps/#p_408",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 80, we set the component state to display Attaching display."
  },
  {
    "objectID": "/tut/rps/#p_409",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 81, we start running the Reach program as Bob, using the {!js} this React component as the participant interact interface object."
  },
  {
    "objectID": "/tut/rps/#p_410",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On lines 83 thru 88, we define the {!js} acceptWager callback."
  },
  {
    "objectID": "/tut/rps/#p_411",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On lines 85 thru 87, we set the component state to display Accept Terms dialog, and wait for a {!js} Promise which can be resolved via user interaction."
  },
  {
    "objectID": "/tut/rps/#p_412",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On lines 89 thru 92, we define what happens when the user clicks the Accept Terms and Pay Wager button: the {!js} Promise from line 90 is resolved, and we set the component state to display Waiting for Turn display."
  },
  {
    "objectID": "/tut/rps/#p_413",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 93, we render the appropriate view from rps-9-web/views/AttacherViews.js"
  },
  {
    "objectID": "/tut/rps/#p_414",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The dialog used to attach (rps-9-web/views/AttacherViews.js) looks like: "
  },
  {
    "objectID": "/tut/rps/#p_415",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The display when attaching (rps-9-web/views/AttacherViews.js) looks like: "
  },
  {
    "objectID": "/tut/rps/#p_416",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The dialog used to accept the terms of the wager (rps-9-web/views/AttacherViews.js) looks like: "
  },
  {
    "objectID": "/tut/rps/#p_417",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The display when waiting for a turn (rps-9-web/views/AttacherViews.js) looks like: "
  },
  {
    "objectID": "/tut/rps/#p_418",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Finally, we call a small helper function from rps-9-web/views/render.js to render our App component."
  },
  {
    "objectID": "/tut/rps/#p_419",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "As a convenience for running the React development server, you can call:"
  },
  {
    "objectID": "/tut/rps/#p_420",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If you get an error or it does not seem to be working correctly, make sure that the folder does not have an index.mjs file. If you do, you can rename it to index.mjs.bak or move it to a new directory with a copy of the old index.rsh."
  },
  {
    "objectID": "/tut/rps/#p_421",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "To run the React development server with Algorand, you can call:"
  },
  {
    "objectID": "/tut/rps/#p_422",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If you expect that your Algorand users do not have access to an ARC-0011 browser wallet, you want to provide a fallback."
  },
  {
    "objectID": "/tut/rps/#p_423",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If you add the following to your program, then you can provide a simple wallet where the user copies and pastes their mnemonic for each interaction."
  },
  {
    "objectID": "/tut/rps/#p_424",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Instead, if you would like to allow your users to use MyAlgo, then you can add the following:"
  },
  {
    "objectID": "/tut/rps/#p_425",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Or, you could have your users use WalletConnect to connect to the Algorand Wallet, by adding the following:"
  },
  {
    "objectID": "/tut/rps/#p_426",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "(Of course, you may want to replace 'TestNet' in either of these samples with a different network name, like 'MainNet'.)"
  },
  {
    "objectID": "/tut/rps/#p_427",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Because these are fallbacks, you need to decide for your users which wallet they'll use, or make a user interface element to let them select which wallet fallback to use."
  },
  {
    "objectID": "/tut/rps/#p_428",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Similarly, to run with Conflux:"
  },
  {
    "objectID": "/tut/rps/#p_429",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "To adapt this example for Conflux TestNet or MainNet, you can add this after the imports:"
  },
  {
    "objectID": "/tut/rps/#p_430",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "For details, see the Conflux FAQ."
  },
  {
    "objectID": "/tut/rps/#p_431",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If you'd like to instead use Reach in your own JavaScript project, you can call:"
  },
  {
    "objectID": "/tut/rps/#p_432",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The Reach standard library is undergoing continual improvement and is updated often. If you are experiencing issues with the Node.js package, try updating!"
  },
  {
    "objectID": "/tut/rps/#p_433",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "As usual, you can compile your Reach program index.rsh to the {!js} backend build artifact build/index.main.mjs with:"
  },
  {
    "objectID": "/tut/rps/#p_434",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Now our implementation of Rock, Paper, Scissors! is live in the browser! We can leverage callbacks in the participant interact interface to display to and gather information from the user, through any Web UI framework of our choice."
  },
  {
    "objectID": "/tut/rps/#p_435",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If we wanted to deploy this application to the world, then we would take the static files that React produces and host them on a Web server. These files embed your compiled Reach program, so there's nothing more to do than provide them to the world."
  },
  {
    "objectID": "/tut/rps/#p_436",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In the next section, we'll summarize where we've gone and direct you to the next step of your journey to decentralized application mastery."
  },
  {
    "objectID": "/tut/rps/#p_437",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Reach integrates with all Web interface libraries, like React, Vue, and so on, because Reach frontends are just normal JavaScript programs."
  },
  {
    "objectID": "/tut/rps/#p_438",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "True"
  },
  {
    "objectID": "/tut/rps/#p_439",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Reach accelerates your development with React by baking-in a React development server and the deployment process to test React programs locally."
  },
  {
    "objectID": "/tut/rps/#p_440",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "True"
  },
  {
    "objectID": "/tut/rps/#p_441",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Let's review what we've done through this tutorial:"
  },
  {
    "objectID": "/tut/rps/#p_442",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In part one, we saw how Reach can be installed with one command on almost any system without any dependencies beyond what most developers have anyways."
  },
  {
    "objectID": "/tut/rps/#p_443",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In part two, we saw how Reach programs have a succinct setup that easily abstracts the details of your chosen consensus network into a couple lines and three key API calls."
  },
  {
    "objectID": "/tut/rps/#p_444",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In part three, we saw how Reach allows developers to focus on the business logic of their decentralized application and look past the nitty-gritty details of blockchain interaction and protocol design."
  },
  {
    "objectID": "/tut/rps/#p_445",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In part four, we saw that it is just as easy for Reach to deal with tokens and network transactions as it is to deal with data sharing."
  },
  {
    "objectID": "/tut/rps/#p_446",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In part five, we introduced you to the Reach automatic formal verification engine and its ability to ensure our program doesn't have entire categories of flaws and security vulnerabilities."
  },
  {
    "objectID": "/tut/rps/#p_447",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In part six, we saw how Reach allows you to specify how to deal with non-participation and protect against funds being locked in contracts."
  },
  {
    "objectID": "/tut/rps/#p_448",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In part seven, we saw how Reach can express arbitrary length interactions and how flexible the Reach frontends are to variations in the backend."
  },
  {
    "objectID": "/tut/rps/#p_449",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In part eight, we saw how to decouple your Reach program from the Reach standard testing environment and launch an interactive version on a real network."
  },
  {
    "objectID": "/tut/rps/#p_450",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In part nine, we saw how to deploy your Reach program as a fully decentralized Web application."
  },
  {
    "objectID": "/tut/rps/#p_451",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Despite having done so much, this is really just a brief introduction to what is possible with Reach."
  },
  {
    "objectID": "/tut/rps/#p_452",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "How difficult was all this? Let's look at the final versions of our programs."
  },
  {
    "objectID": "/tut/rps/#p_453",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "First, let's look at the Reach program:"
  },
  {
    "objectID": "/tut/rps/#p_454",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next, the JavaScript command-line frontend:"
  },
  {
    "objectID": "/tut/rps/#p_455",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "And finally, the Web frontend:"
  },
  {
    "objectID": "/tut/rps/#p_456",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We wrote about a hundred lines of Reach and two different frontends. Our command-line version is about a hundred lines of JavaScript, while our Web version is about the same length, but has a lot of presentation code as well."
  },
  {
    "objectID": "/tut/rps/#p_457",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Behind the scenes, Reach generated hundreds of lines of Solidity (which you can look at here: rps-8-interact/build/index.main.sol), almost two thousand lines of TEAL (which you can look at here: rps-8-interact/build/index.main.appApproval.teal), as well as over a thousand lines of JavaScript (which you can look at here: rps-8-interact/build/index.main.mjs). If we weren't using Reach, then we'd have to write all this code ourselves and ensure that they are consistent and updated at every change to the application."
  },
  {
    "objectID": "/tut/rps/#p_458",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Now that you've seen an entire Reach application from beginning to end, it's time for you to start working on your own applications!"
  },
  {
    "objectID": "/tut/rps/#p_459",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "You may want to start the workshop, which is a self-study course on practicing and learning Reach through different specific projects."
  },
  {
    "objectID": "/tut/rps/#p_460",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Or, maybe you'd like to spend some time in the guide learning about the background of some of the concepts used in Reach programs."
  },
  {
    "objectID": "/tut/rps/#p_461",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Or, maybe it's time for you to dive into the reference and look into the minutiae of Reach's features."
  },
  {
    "objectID": "/tut/rps/#p_462",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Finally, you may like to repeat a portion of this tutorial, but using a language other than JavaScript, like Python or Go!"
  },
  {
    "objectID": "/tut/rps/#p_463",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "No matter what you decide to read or work on next, we hope you'll join us on the Discord community. Once you join, message @team, I just completed the tutorial! and we'll give you the tutorial veteran role, so you can more easily help others work through it!"
  },
  {
    "objectID": "/tut/rps/#p_464",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Thanks for spending your afternoon with us!"
  },
  {
    "objectID": "/guide/assert/#guide-assert",
    "pt": "How and what to verify",
    "t": 2,
    "c": "How and what to verify"
  },
  {
    "objectID": "/guide/assert/#p_0",
    "pt": "How and what to verify",
    "t": 3,
    "c": "Reach's verification engine ensures that invariants about the state of a program assumed by programmers are held by all possible executions of the program."
  },
  {
    "objectID": "/guide/assert/#p_1",
    "pt": "How and what to verify",
    "t": 3,
    "c": "At a high-level, the goal of a programmer getting started with verification is to write down every single assumption they have into the program in the form of {!rsh} assert statements. For example, if a value, {!rsh} x is assumed to be smaller than 20, then the programmer should always include {!rsh} assert(x < 20); in the program. This is not to help the verification engine prove later properties, but is to give the verification engine assumptions that it can attempt to falsify so the programmer can learn if their assumptions are correct."
  },
  {
    "objectID": "/guide/assert/#p_2",
    "pt": "How and what to verify",
    "t": 3,
    "c": "At a low-level, the programmer should see the verification engine as a tool to prevent test regressions by encoding tests directly into the program in the form of assertions. For example, suppose that during development and testing, a programmer observes an erroneous state where the variable {!rsh} y is assigned to the value {!rsh} 41, then the programmer should insert {!rsh} assert(y != 41); into the program. The programmer should insert this check before they fix the problem in the code. This will ensure that all future versions of the program will also be protected from these problems."
  },
  {
    "objectID": "/guide/assert/#p_3",
    "pt": "How and what to verify",
    "t": 3,
    "c": "These high- and low-level perspectives on assertions apply to individual code fragments, like the body of an {!rsh} only statement, as well as entire functions. For example, if a programmer expects a unary function over integers, {!rsh} f, to always return a number between {!rsh} 0 and {!rsh} 50, then they should write {!rsh} assert(f(forall(UInt)) <= 50); in their program. Similarly, the unit tests for a function that a developer would normally write in a test suite, should instead be written as a series of assertions in the module that defines a function."
  },
  {
    "objectID": "/guide/assert/#p_4",
    "pt": "How and what to verify",
    "t": 3,
    "c": "If you'd like to continue learning about verification, we recommend reading about \"property-based testing\". Although most resources on the topic will refer to dynamic, random tools, like QuickCheck, the strategies used transfer automatically to a formally verified context, like Reach."
  },
  {
    "objectID": "/guide/assert/#p_5",
    "pt": "How and what to verify",
    "t": 3,
    "c": "If you'd like to continue reading about verification in Reach specifically, read the guide section on loop invariants."
  },
  {
    "objectID": "/workshop/fomo-generalized/#workshop-fomo-generalized",
    "pt": "Fear of Missing Out+",
    "t": 2,
    "c": "Fear of Missing Out+"
  },
  {
    "objectID": "/workshop/fomo-generalized/#workshop-fomo-generalized-pr",
    "pt": "Fear of Missing Out+",
    "t": 2,
    "c": "Problem Analysis"
  },
  {
    "objectID": "/workshop/fomo-generalized/#workshop-fomo-generalized-dd",
    "pt": "Fear of Missing Out+",
    "t": 2,
    "c": "Data Definition"
  },
  {
    "objectID": "/workshop/fomo-generalized/#workshop-fomo-generalized-cc",
    "pt": "Fear of Missing Out+",
    "t": 2,
    "c": "Communication Construction"
  },
  {
    "objectID": "/workshop/fomo-generalized/#workshop-fomo-generalized-ai",
    "pt": "Fear of Missing Out+",
    "t": 2,
    "c": "Assertion Insertion"
  },
  {
    "objectID": "/workshop/fomo-generalized/#workshop-fomo-generalized-ii",
    "pt": "Fear of Missing Out+",
    "t": 2,
    "c": "Interaction Introduction"
  },
  {
    "objectID": "/workshop/fomo-generalized/#workshop-fomo-generalized-de",
    "pt": "Fear of Missing Out+",
    "t": 2,
    "c": "Deployment Decisions"
  },
  {
    "objectID": "/workshop/fomo-generalized/#workshop-fomo-generalized-dns",
    "pt": "Fear of Missing Out+",
    "t": 2,
    "c": "Discussion and Next Steps"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_0",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "In this workshop, we will extend our Fear of Missing Out application with the ability to split the reward between the N most recent Buyers."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_1",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "In this version, the Funder will have the advantage that, if there are less than N Buyers, the Funder will earn the rewards for every absent Buyer. For example, if the auction is set to have 5 winners, yet only 3 Buyers bid, the first three Buyers will receive 1/5 of the funds each, and the Funder will receive the remaining 2/5 of the funds."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_2",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Fear of Missing Out."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_3",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "We assume that you'll go through this workshop in a directory named ~/reach/workshop-fomo-generalized:"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_4",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "And that you have a copy of Reach installed in ~/reach so you can write"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_5",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "And it will run Reach. You should start off by initializing your Reach program:"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_6",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Our problem analysis is practically the same as the original Fear of Missing Out application, except for one difference:"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_7",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "What funds change ownership during the application and how?"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_8",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Let's compare answers for how funds should change ownership in this generalized version:"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_9",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Buyers continually add funds to the balance during execution until the last N Buyers, and potentially the Funder, split the balance."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_10",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "The data type representation of this program will basically be the same as the regular Fear of Missing Out program. However, instead of tracking the latest Buyer as an {!rsh} Address, we will track the last N Buyers as an {!rsh} Array(Address, N)."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_11",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Refer to Types for a reminder of what data types are available in Reach."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_12",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "You should take the time now to fill out the interaction interface for the participants."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_13",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Our participant interact interface, with the addition of some handy logging functions, looks like this so far:"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_14",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "It is worth noting that Reach does not support arbitrarily sized arrays, so we could not determine NUM_OF_WINNERS at runtime, e.g. from the interaction interface. However, we can still write a program that is generic in the size of the array, then specialize it when we compile."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_15",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "At this point, you can modify your JavaScript file (index.mjs) to contain definitions of these values, although you may want to use placeholders for the actual values. When you're writing a Reach program, especially in the early phases, you should have these two files open side-by-side and update them in tandem as you're deciding the participant interact interface."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_16",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "A fundamental aspect of a decentralized application is the pattern of communication and transfer among the participants. We should write down this structure as comments in our program to serve as an outline and guide us in implementation. In our original Fear of Missing Out implementation, we outlined the pattern of communication as follows:"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_17",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "This outline will need to be updated for our generalized version. You should do this now, in your Reach program (index.rsh)."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_18",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Here's what we wrote for our outline:"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_19",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Now, this outline needs to be converted to a real program."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_20",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "The body of your application should look something like this:"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_21",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Extending this program to track an array of {!rsh} Addresses, as opposed to a single {!rsh} Address is fairly straightforward. We maintain an array of size NUM_OF_WINNERS and implement a ring buffer to keep it up to date with the most recent N winners, as demonstrated in step 2b."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_22",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Another aspect of this code worth highlighting is step 3. We transfer {!rsh} balance() % NUM_OF_WINNERS to the winner because the total balance may not be evenly divisible by the number of winners."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_23",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "For example, if the ticket price is 4 ETH and there are 10 tickets purchased by Buyers, then the total balance will be 40 ETH. However, if the application is set to select 3 winners, then 40 cannot be evenly distributed to 3 participants. So, we will transfer 1 ETH to the Funder, and split the remaining 39 ETH between the 3 Buyers."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_24",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "This program doesn't have many interesting properties to prove as assertions, beyond the token linearity property. The only property of interest is the {!rsh} parallelReduce invariant which states that the balance must be equal to the number of tickets sold multiplied by the ticket price."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_25",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Next, we need to insert the appropriate calls to {!rsh} interact. In this case, our program is very simple and we expect you'll do a great job without further discussion."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_26",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Let's look at our whole program now:"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_27",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Next, it is time to test our program. As usual, we'll present a completely automated test deployment, rather than an interactive one."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_28",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "The program is fairly straightfoward to test. We just create test accounts for the Funder and any number of Buyers. The decision to purchase a ticket by a Buyer will rely simply on generating a random boolean."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_29",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Here's the JavaScript frontend we wrote:"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_30",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Let's see what it looks like when we run the program:"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_31",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Great job!"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_32",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "You've now implemented a generalized Fear of Missing Out game. You can try extending this application with additional features such as:"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_33",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Slightly increasing the ticket price with each purchase."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_34",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Introducing a small payout system (dividends) to Buyers as the game progresses. e.g. every time the ring buffer is filled."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_35",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "If you found this workshop rewarding, please let us know on the Discord community!"
  },
  {
    "objectID": "/workshop/hash-lock/#workshop-hash-lock",
    "pt": "Hash Lock",
    "t": 2,
    "c": "Hash Lock"
  },
  {
    "objectID": "/workshop/hash-lock/#workshop-hash-lock-pr",
    "pt": "Hash Lock",
    "t": 2,
    "c": "Problem Analysis"
  },
  {
    "objectID": "/workshop/hash-lock/#workshop-hash-lock-dd",
    "pt": "Hash Lock",
    "t": 2,
    "c": "Data Definition"
  },
  {
    "objectID": "/workshop/hash-lock/#workshop-hash-lock-cc",
    "pt": "Hash Lock",
    "t": 2,
    "c": "Communication Construction"
  },
  {
    "objectID": "/workshop/hash-lock/#workshop-hash-lock-ai",
    "pt": "Hash Lock",
    "t": 2,
    "c": "Assertion Insertion"
  },
  {
    "objectID": "/workshop/hash-lock/#workshop-hash-lock-ii",
    "pt": "Hash Lock",
    "t": 2,
    "c": "Interaction Introduction"
  },
  {
    "objectID": "/workshop/hash-lock/#workshop-hash-lock-de",
    "pt": "Hash Lock",
    "t": 2,
    "c": "Deployment Decisions"
  },
  {
    "objectID": "/workshop/hash-lock/#workshop-hash-lock-dns",
    "pt": "Hash Lock",
    "t": 2,
    "c": "Discussion"
  },
  {
    "objectID": "/workshop/hash-lock/#p_0",
    "pt": "Hash Lock",
    "t": 3,
    "c": "In this workshop, we'll design an application that allows a payer to lock funds with a secret password, independent from their consensus network identity, which can be drawn by anyone possessing the secret password. This is a useful way for a payer to show that they have funds and have committed to disbursing them, without deciding beforehand who they are paying."
  },
  {
    "objectID": "/workshop/hash-lock/#p_1",
    "pt": "Hash Lock",
    "t": 3,
    "c": "This workshop is independent of all others."
  },
  {
    "objectID": "/workshop/hash-lock/#p_2",
    "pt": "Hash Lock",
    "t": 3,
    "c": "We assume that you'll go through this workshop in a directory named ~/reach/workshop-hash-lock:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_3",
    "pt": "Hash Lock",
    "t": 3,
    "c": "And that you have a copy of Reach installed in ~/reach so you can write"
  },
  {
    "objectID": "/workshop/hash-lock/#p_4",
    "pt": "Hash Lock",
    "t": 3,
    "c": "And it will run Reach. You should start off by initializing your Reach program:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_5",
    "pt": "Hash Lock",
    "t": 3,
    "c": "The first step in any program design is to perform problem analysis and determine what information is relevant to the problem. When writing decentralized applications in Reach, this information analysis includes an analysis of the set of participants involved in a computation."
  },
  {
    "objectID": "/workshop/hash-lock/#p_6",
    "pt": "Hash Lock",
    "t": 3,
    "c": "In this case, let's ask the questions:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_7",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Who is involved in this application?"
  },
  {
    "objectID": "/workshop/hash-lock/#p_8",
    "pt": "Hash Lock",
    "t": 3,
    "c": "What information do they know at the start of the program?"
  },
  {
    "objectID": "/workshop/hash-lock/#p_9",
    "pt": "Hash Lock",
    "t": 3,
    "c": "What information are they going to discover and use in the program?"
  },
  {
    "objectID": "/workshop/hash-lock/#p_10",
    "pt": "Hash Lock",
    "t": 3,
    "c": "What funds change ownership during the application and how?"
  },
  {
    "objectID": "/workshop/hash-lock/#p_11",
    "pt": "Hash Lock",
    "t": 3,
    "c": "You should write your answers in your Reach program (index.rsh) using a comment. {!rsh} /* Remember comments are written like this. */"
  },
  {
    "objectID": "/workshop/hash-lock/#p_12",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Let's see how your answers compare to our answers:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_13",
    "pt": "Hash Lock",
    "t": 3,
    "c": "This program involves two parties: the payer sending the funds and the receiver of those funds. By tradition, we'll call the first 'Alice' and the second 'Bob'. You might like to use other names, like 'Sender' and 'Receiver'."
  },
  {
    "objectID": "/workshop/hash-lock/#p_14",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Alice starts off knowing the amount she wants to send and the secret password."
  },
  {
    "objectID": "/workshop/hash-lock/#p_15",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Bob starts off like Jon Snow and knows nothing."
  },
  {
    "objectID": "/workshop/hash-lock/#p_16",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Alice doesn't learn anything during the execution of the program, but Bob learns the password."
  },
  {
    "objectID": "/workshop/hash-lock/#p_17",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Alice transfers funds at the beginning of the program and Bob receives those funds at the end, after he learns the password."
  },
  {
    "objectID": "/workshop/hash-lock/#p_18",
    "pt": "Hash Lock",
    "t": 3,
    "c": "It's okay if your answers are different than ours. Problem analysis is a \"loose\" process that is more like creative artistry than it is like rote calculation. But, that doesn't mean it is superfluous and unnecessary or unneeded."
  },
  {
    "objectID": "/workshop/hash-lock/#p_19",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Problem analysis is a crucial step that helps us understand what our application is supposed to be doing. Remember, programming in general, and Reach in particular, does not solve problems for you; instead, programs encode automatic solutions to problems you've already solved. Compared to normal languages, Reach does do a bit automatically for you: it automatically discovers problems you may not have realized your program had. You still have to solve them yourself though! But, at least you know about them because of Reach."
  },
  {
    "objectID": "/workshop/hash-lock/#p_20",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Humans and their social systems deal with information, but computers can only interact with data, which is merely a representation of information using particular structures, like numbers, arrays, and so on. After problem analysis, we know what information our program will deal with, but next we need to decide how to translate that information into concrete data."
  },
  {
    "objectID": "/workshop/hash-lock/#p_21",
    "pt": "Hash Lock",
    "t": 3,
    "c": "So, for this program, we should decide:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_22",
    "pt": "Hash Lock",
    "t": 3,
    "c": "What data type will represent the amount Alice transfers?"
  },
  {
    "objectID": "/workshop/hash-lock/#p_23",
    "pt": "Hash Lock",
    "t": 3,
    "c": "What data type will represent Alice's password?"
  },
  {
    "objectID": "/workshop/hash-lock/#p_24",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Refer to Types for a reminder of what data types are available in Reach."
  },
  {
    "objectID": "/workshop/hash-lock/#p_25",
    "pt": "Hash Lock",
    "t": 3,
    "c": "After deciding those things, you should think about how the program will be provided these values. In other words:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_26",
    "pt": "Hash Lock",
    "t": 3,
    "c": "What participant interact interface will each participant use?"
  },
  {
    "objectID": "/workshop/hash-lock/#p_27",
    "pt": "Hash Lock",
    "t": 3,
    "c": "You should look back at your problem analysis to do this step. Whenever a participant starts off knowing something, then it is a field in the {!rsh} interact object. If they learn something, then it will be an argument to a function. If they provide something later, then it will be the result of a function."
  },
  {
    "objectID": "/workshop/hash-lock/#p_28",
    "pt": "Hash Lock",
    "t": 3,
    "c": "You should write your answers in your Reach file (index.rsh) as the participant interact interface for each of the participants."
  },
  {
    "objectID": "/workshop/hash-lock/#p_29",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Let's compare notes again."
  },
  {
    "objectID": "/workshop/hash-lock/#p_30",
    "pt": "Hash Lock",
    "t": 3,
    "c": "We're going to represent the amount Alice transfers as an unsigned integer ({!rsh} UInt) named {!rsh} amt."
  },
  {
    "objectID": "/workshop/hash-lock/#p_31",
    "pt": "Hash Lock",
    "t": 3,
    "c": "We will represent the password as another unsigned integer ({!rsh} UInt) named {!rsh} pass."
  },
  {
    "objectID": "/workshop/hash-lock/#p_32",
    "pt": "Hash Lock",
    "t": 3,
    "c": "These two values are the only fields of Alice's interface, but Bob will have a function named {!rsh} getPass that will return the password that he knows."
  },
  {
    "objectID": "/workshop/hash-lock/#p_33",
    "pt": "Hash Lock",
    "t": 3,
    "c": "We wrote this in our program as:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_34",
    "pt": "Hash Lock",
    "t": 3,
    "c": "It would be very surprising if you choose the exact same names as us in your code, but did you choose the same types? We expect that many of you might have chosen to represent the password by a string of bytes using the Reach type, {!rsh} Bytes. There's nothing necessarily wrong with this option, but we did not choose it because it is hard to decide exactly how long to make it, but we are satisfied with an unsigned integer, because it has a minimum of 64 bits on typical consensus networks."
  },
  {
    "objectID": "/workshop/hash-lock/#p_35",
    "pt": "Hash Lock",
    "t": 3,
    "c": "At this point, you can modify your JavaScript file (index.mjs) to contain definitions of these values, although you may want to use a placeholder like {!js} 42 or something for the actual value. When you're writing a Reach program, especially in the early phases, you should have these two files open side-by-side and update them in tandem as you're deciding the participant interact interface."
  },
  {
    "objectID": "/workshop/hash-lock/#p_36",
    "pt": "Hash Lock",
    "t": 3,
    "c": "A fundamental aspect of a decentralized application is the pattern of communication and transfer among the participants, including the consensus network. For example, who initiates the application? Who responds next? Is there a repeated segment of the program that occurs over and over again? We should explicitly write down this structure as comments in our program. For example, for the tutorial version of Rock, Paper, Scissors!, we might write:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_37",
    "pt": "Hash Lock",
    "t": 3,
    "c": "You should do this now, in your Reach program (index.rsh)."
  },
  {
    "objectID": "/workshop/hash-lock/#p_38",
    "pt": "Hash Lock",
    "t": 3,
    "c": "This is a simple application, so we should all share the same communication pattern. Here's what we wrote:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_39",
    "pt": "Hash Lock",
    "t": 3,
    "c": "However, looking at this pattern reveals a subtlety in this application: how can the consensus ensure that Bob publishes the correct password? The only way is for Alice to publish something first that can be checked by the consensus. For example, we could use the pattern:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_40",
    "pt": "Hash Lock",
    "t": 3,
    "c": "However, this is definitely wrong, because Alice doesn't want to share her password with the world across the network, she only wants to share it with Bob, potentially at some later moment. So, she should not publish the password, but instead, publish a digest of the password, that can be checked against the actual password later. In other words, we should use a pattern like:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_41",
    "pt": "Hash Lock",
    "t": 3,
    "c": "It is cheaper to go through this iteration process in the human-centered design phase than in the code-centered programming phase, even when you're using a high-level language like Reach for programming."
  },
  {
    "objectID": "/workshop/hash-lock/#p_42",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Next, we need to convert this pattern into actual program code using {!rsh} publish, {!rsh} pay, and {!rsh} commit."
  },
  {
    "objectID": "/workshop/hash-lock/#p_43",
    "pt": "Hash Lock",
    "t": 3,
    "c": "The body of your application should look something like:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_44",
    "pt": "Hash Lock",
    "t": 3,
    "c": "We can now move on to the next part of designing a decentralized application: verification."
  },
  {
    "objectID": "/workshop/hash-lock/#p_45",
    "pt": "Hash Lock",
    "t": 3,
    "c": "When we are programming, we hold a complex theory of the behavior of the program inside of our minds that helps us know what should happen next in the program based on what has happened before and what is true at every point in the program. As programs become more complex, this theory becomes more and more difficult to grasp, so we might make mistakes. Furthermore, when another programmer reads our code (such as a version of ourselves from the future trying to modify the program), it can be very difficult to understand this theory for ourselves. Assertions are ways of encoding this theory directly into the text of the program in a way that will be checked by Reach and available to all future readers and editors of the code."
  },
  {
    "objectID": "/workshop/hash-lock/#p_46",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Look at your application. What are the assumptions you have about the values in the program?"
  },
  {
    "objectID": "/workshop/hash-lock/#p_47",
    "pt": "Hash Lock",
    "t": 3,
    "c": "There are three main assumptions we came up with for this program:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_48",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Before Bob publishes the password, it is unknowable by him and everyone else except Alice."
  },
  {
    "objectID": "/workshop/hash-lock/#p_49",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Bob assumes that the password digest published by Alice matches the digest of the password he's publishing."
  },
  {
    "objectID": "/workshop/hash-lock/#p_50",
    "pt": "Hash Lock",
    "t": 3,
    "c": "The consensus requires that Alice's digest and the digest of Bob's password match."
  },
  {
    "objectID": "/workshop/hash-lock/#p_51",
    "pt": "Hash Lock",
    "t": 3,
    "c": "We expect that the third of these is the least controversial and the most obvious property, but the others are important too. The first property essentially guarantees that the erroneous version of the application we contemplated, where Alice directly sent her password over the network, is disallowed. The second property encodes Bob's assumption of good will and integrity when he submits his value: an honest version of the Bob participant would not willingly send a password that wasn't the correct one. Furthermore, it is possible for any participant to check, without going through consensus, if they know what the password is."
  },
  {
    "objectID": "/workshop/hash-lock/#p_52",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Now that we know what the properties are, we need to encode them into our program via calls to Reach functions like {!rsh} unknowable, {!rsh} assume, and {!rsh} require. Let's do that now."
  },
  {
    "objectID": "/workshop/hash-lock/#p_53",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Here's what we did:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_54",
    "pt": "Hash Lock",
    "t": 3,
    "c": "First, we assert that Bob can't know Alice's password, based on what the Reach program does."
  },
  {
    "objectID": "/workshop/hash-lock/#p_55",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Next, we assert that Bob believes his password is correct (and that an honest Bob will check it.)"
  },
  {
    "objectID": "/workshop/hash-lock/#p_56",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Finally, we assert that the consensus can only continue if this is the case."
  },
  {
    "objectID": "/workshop/hash-lock/#p_57",
    "pt": "Hash Lock",
    "t": 3,
    "c": "At this point, we are almost ready to complete our program and make it so that we can run it. You've probably noticed that in our samples, the variables {!rsh} pass, {!rsh} amt, and {!rsh} passDigest are undefined. We'll handle that next."
  },
  {
    "objectID": "/workshop/hash-lock/#p_58",
    "pt": "Hash Lock",
    "t": 3,
    "c": "A key concept of Reach programs is that they are concerned solely with the communication and consensus portions of a decentralized application. Frontends are responsible for all other aspects of the program. Thus, eventually a Reach programmer needs to insert calls into their code to send data to and from the frontend via the participant interact interfaces that they defined during the Data Definition step."
  },
  {
    "objectID": "/workshop/hash-lock/#p_59",
    "pt": "Hash Lock",
    "t": 3,
    "c": "In our program, that means defining {!rsh} amt and {!rsh} passDigest by Alice and {!rsh} pass by Bob. Do that now."
  },
  {
    "objectID": "/workshop/hash-lock/#p_60",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Here's what we did:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_61",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Lines 11-14 have Alice declassify some of her values."
  },
  {
    "objectID": "/workshop/hash-lock/#p_62",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Line 21 has Bob provide his password."
  },
  {
    "objectID": "/workshop/hash-lock/#p_63",
    "pt": "Hash Lock",
    "t": 3,
    "c": "At this point, when we"
  },
  {
    "objectID": "/workshop/hash-lock/#p_64",
    "pt": "Hash Lock",
    "t": 3,
    "c": "We'll get a happy message that all our theorems are true. Great job! But we still need to run our program!"
  },
  {
    "objectID": "/workshop/hash-lock/#p_65",
    "pt": "Hash Lock",
    "t": 3,
    "c": "At this point, we need to decide how we're going to deploy this program and really use it in the world. We need to decide how to deploy the contract, as well as what kind of user interaction modality we'll implement inside of our frontend."
  },
  {
    "objectID": "/workshop/hash-lock/#p_66",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Unfortunately, on many consensus networks, like Ethereum and Algorand, this application is dangerous to run. The problem is that a malicious miner, like Eve, can intercept Bob's message that provides him the funds, refuse to forward it through to the consensus network, take the password from it, and submit it for her own account. There is not a good general solution to this problem, meaning a theorem that we could insert into our program to make sure this attack isn't possible, because the whole point of this application is that Bob's identity is not known at the time that Alice sends the first message. Ideally, such networks would support a kind of cryptographic operation where Bob could prove that he knows the password without revealing it. There are some ideas on how to provide this sort of thing through zero-knowledge proofs and homomorphic encryption, but there is no widely accepted and available solution."
  },
  {
    "objectID": "/workshop/hash-lock/#p_67",
    "pt": "Hash Lock",
    "t": 3,
    "c": "In short: Don't run this program. If you want to do something like this, then continue to the next workshop on relays. If you want to do exactly this, then stay tuned for a more complex zero-knowledge version."
  },
  {
    "objectID": "/workshop/hash-lock/#p_68",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Next, we'll settle for a simple testing program for now to show the application, and let the rest of our full stack team deal with actually building the interface. Here's the JavaScript frontend we wrote:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_69",
    "pt": "Hash Lock",
    "t": 3,
    "c": "In this case, Bob learns the password outside of the Reach program by directly sharing memory with Alice. In a real deployment, she might give Bob the password through some other channel, like an encrypted email message, or a calligraphic scroll delivered by raven or intoned from Himalayan cliffs."
  },
  {
    "objectID": "/workshop/hash-lock/#p_70",
    "pt": "Hash Lock",
    "t": 3,
    "c": "With this testing frontend in place, we can run"
  },
  {
    "objectID": "/workshop/hash-lock/#p_71",
    "pt": "Hash Lock",
    "t": 3,
    "c": "and see an example execution:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_72",
    "pt": "Hash Lock",
    "t": 3,
    "c": "You did it!"
  },
  {
    "objectID": "/workshop/hash-lock/#p_73",
    "pt": "Hash Lock",
    "t": 3,
    "c": "You implemented a Reach program totally on your own, with only a little bit of prodding."
  },
  {
    "objectID": "/workshop/hash-lock/#p_74",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Unlike the tutorial, this workshop uses a \"top-down\" perspective on Reach application design, where you derive the program from the requirements and slowly fill out the shell, while knowing that each step was correct before moving on. In contrast, in the tutorial, we demonstrated a \"bottom-up\" style where you start implementing the easy parts and realize the problems and their fixes as you go. There's no right way to program and in our own Reach development, we use a combination of the two tactics. Try both and keep them both in mind during your own development."
  },
  {
    "objectID": "/workshop/hash-lock/#p_75",
    "pt": "Hash Lock",
    "t": 3,
    "c": "If you found this workshop rewarding, please let us know on the Discord community!"
  },
  {
    "objectID": "/workshop/hash-lock/#p_76",
    "pt": "Hash Lock",
    "t": 3,
    "c": "If you want to know what to do next, a natural extension of the concepts in this workshop is a relay account. Why don't you check it out?"
  },
  {
    "objectID": "/workshop/relay/#term_relay%20account",
    "pt": "Relay Account",
    "t": 1,
    "c": "relay account"
  },
  {
    "objectID": "/workshop/relay/#workshop-relay",
    "pt": "Relay Account",
    "t": 2,
    "c": "Relay Account"
  },
  {
    "objectID": "/workshop/relay/#workshop-relay-pr",
    "pt": "Relay Account",
    "t": 2,
    "c": "Problem Analysis"
  },
  {
    "objectID": "/workshop/relay/#workshop-relay-dd",
    "pt": "Relay Account",
    "t": 2,
    "c": "Data Definition"
  },
  {
    "objectID": "/workshop/relay/#workshop-relay-cc",
    "pt": "Relay Account",
    "t": 2,
    "c": "Communication Construction"
  },
  {
    "objectID": "/workshop/relay/#workshop-relay-ai",
    "pt": "Relay Account",
    "t": 2,
    "c": "Assertion Insertion"
  },
  {
    "objectID": "/workshop/relay/#workshop-relay-ii",
    "pt": "Relay Account",
    "t": 2,
    "c": "Interaction Introduction"
  },
  {
    "objectID": "/workshop/relay/#workshop-relay-de",
    "pt": "Relay Account",
    "t": 2,
    "c": "Deployment Decisions"
  },
  {
    "objectID": "/workshop/relay/#workshop-relay-dns",
    "pt": "Relay Account",
    "t": 2,
    "c": "Discussion and Next Steps"
  },
  {
    "objectID": "/workshop/relay/#p_0",
    "pt": "Relay Account",
    "t": 3,
    "c": "In this workshop, we'll revisit the problem of allowing a payer to transfer funds to another party before knowing their identity. However, unlike in Hash Lock, we will use a technique that is safe against malicious miners. One deployment of a decentralized application like this is as a \"gift card\" where a funder provides a fixed amount of currency to another without knowing their identity."
  },
  {
    "objectID": "/workshop/relay/#p_1",
    "pt": "Relay Account",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Hash Lock."
  },
  {
    "objectID": "/workshop/relay/#p_2",
    "pt": "Relay Account",
    "t": 3,
    "c": "We assume that you'll go through this workshop in a directory named ~/reach/workshop-relay:"
  },
  {
    "objectID": "/workshop/relay/#p_3",
    "pt": "Relay Account",
    "t": 3,
    "c": "And that you have a copy of Reach installed in ~/reach so you can write"
  },
  {
    "objectID": "/workshop/relay/#p_4",
    "pt": "Relay Account",
    "t": 3,
    "c": "And it will run Reach. You should start off by initializing your Reach program:"
  },
  {
    "objectID": "/workshop/relay/#p_5",
    "pt": "Relay Account",
    "t": 3,
    "c": "For this workshop, we'll provide some constraints on your solution and problem analysis, since we'd like you to explore writing a Reach program with a specific design."
  },
  {
    "objectID": "/workshop/relay/#p_6",
    "pt": "Relay Account",
    "t": 3,
    "c": "The overall purpose of this application is so that:"
  },
  {
    "objectID": "/workshop/relay/#p_7",
    "pt": "Relay Account",
    "t": 3,
    "c": "Alice can decide an amount of funds to provide."
  },
  {
    "objectID": "/workshop/relay/#p_8",
    "pt": "Relay Account",
    "t": 3,
    "c": "Alice later decides who will have access to this by sharing a secret with them. We call this person, Bob."
  },
  {
    "objectID": "/workshop/relay/#p_9",
    "pt": "Relay Account",
    "t": 3,
    "c": "Bob can transfer the funds to wherever he'd like."
  },
  {
    "objectID": "/workshop/relay/#p_10",
    "pt": "Relay Account",
    "t": 3,
    "c": "In Hash Lock, we designed the application so that the \"secret\" was a special number that the contract compared against a known digest to release the funds. This approach was flawed, because when Bob used the secret to gain access, it was possible for anyone else to see the transaction and attempt to play it themselves."
  },
  {
    "objectID": "/workshop/relay/#p_11",
    "pt": "Relay Account",
    "t": 3,
    "c": "In today's workshop, we'll use a crucial insight about decentralized applications: account ownership is fluid and account credentials are a form of secret knowledge that every consensus network builds in to their foundation. With that in mind, let's use the following design:"
  },
  {
    "objectID": "/workshop/relay/#p_12",
    "pt": "Relay Account",
    "t": 3,
    "c": "This is called a relay account, because it exists temporarily to faciliate the relaying of funds from Alice to Bob."
  },
  {
    "objectID": "/workshop/relay/#p_13",
    "pt": "Relay Account",
    "t": 3,
    "c": "With this in mind, let's answer the questions:"
  },
  {
    "objectID": "/workshop/relay/#p_14",
    "pt": "Relay Account",
    "t": 3,
    "c": "Who are the principals of the application?"
  },
  {
    "objectID": "/workshop/relay/#p_15",
    "pt": "Relay Account",
    "t": 3,
    "c": "What are the participants of the program?"
  },
  {
    "objectID": "/workshop/relay/#p_16",
    "pt": "Relay Account",
    "t": 3,
    "c": "What information do they know at the start of the program?"
  },
  {
    "objectID": "/workshop/relay/#p_17",
    "pt": "Relay Account",
    "t": 3,
    "c": "What information are they going to discover and use in the program?"
  },
  {
    "objectID": "/workshop/relay/#p_18",
    "pt": "Relay Account",
    "t": 3,
    "c": "What funds change ownership during the application and how?"
  },
  {
    "objectID": "/workshop/relay/#p_19",
    "pt": "Relay Account",
    "t": 3,
    "c": "Let's see how your answers compare to our answers:"
  },
  {
    "objectID": "/workshop/relay/#p_20",
    "pt": "Relay Account",
    "t": 3,
    "c": "This application involves two principals: Alice, who sends funds, and Bob, who receives funds."
  },
  {
    "objectID": "/workshop/relay/#p_21",
    "pt": "Relay Account",
    "t": 3,
    "c": "The program has two participants: Alice, who initiates the application, and the Relay, which transfers the funds to Bob."
  },
  {
    "objectID": "/workshop/relay/#p_22",
    "pt": "Relay Account",
    "t": 3,
    "c": "Alice starts knowing the amount she wants to transfer."
  },
  {
    "objectID": "/workshop/relay/#p_23",
    "pt": "Relay Account",
    "t": 3,
    "c": "Alice creates the Relay account, while the Relay account learns the address of Bob, who will receive the funds."
  },
  {
    "objectID": "/workshop/relay/#p_24",
    "pt": "Relay Account",
    "t": 3,
    "c": "The funds start with Alice and then move to Bob under the instruction of the Relay."
  },
  {
    "objectID": "/workshop/relay/#p_25",
    "pt": "Relay Account",
    "t": 3,
    "c": "The most surprising thing about this application is that Bob is not one of the participants in the application! Of course, the Relay will actually run under the auspices of Bob, after Alice shares the account credentials with him, but there is a distinction in the program between Bob's identity and the Relay's."
  },
  {
    "objectID": "/workshop/relay/#p_26",
    "pt": "Relay Account",
    "t": 3,
    "c": "The next step of designing our program is representing this information in our program and deciding the participant interact interface for each participant. Which pieces of information go with which participants? Which are functions and which are values? Finally, how should the Relay account information and Bob's identity be represented? (Hint: Reach has a type named {!rsh} Address that represents an account address!)"
  },
  {
    "objectID": "/workshop/relay/#p_27",
    "pt": "Relay Account",
    "t": 3,
    "c": "Refer to Types for a reminder of what data types are available in Reach."
  },
  {
    "objectID": "/workshop/relay/#p_28",
    "pt": "Relay Account",
    "t": 3,
    "c": "Let's compare notes again. Here's what we wrote in our program:"
  },
  {
    "objectID": "/workshop/relay/#p_29",
    "pt": "Relay Account",
    "t": 3,
    "c": "We chose to represent the amount as a {!rsh} UInt field, which should be unsurprising. We then have two functions that take no arguments and return an {!rsh} Address which respectively return the Relay identity and the Bob identity. The idea here is that Alice will create the Relay account in the midst of the program and Bob will provide his own identity when he's acting as Relay."
  },
  {
    "objectID": "/workshop/relay/#p_30",
    "pt": "Relay Account",
    "t": 3,
    "c": "Now, we can write down the structure of communication and action in our application. Try this on your own based on your experience with Hash Lock."
  },
  {
    "objectID": "/workshop/relay/#p_31",
    "pt": "Relay Account",
    "t": 3,
    "c": "Here's what we wrote:"
  },
  {
    "objectID": "/workshop/relay/#p_32",
    "pt": "Relay Account",
    "t": 3,
    "c": "We assume that most of you found it natural to think of steps one, three, and four, but found step two to be a strange addition. Perhaps you felt that step two is implied by step one, where Alice says who the Relay is. But, it all depends upon what the meaning of the word \"is\" is. Since that is unclear to some, we'll make it explicit by stating that the consensus will remember the Relay's identity."
  },
  {
    "objectID": "/workshop/relay/#p_33",
    "pt": "Relay Account",
    "t": 3,
    "c": "The next step is to convert this pattern into actual program code using {!rsh} publish, {!rsh} pay, and {!rsh} commit. However, we expect that you'll need a bit of help with step two. Reach has a special operation, available only in consensus steps, for asserting the identity of a participant: {!rsh} Participant.set. You can write {!rsh} Relay.set(someAddr) to assert that the address of the Relay is {!rsh} someAddr. With that in mind..."
  },
  {
    "objectID": "/workshop/relay/#p_34",
    "pt": "Relay Account",
    "t": 3,
    "c": "The body of your application should look something like:"
  },
  {
    "objectID": "/workshop/relay/#p_35",
    "pt": "Relay Account",
    "t": 3,
    "c": "We expect that for most of you, the coding of step four is also a bit strange, because we've never seen an example where the destination of a transfer is not a participant. You may have thought that the {!rsh} to position in a {!rsh} transfer must be a participant, but actually it can be any address. Participants, however, can be used as addresses if they are bound."
  },
  {
    "objectID": "/workshop/relay/#p_36",
    "pt": "Relay Account",
    "t": 3,
    "c": "You might like to re-write this program to have a third participant, Bob, who takes no actions, and try to write {!rsh} transfer(amt).to(Bob). You'll find that Reach rejects this program because Bob is not bound. You can correct this by adding {!rsh} Bob.set(bob) after the Relay publishes Bob's address. There's nothing better about this version of the program, but it is unneccessary to have a participant like Bob that performs no part in the computation."
  },
  {
    "objectID": "/workshop/relay/#p_37",
    "pt": "Relay Account",
    "t": 3,
    "c": "As usual, we should consider what assertions we can add to our program. In some ways this is what we just did with the {!rsh} Relay.set(relay) line above, but that is unlike a normal assertion in that it is added primarily to direct the runtime activities on the consensus contract, rather than as a statement about the logical properties of our program variables."
  },
  {
    "objectID": "/workshop/relay/#p_38",
    "pt": "Relay Account",
    "t": 3,
    "c": "Sometimes it can be difficult to decide which things are part of the application, like this, and which things are properties of the application, like the assertions we've seen before. This is a general problem in verification where the logical properties of the desired program are often mixed up with the logical properties of the actual program. If you're interested in this topic, you might like to spend time reading about formal specification on Wikipedia."
  },
  {
    "objectID": "/workshop/relay/#p_39",
    "pt": "Relay Account",
    "t": 3,
    "c": "Now, if we were devious, we might send you on a SNARK hunt after some more assertions to add to our program, but we're not mean, so we'll just tell you that there's nothing else to assert about this program."
  },
  {
    "objectID": "/workshop/relay/#p_40",
    "pt": "Relay Account",
    "t": 3,
    "c": "Next, we need to insert the appropriate calls to {!rsh} interact. In this case, our program is very simple and we expect you'll do a great job without further discussion."
  },
  {
    "objectID": "/workshop/relay/#p_41",
    "pt": "Relay Account",
    "t": 3,
    "c": "Let's look at our whole program now:"
  },
  {
    "objectID": "/workshop/relay/#p_42",
    "pt": "Relay Account",
    "t": 3,
    "c": "This program is a bit odd to test, because it relies on Alice creating a temporary account and then sharing its information with Bob. We don't know of any beautiful way to derive this program from first principles, and instead must appeal to your JavaScript programming skills. If you'd like a hint, remember that you can call {!js} stdlib.newTestAccount any number of times and that a backend's participant functions don't need to be called at the same time."
  },
  {
    "objectID": "/workshop/relay/#p_43",
    "pt": "Relay Account",
    "t": 3,
    "c": "If you're brave, then try it yourself; otherwise, scroll down to see our solution."
  },
  {
    "objectID": "/workshop/relay/#p_44",
    "pt": "Relay Account",
    "t": 3,
    "c": "Here's the JavaScript frontend we wrote:"
  },
  {
    "objectID": "/workshop/relay/#p_45",
    "pt": "Relay Account",
    "t": 3,
    "c": "We do a few sneaky things in this program:"
  },
  {
    "objectID": "/workshop/relay/#p_46",
    "pt": "Relay Account",
    "t": 3,
    "c": "Lines 17 through 20 create a JavaScript Promise that will be filled in later by Alice."
  },
  {
    "objectID": "/workshop/relay/#p_47",
    "pt": "Relay Account",
    "t": 3,
    "c": "Alice's {!rsh} getRelay function (lines 25 through 31) creates the new account and communicates it \"outside of the network\" through the aforementioned Promise."
  },
  {
    "objectID": "/workshop/relay/#p_48",
    "pt": "Relay Account",
    "t": 3,
    "c": "Bob's thread (lines 33 through 47) waits for the Promise to resolve and then connects to the application with this new account."
  },
  {
    "objectID": "/workshop/relay/#p_49",
    "pt": "Relay Account",
    "t": 3,
    "c": "The Relay's {!rsh} getBob function (lines 42 through 45) returns his own address to receive the funds."
  },
  {
    "objectID": "/workshop/relay/#p_50",
    "pt": "Relay Account",
    "t": 3,
    "c": "If this program is scary for you, don't worry! It uses some fairly esoteric JavaScript features to make a completely automated test of this program. If instead you wrote it so that it ran interactively and had Bob paste in the information about the new Relay account, it might be easier for you to code with those two aspects totally separated."
  },
  {
    "objectID": "/workshop/relay/#p_51",
    "pt": "Relay Account",
    "t": 3,
    "c": "Let's see what it looks like when we run this program:"
  },
  {
    "objectID": "/workshop/relay/#p_52",
    "pt": "Relay Account",
    "t": 3,
    "c": "Great job! You could use this application today and start minting gift cards of tokens for your friends on their birthdays! Wouldn't that be fun?"
  },
  {
    "objectID": "/workshop/relay/#p_53",
    "pt": "Relay Account",
    "t": 3,
    "c": "If you found this workshop rewarding, please let us know on the Discord community!"
  },
  {
    "objectID": "/workshop/relay/#p_54",
    "pt": "Relay Account",
    "t": 3,
    "c": "If you'd like to make this application a little more interesting, maybe you'd like to have a secret password just like the hash lock as well, so Alice can separate the revealing of information to Bob."
  },
  {
    "objectID": "/workshop/relay/#p_55",
    "pt": "Relay Account",
    "t": 3,
    "c": "If you want to know what to do next to advance your study of decentralized application design, a natural extension of the concepts in this workshop is a trust fund. Why don't you check it out?"
  },
  {
    "objectID": "/workshop/trust-fund/#workshop-trust-fund",
    "pt": "Trust Fund",
    "t": 2,
    "c": "Trust Fund"
  },
  {
    "objectID": "/workshop/trust-fund/#workshop-trust-fund-pr",
    "pt": "Trust Fund",
    "t": 2,
    "c": "Problem Analysis"
  },
  {
    "objectID": "/workshop/trust-fund/#workshop-trust-fund-dd",
    "pt": "Trust Fund",
    "t": 2,
    "c": "Data Definition"
  },
  {
    "objectID": "/workshop/trust-fund/#workshop-trust-fund-cc",
    "pt": "Trust Fund",
    "t": 2,
    "c": "Communication Construction"
  },
  {
    "objectID": "/workshop/trust-fund/#workshop-trust-fund-ai",
    "pt": "Trust Fund",
    "t": 2,
    "c": "Assertion Insertion"
  },
  {
    "objectID": "/workshop/trust-fund/#workshop-trust-fund-ii",
    "pt": "Trust Fund",
    "t": 2,
    "c": "Interaction Introduction"
  },
  {
    "objectID": "/workshop/trust-fund/#workshop-trust-fund-de",
    "pt": "Trust Fund",
    "t": 2,
    "c": "Deployment Decisions"
  },
  {
    "objectID": "/workshop/trust-fund/#workshop-trust-fund-dns",
    "pt": "Trust Fund",
    "t": 2,
    "c": "Discussion and Next Steps"
  },
  {
    "objectID": "/workshop/trust-fund/#p_0",
    "pt": "Trust Fund",
    "t": 3,
    "c": "In this workshop, we'll look at yet another strategy for transferring funds, but in this version, we'll think about it as establishing a \"trust fund\": a funder will establish an account for the receiver, which they must wait a certain amount of time to access, and if they do not, then it reverts to the funder, and if the funder does not claim it, then it is dormant and any third party can remove the funds. You could think of this as a variant of the relay account, with a mandatory waiting period and two fallbacks on non-participation."
  },
  {
    "objectID": "/workshop/trust-fund/#p_1",
    "pt": "Trust Fund",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Relay Account."
  },
  {
    "objectID": "/workshop/trust-fund/#p_2",
    "pt": "Trust Fund",
    "t": 3,
    "c": "We assume that you'll go through this workshop in a directory named ~/reach/workshop-trust-fund:"
  },
  {
    "objectID": "/workshop/trust-fund/#p_3",
    "pt": "Trust Fund",
    "t": 3,
    "c": "And that you have a copy of Reach installed in ~/reach so you can write"
  },
  {
    "objectID": "/workshop/trust-fund/#p_4",
    "pt": "Trust Fund",
    "t": 3,
    "c": "And it will run Reach. You should start off by initializing your Reach program:"
  },
  {
    "objectID": "/workshop/trust-fund/#p_5",
    "pt": "Trust Fund",
    "t": 3,
    "c": "For this workshop, we'll provide some constraints on your solution and problem analysis, since we'd like you to explore writing a Reach program with a specific design."
  },
  {
    "objectID": "/workshop/trust-fund/#p_6",
    "pt": "Trust Fund",
    "t": 3,
    "c": "The overall purpose of this application is so that:"
  },
  {
    "objectID": "/workshop/trust-fund/#p_7",
    "pt": "Trust Fund",
    "t": 3,
    "c": "The Funder must decide an amount of funds to provide, as well as all of the other parameters of the application."
  },
  {
    "objectID": "/workshop/trust-fund/#p_8",
    "pt": "Trust Fund",
    "t": 3,
    "c": "The Funder will know the identity of the Receiver at the beginning."
  },
  {
    "objectID": "/workshop/trust-fund/#p_9",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Whomever ultimately receives the funds transfers it to themselves."
  },
  {
    "objectID": "/workshop/trust-fund/#p_10",
    "pt": "Trust Fund",
    "t": 3,
    "c": "With this in mind, let's answer the questions:"
  },
  {
    "objectID": "/workshop/trust-fund/#p_11",
    "pt": "Trust Fund",
    "t": 3,
    "c": "What are the participants of the application?"
  },
  {
    "objectID": "/workshop/trust-fund/#p_12",
    "pt": "Trust Fund",
    "t": 3,
    "c": "What information do they know at the start of the program?"
  },
  {
    "objectID": "/workshop/trust-fund/#p_13",
    "pt": "Trust Fund",
    "t": 3,
    "c": "What information are they going to discover and use in the program?"
  },
  {
    "objectID": "/workshop/trust-fund/#p_14",
    "pt": "Trust Fund",
    "t": 3,
    "c": "What funds change ownership during the application and how?"
  },
  {
    "objectID": "/workshop/trust-fund/#p_15",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Let's see how your answers compare to our answers:"
  },
  {
    "objectID": "/workshop/trust-fund/#p_16",
    "pt": "Trust Fund",
    "t": 3,
    "c": "This application involves three participants: the Funder, the Receiver, and a Bystander."
  },
  {
    "objectID": "/workshop/trust-fund/#p_17",
    "pt": "Trust Fund",
    "t": 3,
    "c": "The Funder knows the identity of the Receiver, the amount, as well as the maturity of the fund, and the delays before which it will be declared dormant or forsook."
  },
  {
    "objectID": "/workshop/trust-fund/#p_18",
    "pt": "Trust Fund",
    "t": 3,
    "c": "The Receiver and the Bystander don't learn or provide anything, aside from the existence of the fund and its maturity."
  },
  {
    "objectID": "/workshop/trust-fund/#p_19",
    "pt": "Trust Fund",
    "t": 3,
    "c": "The funds start with the Funder and then move to either the Receiver, the Funder, or the Bystander, depending on when they are claimed."
  },
  {
    "objectID": "/workshop/trust-fund/#p_20",
    "pt": "Trust Fund",
    "t": 3,
    "c": "The next step of designing our program is representing this information in our program and deciding the participant interact interface for each participant. In this application, we'll be using a new concept of Reach: the time delta. The trust fund has a \"maturity\", as well as the lengths of time before which the fund is forsook or abandoned. In the fiat world, these would likely be expressed as real time durations, like months and years. However, on most consensus networks there is an abstraction of time into something like a \"block height\", which represents the number of rounds of consensus which have reached their conclusion. There is a loose relationship of these notions to real-time, but most networks do not guarantee any particular connection. (Indeed, such a connection between the abstract world of consensus networks and the \"real\" world is typically provided by an oracle.) Reach abstracts the details of particular consensus networks away into the concept of a time delta, which is represented by an integer in Reach programs, and used in positions that reference time."
  },
  {
    "objectID": "/workshop/trust-fund/#p_21",
    "pt": "Trust Fund",
    "t": 3,
    "c": "With that knowledge in hand,"
  },
  {
    "objectID": "/workshop/trust-fund/#p_22",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Let's compare notes again. Here's what we wrote in our program:"
  },
  {
    "objectID": "/workshop/trust-fund/#p_23",
    "pt": "Trust Fund",
    "t": 3,
    "c": "We've represented most values as {!rsh} UInt fields, and created a \"common\" interface that has a series of signals for the different phases of the application: one for when the account is {!rsh} funded, one for when the particular participant is {!rsh} ready to extract the funds, and finally one for when they have successfuly {!rsh} recvd (received) them."
  },
  {
    "objectID": "/workshop/trust-fund/#p_24",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Now, we can write down the structure of communication and action in our application. Try this on your own based on your experience with Relay Account."
  },
  {
    "objectID": "/workshop/trust-fund/#p_25",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Here's what we wrote:"
  },
  {
    "objectID": "/workshop/trust-fund/#p_26",
    "pt": "Trust Fund",
    "t": 3,
    "c": "The next step is to convert this pattern into actual program code using {!rsh} publish, {!rsh} pay, and {!rsh} commit. However, this program gives us the opportunity to look at a few more features of Reach."
  },
  {
    "objectID": "/workshop/trust-fund/#p_27",
    "pt": "Trust Fund",
    "t": 3,
    "c": "First, how do we implement step three, where each party waits for the fund to mature? Reach has a primitive named {!rsh} wait which causes this to happen. This may only occur in a step, which is the same context where {!rsh} publish may occur. This primitive, however, doesn't just cause the participants to wait, instead it guarantees that the entire computation waits. In other words, this means that the contract will ensure that the later steps do not occur until after the waiting time."
  },
  {
    "objectID": "/workshop/trust-fund/#p_28",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Second, how do we implement steps four and five, where there is a deadline for an action to take place? Reach publication steps take an option called {!rsh} .timeout that specifies an alternative computation to occur if the first does not take place before the deadline. The syntax looks like: {!rsh} publish().timeout(deadline, () => alternative), which uses the arrow expression syntax for specifying the alternative computation."
  },
  {
    "objectID": "/workshop/trust-fund/#p_29",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Finally, we hope you notice that steps four, five, and six are extremely similar. Consider trying to write a function that is used three times to implement all of them!"
  },
  {
    "objectID": "/workshop/trust-fund/#p_30",
    "pt": "Trust Fund",
    "t": 3,
    "c": "The body of your application should look something like:"
  },
  {
    "objectID": "/workshop/trust-fund/#p_31",
    "pt": "Trust Fund",
    "t": 3,
    "c": "If you'd like to see how you might contain the repetition into a function, keep reading!"
  },
  {
    "objectID": "/workshop/trust-fund/#p_32",
    "pt": "Trust Fund",
    "t": 3,
    "c": "As usual, we should consider what assertions we can add to our program, but this program doesn't have any interesting properties to prove, so we'll move on. Or rather, all of its interesting properties are the ones automatically included in all Reach programs, like that the funds are used linearly and nothing is left over in the account at the end, or that the protocol steps must be received before the corresponding deadlines."
  },
  {
    "objectID": "/workshop/trust-fund/#p_33",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Next, we need to insert the appropriate calls to {!rsh} interact. In this case, our program is very simple and we expect you'll do a great job without further discussion. However, if you want to simplify things, you might like to use {!rsh} each to signal to all the parties that the account is funded, rather than duplicating the interaction code over and over."
  },
  {
    "objectID": "/workshop/trust-fund/#p_34",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Let's look at our whole program now:"
  },
  {
    "objectID": "/workshop/trust-fund/#p_35",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Lines 33 and 34 use {!rsh} each to run the same code block {!rsh} only in each of the given participants."
  },
  {
    "objectID": "/workshop/trust-fund/#p_36",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Lines 51 through 59 abstract the duplicate copied repeated structure of the program into three calls to the same function."
  },
  {
    "objectID": "/workshop/trust-fund/#p_37",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Lines 37 through 49 define this function as one that abstracts over who is permitted to extract the funds and whether there is a deadline."
  },
  {
    "objectID": "/workshop/trust-fund/#p_38",
    "pt": "Trust Fund",
    "t": 3,
    "c": "This program demonstrates some of the remarkable features of Reach: we were able to abstract away a pattern of communication into a function and use it repeatedly and in different ways. Behind the scenes, when Reach compiles this program into a contract, it will derive a four step protocol with implicit state to check that the appropriate participant takes their action only when allowed."
  },
  {
    "objectID": "/workshop/trust-fund/#p_39",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Next, it is time to test our program. As usual, we'll present a completely automated test deployment, rather than an interactive one. This means that we'll have to have our participants purposefully \"miss\" their deadlines so we can see that the timeouts and deadlines work correctly. We'll implement it by abstracting away the test into a function of two parameters: booleans that decide whether the Receiver and Funder (respectively) should miss their deadline. We'll implement this miss by using the standard library function {!js} stdlib.wait which takes a time delta encoded as a number. This function is like {!rsh} wait, except it is local only to a single participant and has no bearing on the rules of the application. It's just a convenience mechanism for allowing time to pass on the consensus network."
  },
  {
    "objectID": "/workshop/trust-fund/#p_40",
    "pt": "Trust Fund",
    "t": 3,
    "c": "We highly recommend that you try to implement a test setup like this yourself; when you're done, scroll down to see our solution."
  },
  {
    "objectID": "/workshop/trust-fund/#p_41",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Here's the JavaScript frontend we wrote:"
  },
  {
    "objectID": "/workshop/trust-fund/#p_42",
    "pt": "Trust Fund",
    "t": 3,
    "c": "The most interesting part of this program is on lines 20 through 23 when we optionally cause a delay in the participant after they receive the signal that the account is funded."
  },
  {
    "objectID": "/workshop/trust-fund/#p_43",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Let's see what it looks like when we run this program:"
  },
  {
    "objectID": "/workshop/trust-fund/#p_44",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Great job! You could use this application today and start putting your child's college funds away for safe keeping! Although, perhaps you should wait until you read the workshop about interest-bearing accounts like this."
  },
  {
    "objectID": "/workshop/trust-fund/#p_45",
    "pt": "Trust Fund",
    "t": 3,
    "c": "If you found this workshop rewarding, please let us know on the Discord community!"
  },
  {
    "objectID": "/workshop/trust-fund/#p_46",
    "pt": "Trust Fund",
    "t": 3,
    "c": "If you'd like to make this application a little more interesting, maybe you'd like to have a secret password just like the hash lock as well, so the Funder can separate the revealing of information to Receiver. Similarly, you could make it like a relay account and have the Receiver generated by the Funder and allow the Receiver to specify a third-party (fourth-party) to receive the actual funds."
  },
  {
    "objectID": "/workshop/trust-fund/#p_47",
    "pt": "Trust Fund",
    "t": 3,
    "c": "We recommend that you take a pause from workshops like this and revisit the Rock, Paper, Scissors! application in the fairness workshop. Why don't you check it out?"
  },
  {
    "objectID": "/guide/determ/#guide-determ",
    "pt": "Determinism, simultaneity, and choice in decentralized applications",
    "t": 2,
    "c": "Determinism, simultaneity, and choice in decentralized applications"
  },
  {
    "objectID": "/guide/determ/#p_0",
    "pt": "Determinism, simultaneity, and choice in decentralized applications",
    "t": 3,
    "c": "The structure of a Reach computation is deterministic, because at each point in a computation, all participants agree on which publication is the next one in the computation. If this were not the case, then different participants may attempt to pursue different paths through a computation and thereby reach different values at the end. This deterministic structure, however, does not mean that the participant that provides the publication must be fixed, merely that which publication event is next must be fixed; see for example {!rsh} race expressions and the the guide section on races for an elaboration of this point. Even in the presence of this non-determinism in actors, Reach programs remain deterministic in their structure."
  },
  {
    "objectID": "/guide/determ/#p_1",
    "pt": "Determinism, simultaneity, and choice in decentralized applications",
    "t": 3,
    "c": "However, many developers think of their application as having a step when two participants act simultaneously. For example, in a game of Rock, Paper, Scissors! in the real world, both players simultaneously choose their hands. Similarly, a rental agreement gives both the landlord and the tenant the ability to cancel the agreement (subject to some penalty) at any time. In both of these cases, it is not clear how to understand this interaction as being sequential and deterministic."
  },
  {
    "objectID": "/guide/determ/#p_2",
    "pt": "Determinism, simultaneity, and choice in decentralized applications",
    "t": 3,
    "c": "At first glance, these situations appear different. In the first, the participants are doing \"the same thing\" simultaneously, because both will submit a hand eventually; while in the second, they are doing \"something different\", because only one of them will actually end the agreement early. However, both of these situations are actually identical, because in the second case they are both simultaneously deciding whether they will end early. In the first case, the participants are submitting one of three values (Rock, Paper, or Scissors), while in the second they are submitting one of two (Leave or Stay)."
  },
  {
    "objectID": "/guide/determ/#p_3",
    "pt": "Determinism, simultaneity, and choice in decentralized applications",
    "t": 3,
    "c": "In such situations, in a decentralized application, the program must agree that one participant acts first. The important thing to realize is that \"simultaneity\" is not the same thing as \"non-determinism\". The pertinent design detail is whether one participant has an advantage for going in any particular order. If there is no advantage for either place, then the developer can arbitrarily decide to go in one order. If there is an advantage, then a commitment strategy similar to the Rock, Paper, Scissors! tutorial should be used."
  },
  {
    "objectID": "/guide/determ/#p_4",
    "pt": "Determinism, simultaneity, and choice in decentralized applications",
    "t": 3,
    "c": "For example, in the rental agreement, if we felt there was no advantage for going second, then we could have either the landlord or the tenant go first. But, is there no advantage? If both the tenant and the landlord want to exit in the same month, but the landlord goes first, then the landlord would suffer a loss of their deposit; but, if they fairly shared their choice at the same time, then they could both be refunded in this case. This is an example of the Pareto improvements that are possible in decentralized applications relative to existing institutions."
  },
  {
    "objectID": "/guide/determ/#p_5",
    "pt": "Determinism, simultaneity, and choice in decentralized applications",
    "t": 3,
    "c": "See rental workshop for a discussion of this example in further detail."
  },
  {
    "objectID": "/guide/abstract/#guide-abstract",
    "pt": "Building decentralized abstractions",
    "t": 2,
    "c": "Building decentralized abstractions"
  },
  {
    "objectID": "/guide/abstract/#p_0",
    "pt": "Building decentralized abstractions",
    "t": 3,
    "c": "Many decentralized applications have the same structure, similar to how there are many games that can be categorized as combinatorial games or simultaneous games."
  },
  {
    "objectID": "/guide/abstract/#p_1",
    "pt": "Building decentralized abstractions",
    "t": 3,
    "c": "These applications can either be programmed individually, or you can build an abstraction that captures the common structure of a game. Reach supports typical programming language abstractions, like first-class functions (via arrow expressions) and objects, that can be used to build these abstractions."
  },
  {
    "objectID": "/guide/abstract/#p_2",
    "pt": "Building decentralized abstractions",
    "t": 3,
    "c": "When building such abstractions, the most difficult part is correctly capturing loop invariants of the user of the abstraction on the inside of the abstraction. Often, this means the abstraction must set up a protocol to communicate with its user, such as by receiving an invariant captured by an arrow expression."
  },
  {
    "objectID": "/guide/abstract/#p_3",
    "pt": "Building decentralized abstractions",
    "t": 3,
    "c": "See the abstraction workshop for a walkthrough of building such an abstraction."
  },
  {
    "objectID": "/workshop/fomo/#workshop-fomo",
    "pt": "Fear of Missing Out",
    "t": 2,
    "c": "Fear of Missing Out"
  },
  {
    "objectID": "/workshop/fomo/#workshop-fomo-pr",
    "pt": "Fear of Missing Out",
    "t": 2,
    "c": "Problem Analysis"
  },
  {
    "objectID": "/workshop/fomo/#workshop-fomo-dd",
    "pt": "Fear of Missing Out",
    "t": 2,
    "c": "Data Definition"
  },
  {
    "objectID": "/workshop/fomo/#workshop-fomo-cc",
    "pt": "Fear of Missing Out",
    "t": 2,
    "c": "Communication Construction"
  },
  {
    "objectID": "/workshop/fomo/#workshop-fomo-ai",
    "pt": "Fear of Missing Out",
    "t": 2,
    "c": "Assertion Insertion"
  },
  {
    "objectID": "/workshop/fomo/#workshop-fomo-ii",
    "pt": "Fear of Missing Out",
    "t": 2,
    "c": "Interaction Introduction"
  },
  {
    "objectID": "/workshop/fomo/#workshop-fomo-de",
    "pt": "Fear of Missing Out",
    "t": 2,
    "c": "Deployment Decisions"
  },
  {
    "objectID": "/workshop/fomo/#workshop-fomo-dns",
    "pt": "Fear of Missing Out",
    "t": 2,
    "c": "Discussion and Next Steps"
  },
  {
    "objectID": "/workshop/fomo/#p_0",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "In this workshop, we'll design an application that allows a Funder to create an auction where participants may purchase tickets. The Funder sets a ticket price and a relative deadline. When a Buyer purchases a ticket, the deadline is reset. Whoever is the last person to buy a ticket—when the deadline finally hits—wins the entire balance. This program is based off of the crypto game, FOMO3DGame."
  },
  {
    "objectID": "/workshop/fomo/#p_1",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "This workshop utilizes participant classes to represent Buyers, which allows us to handle multiple participants in a generic way."
  },
  {
    "objectID": "/workshop/fomo/#p_2",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "This workshop is independent of all others."
  },
  {
    "objectID": "/workshop/fomo/#p_3",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "We assume that you'll go through this workshop in a directory named ~/reach/workshop-fomo:"
  },
  {
    "objectID": "/workshop/fomo/#p_4",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "And that you have a copy of Reach installed in ~/reach so you can write"
  },
  {
    "objectID": "/workshop/fomo/#p_5",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "And it will run Reach. You should start off by initializing your Reach program:"
  },
  {
    "objectID": "/workshop/fomo/#p_6",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "First, we should think over the details of the application and answer some questions to help reason about the implementation of the program."
  },
  {
    "objectID": "/workshop/fomo/#p_7",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "You should write the answer to the following questions in your Reach program (index.rsh) using a comment. {!rsh} /* Remember comments are written like this. */"
  },
  {
    "objectID": "/workshop/fomo/#p_8",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Who is involved in this application?"
  },
  {
    "objectID": "/workshop/fomo/#p_9",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "What information do they know at the start of the program?"
  },
  {
    "objectID": "/workshop/fomo/#p_10",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "What information are they going to discover and use in the program?"
  },
  {
    "objectID": "/workshop/fomo/#p_11",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "What funds change ownership during the application and how?"
  },
  {
    "objectID": "/workshop/fomo/#p_12",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Let's see how your answers compare to ours:"
  },
  {
    "objectID": "/workshop/fomo/#p_13",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "This program involves two parties: a Funder who deploys the auction and the Buyers who purchase tickets."
  },
  {
    "objectID": "/workshop/fomo/#p_14",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "The Funder knows the deadline and the ticket price at the start of the application."
  },
  {
    "objectID": "/workshop/fomo/#p_15",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "The Buyers do not know anything of the deadline or ticket price when the application begins."
  },
  {
    "objectID": "/workshop/fomo/#p_16",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "The Funder does not learn anything during the program execution."
  },
  {
    "objectID": "/workshop/fomo/#p_17",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "The Buyers learn of the ticket price and deadline during the program execution."
  },
  {
    "objectID": "/workshop/fomo/#p_18",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Buyers continually add funds to the balance during execution until one Buyer wins the entire balance."
  },
  {
    "objectID": "/workshop/fomo/#p_19",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "It's okay if some of your answers differ from ours!"
  },
  {
    "objectID": "/workshop/fomo/#p_20",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "After problem analysis, we need to decide how we will represent the information in the program:"
  },
  {
    "objectID": "/workshop/fomo/#p_21",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "What data type will represent the deadline set by the Funder?"
  },
  {
    "objectID": "/workshop/fomo/#p_22",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "What data type will represent the ticket price set by the Funder?"
  },
  {
    "objectID": "/workshop/fomo/#p_23",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "What data type will represent the Buyer's decision to purchase a ticket?"
  },
  {
    "objectID": "/workshop/fomo/#p_24",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Refer to Types for a reminder of what data types are available in Reach."
  },
  {
    "objectID": "/workshop/fomo/#p_25",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Now that we've decided what data types to use, we need to determine how the programs will obtain this information. We need to outline the participant interact interface for each participant."
  },
  {
    "objectID": "/workshop/fomo/#p_26",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "What participant interact interface will Funder use?"
  },
  {
    "objectID": "/workshop/fomo/#p_27",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "What participant interact interface will Buyer use?"
  },
  {
    "objectID": "/workshop/fomo/#p_28",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Revisit the problem analysis section when completing this section. Whenever a participant starts off with some knowledge, that will be a field in the {!rsh} interact object. If they learn something, then it will be an argument to a function. If they provide something later, then it will be the result of a function."
  },
  {
    "objectID": "/workshop/fomo/#p_29",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "You should write your answers in your Reach file (index.rsh) as the participant interact interface for each of the participants."
  },
  {
    "objectID": "/workshop/fomo/#p_30",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Let's compare your answers with ours:"
  },
  {
    "objectID": "/workshop/fomo/#p_31",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "The deadline will be represented with a {!rsh} UInt, as it is a relative time delta signifying a change in block numbers."
  },
  {
    "objectID": "/workshop/fomo/#p_32",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "The ticketPrice will be represented with a {!rsh} UInt"
  },
  {
    "objectID": "/workshop/fomo/#p_33",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "The decision to buy a ticket will be represented by a function {!rsh} Fun([UInt], Bool)"
  },
  {
    "objectID": "/workshop/fomo/#p_34",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Our participant interact interface, with the addition of some handy logging functions, looks like this so far:"
  },
  {
    "objectID": "/workshop/fomo/#p_35",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "At this point, you can modify your JavaScript file (index.mjs) to contain definitions of these values, although you may want to use placeholders for the actual values. When you're writing a Reach program, especially in the early phases, you should have these two files open side-by-side and update them in tandem as you're deciding the participant interact interface."
  },
  {
    "objectID": "/workshop/fomo/#p_36",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "A fundamental aspect of a decentralized application is the pattern of communication and transfer among the participants. We should write down this structure as comments in our program to serve as an outline and guide us in implementation. For example, for the tutorial version of Rock, Paper, Scissors!, we might write:"
  },
  {
    "objectID": "/workshop/fomo/#p_37",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "You should do this now, in your Reach program (index.rsh)."
  },
  {
    "objectID": "/workshop/fomo/#p_38",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Here's what we wrote for our outline:"
  },
  {
    "objectID": "/workshop/fomo/#p_39",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Now, this outline needs to be converted to a real program."
  },
  {
    "objectID": "/workshop/fomo/#p_40",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "The body of your application should look something like this:"
  },
  {
    "objectID": "/workshop/fomo/#p_41",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "We use {!rsh} parallelReduce to allow Buyers to purchase tickets until the deadline passes and accumulate the current winner. We maintain the invariant that the balance must be equal to the number of tickets sold multiplied by the ticket price."
  },
  {
    "objectID": "/workshop/fomo/#p_42",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "This program doesn't have many interesting properties to prove as assertions, beyond the token linearity property. The only property of interest is the {!rsh} parallelReduce invariant which states that the balance must be equal to the number of tickets sold multiplied by the ticket price."
  },
  {
    "objectID": "/workshop/fomo/#p_43",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Next, we need to insert the appropriate calls to {!rsh} interact. In this case, our program is very simple and we expect you'll do a great job without further discussion."
  },
  {
    "objectID": "/workshop/fomo/#p_44",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Let's look at our whole program now:"
  },
  {
    "objectID": "/workshop/fomo/#p_45",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Next, it is time to test our program. As usual, we'll present a completely automated test deployment, rather than an interactive one."
  },
  {
    "objectID": "/workshop/fomo/#p_46",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "The program is fairly straightfoward to test. We just create test accounts for the Funder and any number of Buyers. The decision to purchase a ticket by a Buyer will rely simply on generating a random boolean."
  },
  {
    "objectID": "/workshop/fomo/#p_47",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Here's the JavaScript frontend we wrote:"
  },
  {
    "objectID": "/workshop/fomo/#p_48",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Let's see what it looks like when we run the program:"
  },
  {
    "objectID": "/workshop/fomo/#p_49",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Great job!"
  },
  {
    "objectID": "/workshop/fomo/#p_50",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "If you found this workshop rewarding, please let us know on the Discord community!"
  },
  {
    "objectID": "/workshop/fomo/#p_51",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "If you'd like to make this application a little more interesting, maybe you'd like to extend this program to make the last N buyers split the winnings. Check out Fear of Missing Out Generalized for our solution!"
  },
  {
    "objectID": "/tut/rps/7-rpc/#tut-7-rpc",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 2,
    "c": "Rock, Paper, Scissors in Python"
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_0",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "The main sequence of the tutorial uses the JavaScript frontend support library to implement a frontend for our Reach program using JavaScript. But, Reach supports using any programming language through the Reach RPC Server."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_1",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "This tutorial walks through using this technique to implement a Rock, Paper, Scissors! frontend in Python. It is based on the frontend from Play and Play Again, so it does not include a text-based interface, or a Web interface, but uses the final version of the Reach code."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_2",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Below we will compare the Play and Play Again JavaScript frontend with the equivalent Python code communicating via RPC, section by section. Follow along by typing the Python code into a file called index.py."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_3",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "We begin by comparing the necessary imports and program body:"
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_4",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Rather than importing {!js} loadStdlib and {!js} backend as with the JavaScript version, the Python frontend instead plucks {!py} mk_rpc from its supporting {!py} reach_rpc library. It is unnecessary for an RPC frontend to import a backend because the RPC Server handles doing so instead."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_5",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "The Python version also borrows functionality from the {!py} random and {!py} threading libraries. These will be necessary when providing callable methods in the participant interact interface it offers the RPC server."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_6",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "On line 9 the Python program binds {!py} rpc and {!py} rpc_callbacks out of {!py} mk_rpc. These two functions are the only tools we will need to communicate with the RPC server. See Python for more details on how they work."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_7",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Next, we define our Alice and Bob accounts and pre-fund them each with a starting balance of 10."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_8",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Translating code which uses the JavaScript frontend support library to its Python RPC equivalent is a simple matter of specifying the corresponding RPC method (e.g. '/stdlib/newTestAccount'), and supplying the same arguments thereafter."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_9",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Now we define two helper functions and use them to query Alice and Bob's beginning balances:"
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_10",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Deploying and attaching to contracts works slightly differently over RPC:"
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_11",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "As previously mentioned, it is the responsibility of the RPC Server (rather than that of the frontend communicating over RPC) to interface with the DApp's backend, so that argument is absent in the Python version shown above. Instead, Alice's account RPC handle alone is sufficient for her to deploy. We also need to delay Bob's attach until later, because Python lacks Promises that work like JavaScript's. When we do attach Bob, only Bob's account RPC handle and Alice's contract RPC handle are necessary for him to attach."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_12",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "{!py} HAND and {!py} OUTCOME only differ syntactically from their JavaScript equivalents:"
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_13",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Even participant interact interface definitions remain largely the same:"
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_14",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Here, both the JavaScript and Python frontends begin declaring a reusable \"player constructor\". This constructor represents those fields which are common to both Alice and Bob's participant interact interfaces."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_15",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "The JavaScript code explicitly includes {!js} ...stdlib.hasRandom itself, but the Python code can instead direct the RPC server to append it to the interface by including {!py} 'stdlib.hasRandom': True as a field in the constructor's return value."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_16",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Next, they each define a {!py} getHand function which randomly selects an element from the previously defined {!py} HAND set and returns it to the backend. This function will be passed as a callable method of the interface later."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_17",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "The Python version does not mimic the JavaScript's occasional \"pause behavior\", although it easily could with a few extra lines of code."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_18",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "{!py} informTimeout requires no subsequent backend interaction and is accordingly easily to implement in either language:"
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_19",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "The same is true of {!py} seeOutcome:"
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_20",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "At the end of the Python code we return a {!py} dict that represents those fields which are common to both Alice and Bob's participant interact interfaces."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_21",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Again, {!py} 'stdlib.hasRandom': True has special significance when communicating via RPC: it instructs the server to append this signature on the receiving end."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_22",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Finally, we proceed to the most interesting part of the program and use the code we have built up thus far to actually play a game of Rock, Paper, Scissors!:"
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_23",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "In the Python version we create a function called {!py} play_alice and spawn it as a concurrent thread, which begins running in the background on line 56."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_24",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "{!py} play_alice sends Alice's contract RPC handle and her participant interact interface to the server with {!py} rpc_callbacks. The interface includes methods and values created by {!py} player('Alice'), and adds an additional {!py} wager value which is set to the result of {!py} rpc('/stdlib/parseCurrency', 5), as well as setting a {!py} deadline of {!py} 10."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_25",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Bob's interface is likewise defined and spawned as another thread, which also begins running concurrently on line 69. In Bob's case we add an {!py} acceptWager method instead of another value to his participant interact interface. Furthermore, his function is more complex, because we delay creating his contract handle until this time, so that the main thread does not block waiting for Alice's contract information to resolve. This separation is not necessary in JavaScript, because of how JavaScript Promises work."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_26",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Calling {!py} .join() on {!py} alice and {!py} bob instructs the main thread to wait until both child threads have run to completion, signifying the end of the Rock, Paper, Scissors! game. At this point we again collect each player's remaining balance and print them to the console. Each player's child thread will have already printed their success/failure result to the screen prior to reaching this step, because that is how we encoded their {!py} seeOutcome methods."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_27",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "All that remains is to release Alice and Bob's RPC handles from the server's memory on lines 80 and 81 with the /forget/acc and /forget/ctc methods, then instruct the Python process' interpreter to invoke our {!py} main function."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_28",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Now that we have written an entire Rock, Paper, Scissors! game in Python it is time to try running it."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_29",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "First you will need to copy the index.rsh file you used for the tutorial into the directory where you saved index.py."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_30",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Next, open a terminal in that directory and install the Reach Python RPC client:"
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_31",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "What is this \"venv\" thing?"
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_32",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "A Python venv is a \"virtual environment\" that sandboxes dependencies to avoid cluttering your system directories."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_33",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Then use ./reach rpc-run to play a game of Rock, Paper, Scissors!:"
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_34",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Consult the command-line reference section for more details on how this sub-command works."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_35",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Its output will be the same as the final tutorial version of the frontend:"
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_36",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "This will launch an RPC server using the development API key \"opensesame\" and a TLS certificate designed for testing."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_37",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Deploying your DApp into production with the RPC server requires obtaining a certificate which is specific to your DNS domain and which has been signed by a certificate authority such as Let's Encrypt."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_38",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Users who are ready to go live should consult the RPC Server command-line reference section for configuration details."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_39",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "When you are done, type deactivate to exit your venv."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_40",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Well done! You have just reimplemented the tutorial in Python."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_41",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "This tutorial uses Python to demonstrate how RPC frontends are built in Reach, but it is similarly easy to write RPC frontends in other languages, such as with the JavaScript and Go libraries."
  }
]