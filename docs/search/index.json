[
  {
    "objectID": "/#reach-top",
    "pt": "Reach: The Smartest, Fastest, and Safest DApp Programming Language",
    "t": 2,
    "c": "Reach: The Smartest, Fastest, and Safest DApp Programming Language"
  },
  {
    "objectID": "/build/#build",
    "pt": "Reach is for Builders",
    "t": 2,
    "c": "Reach is for Builders"
  },
  {
    "objectID": "/changelog/#cmd_reach%20compile",
    "pt": "Changelog",
    "t": 0,
    "s": "cmd",
    "c": "reach compile"
  },
  {
    "objectID": "/changelog/#cmd_reach%20init",
    "pt": "Changelog",
    "t": 0,
    "s": "cmd",
    "c": "reach init"
  },
  {
    "objectID": "/changelog/#cmd_reach%20run",
    "pt": "Changelog",
    "t": 0,
    "s": "cmd",
    "c": "reach run"
  },
  {
    "objectID": "/changelog/#cmd_reach%20down",
    "pt": "Changelog",
    "t": 0,
    "s": "cmd",
    "c": "reach down"
  },
  {
    "objectID": "/changelog/#cmd_reach%20docker-reset",
    "pt": "Changelog",
    "t": 0,
    "s": "cmd",
    "c": "reach docker-reset"
  },
  {
    "objectID": "/changelog/#cmd_reach%20docker-reset",
    "pt": "Changelog",
    "t": 0,
    "s": "cmd",
    "c": "reach docker-reset"
  },
  {
    "objectID": "/changelog/#cmd_reach%20devnet",
    "pt": "Changelog",
    "t": 0,
    "s": "cmd",
    "c": "reach devnet"
  },
  {
    "objectID": "/changelog/#cmd_reach%20scaffold",
    "pt": "Changelog",
    "t": 0,
    "s": "cmd",
    "c": "reach scaffold"
  },
  {
    "objectID": "/changelog/#guide-changelog",
    "pt": "Changelog",
    "t": 2,
    "c": "Changelog"
  },
  {
    "objectID": "/changelog/#0113-202211---present",
    "pt": "Changelog",
    "t": 2,
    "c": "0.1.13: 2022/11 - present"
  },
  {
    "objectID": "/changelog/#0112-202209---202211",
    "pt": "Changelog",
    "t": 2,
    "c": "0.1.12: 2022/09 - 2022/11"
  },
  {
    "objectID": "/changelog/#0111-202206---202209",
    "pt": "Changelog",
    "t": 2,
    "c": "0.1.11: 2022/06 - 2022/09"
  },
  {
    "objectID": "/changelog/#0110-202204---202205",
    "pt": "Changelog",
    "t": 2,
    "c": "0.1.10: 2022/04 - 2022/05"
  },
  {
    "objectID": "/changelog/#019-202203---202204",
    "pt": "Changelog",
    "t": 2,
    "c": "0.1.9: 2022/03 - 2022/04"
  },
  {
    "objectID": "/changelog/#018-202201---202203",
    "pt": "Changelog",
    "t": 2,
    "c": "0.1.8: 2022/01 - 2022/03"
  },
  {
    "objectID": "/changelog/#017-202111---202112",
    "pt": "Changelog",
    "t": 2,
    "c": "0.1.7: 2021/11 - 2021/12"
  },
  {
    "objectID": "/changelog/#016-202110---202111",
    "pt": "Changelog",
    "t": 2,
    "c": "0.1.6: 2021/10 - 2021/11"
  },
  {
    "objectID": "/changelog/#015-202109---202110",
    "pt": "Changelog",
    "t": 2,
    "c": "0.1.5: 2021/09 - 2021/10"
  },
  {
    "objectID": "/changelog/#014-202109---202109",
    "pt": "Changelog",
    "t": 2,
    "c": "0.1.4: 2021/09 - 2021/09"
  },
  {
    "objectID": "/changelog/#013-202107---202108",
    "pt": "Changelog",
    "t": 2,
    "c": "0.1.3: 2021/07 - 2021/08"
  },
  {
    "objectID": "/changelog/#012-202009---202107",
    "pt": "Changelog",
    "t": 2,
    "c": "0.1.2: 2020/09 - 2021/07"
  },
  {
    "objectID": "/changelog/#011-201909---202009",
    "pt": "Changelog",
    "t": 2,
    "c": "0.1.1: 2019/09 - 2020/09"
  },
  {
    "objectID": "/changelog/#010-201909---202009",
    "pt": "Changelog",
    "t": 2,
    "c": "0.1.0: 2019/09 - 2020/09"
  },
  {
    "objectID": "/changelog/#p_0",
    "pt": "Changelog",
    "t": 3,
    "c": "Below is a list of changes to Reach. Versions and changes-within-versions are listed in reverse-chronological order: newest things first."
  },
  {
    "objectID": "/changelog/#p_1",
    "pt": "Changelog",
    "t": 3,
    "c": "Version 0.1.13 is the current Reach release candidate version."
  },
  {
    "objectID": "/changelog/#p_2",
    "pt": "Changelog",
    "t": 3,
    "c": "2023/02/17: Added {!js} nextUpToTime method for event stream objects."
  },
  {
    "objectID": "/changelog/#p_3",
    "pt": "Changelog",
    "t": 3,
    "c": "2023/01/18: Added {!rsh} Bytes.concat to ALGO connector."
  },
  {
    "objectID": "/changelog/#p_4",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/12/23: Add more options to the boxes field of {!rsh} remote.ALGO."
  },
  {
    "objectID": "/changelog/#p_5",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/12/19: Added {!rsh} Map.reduceWithKey."
  },
  {
    "objectID": "/changelog/#p_6",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/12/19: Added txnOrderForward to {!rsh} remote.ALGO."
  },
  {
    "objectID": "/changelog/#p_7",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/12/19: Added {!rsh} ALGOExitMode to {!rsh} setOptions."
  },
  {
    "objectID": "/changelog/#p_8",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/12/15: Added {!rsh} ALGO.blockSeed, {!rsh} ALGO.blockSecs, and {!js} stdlib.setAdjustTxnParams."
  },
  {
    "objectID": "/changelog/#p_9",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/12/14: Upgraded to PeraConnect 1.0.7 in React runner."
  },
  {
    "objectID": "/changelog/#p_10",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/12/14: Backwards Incompatible: All Algorand wallets are now \"bring-your-own\", where the Reach standard library doesn't bundle the code, but expects to be given a reference to the corresponding library. Please refer to Providers in Browsers via Wallets for more details. The React runner {!cmd} reach react still includes them, however."
  },
  {
    "objectID": "/changelog/#p_11",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/12/14: The Algorand connector has been drastically improved and produces code that can be as much as 25% smaller. This is important because Algorand contracts are limited to 8KB."
  },
  {
    "objectID": "/changelog/#p_12",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/12/05: Upgraded to Algorand node v3.12.2-stable, and indexer 2.15.0."
  },
  {
    "objectID": "/changelog/#p_13",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/11/24: Algorand-only: Contracts now combine all minimum balance payments into a single pay transaction, rather than expecting many individual transactions."
  },
  {
    "objectID": "/changelog/#p_14",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/11/23: Algorand-only: Contracts no longer check their group size, so they can be combined with other transactions in their group. They expect their paired transactions to be in the opposite order from before, however."
  },
  {
    "objectID": "/changelog/#p_15",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/11/21: Added boxes field to {!rsh} remote.ALGO."
  },
  {
    "objectID": "/changelog/#p_16",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/11/21: Algorand-only: The backend interface to deployed contracts was updated, so old contracts will not work with this version."
  },
  {
    "objectID": "/changelog/#p_17",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/11/21: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_18",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/11/21: The {!rsh} untrustworthyMaps option has been removed, because all maps are now trustworthy."
  },
  {
    "objectID": "/changelog/#p_19",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/11/21: The Algorand connector now uses boxes to implement maps. This enables support for any type as a valid map key and ensures that all maps are now trustworthy."
  },
  {
    "objectID": "/changelog/#p_20",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/11/14: The Algorand connector now targets AVM version 8. This means that we use more efficient opcodes, like switch, match, and dupn. These can have a dramatic effect on code size and opcode budgets."
  },
  {
    "objectID": "/changelog/#p_21",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/11/14: Algorand-only: The backend interface to deployed contracts was updated, so old contracts will not work with this version."
  },
  {
    "objectID": "/changelog/#p_22",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/11/14: Algorand-only: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_23",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/11/14: Upgraded to Algorand node v3.12.0-beta, indexer 2.15.0-rc1, and SDK 1.23.2."
  },
  {
    "objectID": "/changelog/#p_24",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/11/14: Upgraded to Ethers 5.7.2."
  },
  {
    "objectID": "/changelog/#p_25",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/11/14: Upgraded to Solidity 0.8.17."
  },
  {
    "objectID": "/changelog/#p_26",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/11/14: Upgraded to geth 1.10.26."
  },
  {
    "objectID": "/changelog/#p_27",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/11/14: Upgraded to MyAlgoConnect 1.4.1, WalletConnect 1.8.0, and PeraConnect 0.2.3."
  },
  {
    "objectID": "/changelog/#p_28",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/11/14: Backwards Incompatible: We have removed support for Conflux (previously accessed through the CFX connector mode)."
  },
  {
    "objectID": "/changelog/#p_29",
    "pt": "Changelog",
    "t": 3,
    "c": "Version 0.1.12 is the current Reach release version."
  },
  {
    "objectID": "/changelog/#p_30",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/11/08: Added support for AlgoSigner as wallet fallback for Algorand."
  },
  {
    "objectID": "/changelog/#p_31",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/11/07: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_32",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/11/02: Ethereum-like-only: The backend interface to deployed contracts was updated, so old contracts will not work with this version."
  },
  {
    "objectID": "/changelog/#p_33",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/10/28: Added support for launching {!rsh} Reach.App via {!rsh} new Contract."
  },
  {
    "objectID": "/changelog/#p_34",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/10/25: Added {!rsh} Tuple.includes."
  },
  {
    "objectID": "/changelog/#p_35",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/10/25: Added {!js} manager optional field for {!js} stdlib.launchToken"
  },
  {
    "objectID": "/changelog/#p_36",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/10/25: Added {!rsh} BytesDyn casting from fixed-length bytes."
  },
  {
    "objectID": "/changelog/#p_37",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/10/19: Added {!js} ctc.appOptIn and {!js} account.appOptedIn"
  },
  {
    "objectID": "/changelog/#p_38",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/10/18: Added {!js} acc.getDebugLabel."
  },
  {
    "objectID": "/changelog/#p_39",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/10/12: Updated {!js} test.chkErr to use a regex for the expected error."
  },
  {
    "objectID": "/changelog/#p_40",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/10/09 Added {!rsh} opts.simNetRecv, {!rsh} opts.simTokensRecv, and {!rsh} opts.simReturnVal."
  },
  {
    "objectID": "/changelog/#p_41",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/10/07 Added {!js} ctc.getEventTys."
  },
  {
    "objectID": "/changelog/#p_42",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/09/23: Added {!js} ctc.getInternalState."
  },
  {
    "objectID": "/changelog/#p_43",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/09/19: Added accounts field to {!rsh} remote.ALGO."
  },
  {
    "objectID": "/changelog/#p_44",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/09/15: Added {!js} stdlib.contract."
  },
  {
    "objectID": "/changelog/#p_45",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/09/15: Added {!js} new Reach(env?)."
  },
  {
    "objectID": "/changelog/#p_46",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/09/15: Backwards Incompatible: In 0.1.11-rc.6, we introduced the PeraWallet fallback for Algorand wallets. This introduced a dependency of the standard library on React, which was too onerous. We've removed it and thus, there is a slightly different way to enable PeraWallet as fallback. We apologize for this incompatibility."
  },
  {
    "objectID": "/changelog/#p_47",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/09/14: Added {!rsh} mixin."
  },
  {
    "objectID": "/changelog/#p_48",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/08/31: Upgraded to Algorand node v3.9.2, indexer 2.14.0, SDK 1.20.0."
  },
  {
    "objectID": "/changelog/#p_49",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/08/31: Algorand-only: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_50",
    "pt": "Changelog",
    "t": 3,
    "c": "Version 0.1.11 is an old Reach release version."
  },
  {
    "objectID": "/changelog/#p_51",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/09/08: Added {!rsh} Contract.fromAddress."
  },
  {
    "objectID": "/changelog/#p_52",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/08/31: Added rawCall field to {!rsh} remote.ALGO."
  },
  {
    "objectID": "/changelog/#p_53",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/08/29: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_54",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/08/29: Modified the type of {!js} T_Bytes in the JavaScript standard library to allow {!js} Uint8Arrays and sometimes produce them when the bytes produced cannot be represented as a UTF-8 encoded string."
  },
  {
    "objectID": "/changelog/#p_55",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/08/29: Added {!rsh} Bytes.fromHex."
  },
  {
    "objectID": "/changelog/#p_56",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/08/25: Ethereum-like-only: The backend interface to deployed contracts was updated, so old contracts will not work with this version."
  },
  {
    "objectID": "/changelog/#p_57",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/08/24: Added {!rsh} StringDyn.concat function and {!rsh} StringDyn cast application."
  },
  {
    "objectID": "/changelog/#p_58",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/08/24: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_59",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/08/19: Added {!rsh} StringDyn type."
  },
  {
    "objectID": "/changelog/#p_60",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/08/19: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_61",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/08/18: Added {!rsh} BytesDyn type."
  },
  {
    "objectID": "/changelog/#p_62",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/08/16: Added {!js} opts parameter to {!js} stdlib.transfer."
  },
  {
    "objectID": "/changelog/#p_63",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/08/16: Added noVarOutput option to {!js} test.run."
  },
  {
    "objectID": "/changelog/#p_64",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/08/15: Added {!rsh} autoTrackPublishedTokens to {!rsh} setOptions."
  },
  {
    "objectID": "/changelog/#p_65",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/08/10: Added support for exponential notation for numeric literals."
  },
  {
    "objectID": "/changelog/#p_66",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/08/09: Added strictPay field to {!rsh} remote.ALGO."
  },
  {
    "objectID": "/changelog/#p_67",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/08/07: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_68",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/08/07: Added {!rsh} safe* and {!rsh} veri* arithmetic functions, e.g. {!rsh} safeAdd and {!rsh} veriAdd."
  },
  {
    "objectID": "/changelog/#p_69",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/08/05: Added {!rsh} Struct.fields and {!rsh} Object.fields."
  },
  {
    "objectID": "/changelog/#p_70",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/08/04: Added {!js} stdlib.tokensAccepted and {!js} acc.tokensAccepted."
  },
  {
    "objectID": "/changelog/#p_71",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/08/03: Added {!rsh} isDataVariant."
  },
  {
    "objectID": "/changelog/#p_72",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/07/30: Backwards Incompatible: The {!rsh} this variable is removed from the scope inside {!rsh} while and {!rsh} parallelReduce syntax, except for the initialization expressions."
  },
  {
    "objectID": "/changelog/#p_73",
    "pt": "Changelog",
    "t": 3,
    "c": "We consider backwards incompatible changes to be very serious and do not introduce them lightly. In this case, we have observed too many programs containing major errors because they confuse {!rsh} this, which would refer to the previous actor in these contexts with the current actor. This confusion creates scenarios where applications are incorrectly protected: either they are overly protected, by enforcing that an actor do two things in a row; or they are under protected, by allowing anyone to perform any action after the desired actor does something else first. Given this danger, we are introducing this backwards incompatible change."
  },
  {
    "objectID": "/changelog/#p_74",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/07/30: Added support for PeraWallet Connect as wallet fallback for Algorand."
  },
  {
    "objectID": "/changelog/#p_75",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/07/30: Upgraded React to 18.2.0 in {!cmd} reach react."
  },
  {
    "objectID": "/changelog/#p_76",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/07/30: Many more customization options were added to {!js} stdlib.setWalletFallback."
  },
  {
    "objectID": "/changelog/#p_77",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/07/30: Added support for customize ALGO_INDEXER_TOKEN_HEADER in Algorand provider configuration."
  },
  {
    "objectID": "/changelog/#p_78",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/07/30: Added support for customize ALGO_TOKEN_HEADER in Algorand provider configuration."
  },
  {
    "objectID": "/changelog/#p_79",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/07/30: Added {!rsh} Token.accepted."
  },
  {
    "objectID": "/changelog/#p_80",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/07/29: Allow {!js} loadStdlib to be called multiple times to get separate standard library instances."
  },
  {
    "objectID": "/changelog/#p_81",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/07/22: Added support for {!rsh} View aliases."
  },
  {
    "objectID": "/changelog/#p_82",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/07/22: Added freeze, reserve, and defaultFrozen options to {!js} stdlib.launchToken."
  },
  {
    "objectID": "/changelog/#p_83",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/07/13: Added {!rsh} Token.track."
  },
  {
    "objectID": "/changelog/#p_84",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/06/18: Added {!rsh} enforce."
  },
  {
    "objectID": "/changelog/#p_85",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/06/18: Added {!rsh} currentMode."
  },
  {
    "objectID": "/changelog/#p_86",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/06/01: Added onCompletion field to {!rsh} remote.ALGO."
  },
  {
    "objectID": "/changelog/#p_87",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/06/01: Added Contract creation support."
  },
  {
    "objectID": "/changelog/#p_88",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/06/01: Added Contract code definition support."
  },
  {
    "objectID": "/changelog/#p_89",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/06/01: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_90",
    "pt": "Changelog",
    "t": 3,
    "c": "Version 0.1.10 is an old Reach release version."
  },
  {
    "objectID": "/changelog/#p_91",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/05/14: Added {!cmd} reach support sub-command."
  },
  {
    "objectID": "/changelog/#p_92",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/05/13: Support custom violation messages for {!rsh} invariants."
  },
  {
    "objectID": "/changelog/#p_93",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/05/13: Support multiple {!rsh} invariants for {!rsh} while loops and {!rsh} parallelReduce."
  },
  {
    "objectID": "/changelog/#p_94",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/05/13: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_95",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/05/13: Added {!rsh} getCompanion."
  },
  {
    "objectID": "/changelog/#p_96",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/05/13: Added apps field to {!rsh} remote.ALGO."
  },
  {
    "objectID": "/changelog/#p_97",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/05/07: Added addressToAccount field to {!rsh} remote.ALGO."
  },
  {
    "objectID": "/changelog/#p_98",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/05/05: Added support for multiple {!rsh} .define branches in a {!rsh} parallelReduce."
  },
  {
    "objectID": "/changelog/#p_99",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/05/04: Added .api_ branch to {!rsh} fork and {!rsh} parallelReduce."
  },
  {
    "objectID": "/changelog/#p_100",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/05/04: Added CHECK_EXPR to {!rsh} .case in {!rsh} fork and {!rsh} parallelReduce."
  },
  {
    "objectID": "/changelog/#p_101",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/05/04: Added .check to {!rsh} publish and API {!rsh} calls."
  },
  {
    "objectID": "/changelog/#p_102",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/30: Added assets field to {!rsh} remote.ALGO."
  },
  {
    "objectID": "/changelog/#p_103",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/28: Added {!rsh} sqrt and renamed old version to {!rsh} sqrtApprox. This change is backwards incompatible, but we believe that most users will prefer the new version and will want to be warned, via a compile error, that it is available."
  },
  {
    "objectID": "/changelog/#p_104",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/28: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_105",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/28: Added {!cmd} REACH_NO_WARN environment variable."
  },
  {
    "objectID": "/changelog/#p_106",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/28: Added {!js} test to the JavaScript standard library."
  },
  {
    "objectID": "/changelog/#p_107",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/26: Add support for calling {!rsh} APIs multiple times in a program."
  },
  {
    "objectID": "/changelog/#p_108",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/26: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_109",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/22: Added --verify-fail-once flag to reach compile to only print the first verification failure produced by a program."
  },
  {
    "objectID": "/changelog/#p_110",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/19: Added {!js} withDisconnect and {!js} disconnect to help participant frontends disconnect early from a contract."
  },
  {
    "objectID": "/changelog/#p_111",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/18: Added {!rsh} Contract.addressEq."
  },
  {
    "objectID": "/changelog/#p_112",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/18: Added {!rsh} remote.ALGO."
  },
  {
    "objectID": "/changelog/#p_113",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/18: Ethereum-like-only: The backend interface to deployed contracts was updated, so old contracts will not work with this version."
  },
  {
    "objectID": "/changelog/#p_114",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/18: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_115",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/12: Added {!js} getTimeSecs for converting network time to network seconds."
  },
  {
    "objectID": "/changelog/#p_116",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/09: Added the note field to {!js} launchToken."
  },
  {
    "objectID": "/changelog/#p_117",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/07: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_118",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/07: Added {!rsh} UInt256 type and associated operations."
  },
  {
    "objectID": "/changelog/#p_119",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/07: Algorand indexer upgraded to 2.10.0."
  },
  {
    "objectID": "/changelog/#p_120",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/07: Algorand node upgraded to 3.5.1."
  },
  {
    "objectID": "/changelog/#p_121",
    "pt": "Changelog",
    "t": 3,
    "c": "Version 0.1.9 is an old Reach release version."
  },
  {
    "objectID": "/changelog/#p_122",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/06: Added support for arbitrary {!rsh} Map keys on Ethereum/Conflux."
  },
  {
    "objectID": "/changelog/#p_123",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/04/05: Added support for creating overloaded {!rsh} API functions and calling overloaded {!rsh} remote functions."
  },
  {
    "objectID": "/changelog/#p_124",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/30: Added {!rsh} thisConsensusTime and {!rsh} thisConsensusSecs."
  },
  {
    "objectID": "/changelog/#p_125",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/30: Added {!rsh} polyMod, which supports {!rsh} Bytes and {!rsh} Digests."
  },
  {
    "objectID": "/changelog/#p_126",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/22: Added {!rsh} Set.Map field."
  },
  {
    "objectID": "/changelog/#p_127",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/22: Added support for {!js} _ in JavaScript number literals, like {!js} 1_337."
  },
  {
    "objectID": "/changelog/#p_128",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/17: Removed {!rsh} polyXor and made {!rsh} xor polymorphic."
  },
  {
    "objectID": "/changelog/#p_129",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/16: On Algorand, Reach will use a companion application and inner transaction calls to it to provide up to 179,200 units of computation budget. Each 700 costs an extra transaction fee. The compiler will produce a fee and resource allocation report when run with debugging enabled."
  },
  {
    "objectID": "/changelog/#p_130",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/14: Algorand-only: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_131",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/14: Added {!rsh} polyXor and update {!rsh} ^ to use it."
  },
  {
    "objectID": "/changelog/#p_132",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/12: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_133",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/09: Added {!rsh} _local to {!rsh} parallelReduce and {!rsh} fork."
  },
  {
    "objectID": "/changelog/#p_134",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/08: Added {!rsh} distinct."
  },
  {
    "objectID": "/changelog/#p_135",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/07: {!rsh} remote objects supported on Algorand."
  },
  {
    "objectID": "/changelog/#p_136",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/02: Algorand-only: Drastically reduced the cost of {!rsh} muldiv."
  },
  {
    "objectID": "/changelog/#p_137",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/02: Algorand-only: Contract bytecode upgraded to version 6. (This enables {!rsh} API and {!rsh} View functions to be called on-chain.)"
  },
  {
    "objectID": "/changelog/#p_138",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/02: Algorand-only: Updated the default faucet. If you upgrade the standard library, but do not restart your devnet, tests will fail."
  },
  {
    "objectID": "/changelog/#p_139",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/02: Algorand indexer upgraded to 2.9.0."
  },
  {
    "objectID": "/changelog/#p_140",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/02: Algorand node upgraded to 3.4.2."
  },
  {
    "objectID": "/changelog/#p_141",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/02: Ethers upgraded to 5.5.4."
  },
  {
    "objectID": "/changelog/#p_142",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/02: Ethereum ERC-20 implementation upgraded to OpenZeppelin 4.5.0."
  },
  {
    "objectID": "/changelog/#p_143",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/02: Ethereum (geth) upgraded to 1.10.16."
  },
  {
    "objectID": "/changelog/#p_144",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/02: Solidity upgraded to 0.8.12."
  },
  {
    "objectID": "/changelog/#p_145",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/03/02: Z3 upgraded to 4.8.14."
  },
  {
    "objectID": "/changelog/#p_146",
    "pt": "Changelog",
    "t": 3,
    "c": "Version 0.1.8 is an old Reach release version."
  },
  {
    "objectID": "/changelog/#p_147",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/02/28: Added {!js} launchToken for token minting in frontends."
  },
  {
    "objectID": "/changelog/#p_148",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/02/25: Added support for tracking {!rsh} Token information—such as balance, supply, and whether its destroyed—dynamically."
  },
  {
    "objectID": "/changelog/#p_149",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/02/25: Added {!cmd} reach info."
  },
  {
    "objectID": "/changelog/#p_150",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/02/25: Removed {!cmd} reach upgrade (subsumed by {!cmd} reach update)."
  },
  {
    "objectID": "/changelog/#p_151",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/02/08: Added {!js} balancesOf."
  },
  {
    "objectID": "/changelog/#p_152",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/02/06: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_153",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/29: Added {!cmd} ALGO_NODE_WRITE_ONLY."
  },
  {
    "objectID": "/changelog/#p_154",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/28: Added {!js} setSigningMonitor."
  },
  {
    "objectID": "/changelog/#p_155",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/27: Added {!js} setMinMillisBetweenRequests."
  },
  {
    "objectID": "/changelog/#p_156",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/27: Added {!js} setCustomHttpEventHandler."
  },
  {
    "objectID": "/changelog/#p_157",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/27: Added {!js} minimumBalanceOf."
  },
  {
    "objectID": "/changelog/#p_158",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/26: Added {!rsh} untrustworthyMaps option to {!rsh} setOptions."
  },
  {
    "objectID": "/changelog/#p_159",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/25: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_160",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/24: Added {!rsh} Array.forEachWithIndex."
  },
  {
    "objectID": "/changelog/#p_161",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/20: Added {!rsh} check."
  },
  {
    "objectID": "/changelog/#p_162",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/13: Algorand-only: The backend interface to deployed contracts was updated, so old contracts will not work with this version."
  },
  {
    "objectID": "/changelog/#p_163",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/13: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_164",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/13: Added {!js} ctc.getABI."
  },
  {
    "objectID": "/changelog/#p_165",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/08: The Algorand connector does not rely on an Algorand Node for any information available through an Algorand Indexer. This is compatible with some Algorand network providers that restrict the API on Algorand Nodes."
  },
  {
    "objectID": "/changelog/#p_166",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/06: The analysis of cost on Algorand is more precise in the presence of array operations."
  },
  {
    "objectID": "/changelog/#p_167",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/06: Verification of only-one-honest participant is disabled. This proves nothing that wasn't verified already by the other two cases and just takes more time."
  },
  {
    "objectID": "/changelog/#p_168",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/05: Conflux devnet has been upgraded to 0.1.7."
  },
  {
    "objectID": "/changelog/#p_169",
    "pt": "Changelog",
    "t": 3,
    "c": "Version 0.1.7 is an old Reach release version."
  },
  {
    "objectID": "/changelog/#p_170",
    "pt": "Changelog",
    "t": 3,
    "c": "2022/01/06: Added {!rsh} getUntrackedFunds."
  },
  {
    "objectID": "/changelog/#p_171",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/12/31: {!js} setQueryLowerBound is deprecated."
  },
  {
    "objectID": "/changelog/#p_172",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/12/28: Algorand-only: The backend interface to compiled contract objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_173",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/12/23: Algorand-only: The backend interface to deployed contracts was updated, so old contracts will not work with this version."
  },
  {
    "objectID": "/changelog/#p_174",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/12/23: Added {!rsh} verifyMuldiv."
  },
  {
    "objectID": "/changelog/#p_175",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/12/23: {!rsh} deploy was renamed to {!rsh} init."
  },
  {
    "objectID": "/changelog/#p_176",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/12/21: The backend interface to deployed contracts was updated, so old contracts will not work with this version."
  },
  {
    "objectID": "/changelog/#p_177",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/12/21: EVM-only: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_178",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/12/20: Added support for {!rsh} PAY_REQUIRE_EXPR, which allows {!rsh} require claims to be made about payments."
  },
  {
    "objectID": "/changelog/#p_179",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/12/16: Added {!rsh} Events."
  },
  {
    "objectID": "/changelog/#p_180",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/12/16: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_181",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/12/16: The backend interface to deployed contracts was updated, so old contracts will not work with this version."
  },
  {
    "objectID": "/changelog/#p_182",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/12/10: Added support for using Reach on Apple Silicon."
  },
  {
    "objectID": "/changelog/#p_183",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/11/25: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_184",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/11/19: The backend interface to deployed contracts was updated, so old contracts will not work with this version."
  },
  {
    "objectID": "/changelog/#p_185",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/11/19: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_186",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/11/17: Added {!js} ctc.unsafeViews and {!js} ctc.safeApis."
  },
  {
    "objectID": "/changelog/#p_187",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/11/15: Algorand connector now uses the application-controlled account for the escrow account. This means that some programs will no longer work, if they do certain things, like trying to transfer non-network tokens in the same step that they share them with the consensus, because the contract needs to opt-in. On the other hand, some things that used to not work, now do; for example, there used to be a limit of 15 extra transactions per consensus transfer, but now the limit is 31, with 15 from the client and 16 generated by the contract."
  },
  {
    "objectID": "/changelog/#p_188",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/11/15: Algorand-only: The backend interface to deployed contracts was updated, so old contracts will not work with this version."
  },
  {
    "objectID": "/changelog/#p_189",
    "pt": "Changelog",
    "t": 3,
    "c": "Version 0.1.6 is an old Reach release version."
  },
  {
    "objectID": "/changelog/#p_190",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/11/02: Allow {!rsh} APIs and {!rsh} Views to be specified without names."
  },
  {
    "objectID": "/changelog/#p_191",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/28: REACH_CONNECTOR_MODE no longer defaults to ETH when unset."
  },
  {
    "objectID": "/changelog/#p_192",
    "pt": "Changelog",
    "t": 3,
    "c": "Users are instead encouraged to run reach config to set a persistent default in their shell or supply REACH_CONNECTOR_MODE explicitly at the command-line and in scripts."
  },
  {
    "objectID": "/changelog/#p_193",
    "pt": "Changelog",
    "t": 3,
    "c": "Attempting to reach run|react|rpc-server|rpc-run|devnet without setting REACH_CONNECTOR_MODE in one's terminal will result in an error message being shown and execution aborted."
  },
  {
    "objectID": "/changelog/#p_194",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/28: Added reach config subcommand."
  },
  {
    "objectID": "/changelog/#p_195",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/28: The backend interface to deployed contracts was updated, so old contracts will not work with this version."
  },
  {
    "objectID": "/changelog/#p_196",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/28: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_197",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/20: Added {!rsh} decimals field for token minting."
  },
  {
    "objectID": "/changelog/#p_198",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/18: Added APIs via the {!rsh} API form."
  },
  {
    "objectID": "/changelog/#p_199",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/15: The backend interface to deployed contracts was updated, so old contracts will not work with this version."
  },
  {
    "objectID": "/changelog/#p_200",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/15: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_201",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/15: Algorand devnet updated to versions 3.0.1 and 2.6."
  },
  {
    "objectID": "/changelog/#p_202",
    "pt": "Changelog",
    "t": 3,
    "c": "Version 0.1.5 is an old Reach release version."
  },
  {
    "objectID": "/changelog/#p_203",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/15: Added {!js} setValidQueryWindow."
  },
  {
    "objectID": "/changelog/#p_204",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/11: The Solidity compiler has been upgraded to 0.8.9."
  },
  {
    "objectID": "/changelog/#p_205",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/08: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_206",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/08: {!rsh} parallelReduce is more strict in checking that the msg argument is present in the parameter list of {!rsh} case components, even when it is is bound to a {!rsh} null."
  },
  {
    "objectID": "/changelog/#p_207",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/08: Added {!rsh} getContract and {!rsh} getAddress."
  },
  {
    "objectID": "/changelog/#p_208",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/08: Added {!js} ctc.getContractAddress."
  },
  {
    "objectID": "/changelog/#p_209",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/05: Added {!rsh} Contract. Updated {!js} ctc.getInfo to return a {!rsh} Contract."
  },
  {
    "objectID": "/changelog/#p_210",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/10/04: Added {!rsh} unstrict."
  },
  {
    "objectID": "/changelog/#p_211",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/09/25: Reach clients will detect that they are attempting to publish in a race that they cannot win and switch to listening for the publication of another. This has the impact of frontends not being asked to sign transactions that cannot possibly succeed."
  },
  {
    "objectID": "/changelog/#p_212",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/09/25: Added {!rsh} didPublish()."
  },
  {
    "objectID": "/changelog/#p_213",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/09/24: Contracts do not store the Merkleization of the state, but store the state itself; this changes the interface to contracts, so this release cannot communicate with DApps compiled by older versions of Reach."
  },
  {
    "objectID": "/changelog/#p_214",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/09/16: Bare integers used as time arguments will throw a deprecation warning. Use {!rsh} relativeTime instead."
  },
  {
    "objectID": "/changelog/#p_215",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/09/16: The concept of deployment modes has been removed and the only available behavior is what was previously the firstMsg deployment mode."
  },
  {
    "objectID": "/changelog/#p_216",
    "pt": "Changelog",
    "t": 3,
    "c": "If you would like the old behavior, then you'll want to create a new participant, perhaps called Constructor, that exists simply to run {!rsh} Constructor.publish(); commit();, but we expect that almost no one actually wants the old behavior exactly. Instead, you probably want to select one of your existing participants and assign the first publication to them."
  },
  {
    "objectID": "/changelog/#p_217",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/09/16: The backend interface to deployed contracts was updated, so old contracts will not work with this version."
  },
  {
    "objectID": "/changelog/#p_218",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/09/16: The backend interface to the compiled objects was updated, so you'll need to recompile for this release."
  },
  {
    "objectID": "/changelog/#p_219",
    "pt": "Changelog",
    "t": 3,
    "c": "Version 0.1.4 is an old Reach release version."
  },
  {
    "objectID": "/changelog/#p_220",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/09/15: {!rsh} muldiv added."
  },
  {
    "objectID": "/changelog/#p_221",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/09/08: Add --stop-after-eval and --verify-timeout options to reach compile."
  },
  {
    "objectID": "/changelog/#p_222",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/08/31: Removed {!js} getSignStrategy and {!js} setSignStrategy in favor of {!js} setWalletFallBack and {!js} walletFallback."
  },
  {
    "objectID": "/changelog/#p_223",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/08/31: Algorand devnet updated to versions 2.9.1 and 2.6."
  },
  {
    "objectID": "/changelog/#p_224",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/08/31: The reach command-line has changed:"
  },
  {
    "objectID": "/changelog/#p_225",
    "pt": "Changelog",
    "t": 3,
    "c": "All subcommands now support -h/--help switches, e.g. reach compile --help."
  },
  {
    "objectID": "/changelog/#p_226",
    "pt": "Changelog",
    "t": 3,
    "c": "The APP argument to reach init has been removed."
  },
  {
    "objectID": "/changelog/#p_227",
    "pt": "Changelog",
    "t": 3,
    "c": "The reach script now permits the use of subdirectories as arguments to certain subcommands, e.g. reach compile dir/index.rsh, but disallows parent directories (..) for reasons pertaining to Docker."
  },
  {
    "objectID": "/changelog/#p_228",
    "pt": "Changelog",
    "t": 3,
    "c": "Devnets have been consolidated into a single Dockerized network and container topology."
  },
  {
    "objectID": "/changelog/#p_229",
    "pt": "Changelog",
    "t": 3,
    "c": "The --use-existing-devnet flag has been deprecated and no longer has any effect."
  },
  {
    "objectID": "/changelog/#p_230",
    "pt": "Changelog",
    "t": 3,
    "c": "reach run will now automatically connect to a given connector's devnet when already present. Devnets which are not yet running will be launched as needed."
  },
  {
    "objectID": "/changelog/#p_231",
    "pt": "Changelog",
    "t": 3,
    "c": "reach down now halts ALL Dockerized Reach containers and devnets (i.e. it's no longer specific to a single project). Non-Reach Docker services are unaffected (see reach docker-reset)."
  },
  {
    "objectID": "/changelog/#p_232",
    "pt": "Changelog",
    "t": 3,
    "c": "reach docker-reset now prompts the user for confirmation before continuing since it kills and removes ALL containers (not just those related to Reach). The -y or --even-non-reach flags may be appended for non-interactive execution."
  },
  {
    "objectID": "/changelog/#p_233",
    "pt": "Changelog",
    "t": 3,
    "c": "An --await-background flag has been introduced to the reach devnet subcommand."
  },
  {
    "objectID": "/changelog/#p_234",
    "pt": "Changelog",
    "t": 3,
    "c": "The reach script has been simplified such that Makefile and docker-compose.yml files are no longer integral to its function. Accordingly, these files have been removed from reach scaffold's output. Authors of existing projects which contain unmodified Makefile or docker-compose.yml files are encouraged to remove them."
  },
  {
    "objectID": "/changelog/#p_235",
    "pt": "Changelog",
    "t": 3,
    "c": "Version 0.1.3 is an old Reach release version."
  },
  {
    "objectID": "/changelog/#p_236",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/08/31: Added {!js} acc.setStorageLimit to JavaScript standard library for Conflux."
  },
  {
    "objectID": "/changelog/#p_237",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/08/16: Allow {!rsh} continue in step in some cases."
  },
  {
    "objectID": "/changelog/#p_238",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/31: Added {!js} newTestAccounts, {!js} waitUntilSecs, and {!js} getNetworkSecs to JavaScript standard library."
  },
  {
    "objectID": "/changelog/#p_239",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/31: Updated {!js} onProgress type in JavaScript standard library."
  },
  {
    "objectID": "/changelog/#p_240",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/31: Added {!rsh} relativeTime, {!rsh} absoluteTime, {!rsh} relativeSecs, {!rsh} absoluteSecs, {!rsh} baseWaitTime, {!rsh} baseWaitSecs, and {!rsh} lastConsensusSecs to Reach, with support in {!rsh} wait and {!rsh} .timeout."
  },
  {
    "objectID": "/changelog/#p_241",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/22: {!js} numberToFixedPoint() and {!js} numberToInt() added."
  },
  {
    "objectID": "/changelog/#p_242",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/21: Renamed Ethereum devnet Docker image to devnet-eth."
  },
  {
    "objectID": "/changelog/#p_243",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/21: Renamed connector modes to use naming convention $NET-devnet, rather than exposing implementation."
  },
  {
    "objectID": "/changelog/#p_244",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/21: Ethereum contract bytecode verification changed to directly compare deployment data"
  },
  {
    "objectID": "/changelog/#p_245",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/20: {!rsh} Array.slice() added."
  },
  {
    "objectID": "/changelog/#p_246",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/19: {!rsh} Token.destroyed() added."
  },
  {
    "objectID": "/changelog/#p_247",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/15: Ethereum contract info (i.e. {!js} ctc.getInfo()) reduced to address only."
  },
  {
    "objectID": "/changelog/#p_248",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/14: Algorand contract info (i.e. {!js} ctc.getInfo()) reduced to application id only."
  },
  {
    "objectID": "/changelog/#p_249",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/14: Minted tokens must be destroyed by end of application."
  },
  {
    "objectID": "/changelog/#p_250",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/14: Token minting support added to Algorand."
  },
  {
    "objectID": "/changelog/#p_251",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/14: Token URL metadata increased to 96 bytes."
  },
  {
    "objectID": "/changelog/#p_252",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/14: Algorand {!rsh} digest switched to SHA256 (to save compute cost)."
  },
  {
    "objectID": "/changelog/#p_253",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/14: Algorand connector updated to AVM 0.9 (TEAL version 4)"
  },
  {
    "objectID": "/changelog/#p_254",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/14: Algorand devnet version updated to 2.7.1, plus DevMode patch"
  },
  {
    "objectID": "/changelog/#p_255",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/14: Algorand devnet image renamed to devnet-algo"
  },
  {
    "objectID": "/changelog/#p_256",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/14: version tagged"
  },
  {
    "objectID": "/changelog/#p_257",
    "pt": "Changelog",
    "t": 3,
    "c": "Version 0.1.2 is an old Reach release version."
  },
  {
    "objectID": "/changelog/#p_258",
    "pt": "Changelog",
    "t": 3,
    "c": "It is the last version that supports Algorand using TEAL3; if you deployed a contract on Algorand using Reach version 0.1.2, you will need to continue accessing it via the 0.1.2 version of the Reach standard library."
  },
  {
    "objectID": "/changelog/#p_259",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/09: {!rsh} .define component added to {!rsh} parallelReduce"
  },
  {
    "objectID": "/changelog/#p_260",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/07/08: Error code reference created"
  },
  {
    "objectID": "/changelog/#p_261",
    "pt": "Changelog",
    "t": 3,
    "c": "2021/06/20: Token minting introduced, with implementation on ETH."
  },
  {
    "objectID": "/changelog/#p_262",
    "pt": "Changelog",
    "t": 3,
    "c": "... many interesting things ..."
  },
  {
    "objectID": "/changelog/#p_263",
    "pt": "Changelog",
    "t": 3,
    "c": "2020/09/01: version tagged"
  },
  {
    "objectID": "/changelog/#p_264",
    "pt": "Changelog",
    "t": 3,
    "c": "Version 0.1.1 was used prior to our documented release process."
  },
  {
    "objectID": "/changelog/#p_265",
    "pt": "Changelog",
    "t": 3,
    "c": "Version 0.1.0 was used prior to our documented release process."
  },
  {
    "objectID": "/cout/#js_backend",
    "pt": "Compiled Output",
    "t": 0,
    "s": "js",
    "c": "backend"
  },
  {
    "objectID": "/cout/#js_getExports",
    "pt": "Compiled Output",
    "t": 0,
    "s": "js",
    "c": "getExports"
  },
  {
    "objectID": "/cout/#ref-backends",
    "pt": "Compiled Output",
    "t": 2,
    "c": "Compiled Output"
  },
  {
    "objectID": "/cout/#ref-backends-js",
    "pt": "Compiled Output",
    "t": 2,
    "c": "JavaScript"
  },
  {
    "objectID": "/cout/#ref-backends-js-guarantees",
    "pt": "Compiled Output",
    "t": 2,
    "c": "Guarantees"
  },
  {
    "objectID": "/cout/#p_0",
    "pt": "Compiled Output",
    "t": 3,
    "c": "This section describes the compilation output of Reach version 0.1.13, which are participant backends."
  },
  {
    "objectID": "/cout/#p_1",
    "pt": "Compiled Output",
    "t": 3,
    "c": "They are accessed via JavaScript or via the RPC server."
  },
  {
    "objectID": "/cout/#p_2",
    "pt": "Compiled Output",
    "t": 3,
    "c": "The Reach JavaScript backend produces a compilation output named input.APP.mjs. This will normally be imported by writing:"
  },
  {
    "objectID": "/cout/#p_3",
    "pt": "Compiled Output",
    "t": 3,
    "c": "This module exports an asynchronous function for each participant. For example, if a Reach program contains a participant named {!rsh} 'A' in the {!rsh} Reach.App, then the JavaScript backend will include a function named {!js} A (i.e. {!js} backend.A). The {!js} Promise returned by these functions is resolved when the Reach program terminates (i.e. reaches {!rsh} exit();)."
  },
  {
    "objectID": "/cout/#p_4",
    "pt": "Compiled Output",
    "t": 3,
    "c": "Each function accepts two arguments: {!js} ctc and {!js} interact. These functions should be called by the frontend."
  },
  {
    "objectID": "/cout/#p_5",
    "pt": "Compiled Output",
    "t": 3,
    "c": "The {!js} ctc argument is the result of a call to the functions {!js} acc.deploy or {!js} acc.attach provided by the JavaScript frontend support library."
  },
  {
    "objectID": "/cout/#p_6",
    "pt": "Compiled Output",
    "t": 3,
    "c": "The {!js} interact argument is an object matching the participant interact interface for the corresponding participant. The types of values this object contains must match those specified on this list. Each function may return a {!js} Promise, which the backend will {!js} await, if it needs to perform an asynchronous action."
  },
  {
    "objectID": "/cout/#p_7",
    "pt": "Compiled Output",
    "t": 3,
    "c": "The backend provides a value, {!js} _version, which is a string representation of the Reach version used to compile the program. For example, the version of Reach used to produce this documentation would contain the string {!js} 'reach-vers'."
  },
  {
    "objectID": "/cout/#p_8",
    "pt": "Compiled Output",
    "t": 3,
    "c": "The backend provides a function, {!js} getExports, which exposes the exports of a Reach program. This function receives the standard library as an argument and returns an object with all the exports present in the module being compiled."
  },
  {
    "objectID": "/cout/#p_9",
    "pt": "Compiled Output",
    "t": 3,
    "c": "It's possible to expose bindings from other modules to {!js} getExports by re-exporting them in your \"top-level\" module."
  },
  {
    "objectID": "/cout/#p_10",
    "pt": "Compiled Output",
    "t": 3,
    "c": "For example, if a Reach program exported a variable x, i.e. {!rsh} export const x = 5, the frontend could access the value in the following manner:"
  },
  {
    "objectID": "/cout/#p_11",
    "pt": "Compiled Output",
    "t": 3,
    "c": "Finally, the backend provides a value, {!js} _Connectors, which is an opaque object representing the connectors the app was compiled for."
  },
  {
    "objectID": "/cout/#p_12",
    "pt": "Compiled Output",
    "t": 3,
    "c": "This backend does not guarantee that values in a positive position in a participant interact interface, that are later passed to a negative position in a participant interact interface, will be identical, in the sense of JavaScript's {!js} === operator, to the original value. In other words, this backend does not ensure that Reach programs are parametric over JavaScript values that they interact with."
  },
  {
    "objectID": "/cout/#p_13",
    "pt": "Compiled Output",
    "t": 3,
    "c": "Positive and negative are best understood by example with a function type: a positive position is supplied by the function, such as the result; while a negative position is supplied by the caller, such as the arguments. These notions generalize, however, to higher (and lower) order contexts. In the case of Reach, this means that non-function values in a participant interact interface are positive."
  },
  {
    "objectID": "/cout/#p_14",
    "pt": "Compiled Output",
    "t": 3,
    "c": "For example, if the Reach program,"
  },
  {
    "objectID": "/cout/#p_15",
    "pt": "Compiled Output",
    "t": 3,
    "c": "is given the {!js} interact object,"
  },
  {
    "objectID": "/cout/#p_16",
    "pt": "Compiled Output",
    "t": 3,
    "c": "then it is not guaranteed that {!rsh} A will publish {!rsh} true, because the {!js} str given to {!js} give may not be identical to {!js} x. (However, they are {!js} bytesEq.)"
  },
  {
    "objectID": "/index/#cmd_REACH_CONNECTOR_MODE",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "REACH_CONNECTOR_MODE"
  },
  {
    "objectID": "/index/#cmd_REACH_VERSION",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "REACH_VERSION"
  },
  {
    "objectID": "/index/#cmd_REACH_DEBUG",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "REACH_DEBUG"
  },
  {
    "objectID": "/index/#cmd_reach%20compile",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach compile"
  },
  {
    "objectID": "/index/#cmd_reach%20init",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach init"
  },
  {
    "objectID": "/index/#cmd_reach%20run",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach run"
  },
  {
    "objectID": "/index/#cmd_reach%20down",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach down"
  },
  {
    "objectID": "/index/#cmd_reach%20clean",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach clean"
  },
  {
    "objectID": "/index/#cmd_reach%20scaffold",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach scaffold"
  },
  {
    "objectID": "/index/#cmd_reach%20support",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach support"
  },
  {
    "objectID": "/index/#cmd_reach%20react",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach react"
  },
  {
    "objectID": "/index/#cmd_reach%20devnet",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach devnet"
  },
  {
    "objectID": "/index/#cmd_reach%20rpc-server",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach rpc-server"
  },
  {
    "objectID": "/index/#cmd_reach%20rpc-run",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach rpc-run"
  },
  {
    "objectID": "/index/#cmd_reach%20docker-reset",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach docker-reset"
  },
  {
    "objectID": "/index/#cmd_reach%20info",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach info"
  },
  {
    "objectID": "/index/#cmd_reach%20update",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach update"
  },
  {
    "objectID": "/index/#cmd_reach%20version",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach version"
  },
  {
    "objectID": "/index/#cmd_reach%20hashes",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach hashes"
  },
  {
    "objectID": "/index/#cmd_reach%20config",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach config"
  },
  {
    "objectID": "/index/#cmd_reach%20--disable-reporting",
    "pt": "Index",
    "t": 0,
    "s": "cmd",
    "c": "reach --disable-reporting"
  },
  {
    "objectID": "/index/#doc-index",
    "pt": "Index",
    "t": 2,
    "c": "Index"
  },
  {
    "objectID": "/model/#term_DApp",
    "pt": "Model",
    "t": 1,
    "c": "DApp"
  },
  {
    "objectID": "/model/#term_consensus%20network",
    "pt": "Model",
    "t": 1,
    "c": "consensus network"
  },
  {
    "objectID": "/model/#term_network%20token",
    "pt": "Model",
    "t": 1,
    "c": "network token"
  },
  {
    "objectID": "/model/#term_non-network%20token",
    "pt": "Model",
    "t": 1,
    "c": "non-network token"
  },
  {
    "objectID": "/model/#term_network%20time",
    "pt": "Model",
    "t": 1,
    "c": "network time"
  },
  {
    "objectID": "/model/#term_time%20delta",
    "pt": "Model",
    "t": 1,
    "c": "time delta"
  },
  {
    "objectID": "/model/#term_network%20second",
    "pt": "Model",
    "t": 1,
    "c": "network second"
  },
  {
    "objectID": "/model/#term_transfers",
    "pt": "Model",
    "t": 1,
    "c": "transfers"
  },
  {
    "objectID": "/model/#term_account",
    "pt": "Model",
    "t": 1,
    "c": "account"
  },
  {
    "objectID": "/model/#term_address",
    "pt": "Model",
    "t": 1,
    "c": "address"
  },
  {
    "objectID": "/model/#term_publication",
    "pt": "Model",
    "t": 1,
    "c": "publication"
  },
  {
    "objectID": "/model/#term_Contracts",
    "pt": "Model",
    "t": 1,
    "c": "Contracts"
  },
  {
    "objectID": "/model/#term_consensus%20state",
    "pt": "Model",
    "t": 1,
    "c": "consensus state"
  },
  {
    "objectID": "/model/#term_mappings",
    "pt": "Model",
    "t": 1,
    "c": "mappings"
  },
  {
    "objectID": "/model/#term_linear%20state",
    "pt": "Model",
    "t": 1,
    "c": "linear state"
  },
  {
    "objectID": "/model/#term_views",
    "pt": "Model",
    "t": 1,
    "c": "views"
  },
  {
    "objectID": "/model/#term_event",
    "pt": "Model",
    "t": 1,
    "c": "event"
  },
  {
    "objectID": "/model/#term_companion",
    "pt": "Model",
    "t": 1,
    "c": "companion"
  },
  {
    "objectID": "/model/#term_deploy",
    "pt": "Model",
    "t": 1,
    "c": "deploy"
  },
  {
    "objectID": "/model/#term_participant",
    "pt": "Model",
    "t": 1,
    "c": "participant"
  },
  {
    "objectID": "/model/#term_local%20state",
    "pt": "Model",
    "t": 1,
    "c": "local state"
  },
  {
    "objectID": "/model/#term_frontend",
    "pt": "Model",
    "t": 1,
    "c": "frontend"
  },
  {
    "objectID": "/model/#term_interact",
    "pt": "Model",
    "t": 1,
    "c": "interact"
  },
  {
    "objectID": "/model/#term_participant%20class",
    "pt": "Model",
    "t": 1,
    "c": "participant class"
  },
  {
    "objectID": "/model/#term_participant%20instances",
    "pt": "Model",
    "t": 1,
    "c": "participant instances"
  },
  {
    "objectID": "/model/#term_API",
    "pt": "Model",
    "t": 1,
    "c": "API"
  },
  {
    "objectID": "/model/#term_token%20linearity%20property",
    "pt": "Model",
    "t": 1,
    "c": "token linearity property"
  },
  {
    "objectID": "/model/#term_step",
    "pt": "Model",
    "t": 1,
    "c": "step"
  },
  {
    "objectID": "/model/#term_local%20step",
    "pt": "Model",
    "t": 1,
    "c": "local step"
  },
  {
    "objectID": "/model/#term_local%20computation",
    "pt": "Model",
    "t": 1,
    "c": "local computation"
  },
  {
    "objectID": "/model/#term_consensus%20transfer",
    "pt": "Model",
    "t": 1,
    "c": "consensus transfer"
  },
  {
    "objectID": "/model/#term_originator",
    "pt": "Model",
    "t": 1,
    "c": "originator"
  },
  {
    "objectID": "/model/#term_timeout",
    "pt": "Model",
    "t": 1,
    "c": "timeout"
  },
  {
    "objectID": "/model/#term_private",
    "pt": "Model",
    "t": 1,
    "c": "private"
  },
  {
    "objectID": "/model/#term_public",
    "pt": "Model",
    "t": 1,
    "c": "public"
  },
  {
    "objectID": "/model/#term_declassification",
    "pt": "Model",
    "t": 1,
    "c": "declassification"
  },
  {
    "objectID": "/model/#term_join",
    "pt": "Model",
    "t": 1,
    "c": "join"
  },
  {
    "objectID": "/model/#term_fixed",
    "pt": "Model",
    "t": 1,
    "c": "fixed"
  },
  {
    "objectID": "/model/#term_consensus%20step",
    "pt": "Model",
    "t": 1,
    "c": "consensus step"
  },
  {
    "objectID": "/model/#term_consensus%20computation",
    "pt": "Model",
    "t": 1,
    "c": "consensus computation"
  },
  {
    "objectID": "/model/#term_commits",
    "pt": "Model",
    "t": 1,
    "c": "commits"
  },
  {
    "objectID": "/model/#term_assert",
    "pt": "Model",
    "t": 1,
    "c": "assert"
  },
  {
    "objectID": "/model/#term_knowledge%20assertion",
    "pt": "Model",
    "t": 1,
    "c": "knowledge assertion"
  },
  {
    "objectID": "/model/#term_static%20assertion",
    "pt": "Model",
    "t": 1,
    "c": "static assertion"
  },
  {
    "objectID": "/model/#term_assumption",
    "pt": "Model",
    "t": 1,
    "c": "assumption"
  },
  {
    "objectID": "/model/#term_requirement",
    "pt": "Model",
    "t": 1,
    "c": "requirement"
  },
  {
    "objectID": "/model/#term_possibility%20assertion",
    "pt": "Model",
    "t": 1,
    "c": "possibility assertion"
  },
  {
    "objectID": "/model/#term_honest",
    "pt": "Model",
    "t": 1,
    "c": "honest"
  },
  {
    "objectID": "/model/#term_value",
    "pt": "Model",
    "t": 1,
    "c": "value"
  },
  {
    "objectID": "/model/#term_digest",
    "pt": "Model",
    "t": 1,
    "c": "digest"
  },
  {
    "objectID": "/model/#term_compile",
    "pt": "Model",
    "t": 1,
    "c": "compile"
  },
  {
    "objectID": "/model/#term_connector",
    "pt": "Model",
    "t": 1,
    "c": "connector"
  },
  {
    "objectID": "/model/#term_backends",
    "pt": "Model",
    "t": 1,
    "c": "backends"
  },
  {
    "objectID": "/model/#ref-model",
    "pt": "Model",
    "t": 2,
    "c": "Model"
  },
  {
    "objectID": "/model/#ref-model-eval",
    "pt": "Model",
    "t": 2,
    "c": "Evaluation Model"
  },
  {
    "objectID": "/model/#ref-model-compile",
    "pt": "Model",
    "t": 2,
    "c": "Compilation Model"
  },
  {
    "objectID": "/model/#ref-model-syntax",
    "pt": "Model",
    "t": 2,
    "c": "Syntax Model"
  },
  {
    "objectID": "/model/#p_0",
    "pt": "Model",
    "t": 3,
    "c": "This document describes the fundamental assumptions and concepts of Reach. First, we discuss the model of running a Reach program in Evaluation Model. Next, we discuss the details about compilation of a Reach program that are relevant to Reach programmers in Compilation Model. Finally, we discuss how Reach programs are syntactically constructed in Syntax Model."
  },
  {
    "objectID": "/model/#p_1",
    "pt": "Model",
    "t": 3,
    "c": "This is not an introduction to Reach. We recommend reading the overview for an introduction to what Reach is and the tutorial to get started with programming Reach."
  },
  {
    "objectID": "/model/#p_2",
    "pt": "Model",
    "t": 3,
    "c": "Furthermore, it is not an introduction to consensus networks or \"blockchain\". If you would like to read such an introduction, we recommend the Wikipedia article on consensus and the Wikipedia article on blockchains."
  },
  {
    "objectID": "/model/#p_3",
    "pt": "Model",
    "t": 3,
    "c": "Reach programs specify a decentralized application (DApp), which is a distributed computation involving many participants and utilizing one contract on one consensus network for reaching agreement on the intermediate values of the computation."
  },
  {
    "objectID": "/model/#p_4",
    "pt": "Model",
    "t": 3,
    "c": "\"Many\" is a technical term that means \"zero or more\"."
  },
  {
    "objectID": "/model/#p_5",
    "pt": "Model",
    "t": 3,
    "c": "When the computation terminates, all participants agree on the outcome, because they agreed on the intermediate values."
  },
  {
    "objectID": "/model/#p_6",
    "pt": "Model",
    "t": 3,
    "c": "At the start of a Reach computation, the set of participants is not necessarily known and can evolve throughout the execution of the application."
  },
  {
    "objectID": "/model/#p_7",
    "pt": "Model",
    "t": 3,
    "c": "A consensus network is a network protocol with a network token, a set of non-network tokens, a set of accounts, a set of contracts, and a network time. A network token is an opaque unit of account. A non-network token is an opaque unit of account; typical consensus networks allow the set of non-network tokens to grow over time and be issued by accounts."
  },
  {
    "objectID": "/model/#p_8",
    "pt": "Model",
    "t": 3,
    "c": "Reach assumes that network tokens and non-network tokens behave identically, but often they do not; this article discusses the causes and consequences of this."
  },
  {
    "objectID": "/model/#p_9",
    "pt": "Model",
    "t": 3,
    "c": "A consensus network's network time is some monotonically increasing discrete value from a totally ordered set; typically, it is the height of the blockchain for consensus networks that use blockchains. A time delta represents the difference between two points in network time as a discrete number of network time units. Each network time corresponds to some network second, which has a connection to real time; typically, it is a Unix time."
  },
  {
    "objectID": "/model/#p_10",
    "pt": "Model",
    "t": 3,
    "c": "This description of consensus networks is an abstraction that may not be directly implemented by actual networks."
  },
  {
    "objectID": "/model/#p_11",
    "pt": "Model",
    "t": 3,
    "c": "For example, in UTXO-based networks, there is not typically an explicitly represented account balance ledger. However, such networks do abstractly have accounts with balances, because particular private keys represent accounts which have exclusive access to some set of network tokens which is their balance."
  },
  {
    "objectID": "/model/#p_12",
    "pt": "Model",
    "t": 3,
    "c": "Similarly, Reach's notion of time may appear overly abstract (\"monotonically increasing ... totally ordered set\") if you know that many consensus networks are based on blockchains and use the chain length, also called the height or block number, as a notion of time. In this case, network time would be a natural number, which is a prototypical model of a totally ordered set. However, Reach is flexible enough to support non-blockchain-based consensus networks, so it does not mandate this particular natural number-based notion of time."
  },
  {
    "objectID": "/model/#p_13",
    "pt": "Model",
    "t": 3,
    "c": "Finally, Reach's definition of consensus network does not require any particular technology or features of this. In particular, it does not only refer to so-called \"layer-1\" protocols, nor does it exclude centralized systems with trusted parties controlling the network."
  },
  {
    "objectID": "/model/#p_14",
    "pt": "Model",
    "t": 3,
    "c": "Consensus networks support transfers of network tokens and non-network tokens between accounts. An account is a unique identity (called an address) with a non-negative balance of network tokens. Accounts may sign values in a way that may not be repudiated or impersonated; this is called publication. The chapter, Networks, discusses which consensus networks are supported by Reach."
  },
  {
    "objectID": "/model/#p_15",
    "pt": "Model",
    "t": 3,
    "c": "Contracts are accounts with three extra capacities: they persistently store values (called the consensus state), they may receive publications, and when they receive publications, they systematically process them and may modify their consensus state, make publications, and may transfer network tokens and non-network tokens in response to the reception. In addition to values, consensus state may contain a fixed number of mappings between an address and a value. These mappings are referred to as \"linear state\" because their size is linear in the number of addresses visible to the contract. Furthermore, a contract may provide views of its consensus state, which are labeled functions and values which may be hierarchically organized, such as NFT.owner or scoreOfPlayer. These views are visible in sub-trees of the computation graph. A contract may also emit events, which are externally observable values that are persistently available. On some networks, contracts have companions, which are another contract that does work for them that cannot be done in the contract itself. The creation of a contract is called deployment."
  },
  {
    "objectID": "/model/#p_16",
    "pt": "Model",
    "t": 3,
    "c": "A participant is a logical actor which takes part in a DApp. It is associated with an account on the consensus network."
  },
  {
    "objectID": "/model/#p_17",
    "pt": "Model",
    "t": 3,
    "c": "The same account may be used by multiple participants in a DApp."
  },
  {
    "objectID": "/model/#p_18",
    "pt": "Model",
    "t": 3,
    "c": "A participant has persistently stored values, called its local state. It has a frontend which it interacts with. A frontend is an abstract actor which supports a set of functions which consume and produce values; when a participant invokes one of these functions it is referred to as interaction."
  },
  {
    "objectID": "/model/#p_19",
    "pt": "Model",
    "t": 3,
    "c": "A participant class is a category of participant that may occur many times in a single application. Members of a participant class are referred to as participant instances when their status as a member of a class is important, but just \"participants\" otherwise. Participant instances are independent participants like any other; for example, with their own local state, frontend, and so on. The main distinction is that when a member of a participant class joins an application, it is not fixed like other participants, because a participant instance does not exclusively represent the participant class."
  },
  {
    "objectID": "/model/#p_20",
    "pt": "Model",
    "t": 3,
    "c": "An API is a source of publications that do not correspond to any participant and are therefore like asynchronous events that impinge on the computation. The contract returns a value to an API call. APIs are organized into a labeled hierarchy, like Contest.vote and User.write."
  },
  {
    "objectID": "/model/#p_21",
    "pt": "Model",
    "t": 3,
    "c": "Since DApps have an associated contract, they have an associated account."
  },
  {
    "objectID": "/model/#p_22",
    "pt": "Model",
    "t": 3,
    "c": "The contract account must be distinct from all participant accounts."
  },
  {
    "objectID": "/model/#p_23",
    "pt": "Model",
    "t": 3,
    "c": "This account is assumed to be empty when the computation starts."
  },
  {
    "objectID": "/model/#p_24",
    "pt": "Model",
    "t": 3,
    "c": "On some consensus networks, it is possible for transfers to a contract account to occur outside of the purview of Reach. If this occurs, then those network tokens are remitted to the originator of the final consensus transfer."
  },
  {
    "objectID": "/model/#p_25",
    "pt": "Model",
    "t": 3,
    "c": "Any network tokens transferred into the account must be removed by the DApp's completion. This is called the token linearity property."
  },
  {
    "objectID": "/model/#p_26",
    "pt": "Model",
    "t": 3,
    "c": "A DApp computation can be seen as a graph of steps with a unique first step. A step is a set of local steps by participants followed by a single consensus step introduced via a single consensus transfer."
  },
  {
    "objectID": "/model/#p_27",
    "pt": "Model",
    "t": 3,
    "c": "A local step is executed by a single participant and is a sequence of local computations. A local computation may bind a piece of local state, assert a property of the local state, or interact with the frontend. A consensus transfer is executed by a single participant (called the originator) which makes a publication of a set of public values from its local state and transfers zero or more network tokens to the contract account. A consensus transfer specifies an alternative step, called a timeout, that is executed if the originator fails to make the transfer before a given time delta has elapsed. All local state is initially private, until it is explicitly made public via a declassification, which is a kind of local computation."
  },
  {
    "objectID": "/model/#p_28",
    "pt": "Model",
    "t": 3,
    "c": "A participant is said to join an application when it first makes a publication. For non-participant instances, this also makes the participant fixed, whereby the consensus state includes an assignment from the participant to the particular account (i.e. address) which it is fixed to. All subsequent publications by a fixed participant must be from the fixed account."
  },
  {
    "objectID": "/model/#p_29",
    "pt": "Model",
    "t": 3,
    "c": "A consensus step is a graph of consensus computations with a unique first computation. A consensus computation either binds consensus state, asserts a property of the consensus state, performs a transfer, selects between different next consensus computations, communicates with another contract (referred to as a remote object), or commits to the next step."
  },
  {
    "objectID": "/model/#p_30",
    "pt": "Model",
    "t": 3,
    "c": "An assertion is either: a knowledge assertion, which is a claim that one honest participant cannot know something that another honest participant does know; a static assertion, which is an always-true formula; an assumption, which is a true formula if frontends behave honestly; a requirement, which is a true formula if participants behave honestly; or, a possibility assertion, which is a formula for which there exists some values that honest participants and frontends could submit which results in the truth of the formula. An honest participant is one that executes the steps specified by the DApp, while an honest frontend is one that only returns values which ensure that all assumptions evaluate to the boolean {!rsh} true."
  },
  {
    "objectID": "/model/#p_31",
    "pt": "Model",
    "t": 3,
    "c": "A value is either: the null value, a boolean, an unsigned integer, a string of bytes, a digest, an address, a fixed tuple of values, a statically-sized homogeneous array of values, or a fixed record of values. Values may be digested to produce a cryptographic hash of their binary encoding."
  },
  {
    "objectID": "/model/#p_32",
    "pt": "Model",
    "t": 3,
    "c": "Values are in one of three possible conditions. They could be consensus state, in which case they are known to all participants. They could be local state of a single participant, which means they are known by only that participant. Local state is further divided into private local state, which cannot be included in a publication, and public local state, which can. These conditions are summarized thus:"
  },
  {
    "objectID": "/model/#p_33",
    "pt": "Model",
    "t": 3,
    "c": "Local, private: The initial state."
  },
  {
    "objectID": "/model/#p_34",
    "pt": "Model",
    "t": 3,
    "c": "Local, public: The result of {!rsh} declassify."
  },
  {
    "objectID": "/model/#p_35",
    "pt": "Model",
    "t": 3,
    "c": "Consensus: The result of {!rsh} publish."
  },
  {
    "objectID": "/model/#p_36",
    "pt": "Model",
    "t": 3,
    "c": "Reach programs cannot execute independently of a consensus network and a set of frontends. Thus, the semantics of Reach treats these components abstractly and does not specify their semantics. Therefore, the semantics of Reach cannot be effectively implemented directly in a virtual machine or interpreter. Instead, Reach programs are compiled to a particular consensus network connector and a set of participant backends which execute the computation of the particular consensus network. Connectors and backends are sound if they faithfully model the abstract semantics assumed by Reach."
  },
  {
    "objectID": "/model/#p_37",
    "pt": "Model",
    "t": 3,
    "c": "During compilation, the Reach compiler automatically verifies that the token linearity property and all static assertions and possibility assertions are true whether participants and frontends are honest or not. Similarly, all knowledge assertions are verified using a conservative approximation of participant knowledge. This conservative approximation assumes that all inputs to a computation are revealed by the result of the computation, except for digests and interaction. This approximation means that Reach cannot, for example, reason about the details of manually expressed encryption formulas and will assume they are insecure. Finally, a subtle point about the knowledge checker is relevant: technically participants with different identities in a Reach program may actually be instantiated by the same principals, i.e. if Alice choses to play a game of a Chess against herself, where she controls both Black and White; as this is always possible, the knowledge checker does not consider it a violation of a claim that White knows something Black does not."
  },
  {
    "objectID": "/model/#p_38",
    "pt": "Model",
    "t": 3,
    "c": "If these assertions cannot be statically verified, then the compilation process aborts. After this verification, such static assertions and possibility assertions are removed from the program and do not occur at runtime. In contrast, assumptions are enforced at runtime by backends and requirements are enforced at runtime by connectors. If assumptions are violated at runtime, then the backend aborts. If requirements are violated at runtime, then the connector ensures that all aspects of the DApp (the contract and participant) ignore the inducing consensus transfer, which often results in a timeout."
  },
  {
    "objectID": "/model/#p_39",
    "pt": "Model",
    "t": 3,
    "c": "Reach programs are specified via a subset of well-formed JavaScript syntax inside source files. The section Language describes the syntax of Reach programs in detail."
  },
  {
    "objectID": "/networks/#ref-networks",
    "pt": "Networks",
    "t": 2,
    "c": "Networks"
  },
  {
    "objectID": "/networks/#ref-network-algo",
    "pt": "Networks",
    "t": 2,
    "c": "Algorand"
  },
  {
    "objectID": "/networks/#ref-network-eth",
    "pt": "Networks",
    "t": 2,
    "c": "Ethereum"
  },
  {
    "objectID": "/networks/#p_0",
    "pt": "Networks",
    "t": 3,
    "c": "This section describes the consensus network connectors supported by Reach version 0.1.13:"
  },
  {
    "objectID": "/networks/#p_1",
    "pt": "Networks",
    "t": 3,
    "c": "The Algorand Reach connector generates a contract that manage one instance of the DApp's execution."
  },
  {
    "objectID": "/networks/#p_2",
    "pt": "Networks",
    "t": 3,
    "c": "It uses finite on-chain state. The DApp consists of one application. The contract escrow account is the application account. Sometimes a companion contract is created that is used to increase the opcode budget during contract execution."
  },
  {
    "objectID": "/networks/#p_3",
    "pt": "Networks",
    "t": 3,
    "c": "It relies on versions of algod that support TEAL version 6, such as Algorand 3.5.1. It uses the Algorand indexer version 2 to lookup and monitor publications; in other words, it does not rely on any communication network other than Algorand itself."
  },
  {
    "objectID": "/networks/#p_4",
    "pt": "Networks",
    "t": 3,
    "c": "Algorand uses the SHA256 algorithm to perform digests. Its bit width is 64-bits."
  },
  {
    "objectID": "/networks/#p_5",
    "pt": "Networks",
    "t": 3,
    "c": "Non-network tokens are compiled to Algorand Standard Assets (ASAs). Specifically, the {!rsh} Token type refers to the id of the ASA."
  },
  {
    "objectID": "/networks/#p_6",
    "pt": "Networks",
    "t": 3,
    "c": "Token minting creates an ASA owned and managed by the contract account. Freezing, clawback, reserves, and separate managers are not supported."
  },
  {
    "objectID": "/networks/#p_7",
    "pt": "Networks",
    "t": 3,
    "c": "Views are compiled to client-side functions that can interpret the global and local state of the Algorand Application associated with the DApp. This means they are sensitive to the particular compilation details of the particular Reach program. We hope to work with the Algorand community to define a standard for views. Views expand the on-chain state to include the free variables of all values bound to a view."
  },
  {
    "objectID": "/networks/#p_8",
    "pt": "Networks",
    "t": 3,
    "c": "Linear state is compiled into application box storage. The names of boxes are either:"
  },
  {
    "objectID": "/networks/#p_9",
    "pt": "Networks",
    "t": 3,
    "c": "${MapIndexByte}${KeyBytes}, where MapIndexByte is the single-byte representation of which {!rsh} Map it is and KeyBytes is the ABI encoding of the key, if this is less than 64 bytes; or"
  },
  {
    "objectID": "/networks/#p_10",
    "pt": "Networks",
    "t": 3,
    "c": "sha256(${MapIndexBytes}${KeyBytes}), where MapIndexBytes is the multi-byte representation of the {!rsh} Map it is, otherwise."
  },
  {
    "objectID": "/networks/#p_11",
    "pt": "Networks",
    "t": 3,
    "c": "Reach makes no attempt to ensure that when the application ends, all boxes are freed. You should read about the {!rsh} ALGOExitMode option for {!rsh} setOptions for more information about the issues this poses."
  },
  {
    "objectID": "/networks/#p_12",
    "pt": "Networks",
    "t": 3,
    "c": "In Algorand, network time corresponds to round numbers. Each round is assigned a Unix timestamp, but when you look at the timestamp in code executing in round N+1, you read the timestamp assigned to round N. Ensure that you read RW0006 if you use network seconds."
  },
  {
    "objectID": "/networks/#p_13",
    "pt": "Networks",
    "t": 3,
    "c": "The connector provides a binding named {!rsh} ALGO to backends."
  },
  {
    "objectID": "/networks/#p_14",
    "pt": "Networks",
    "t": 3,
    "c": "Reach uses the following environment variables:"
  },
  {
    "objectID": "/networks/#p_15",
    "pt": "Networks",
    "t": 3,
    "c": "ALGO_TOKEN is used as the API token for your algod. When left unspecified, this defaults to the token of the Reach devnet."
  },
  {
    "objectID": "/networks/#p_16",
    "pt": "Networks",
    "t": 3,
    "c": "ALGO_TOKEN_HEADER is used as the HTTP header to share the algod API token. When left unspecified, this defaults to X-Algo-API-Token."
  },
  {
    "objectID": "/networks/#p_17",
    "pt": "Networks",
    "t": 3,
    "c": "ALGO_SERVER is used as the address of your algod. When left unspecified, this defaults to http://localhost."
  },
  {
    "objectID": "/networks/#p_18",
    "pt": "Networks",
    "t": 3,
    "c": "ALGO_PORT is used as the port of your algod. When left unspecified, this defaults to 4180."
  },
  {
    "objectID": "/networks/#p_19",
    "pt": "Networks",
    "t": 3,
    "c": "ALGO_INDEXER_TOKEN is used as the API token for your indexer. When left unspecified, this defaults to the token of the Reach devnet."
  },
  {
    "objectID": "/networks/#p_20",
    "pt": "Networks",
    "t": 3,
    "c": "ALGO_INDEXER_TOKEN_HEADER is used as the HTTP header to share the indexer API token. When left unspecified, this defaults to X-Indexer-API-Token."
  },
  {
    "objectID": "/networks/#p_21",
    "pt": "Networks",
    "t": 3,
    "c": "ALGO_INDEXER_SERVER is used as the address of your indexer. When left unspecified, this defaults to http://localhost."
  },
  {
    "objectID": "/networks/#p_22",
    "pt": "Networks",
    "t": 3,
    "c": "ALGO_INDEXER_PORT is used as the port of your indexer. When left unspecified, this defaults to 8980."
  },
  {
    "objectID": "/networks/#p_23",
    "pt": "Networks",
    "t": 3,
    "c": "ALGO_NODE_WRITE_ONLY specifies if your algod will handle read requests, or just writes. When left unspecified, this defaults to no."
  },
  {
    "objectID": "/networks/#p_24",
    "pt": "Networks",
    "t": 3,
    "c": "ALGO_FAUCET_PASSPHRASE is used as the mnemonic for the faucet of your network. When left unspecified, this defaults to the passphrase of the Reach devnet's faucet. This is useful if you are running your own testing network."
  },
  {
    "objectID": "/networks/#p_25",
    "pt": "Networks",
    "t": 3,
    "c": "ALGO_GENESIS_ID or ALGO_GENESIS_HASH (or both), which allows you to request that the user's ARC-6 compliant wallet connect to a specific network. When left unspecified, it allows the user to select one of their wallet's supported networks."
  },
  {
    "objectID": "/networks/#p_26",
    "pt": "Networks",
    "t": 3,
    "c": "ALGO_ACCOUNT, which allows you to request the use of a specific account from the user's ARC-6 compliant wallet by address. This should usually be left unspecified, which allows the user to instead select their preferred account."
  },
  {
    "objectID": "/networks/#p_27",
    "pt": "Networks",
    "t": 3,
    "c": "The Ethereum Reach connector generates a contract that manages one instance of the DApp's execution. It is guaranteed to use exactly one word of on-chain state, while each piece of consensus state appears as a transaction argument."
  },
  {
    "objectID": "/networks/#p_28",
    "pt": "Networks",
    "t": 3,
    "c": "Ethereum uses the Keccak256 algorithm to perform digests. Its bit width is 256-bits."
  },
  {
    "objectID": "/networks/#p_29",
    "pt": "Networks",
    "t": 3,
    "c": "Non-network tokens are compiled to ERC-20 fungible tokens. Specifically, the {!rsh} Token type refers to the address of the ERC-20 contract. Token minting launches a fresh ERC-20 contract based on the OpenZeppelin ERC-20 implementation, which stores additional metadata and allows the creator to burn tokens and destroy the token if there is no supply (i.e. it has all been burned)."
  },
  {
    "objectID": "/networks/#p_30",
    "pt": "Networks",
    "t": 3,
    "c": "Views are compiled to view functions. A view named X.Y will be named X_Y. A view named X will be named X. Views expand the on-chain state to include the free variables of all values bound to a view."
  },
  {
    "objectID": "/networks/#p_31",
    "pt": "Networks",
    "t": 3,
    "c": "In Ethereum, network time corresponds to block numbers and network seconds correspond to the Unix timestamp of the block. Ensure that you read RW0006 if you use network seconds."
  },
  {
    "objectID": "/networks/#p_32",
    "pt": "Networks",
    "t": 3,
    "c": "The connector provides a binding named {!rsh} ETH to backends."
  },
  {
    "objectID": "/networks/#p_33",
    "pt": "Networks",
    "t": 3,
    "c": "During compilation, the connector produces one intermediate output: input.export.sol, containing the Solidity code implementing the contract."
  },
  {
    "objectID": "/networks/#p_34",
    "pt": "Networks",
    "t": 3,
    "c": "A few details of Ethereum leak through to Reach. The node that a given participant is connected to does not instantly know that its blocks are correct and may revert past transactions after it reaches consensus with the rest of the network. This means that Reach applications must not make externally observable effects until after such consensus is reached."
  },
  {
    "objectID": "/networks/#p_35",
    "pt": "Networks",
    "t": 3,
    "c": "Backends must respect the following environment variables:"
  },
  {
    "objectID": "/networks/#p_36",
    "pt": "Networks",
    "t": 3,
    "c": "ETH_NODE_URI is used to contact the Ethereum node. It defaults to http://localhost:8545."
  },
  {
    "objectID": "/networks/#p_37",
    "pt": "Networks",
    "t": 3,
    "c": "ETH_NODE_NETWORK is used to name the Ethereum network. It defaults to unspecified."
  },
  {
    "objectID": "/quickstart/#quickstart",
    "pt": "Quickstart",
    "t": 2,
    "c": "Quickstart"
  },
  {
    "objectID": "/quickstart/#qs-win",
    "pt": "Quickstart",
    "t": 2,
    "c": "Windows"
  },
  {
    "objectID": "/quickstart/#qs-win-prereqs",
    "pt": "Quickstart",
    "t": 2,
    "c": "Prerequisites"
  },
  {
    "objectID": "/quickstart/#qs-win-install",
    "pt": "Quickstart",
    "t": 2,
    "c": "Installation"
  },
  {
    "objectID": "/quickstart/#qs-installing-docker",
    "pt": "Quickstart",
    "t": 2,
    "c": "Installing Docker:"
  },
  {
    "objectID": "/quickstart/#qs-win-conf-docker",
    "pt": "Quickstart",
    "t": 2,
    "c": "Configuring Docker:"
  },
  {
    "objectID": "/quickstart/#qs-linux",
    "pt": "Quickstart",
    "t": 2,
    "c": "Linux"
  },
  {
    "objectID": "/quickstart/#qs-linux-prereqs",
    "pt": "Quickstart",
    "t": 2,
    "c": "Prerequisites"
  },
  {
    "objectID": "/quickstart/#qs-linux-install",
    "pt": "Quickstart",
    "t": 2,
    "c": "Installation for Ubuntu"
  },
  {
    "objectID": "/quickstart/#qs-mac",
    "pt": "Quickstart",
    "t": 2,
    "c": "MacOS"
  },
  {
    "objectID": "/quickstart/#qs-mac-install",
    "pt": "Quickstart",
    "t": 2,
    "c": "Installation"
  },
  {
    "objectID": "/quickstart/#p_0",
    "pt": "Quickstart",
    "t": 3,
    "c": "This quickstart guide outlines the step-by-step instructions for getting started with programming in Reach. You can install on the following operating systems:"
  },
  {
    "objectID": "/quickstart/#p_1",
    "pt": "Quickstart",
    "t": 3,
    "c": "If you have any issues running reach, please check the Troubleshooting page for solutions."
  },
  {
    "objectID": "/quickstart/#p_2",
    "pt": "Quickstart",
    "t": 3,
    "c": "Reach requires WSL 2 and Docker Desktop to be installed."
  },
  {
    "objectID": "/quickstart/#p_3",
    "pt": "Quickstart",
    "t": 3,
    "c": "Windows 10 installed with version 2004 or higher,"
  },
  {
    "objectID": "/quickstart/#p_4",
    "pt": "Quickstart",
    "t": 3,
    "c": "or"
  },
  {
    "objectID": "/quickstart/#p_5",
    "pt": "Quickstart",
    "t": 3,
    "c": "Windows "
  },
  {
    "objectID": "/quickstart/#p_6",
    "pt": "Quickstart",
    "t": 3,
    "c": "Virtualization Technology (VT-x) enabled on the BIOS"
  },
  {
    "objectID": "/quickstart/#p_7",
    "pt": "Quickstart",
    "t": 3,
    "c": "Click the Windows icon, type Powershell, and then click Run as Administrator. There are a number of commands that need to be run to get Windows ready for Reach."
  },
  {
    "objectID": "/quickstart/#p_8",
    "pt": "Quickstart",
    "t": 3,
    "c": "To install WSL on Windows, enable these two features:"
  },
  {
    "objectID": "/quickstart/#p_9",
    "pt": "Quickstart",
    "t": 3,
    "c": "Enable WSL:"
  },
  {
    "objectID": "/quickstart/#p_10",
    "pt": "Quickstart",
    "t": 3,
    "c": "Enable the Virtual Machine feature:"
  },
  {
    "objectID": "/quickstart/#p_11",
    "pt": "Quickstart",
    "t": 3,
    "c": "After enabling these two features, reboot:"
  },
  {
    "objectID": "/quickstart/#p_12",
    "pt": "Quickstart",
    "t": 3,
    "c": "After rebooting, reopen Powershell as an administrator, and execute the following commands:"
  },
  {
    "objectID": "/quickstart/#p_13",
    "pt": "Quickstart",
    "t": 3,
    "c": "In the Command Prompt window, run the following command to set the WSL version to 2:"
  },
  {
    "objectID": "/quickstart/#p_14",
    "pt": "Quickstart",
    "t": 3,
    "c": "After setting up the default version, install the WSL distribution:"
  },
  {
    "objectID": "/quickstart/#p_15",
    "pt": "Quickstart",
    "t": 3,
    "c": "When the installation is finished, a terminal called Ubuntu should open on your screen. It will request that you set up a user and password. Make sure you don't skip this step."
  },
  {
    "objectID": "/quickstart/#p_16",
    "pt": "Quickstart",
    "t": 3,
    "c": "To install Docker we will use winget. It is the official package manager for Windows. We will download the package from Microsoft's official GitHub account."
  },
  {
    "objectID": "/quickstart/#p_17",
    "pt": "Quickstart",
    "t": 3,
    "c": "To install Winget run:"
  },
  {
    "objectID": "/quickstart/#p_18",
    "pt": "Quickstart",
    "t": 3,
    "c": "A window should pop up. Click Update."
  },
  {
    "objectID": "/quickstart/#p_19",
    "pt": "Quickstart",
    "t": 3,
    "c": "Next, install Docker using winget:"
  },
  {
    "objectID": "/quickstart/#p_20",
    "pt": "Quickstart",
    "t": 3,
    "c": "After installing Docker, reboot:"
  },
  {
    "objectID": "/quickstart/#p_21",
    "pt": "Quickstart",
    "t": 3,
    "c": "Open Docker and wait for it to initialize. Click the Settings (gear) icon along the top of the Docker app."
  },
  {
    "objectID": "/quickstart/#p_22",
    "pt": "Quickstart",
    "t": 3,
    "c": "Verify that WSL 2.0 and Use Docker Compose V2 are checked."
  },
  {
    "objectID": "/quickstart/#p_23",
    "pt": "Quickstart",
    "t": 3,
    "c": "Click Resources in the left-hand menu, and make sure that Enable integration with additional distros is checked, and that Ubuntu is selected."
  },
  {
    "objectID": "/quickstart/#p_24",
    "pt": "Quickstart",
    "t": 3,
    "c": "Click the Ubuntu icon in the Windows Start-up menu to open the Ubuntu terminal. You will need to provide a username and password for Ubuntu."
  },
  {
    "objectID": "/quickstart/#p_25",
    "pt": "Quickstart",
    "t": 3,
    "c": "In the terminal, run the following to install make and curl:"
  },
  {
    "objectID": "/quickstart/#p_26",
    "pt": "Quickstart",
    "t": 3,
    "c": "Create and navigate to the reach directory with the following command:"
  },
  {
    "objectID": "/quickstart/#p_27",
    "pt": "Quickstart",
    "t": 3,
    "c": "Download Reach with the following command:"
  },
  {
    "objectID": "/quickstart/#p_28",
    "pt": "Quickstart",
    "t": 3,
    "c": "Reach is successfully downloaded if the following command returns a version number:"
  },
  {
    "objectID": "/quickstart/#p_29",
    "pt": "Quickstart",
    "t": 3,
    "c": "You are now ready to start programming in Reach. Begin with the Wisdom For Sale tutorial."
  },
  {
    "objectID": "/quickstart/#p_30",
    "pt": "Quickstart",
    "t": 3,
    "c": "Reach requires make, Docker Engine, and Docker Compose."
  },
  {
    "objectID": "/quickstart/#p_31",
    "pt": "Quickstart",
    "t": 3,
    "c": "A version of Linux compatible with Docker."
  },
  {
    "objectID": "/quickstart/#p_32",
    "pt": "Quickstart",
    "t": 3,
    "c": "Our instructions are written assuming you're using the most recent version of Ubuntu. Check the Docker Engine page for supported distros."
  },
  {
    "objectID": "/quickstart/#p_33",
    "pt": "Quickstart",
    "t": 3,
    "c": "Follow the Docker Engine instructions for installing on your version of Linux. Check the commands required for completing the tasks below for your distro. The following instructions from Docker assume that Ubuntu is the installed distro."
  },
  {
    "objectID": "/quickstart/#p_34",
    "pt": "Quickstart",
    "t": 3,
    "c": "In the terminal, run the following to install make:"
  },
  {
    "objectID": "/quickstart/#p_35",
    "pt": "Quickstart",
    "t": 3,
    "c": "Next, run the following to allow apt to use repositories containing HTTPS:"
  },
  {
    "objectID": "/quickstart/#p_36",
    "pt": "Quickstart",
    "t": 3,
    "c": "Docker will be installed by adding a package repository from Docker; this requires updating your apt configuration:"
  },
  {
    "objectID": "/quickstart/#p_37",
    "pt": "Quickstart",
    "t": 3,
    "c": "Then run:"
  },
  {
    "objectID": "/quickstart/#p_38",
    "pt": "Quickstart",
    "t": 3,
    "c": "And then run:"
  },
  {
    "objectID": "/quickstart/#p_39",
    "pt": "Quickstart",
    "t": 3,
    "c": "You may want to run the post-installation steps for Linux that Docker recommends."
  },
  {
    "objectID": "/quickstart/#p_40",
    "pt": "Quickstart",
    "t": 3,
    "c": "Create and navigate to the reach directory with the following command:"
  },
  {
    "objectID": "/quickstart/#p_41",
    "pt": "Quickstart",
    "t": 3,
    "c": "Download Reach with the following command:"
  },
  {
    "objectID": "/quickstart/#p_42",
    "pt": "Quickstart",
    "t": 3,
    "c": "Reach is successfully downloaded if the following command returns a version number:"
  },
  {
    "objectID": "/quickstart/#p_43",
    "pt": "Quickstart",
    "t": 3,
    "c": "You are now ready to start programming in Reach. Begin with the Wisdom For Sale tutorial."
  },
  {
    "objectID": "/quickstart/#p_44",
    "pt": "Quickstart",
    "t": 3,
    "c": "Reach is compatible with M1 chips and Intel chips running macOS 10.15 or newer. Installation instructions should not differ regardless of the MacOS architecture. Reach requires installing Docker."
  },
  {
    "objectID": "/quickstart/#p_45",
    "pt": "Quickstart",
    "t": 3,
    "c": "make should be preinstalled. Test this by opening terminal and running the following command:"
  },
  {
    "objectID": "/quickstart/#p_46",
    "pt": "Quickstart",
    "t": 3,
    "c": "Download Docker Desktop and follow the prompts to complete application setup."
  },
  {
    "objectID": "/quickstart/#p_47",
    "pt": "Quickstart",
    "t": 3,
    "c": "According to the Docker Docs, \"Docker Desktop for Mac includes Compose along with other Docker apps, so Mac users do not need to install Compose separately.\""
  },
  {
    "objectID": "/quickstart/#p_48",
    "pt": "Quickstart",
    "t": 3,
    "c": "To verify that Docker Compose is operating on your Mac, execute the command:"
  },
  {
    "objectID": "/quickstart/#p_49",
    "pt": "Quickstart",
    "t": 3,
    "c": "When it returns a version number, Reach is ready to be installed."
  },
  {
    "objectID": "/quickstart/#p_50",
    "pt": "Quickstart",
    "t": 3,
    "c": "Create and navigate to the reach directory with the following command:"
  },
  {
    "objectID": "/quickstart/#p_51",
    "pt": "Quickstart",
    "t": 3,
    "c": "Download Reach with the following command:"
  },
  {
    "objectID": "/quickstart/#p_52",
    "pt": "Quickstart",
    "t": 3,
    "c": "Reach is successfully downloaded if the following command returns a version number:"
  },
  {
    "objectID": "/quickstart/#p_53",
    "pt": "Quickstart",
    "t": 3,
    "c": "You are now ready to start programming in Reach. Begin with the Wisdom For Sale tutorial."
  },
  {
    "objectID": "/rsh/#term_programs",
    "pt": "Language",
    "t": 1,
    "c": "programs"
  },
  {
    "objectID": "/rsh/#term_valid",
    "pt": "Language",
    "t": 1,
    "c": "valid"
  },
  {
    "objectID": "/rsh/#term_invalid",
    "pt": "Language",
    "t": 1,
    "c": "invalid"
  },
  {
    "objectID": "/rsh/#term_secret",
    "pt": "Language",
    "t": 1,
    "c": "secret"
  },
  {
    "objectID": "/rsh/#term_dominated",
    "pt": "Language",
    "t": 1,
    "c": "dominated"
  },
  {
    "objectID": "/rsh/#ref-programs",
    "pt": "Language",
    "t": 2,
    "c": "Language"
  },
  {
    "objectID": "/rsh/#ref-programs-valid",
    "pt": "Language",
    "t": 2,
    "c": "Validity and other concepts"
  },
  {
    "objectID": "/rsh/#security-levels-and-scope",
    "pt": "Language",
    "t": 2,
    "c": "Security levels and scope"
  },
  {
    "objectID": "/rsh/#domination",
    "pt": "Language",
    "t": 2,
    "c": "Domination"
  },
  {
    "objectID": "/rsh/#p_0",
    "pt": "Language",
    "t": 3,
    "c": "This document describes the structure and content of Reach programs, including their syntactic forms, the standard library, and the standards of valid programs."
  },
  {
    "objectID": "/rsh/#p_1",
    "pt": "Language",
    "t": 3,
    "c": "Get language support for Reach in your editor by visiting IDE/Text Editor Support."
  },
  {
    "objectID": "/rsh/#p_2",
    "pt": "Language",
    "t": 3,
    "c": "The rest of this section is structured according to the contexts of the different parts of a Reach program, as follows:"
  },
  {
    "objectID": "/rsh/#p_3",
    "pt": "Language",
    "t": 3,
    "c": "Validity and other concepts describes what is meant by the term valid in Reach."
  },
  {
    "objectID": "/rsh/#p_4",
    "pt": "Language",
    "t": 3,
    "c": "Modules describes the top-level structure of a Reach module."
  },
  {
    "objectID": "/rsh/#p_5",
    "pt": "Language",
    "t": 3,
    "c": "Application Initialization describes the structure of Reach application initialization."
  },
  {
    "objectID": "/rsh/#p_6",
    "pt": "Language",
    "t": 3,
    "c": "Steps describes the structure of Reach steps."
  },
  {
    "objectID": "/rsh/#p_7",
    "pt": "Language",
    "t": 3,
    "c": "Local Steps describes the structure of Reach local steps."
  },
  {
    "objectID": "/rsh/#p_8",
    "pt": "Language",
    "t": 3,
    "c": "Consensus Steps describes the structure of Reach consensus steps."
  },
  {
    "objectID": "/rsh/#p_9",
    "pt": "Language",
    "t": 3,
    "c": "Computations describes the common structure of Reach computations shared by all contexts."
  },
  {
    "objectID": "/rsh/#p_10",
    "pt": "Language",
    "t": 3,
    "c": "The relationship between the modes of a Reach application is shown by this diagram:"
  },
  {
    "objectID": "/rsh/#p_11",
    "pt": "Language",
    "t": 3,
    "c": "Reach imposes further restrictions on syntactically well-formed programs. These restrictions are described throughout this manual using the term valid to refer to constructions that obey the restrictions, and the term invalid to refer to constructions that do not obey them."
  },
  {
    "objectID": "/rsh/#p_12",
    "pt": "Language",
    "t": 3,
    "c": "It is always invalid to use a value with an operation for which it is undefined. For example, {!rsh} 1 + true is invalid. In other words, Reach enforces a static type discipline."
  },
  {
    "objectID": "/rsh/#p_13",
    "pt": "Language",
    "t": 3,
    "c": "The text of a Reach program is public knowledge to all participants. However, any value that comes from an interaction expression is a secret which only that participant knows. Furthermore, any values derived from secret values are also secret. A value, X, is considered derived from another, Y, if the value of Y is provided to a primitive operation to arrive at X, or if Y is used as part of a conditional that influences the definition of X. Secrets can only be made public by using the declassify primitive."
  },
  {
    "objectID": "/rsh/#p_14",
    "pt": "Language",
    "t": 3,
    "c": "When secret values are bound to an identifier within a local step, the identifier name MUST be prefixed by an underscore ({!rsh} _)."
  },
  {
    "objectID": "/rsh/#p_15",
    "pt": "Language",
    "t": 3,
    "c": "When public values are bound to an identifier, regardless of context, the identifier name MUST NOT be prefixed by an underscore ({!rsh} _)."
  },
  {
    "objectID": "/rsh/#p_16",
    "pt": "Language",
    "t": 3,
    "c": "Consequently, identifiers which appear inside of a function definition or arrow expression MAY be prefixed by an underscore. This will cause a compiler error if any value bound to that identifier is public."
  },
  {
    "objectID": "/rsh/#p_17",
    "pt": "Language",
    "t": 3,
    "c": "A term Y is said to be \"dominated\" by a term X if all paths in the control-flow graph of the application from the root to Y pass through X. In most cases, this corresponds to \"X appears above Y at the same or lower level of indentation\" in the program source code."
  },
  {
    "objectID": "/rsh/#p_18",
    "pt": "Language",
    "t": 3,
    "c": "For example, in the following program:"
  },
  {
    "objectID": "/rsh/#p_19",
    "pt": "Language",
    "t": 3,
    "c": "{!rsh} f dominates {!rsh} p, {!rsh} g, {!rsh} h, and {!rsh} m. But no other term dominates any other term. In particular, {!rsh} g does not dominate {!rsh} m because it is possible to reach {!rsh} m without going through {!rsh} g, such as when {!rsh} p() is false."
  },
  {
    "objectID": "/search/#search",
    "pt": "Search",
    "t": 2,
    "c": "Search"
  },
  {
    "objectID": "/tool/#cmd_REACH_CONNECTOR_MODE",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "REACH_CONNECTOR_MODE"
  },
  {
    "objectID": "/tool/#cmd_REACH_VERSION",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "REACH_VERSION"
  },
  {
    "objectID": "/tool/#cmd_REACH_DEBUG",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "REACH_DEBUG"
  },
  {
    "objectID": "/tool/#cmd_reach%20compile",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach compile"
  },
  {
    "objectID": "/tool/#cmd_reach%20init",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach init"
  },
  {
    "objectID": "/tool/#cmd_reach%20run",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach run"
  },
  {
    "objectID": "/tool/#cmd_reach%20down",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach down"
  },
  {
    "objectID": "/tool/#cmd_reach%20clean",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach clean"
  },
  {
    "objectID": "/tool/#cmd_reach%20scaffold",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach scaffold"
  },
  {
    "objectID": "/tool/#cmd_reach%20support",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach support"
  },
  {
    "objectID": "/tool/#cmd_reach%20react",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach react"
  },
  {
    "objectID": "/tool/#cmd_reach%20devnet",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach devnet"
  },
  {
    "objectID": "/tool/#cmd_reach%20rpc-server",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach rpc-server"
  },
  {
    "objectID": "/tool/#cmd_reach%20rpc-run",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach rpc-run"
  },
  {
    "objectID": "/tool/#cmd_reach%20docker-reset",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach docker-reset"
  },
  {
    "objectID": "/tool/#cmd_reach%20info",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach info"
  },
  {
    "objectID": "/tool/#cmd_reach%20update",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach update"
  },
  {
    "objectID": "/tool/#cmd_reach%20version",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach version"
  },
  {
    "objectID": "/tool/#cmd_reach%20hashes",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach hashes"
  },
  {
    "objectID": "/tool/#cmd_reach%20config",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach config"
  },
  {
    "objectID": "/tool/#cmd_reach%20--disable-reporting",
    "pt": "Tool",
    "t": 0,
    "s": "cmd",
    "c": "reach --disable-reporting"
  },
  {
    "objectID": "/tool/#term_lockfile",
    "pt": "Tool",
    "t": 1,
    "c": "lockfile"
  },
  {
    "objectID": "/tool/#ref",
    "pt": "Tool",
    "t": 2,
    "c": "Tool"
  },
  {
    "objectID": "/tool/#ref-install",
    "pt": "Tool",
    "t": 2,
    "c": "Installation"
  },
  {
    "objectID": "/tool/#ref-usage",
    "pt": "Tool",
    "t": 2,
    "c": "Usage"
  },
  {
    "objectID": "/tool/#ref-usage-envvar-connector-mode",
    "pt": "Tool",
    "t": 2,
    "c": "REACH_CONNECTOR_MODE"
  },
  {
    "objectID": "/tool/#ref-usage-envvar-version",
    "pt": "Tool",
    "t": 2,
    "c": "REACH_VERSION"
  },
  {
    "objectID": "/tool/#ref-usage-envvar-debug",
    "pt": "Tool",
    "t": 2,
    "c": "REACH_DEBUG"
  },
  {
    "objectID": "/tool/#ref-usage-compile",
    "pt": "Tool",
    "t": 2,
    "c": "reach compile"
  },
  {
    "objectID": "/tool/#ref-usage-init",
    "pt": "Tool",
    "t": 2,
    "c": "reach init"
  },
  {
    "objectID": "/tool/#ref-usage-run",
    "pt": "Tool",
    "t": 2,
    "c": "reach run"
  },
  {
    "objectID": "/tool/#ref-usage-down",
    "pt": "Tool",
    "t": 2,
    "c": "reach down"
  },
  {
    "objectID": "/tool/#ref-usage-clean",
    "pt": "Tool",
    "t": 2,
    "c": "reach clean"
  },
  {
    "objectID": "/tool/#ref-usage-scaffold",
    "pt": "Tool",
    "t": 2,
    "c": "reach scaffold"
  },
  {
    "objectID": "/tool/#ref-usage-support",
    "pt": "Tool",
    "t": 2,
    "c": "reach support"
  },
  {
    "objectID": "/tool/#ref-usage-react",
    "pt": "Tool",
    "t": 2,
    "c": "reach react"
  },
  {
    "objectID": "/tool/#ref-usage-devnet",
    "pt": "Tool",
    "t": 2,
    "c": "reach devnet"
  },
  {
    "objectID": "/tool/#ref-usage-rpc-server",
    "pt": "Tool",
    "t": 2,
    "c": "reach rpc-server"
  },
  {
    "objectID": "/tool/#ref-usage-rpc-run",
    "pt": "Tool",
    "t": 2,
    "c": "reach rpc-run"
  },
  {
    "objectID": "/tool/#ref-usage-docker-reset",
    "pt": "Tool",
    "t": 2,
    "c": "reach docker-reset"
  },
  {
    "objectID": "/tool/#ref-usage-info",
    "pt": "Tool",
    "t": 2,
    "c": "reach info"
  },
  {
    "objectID": "/tool/#ref-usage-update",
    "pt": "Tool",
    "t": 2,
    "c": "reach update"
  },
  {
    "objectID": "/tool/#ref-usage-version",
    "pt": "Tool",
    "t": 2,
    "c": "reach version"
  },
  {
    "objectID": "/tool/#ref-usage-hashes",
    "pt": "Tool",
    "t": 2,
    "c": "reach hashes"
  },
  {
    "objectID": "/tool/#ref-usage-config",
    "pt": "Tool",
    "t": 2,
    "c": "reach config"
  },
  {
    "objectID": "/tool/#ref-usage-arg-disable-reporting",
    "pt": "Tool",
    "t": 2,
    "c": "reach --disable-reporting"
  },
  {
    "objectID": "/tool/#p_0",
    "pt": "Tool",
    "t": 3,
    "c": "This document describes the reach tool: how to install it and how to use it."
  },
  {
    "objectID": "/tool/#p_1",
    "pt": "Tool",
    "t": 3,
    "c": "Reach is designed to work on POSIX systems with make, Docker, and Docker Compose installed. The best way to install Docker on Mac and Windows is with Docker Desktop."
  },
  {
    "objectID": "/tool/#p_2",
    "pt": "Tool",
    "t": 3,
    "c": "You probably already have make installed. For example, OS X and many other POSIX systems come with make, but some versions of Linux do not include it by default and will require you to install it. If you are on Ubuntu, you can run sudo apt install make to get it."
  },
  {
    "objectID": "/tool/#p_3",
    "pt": "Tool",
    "t": 3,
    "c": "You can install Reach by running:"
  },
  {
    "objectID": "/tool/#p_4",
    "pt": "Tool",
    "t": 3,
    "c": "in your project repository. You can copy this file to other repositories or move it to a directory in your PATH, like ~/bin. (PATH is a UNIX environment variable listing each of the directories that contain programs you can run in a shell session.)"
  },
  {
    "objectID": "/tool/#p_5",
    "pt": "Tool",
    "t": 3,
    "c": "If you're using Windows, consult the guide to using Reach on Windows."
  },
  {
    "objectID": "/tool/#p_6",
    "pt": "Tool",
    "t": 3,
    "c": "{!cmd} REACH_CONNECTOR_MODE is how one targets their desired network."
  },
  {
    "objectID": "/tool/#p_7",
    "pt": "Tool",
    "t": 3,
    "c": "The following are all valid options:"
  },
  {
    "objectID": "/tool/#p_8",
    "pt": "Tool",
    "t": 3,
    "c": "ALGO (this is a shortcut for ALGO-devnet)"
  },
  {
    "objectID": "/tool/#p_9",
    "pt": "Tool",
    "t": 3,
    "c": "ETH (this is a shortcut for ETH-devnet)"
  },
  {
    "objectID": "/tool/#p_10",
    "pt": "Tool",
    "t": 3,
    "c": "Not all Reach commands require {!cmd} REACH_CONNECTOR_MODE to be set, and some commands only support a subset of the list above (e.g. {!cmd} reach run and {!cmd} reach react)."
  },
  {
    "objectID": "/tool/#p_11",
    "pt": "Tool",
    "t": 3,
    "c": "Commands for which {!cmd} REACH_CONNECTOR_MODE is mandatory will raise an exception at runtime if it isn't specified."
  },
  {
    "objectID": "/tool/#p_12",
    "pt": "Tool",
    "t": 3,
    "c": "For the sake of convenience it's recommended to run {!cmd} reach config to select a permanent default when first setting up your development machine, but you may also supply an ad hoc network explicitly like so:"
  },
  {
    "objectID": "/tool/#p_13",
    "pt": "Tool",
    "t": 3,
    "c": "Making an explicit selection in this way is how Reach developers can target multiple networks since an environment variable specified at the command-line takes precedence over one's {!cmd} reach config settings."
  },
  {
    "objectID": "/tool/#p_14",
    "pt": "Tool",
    "t": 3,
    "c": "{!cmd} REACH_VERSION may be used to override Reach's default-to-latest behavior and instead select a specific, pinned release."
  },
  {
    "objectID": "/tool/#p_15",
    "pt": "Tool",
    "t": 3,
    "c": "Although normally expressed in a semantic versioning-friendly format, e.g. v0.1 or v0.1.6, {!cmd} REACH_VERSION also supports:"
  },
  {
    "objectID": "/tool/#p_16",
    "pt": "Tool",
    "t": 3,
    "c": "Hashes such as 639fa565."
  },
  {
    "objectID": "/tool/#p_17",
    "pt": "Tool",
    "t": 3,
    "c": "Valid hashes may be obtained by running:"
  },
  {
    "objectID": "/tool/#p_18",
    "pt": "Tool",
    "t": 3,
    "c": "Date-stamps such as 2021-11-04."
  },
  {
    "objectID": "/tool/#p_19",
    "pt": "Tool",
    "t": 3,
    "c": "Valid date-stamps may be obtained by browsing Reach's public Docker image registry on DockerHub."
  },
  {
    "objectID": "/tool/#p_20",
    "pt": "Tool",
    "t": 3,
    "c": "Tip: try entering your desired year in the filter box to skip other tag types."
  },
  {
    "objectID": "/tool/#p_21",
    "pt": "Tool",
    "t": 3,
    "c": "The identifer \"stable\"."
  },
  {
    "objectID": "/tool/#p_22",
    "pt": "Tool",
    "t": 3,
    "c": "Reach will interpret this to mean the most recent stable major version."
  },
  {
    "objectID": "/tool/#p_23",
    "pt": "Tool",
    "t": 3,
    "c": "When using the semantic versioning form of {!cmd} REACH_VERSION the preceding v character is optional. In other words, v0.1.6 is equivalent to 0.1.6."
  },
  {
    "objectID": "/tool/#p_24",
    "pt": "Tool",
    "t": 3,
    "c": "For commands that support it, setting {!cmd} REACH_DEBUG to any non-empty value produces verbose output which may be helpful during development or debugging."
  },
  {
    "objectID": "/tool/#p_25",
    "pt": "Tool",
    "t": 3,
    "c": "See {!cmd} reach compile, {!cmd} reach run, or {!cmd} reach react for examples."
  },
  {
    "objectID": "/tool/#p_26",
    "pt": "Tool",
    "t": 3,
    "c": "Compile Reach code by executing"
  },
  {
    "objectID": "/tool/#p_27",
    "pt": "Tool",
    "t": 3,
    "c": "where SOURCE is your source file, and each EXPORT is an exported {!rsh} Reach.App."
  },
  {
    "objectID": "/tool/#p_28",
    "pt": "Tool",
    "t": 3,
    "c": "If no SOURCE is provided, then index.rsh is used."
  },
  {
    "objectID": "/tool/#p_29",
    "pt": "Tool",
    "t": 3,
    "c": "If no EXPORT is provided, then all the exported {!rsh} Reach.Apps will be compiled. If there are no {!rsh} Reach.Apps exported, then the program will be compiled as a library, where its exports are available to other Reach programs and frontends. The output name of a library is the same as if it exported a {!rsh} Reach.App named default."
  },
  {
    "objectID": "/tool/#p_30",
    "pt": "Tool",
    "t": 3,
    "c": "{!cmd} reach compile supports the following options:"
  },
  {
    "objectID": "/tool/#p_31",
    "pt": "Tool",
    "t": 3,
    "c": "-o/--output OUTPUT --- Writes compiler output files to OUTPUT, which defaults to a directory named build in the same directory as SOURCE."
  },
  {
    "objectID": "/tool/#p_32",
    "pt": "Tool",
    "t": 3,
    "c": "--intermediate-files --- Write intermediate files, which may be interesting for debugging compilation failures or using in other contexts."
  },
  {
    "objectID": "/tool/#p_33",
    "pt": "Tool",
    "t": 3,
    "c": "--install-pkgs --- Allows Reach to fetch remote package imports and stop after doing so."
  },
  {
    "objectID": "/tool/#p_34",
    "pt": "Tool",
    "t": 3,
    "c": "Reach will fail with an error message if package imports have not yet been fetched and this flag is not activated."
  },
  {
    "objectID": "/tool/#p_35",
    "pt": "Tool",
    "t": 3,
    "c": "Using this flag will create a .reach directory for your project. This directory stores your project's lockfile, which is how Reach pins remote packages to specific versions. It is recommended that you commit the .reach directory to source control. Deleting this directory is also safe; it can easily be rebuilt by using the --install-pkgs flag again; in fact, this is the best way to upgrade your packages."
  },
  {
    "objectID": "/tool/#p_36",
    "pt": "Tool",
    "t": 3,
    "c": "--stop-after-eval --- Stops the compilation process before verification and producing output files. This might be useful for performing syntax and type checking quickly."
  },
  {
    "objectID": "/tool/#p_37",
    "pt": "Tool",
    "t": 3,
    "c": "--verify-timeout TIMEOUT-MS --- Sets the timeout of individual verification theorems, in milliseconds. The default value is 2 minutes."
  },
  {
    "objectID": "/tool/#p_38",
    "pt": "Tool",
    "t": 3,
    "c": "--verify-fail-once --- Stops the compilation process after printing a single verification failure. This may help keep you organized while fixing verification failures in your program."
  },
  {
    "objectID": "/tool/#p_39",
    "pt": "Tool",
    "t": 3,
    "c": "The environment variable {!cmd} REACH_DEBUG, if set to any non-empty value, enables debug messages from the Reach compiler, which will appear in the console. This debug information includes: the estimated cost of the contract on Algorand. This variable automatically enables --intermediate-files."
  },
  {
    "objectID": "/tool/#p_40",
    "pt": "Tool",
    "t": 3,
    "c": "A {!cmd} reach compile usage example is available in Overview."
  },
  {
    "objectID": "/tool/#p_41",
    "pt": "Tool",
    "t": 3,
    "c": "This creates the index.rsh and index.mjs template files required for a basic Reach DApp. It allows you to open the files and start writing code. The index.rsh file is the DApp and is written in Reach, and the index.mjs file is the frontend of the DApp and is written in JavaScript."
  },
  {
    "objectID": "/tool/#p_42",
    "pt": "Tool",
    "t": 3,
    "c": "The {!cmd} reach run command with no arguments starts the index application in the current directory by default, but you can set a different directory, application name, or both."
  },
  {
    "objectID": "/tool/#p_43",
    "pt": "Tool",
    "t": 3,
    "c": "The {!cmd} reach run command uses the following interface:"
  },
  {
    "objectID": "/tool/#p_44",
    "pt": "Tool",
    "t": 3,
    "c": "APP represents a Reach module name without its extension (e.g. \"index\" by default)."
  },
  {
    "objectID": "/tool/#p_45",
    "pt": "Tool",
    "t": 3,
    "c": "If no APP or DIR is provided then index in the current working directory is assumed."
  },
  {
    "objectID": "/tool/#p_46",
    "pt": "Tool",
    "t": 3,
    "c": "If DIR matches an existing, relative subdirectory of the current working directory then DIR/index is used."
  },
  {
    "objectID": "/tool/#p_47",
    "pt": "Tool",
    "t": 3,
    "c": "ARGS represents zero or more arguments to be passed into APP's frontend."
  },
  {
    "objectID": "/tool/#p_48",
    "pt": "Tool",
    "t": 3,
    "c": "This assumes"
  },
  {
    "objectID": "/tool/#p_49",
    "pt": "Tool",
    "t": 3,
    "c": "Your Reach program is named APP.rsh."
  },
  {
    "objectID": "/tool/#p_50",
    "pt": "Tool",
    "t": 3,
    "c": "You are using the JavaScript backend and your frontend is named APP.mjs. It also assumes the backend is located at DIR/build/APP.main.mjs, and only depends on the Reach standard library."
  },
  {
    "objectID": "/tool/#p_51",
    "pt": "Tool",
    "t": 3,
    "c": "It then"
  },
  {
    "objectID": "/tool/#p_52",
    "pt": "Tool",
    "t": 3,
    "c": "Compiles your program with Reach."
  },
  {
    "objectID": "/tool/#p_53",
    "pt": "Tool",
    "t": 3,
    "c": "Builds a Docker image named reachsh/reach-app-APP:latest that depends on the Reach JavaScript standard library."
  },
  {
    "objectID": "/tool/#p_54",
    "pt": "Tool",
    "t": 3,
    "c": "Executes a container based upon that image while connected to the network determined by {!cmd} REACH_CONNECTOR_MODE."
  },
  {
    "objectID": "/tool/#p_55",
    "pt": "Tool",
    "t": 3,
    "c": "{!cmd} reach run supports the following options:"
  },
  {
    "objectID": "/tool/#p_56",
    "pt": "Tool",
    "t": 3,
    "c": "The mandatory environment variable {!cmd} REACH_CONNECTOR_MODE specifies which context to run in. The options are:"
  },
  {
    "objectID": "/tool/#p_57",
    "pt": "Tool",
    "t": 3,
    "c": "ETH-devnet (or ETH for short), which uses a Dockerized private Ethereum network."
  },
  {
    "objectID": "/tool/#p_58",
    "pt": "Tool",
    "t": 3,
    "c": "ETH-live, which uses a live Ethereum network node, specified by the environment variable ETH_NODE_URI."
  },
  {
    "objectID": "/tool/#p_59",
    "pt": "Tool",
    "t": 3,
    "c": "ALGO-devnet (or ALGO for short), which uses a Dockerized private Algorand network."
  },
  {
    "objectID": "/tool/#p_60",
    "pt": "Tool",
    "t": 3,
    "c": "ALGO-live, which uses a live Algorand network node, specified by the environment variables documented in the Algorand connector section."
  },
  {
    "objectID": "/tool/#p_61",
    "pt": "Tool",
    "t": 3,
    "c": "The environment variable {!cmd} REACH_DEBUG, if set to any non-empty value, enables debug messages from the Reach standard library, which will appear in the console."
  },
  {
    "objectID": "/tool/#p_62",
    "pt": "Tool",
    "t": 3,
    "c": "{!cmd} reach run can be further specialized via the presence of a Dockerfile and package.json file. If either are absent, {!cmd} reach run assumes a default behavior (which may be persisted with {!cmd} reach scaffold)."
  },
  {
    "objectID": "/tool/#p_63",
    "pt": "Tool",
    "t": 3,
    "c": "The Dockerfile can be modified to introduce new dependencies, services, or filesystem prerequisites into your app's containerized environment, and the package.json file may likewise be extended to include additional libraries or make configuration changes to the resultant Node.js package."
  },
  {
    "objectID": "/tool/#p_64",
    "pt": "Tool",
    "t": 3,
    "c": "You can halt all Dockerized Reach apps and devnets by running"
  },
  {
    "objectID": "/tool/#p_65",
    "pt": "Tool",
    "t": 3,
    "c": "You can delete the contents of build/index.main.mjs with"
  },
  {
    "objectID": "/tool/#p_66",
    "pt": "Tool",
    "t": 3,
    "c": "This command is useful when the backend's version no longer matches the Reach standard library you have installed and you need to recompile."
  },
  {
    "objectID": "/tool/#p_67",
    "pt": "Tool",
    "t": 3,
    "c": "The standard usage is {!cmd} reach clean [MODULE] [IDENT] where MODULE is index by default and IDENT is main. Changing the default values will change the mjs file {!cmd} reach clean seeks to delete."
  },
  {
    "objectID": "/tool/#p_68",
    "pt": "Tool",
    "t": 3,
    "c": "If MODULE is a directory then {!cmd} reach clean will cd into MODULE and remove build/index.IDENT.mjs. If MODULE is a file name then {!cmd} reach clean will remove build/MODULE.IDENT.mjs."
  },
  {
    "objectID": "/tool/#p_69",
    "pt": "Tool",
    "t": 3,
    "c": "You can create templated Dockerfile and package.json files for a simple Reach app by running"
  },
  {
    "objectID": "/tool/#p_70",
    "pt": "Tool",
    "t": 3,
    "c": "The files created are the same as those used temporarily by {!cmd} reach run."
  },
  {
    "objectID": "/tool/#p_71",
    "pt": "Tool",
    "t": 3,
    "c": "You can upload a gist to GitHub using"
  },
  {
    "objectID": "/tool/#p_72",
    "pt": "Tool",
    "t": 3,
    "c": "{!cmd} reach support takes a list of files that defaults to index.rsh and index.mjs if called without parameters."
  },
  {
    "objectID": "/tool/#p_73",
    "pt": "Tool",
    "t": 3,
    "c": "It will fail at the first file it fails to find."
  },
  {
    "objectID": "/tool/#p_74",
    "pt": "Tool",
    "t": 3,
    "c": "If all passed files are present, this command uploads those files as a gist to GitHub, and gives you a link to that gist that anyone with the link can view."
  },
  {
    "objectID": "/tool/#p_75",
    "pt": "Tool",
    "t": 3,
    "c": "You can run a simple React app by executing"
  },
  {
    "objectID": "/tool/#p_76",
    "pt": "Tool",
    "t": 3,
    "c": "This assumes"
  },
  {
    "objectID": "/tool/#p_77",
    "pt": "Tool",
    "t": 3,
    "c": "Your Reach program is named index.rsh"
  },
  {
    "objectID": "/tool/#p_78",
    "pt": "Tool",
    "t": 3,
    "c": "Your frontend React program is named index.js"
  },
  {
    "objectID": "/tool/#p_79",
    "pt": "Tool",
    "t": 3,
    "c": "It then"
  },
  {
    "objectID": "/tool/#p_80",
    "pt": "Tool",
    "t": 3,
    "c": "Compiles your program with Reach"
  },
  {
    "objectID": "/tool/#p_81",
    "pt": "Tool",
    "t": 3,
    "c": "Runs the appropriate devnet based on {!cmd} REACH_CONNECTOR_MODE"
  },
  {
    "objectID": "/tool/#p_82",
    "pt": "Tool",
    "t": 3,
    "c": "Mounts the current directory into /app/src/ in the reachsh/react-runner Docker image and runs it."
  },
  {
    "objectID": "/tool/#p_83",
    "pt": "Tool",
    "t": 3,
    "c": "{!cmd} reach react supports the following options:"
  },
  {
    "objectID": "/tool/#p_84",
    "pt": "Tool",
    "t": 3,
    "c": "The mandatory environment variable {!cmd} REACH_CONNECTOR_MODE specifies which context to run in. The options are:"
  },
  {
    "objectID": "/tool/#p_85",
    "pt": "Tool",
    "t": 3,
    "c": "ETH-browser (or ETH for short), which targets a Dockerized private Ethereum network via a browser extension, like MetaMask."
  },
  {
    "objectID": "/tool/#p_86",
    "pt": "Tool",
    "t": 3,
    "c": "ALGO-browser (or ALGO for short), which targets a Dockerized private Algorand network via an ARC-0011 browser wallet."
  },
  {
    "objectID": "/tool/#p_87",
    "pt": "Tool",
    "t": 3,
    "c": "The environment variable {!cmd} REACH_DEBUG, if set to any non-empty value, enables debug messages from the Reach standard library, which will appear in the browser console."
  },
  {
    "objectID": "/tool/#p_88",
    "pt": "Tool",
    "t": 3,
    "c": "When using {!js} loadStdlib in conjunction with {!cmd} reach react, be sure to pass in {!js} process.env as its argument. See {!js} loadStdlib for details."
  },
  {
    "objectID": "/tool/#p_89",
    "pt": "Tool",
    "t": 3,
    "c": "{!cmd} reach react does not respect the same scaffolded files as {!cmd} reach run. It is just a simplified tool to give you a taste of web programming with reach. If you would like access to more customizations on a browser-based project, such as custom environment variables, custom JavaScript dependencies, or using other JavaScript frameworks like Angular, we recommend that you simply use {!cmd} reach compile, and use your own preferred JavaScript setup for the project. The compiled build/index.main.mjs JavaScript file and the '@reach-sh/stdlib' JavaScript library may be used in any JavaScript project like any other JavaScript file and library, respectively."
  },
  {
    "objectID": "/tool/#p_90",
    "pt": "Tool",
    "t": 3,
    "c": "You can run a private Reach devnet by executing the following command:"
  },
  {
    "objectID": "/tool/#p_91",
    "pt": "Tool",
    "t": 3,
    "c": "If running {!cmd} reach devnet, it is recommended to permanently set {!cmd} REACH_CONNECTOR_MODE to the desired consensus network. If you did not set this when you originally ran {!cmd} reach config, then you can run {!cmd} reach devnet with the argument {!cmd} REACH_CONNECTOR_MODE=[OPTION] as in the following command."
  },
  {
    "objectID": "/tool/#p_92",
    "pt": "Tool",
    "t": 3,
    "c": "{!cmd} reach devnet supports the following options:"
  },
  {
    "objectID": "/tool/#p_93",
    "pt": "Tool",
    "t": 3,
    "c": "--await-background --- Run in the background and await availability."
  },
  {
    "objectID": "/tool/#p_94",
    "pt": "Tool",
    "t": 3,
    "c": "For more information on devnet options, refer to Networks."
  },
  {
    "objectID": "/tool/#p_95",
    "pt": "Tool",
    "t": 3,
    "c": "The following command"
  },
  {
    "objectID": "/tool/#p_96",
    "pt": "Tool",
    "t": 3,
    "c": "starts an instance of the Reach RPC Server, sharing all of the same options and defaults as {!cmd} reach run, but also including the following:"
  },
  {
    "objectID": "/tool/#p_97",
    "pt": "Tool",
    "t": 3,
    "c": "The environment variable {!cmd} REACH_RPC_KEY is used to determine the RPC server key. If not defined, it defaults to opensesame, and a warning will appear in the console stating that the development key is being used."
  },
  {
    "objectID": "/tool/#p_98",
    "pt": "Tool",
    "t": 3,
    "c": "In a production context this key must be kept secret, and it should be randomly generated with a suitably strong method, such as:"
  },
  {
    "objectID": "/tool/#p_99",
    "pt": "Tool",
    "t": 3,
    "c": "The environment variable {!cmd} REACH_RPC_PORT is used to determine which port to bind to. It defaults to 3000."
  },
  {
    "objectID": "/tool/#p_100",
    "pt": "Tool",
    "t": 3,
    "c": "The environment variable {!cmd} REACH_RPC_TLS_KEY is used to determine the path to the TLS key file, which must be in the ./tls directory. It defaults to reach-server.key."
  },
  {
    "objectID": "/tool/#p_101",
    "pt": "Tool",
    "t": 3,
    "c": "The environment variable {!cmd} REACH_RPC_TLS_CRT is used to determine the path to the TLS crt file, which must be in the ./tls directory. It defaults to reach-server.crt."
  },
  {
    "objectID": "/tool/#p_102",
    "pt": "Tool",
    "t": 3,
    "c": "The environment variable {!cmd} REACH_RPC_TLS_PASSPHRASE is used to determine the TLS passphrase. It defaults to rpc-demo."
  },
  {
    "objectID": "/tool/#p_103",
    "pt": "Tool",
    "t": 3,
    "c": "The following command"
  },
  {
    "objectID": "/tool/#p_104",
    "pt": "Tool",
    "t": 3,
    "c": "is a convenient means of launching a pre-configured RPC server and frontend which are suitable for development purposes. It uses a REACH_RPC_KEY value of opensesame (the standard development API key), and sets REACH_RPC_TLS_REJECT_UNVERIFIED to 0."
  },
  {
    "objectID": "/tool/#p_105",
    "pt": "Tool",
    "t": 3,
    "c": "Consider this example from the Rock, Paper, Scissors in Python tutorial:"
  },
  {
    "objectID": "/tool/#p_106",
    "pt": "Tool",
    "t": 3,
    "c": "You can easily kill and remove all Docker containers by executing"
  },
  {
    "objectID": "/tool/#p_107",
    "pt": "Tool",
    "t": 3,
    "c": "This can be a useful thing to try if your Docker containers stop responding to requests or otherwise misbehave, or if you have updated your Reach images (with {!cmd} reach update) but those changes are not taking effect."
  },
  {
    "objectID": "/tool/#p_108",
    "pt": "Tool",
    "t": 3,
    "c": "It will affect all Docker containers on your machine, not just those created by Reach. For this reason it's recommended to prefer {!cmd} reach down."
  },
  {
    "objectID": "/tool/#p_109",
    "pt": "Tool",
    "t": 3,
    "c": "To check whether new releases are available, run"
  },
  {
    "objectID": "/tool/#p_110",
    "pt": "Tool",
    "t": 3,
    "c": "{!cmd} reach info may be paired with the {!cmd} REACH_VERSION environment variable in order to respect version-pinning (e.g. if you want the latest version on Reach's 0.1.6 branch but don't wish to upgrade to 0.1.7)."
  },
  {
    "objectID": "/tool/#p_111",
    "pt": "Tool",
    "t": 3,
    "c": "An interactive menu, allowing you to selectively perform suggested updates, is also available:"
  },
  {
    "objectID": "/tool/#p_112",
    "pt": "Tool",
    "t": 3,
    "c": "You can update Reach to a newer release by executing"
  },
  {
    "objectID": "/tool/#p_113",
    "pt": "Tool",
    "t": 3,
    "c": "As with {!cmd} reach info, {!cmd} reach update respects the {!cmd} REACH_VERSION environment variable for the purpose of version-pinning."
  },
  {
    "objectID": "/tool/#p_114",
    "pt": "Tool",
    "t": 3,
    "c": "Check which version of the Reach command-line tool is currently installed by running"
  },
  {
    "objectID": "/tool/#p_115",
    "pt": "Tool",
    "t": 3,
    "c": "This is less precise than {!cmd} reach hashes, but gives you an idea of which features are, or are not, available in your build version."
  },
  {
    "objectID": "/tool/#p_116",
    "pt": "Tool",
    "t": 3,
    "c": "Check which version of each Reach Docker image is installed. This command returns the hash version of each image in an 8 digit alpha-numeric code (such as 639fa565)."
  },
  {
    "objectID": "/tool/#p_117",
    "pt": "Tool",
    "t": 3,
    "c": "This is more precise, but less readable, than {!cmd} reach version, in that each hash refers to the git commit used to build the image."
  },
  {
    "objectID": "/tool/#p_118",
    "pt": "Tool",
    "t": 3,
    "c": "Reach recommends tuning your default workflow settings by executing"
  },
  {
    "objectID": "/tool/#p_119",
    "pt": "Tool",
    "t": 3,
    "c": "Using {!cmd} reach config is advisable when running Reach for the first time since it will set the {!cmd} REACH_CONNECTOR_MODE environment variable, which is required when executing some other sub-commands (e.g. {!cmd} reach run)."
  },
  {
    "objectID": "/tool/#p_120",
    "pt": "Tool",
    "t": 3,
    "c": "{!cmd} reach config presents users with a guided menu which automatically creates an env file and suggests subsequent steps to activate and make it permanent. This env file exports environment variable settings and is intended to be sourced by users' shells."
  },
  {
    "objectID": "/tool/#p_121",
    "pt": "Tool",
    "t": 3,
    "c": "If an env file already exists, {!cmd} reach config offers to back it up before proceeding."
  },
  {
    "objectID": "/tool/#p_122",
    "pt": "Tool",
    "t": 3,
    "c": "The Reach command-line tool collects anonymous usage data by default, but this can be skipped by prepending --disable-reporting before any given sub-command, e.g.:"
  },
  {
    "objectID": "/tool/#p_123",
    "pt": "Tool",
    "t": 3,
    "c": "Out of respect for users' privacy and the security of their intellectual property, Reach takes special care to avoid gathering personally-identifiable information and instead tallies only metrics which cannot easily be correlated back to specific individuals and which doesn't leak sensitive details about their code."
  },
  {
    "objectID": "/tool/#p_124",
    "pt": "Tool",
    "t": 3,
    "c": "For instance, we discard IP addresses and strip timestamps to just UTC dates."
  },
  {
    "objectID": "/tool/#p_125",
    "pt": "Tool",
    "t": 3,
    "c": "Only the following are tracked:"
  },
  {
    "objectID": "/tool/#p_126",
    "pt": "Tool",
    "t": 3,
    "c": "From the Reach command-line tool or VS Code extension:"
  },
  {
    "objectID": "/tool/#p_127",
    "pt": "Tool",
    "t": 3,
    "c": "A random ID that's unique per-user and per-machine (but which doesn't reveal the user's identity);"
  },
  {
    "objectID": "/tool/#p_128",
    "pt": "Tool",
    "t": 3,
    "c": "The UTC date on which an event occurred;"
  },
  {
    "objectID": "/tool/#p_129",
    "pt": "Tool",
    "t": 3,
    "c": "The type of event, e.g. {!cmd} reach run or {!cmd} reach devnet;"
  },
  {
    "objectID": "/tool/#p_130",
    "pt": "Tool",
    "t": 3,
    "c": "Resultant error code or indication of success associated with the event;"
  },
  {
    "objectID": "/tool/#p_131",
    "pt": "Tool",
    "t": 3,
    "c": "{!cmd} REACH_VERSION;"
  },
  {
    "objectID": "/tool/#p_132",
    "pt": "Tool",
    "t": 3,
    "c": "{!cmd} REACH_CONNECTOR_MODE;"
  },
  {
    "objectID": "/tool/#p_133",
    "pt": "Tool",
    "t": 3,
    "c": "Whether the event was triggered by the Reach VSCode extension."
  },
  {
    "objectID": "/tool/#p_134",
    "pt": "Tool",
    "t": 3,
    "c": "Geolocation data inferred from your IP address:"
  },
  {
    "objectID": "/tool/#p_135",
    "pt": "Tool",
    "t": 3,
    "c": "The user's country;"
  },
  {
    "objectID": "/tool/#p_136",
    "pt": "Tool",
    "t": 3,
    "c": "The user's state or region."
  },
  {
    "objectID": "/tool/#p_137",
    "pt": "Tool",
    "t": 3,
    "c": "Invoking a sub-command with --disable-reporting instructs reach not to send any usage data at all."
  },
  {
    "objectID": "/trouble/#trouble",
    "pt": "Troubleshooting",
    "t": 2,
    "c": "Troubleshooting"
  },
  {
    "objectID": "/trouble/#p_0",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "Troubleshooting guidance is located on GitHub Discussions."
  },
  {
    "objectID": "/trouble/#p_1",
    "pt": "Troubleshooting",
    "t": 3,
    "c": "If you have found a new issue then create a Q&A or ask in our Discord's #help channel."
  },
  {
    "objectID": "/tut/#tuts",
    "pt": "Tutorials",
    "t": 2,
    "c": "Tutorials"
  },
  {
    "objectID": "/tut/#p_0",
    "pt": "Tutorials",
    "t": 3,
    "c": "There are six tutorials:"
  },
  {
    "objectID": "/frontend/#js_Contract",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "Contract"
  },
  {
    "objectID": "/frontend/#js_loadStdlib",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "loadStdlib"
  },
  {
    "objectID": "/frontend/#js_Reach",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "Reach"
  },
  {
    "objectID": "/frontend/#js_unsafeAllowMultipleStdlibs",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "unsafeAllowMultipleStdlibs"
  },
  {
    "objectID": "/frontend/#js_stdlib.setWalletFallback",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.setWalletFallback"
  },
  {
    "objectID": "/frontend/#js_stdlib.walletFallback",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.walletFallback"
  },
  {
    "objectID": "/frontend/#js_stdlib.setProviderByName",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.setProviderByName"
  },
  {
    "objectID": "/frontend/#js_stdlib.providerEnvByName",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.providerEnvByName"
  },
  {
    "objectID": "/frontend/#js_stdlib.setProviderByEnv",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.setProviderByEnv"
  },
  {
    "objectID": "/frontend/#js_stdlib.setProvider",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.setProvider"
  },
  {
    "objectID": "/frontend/#js_getProvider",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "getProvider"
  },
  {
    "objectID": "/frontend/#js_setMinMillisBetweenRequests",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "setMinMillisBetweenRequests"
  },
  {
    "objectID": "/frontend/#js_setCustomHttpEventHandler",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "setCustomHttpEventHandler"
  },
  {
    "objectID": "/frontend/#js_setSigningMonitor",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "setSigningMonitor"
  },
  {
    "objectID": "/frontend/#js_acc",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "acc"
  },
  {
    "objectID": "/frontend/#js_getDefaultAccount",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "getDefaultAccount"
  },
  {
    "objectID": "/frontend/#js_stdlib.getDefaultAccount",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.getDefaultAccount"
  },
  {
    "objectID": "/frontend/#js_newTestAccount",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "newTestAccount"
  },
  {
    "objectID": "/frontend/#js_stdlib.newTestAccount",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.newTestAccount"
  },
  {
    "objectID": "/frontend/#js_newTestAccounts",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "newTestAccounts"
  },
  {
    "objectID": "/frontend/#js_stdlib.newTestAccounts",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.newTestAccounts"
  },
  {
    "objectID": "/frontend/#js_newAccountFromSecret",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "newAccountFromSecret"
  },
  {
    "objectID": "/frontend/#js_newAccountFromMnemonic",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "newAccountFromMnemonic"
  },
  {
    "objectID": "/frontend/#js_createAccount",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "createAccount"
  },
  {
    "objectID": "/frontend/#js_fundFromFaucet",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "fundFromFaucet"
  },
  {
    "objectID": "/frontend/#js_canFundFromFaucet",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "canFundFromFaucet"
  },
  {
    "objectID": "/frontend/#js_connectAccount",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "connectAccount"
  },
  {
    "objectID": "/frontend/#js_networkAccount",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "networkAccount"
  },
  {
    "objectID": "/frontend/#js_getAddress",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "getAddress"
  },
  {
    "objectID": "/frontend/#js_getDebugLabel",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "getDebugLabel"
  },
  {
    "objectID": "/frontend/#js_setDebugLabel",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "setDebugLabel"
  },
  {
    "objectID": "/frontend/#js_tokenAccept",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "tokenAccept"
  },
  {
    "objectID": "/frontend/#js_tokenAccepted",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "tokenAccepted"
  },
  {
    "objectID": "/frontend/#js_acc.tokensAccepted",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "acc.tokensAccepted"
  },
  {
    "objectID": "/frontend/#js_stdlib.tokensAccepted",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.tokensAccepted"
  },
  {
    "objectID": "/frontend/#js_appOptIn",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "appOptIn"
  },
  {
    "objectID": "/frontend/#js_appOptedIn",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "appOptedIn"
  },
  {
    "objectID": "/frontend/#js_stdlib.appOptedIn",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.appOptedIn"
  },
  {
    "objectID": "/frontend/#js_tokenMetadata",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "tokenMetadata"
  },
  {
    "objectID": "/frontend/#js_balanceOf",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "balanceOf"
  },
  {
    "objectID": "/frontend/#js_stdlib.balanceOf",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.balanceOf"
  },
  {
    "objectID": "/frontend/#js_acc.balanceOf",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "acc.balanceOf"
  },
  {
    "objectID": "/frontend/#js_balancesOf",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "balancesOf"
  },
  {
    "objectID": "/frontend/#js_stdlib.balancesOf",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.balancesOf"
  },
  {
    "objectID": "/frontend/#js_acc.balancesOf",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "acc.balancesOf"
  },
  {
    "objectID": "/frontend/#js_minimumBalanceOf",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "minimumBalanceOf"
  },
  {
    "objectID": "/frontend/#js_transfer",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "transfer"
  },
  {
    "objectID": "/frontend/#js_setGasLimit",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "setGasLimit"
  },
  {
    "objectID": "/frontend/#js_ctc",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ctc"
  },
  {
    "objectID": "/frontend/#js_contract",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "contract"
  },
  {
    "objectID": "/frontend/#js_getInfo",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "getInfo"
  },
  {
    "objectID": "/frontend/#js_getContractAddress",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "getContractAddress"
  },
  {
    "objectID": "/frontend/#js_ctc.getABI",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ctc.getABI"
  },
  {
    "objectID": "/frontend/#js_ctc.getEventTys",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ctc.getEventTys"
  },
  {
    "objectID": "/frontend/#js_getInternalState",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "getInternalState"
  },
  {
    "objectID": "/frontend/#js_deploy",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "deploy"
  },
  {
    "objectID": "/frontend/#js_attach",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "attach"
  },
  {
    "objectID": "/frontend/#js_ctc.participants",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ctc.participants"
  },
  {
    "objectID": "/frontend/#js_ctc.p",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ctc.p"
  },
  {
    "objectID": "/frontend/#js_withDisconnect",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "withDisconnect"
  },
  {
    "objectID": "/frontend/#js_stdlib.withDisconnect",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.withDisconnect"
  },
  {
    "objectID": "/frontend/#js_disconnect",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "disconnect"
  },
  {
    "objectID": "/frontend/#js_stdlib.disconnect",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.disconnect"
  },
  {
    "objectID": "/frontend/#js_ctc.apis",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ctc.apis"
  },
  {
    "objectID": "/frontend/#js_ctc.a",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ctc.a"
  },
  {
    "objectID": "/frontend/#js_ctc.safeApis",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ctc.safeApis"
  },
  {
    "objectID": "/frontend/#js_ctc.views",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ctc.views"
  },
  {
    "objectID": "/frontend/#js_ctc.v",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ctc.v"
  },
  {
    "objectID": "/frontend/#js_ctc.unsafeViews",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ctc.unsafeViews"
  },
  {
    "objectID": "/frontend/#js_ctc.getViews",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ctc.getViews"
  },
  {
    "objectID": "/frontend/#js_getViews",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "getViews"
  },
  {
    "objectID": "/frontend/#js_ctc.events",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ctc.events"
  },
  {
    "objectID": "/frontend/#js_ctc.e",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ctc.e"
  },
  {
    "objectID": "/frontend/#js_EventStream",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "EventStream"
  },
  {
    "objectID": "/frontend/#js_Event",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "Event"
  },
  {
    "objectID": "/frontend/#js_launchToken",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "launchToken"
  },
  {
    "objectID": "/frontend/#js_stdlib.launchToken",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.launchToken"
  },
  {
    "objectID": "/frontend/#js_stdlib.connector",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.connector"
  },
  {
    "objectID": "/frontend/#js_connector",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "connector"
  },
  {
    "objectID": "/frontend/#js_stdlib.getNetworkTime",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.getNetworkTime"
  },
  {
    "objectID": "/frontend/#js_getNetworkTime",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "getNetworkTime"
  },
  {
    "objectID": "/frontend/#js_stdlib.getNetworkSecs",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.getNetworkSecs"
  },
  {
    "objectID": "/frontend/#js_getNetworkSecs",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "getNetworkSecs"
  },
  {
    "objectID": "/frontend/#js_stdlib.getTimeSecs",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.getTimeSecs"
  },
  {
    "objectID": "/frontend/#js_getTimeSecs",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "getTimeSecs"
  },
  {
    "objectID": "/frontend/#js_stdlib.waitUntilTime",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.waitUntilTime"
  },
  {
    "objectID": "/frontend/#js_waitUntilTime",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "waitUntilTime"
  },
  {
    "objectID": "/frontend/#js_stdlib.waitUntilSecs",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.waitUntilSecs"
  },
  {
    "objectID": "/frontend/#js_waitUntilSecs",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "waitUntilSecs"
  },
  {
    "objectID": "/frontend/#js_stdlib.wait",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.wait"
  },
  {
    "objectID": "/frontend/#js_wait",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "wait"
  },
  {
    "objectID": "/frontend/#js_stdlib.setValidQueryWindow",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.setValidQueryWindow"
  },
  {
    "objectID": "/frontend/#js_setValidQueryWindow",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "setValidQueryWindow"
  },
  {
    "objectID": "/frontend/#js_stdlib.setAdjustTxnParams",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.setAdjustTxnParams"
  },
  {
    "objectID": "/frontend/#js_stdlib.protect",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.protect"
  },
  {
    "objectID": "/frontend/#js_protect",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "protect"
  },
  {
    "objectID": "/frontend/#js_T_Null",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "T_Null"
  },
  {
    "objectID": "/frontend/#js_T_Bool",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "T_Bool"
  },
  {
    "objectID": "/frontend/#js_T_UInt",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "T_UInt"
  },
  {
    "objectID": "/frontend/#js_T_Bytes",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "T_Bytes"
  },
  {
    "objectID": "/frontend/#js_T_Address",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "T_Address"
  },
  {
    "objectID": "/frontend/#js_T_Array",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "T_Array"
  },
  {
    "objectID": "/frontend/#js_T_Tuple",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "T_Tuple"
  },
  {
    "objectID": "/frontend/#js_T_Object",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "T_Object"
  },
  {
    "objectID": "/frontend/#js_ReachType",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ReachType"
  },
  {
    "objectID": "/frontend/#js_toString",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "toString"
  },
  {
    "objectID": "/frontend/#js_assert",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "assert"
  },
  {
    "objectID": "/frontend/#js_Array_set",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "Array_set"
  },
  {
    "objectID": "/frontend/#js_bigNumberify",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "bigNumberify"
  },
  {
    "objectID": "/frontend/#js_isBigNumber",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "isBigNumber"
  },
  {
    "objectID": "/frontend/#js_bigNumberToNumber",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "bigNumberToNumber"
  },
  {
    "objectID": "/frontend/#js_bigNumberToBigInt",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "bigNumberToBigInt"
  },
  {
    "objectID": "/frontend/#js_isHex",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "isHex"
  },
  {
    "objectID": "/frontend/#js_hexToBigNumber",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "hexToBigNumber"
  },
  {
    "objectID": "/frontend/#js_stringToHex",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stringToHex"
  },
  {
    "objectID": "/frontend/#js_bigNumberToHex",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "bigNumberToHex"
  },
  {
    "objectID": "/frontend/#js_uintToBytes",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "uintToBytes"
  },
  {
    "objectID": "/frontend/#js_bytesEq",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "bytesEq"
  },
  {
    "objectID": "/frontend/#js_digestEq",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "digestEq"
  },
  {
    "objectID": "/frontend/#js_addressEq",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "addressEq"
  },
  {
    "objectID": "/frontend/#js_digest",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "digest"
  },
  {
    "objectID": "/frontend/#js_randomUInt",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "randomUInt"
  },
  {
    "objectID": "/frontend/#js_hasRandom",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "hasRandom"
  },
  {
    "objectID": "/frontend/#js_stdlib.hasRandom",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.hasRandom"
  },
  {
    "objectID": "/frontend/#js_hasConsoleLogger",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "hasConsoleLogger"
  },
  {
    "objectID": "/frontend/#js_stdlib.hasConsoleLogger",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.hasConsoleLogger"
  },
  {
    "objectID": "/frontend/#js_parseFixedPoint",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "parseFixedPoint"
  },
  {
    "objectID": "/frontend/#js_numberToFixedPoint",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "numberToFixedPoint"
  },
  {
    "objectID": "/frontend/#js_parseInt",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "parseInt"
  },
  {
    "objectID": "/frontend/#js_numberToInt",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "numberToInt"
  },
  {
    "objectID": "/frontend/#js_add",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "add"
  },
  {
    "objectID": "/frontend/#js_sub",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "sub"
  },
  {
    "objectID": "/frontend/#js_mod",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "mod"
  },
  {
    "objectID": "/frontend/#js_mul",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "mul"
  },
  {
    "objectID": "/frontend/#js_div",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "div"
  },
  {
    "objectID": "/frontend/#js_eq",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "eq"
  },
  {
    "objectID": "/frontend/#js_ge",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ge"
  },
  {
    "objectID": "/frontend/#js_gt",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "gt"
  },
  {
    "objectID": "/frontend/#js_le",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "le"
  },
  {
    "objectID": "/frontend/#js_lt",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "lt"
  },
  {
    "objectID": "/frontend/#js_btoiLast8",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "btoiLast8"
  },
  {
    "objectID": "/frontend/#js_standardUnit",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "standardUnit"
  },
  {
    "objectID": "/frontend/#js_atomicUnit",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "atomicUnit"
  },
  {
    "objectID": "/frontend/#js_minimumBalance",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "minimumBalance"
  },
  {
    "objectID": "/frontend/#js_parseCurrency",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "parseCurrency"
  },
  {
    "objectID": "/frontend/#js_formatCurrency",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "formatCurrency"
  },
  {
    "objectID": "/frontend/#js_formatWithDecimals",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "formatWithDecimals"
  },
  {
    "objectID": "/frontend/#js_formatAddress",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "formatAddress"
  },
  {
    "objectID": "/frontend/#js_stdlib.formatAddress",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "stdlib.formatAddress"
  },
  {
    "objectID": "/frontend/#js_ask",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ask"
  },
  {
    "objectID": "/frontend/#js_ask.ask",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ask.ask"
  },
  {
    "objectID": "/frontend/#js_ask.yesno",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ask.yesno"
  },
  {
    "objectID": "/frontend/#js_ask.done",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "ask.done"
  },
  {
    "objectID": "/frontend/#js_test",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "test"
  },
  {
    "objectID": "/frontend/#js_test.shouldRun",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "test.shouldRun"
  },
  {
    "objectID": "/frontend/#js_test.shouldRunExac",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "test.shouldRunExac"
  },
  {
    "objectID": "/frontend/#js_test.chk",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "test.chk"
  },
  {
    "objectID": "/frontend/#js_test.chkErr",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "test.chkErr"
  },
  {
    "objectID": "/frontend/#js_test.one",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "test.one"
  },
  {
    "objectID": "/frontend/#js_test.makeChkExport",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "test.makeChkExport"
  },
  {
    "objectID": "/frontend/#js_test.run",
    "pt": "Frontends",
    "t": 0,
    "s": "js",
    "c": "test.run"
  },
  {
    "objectID": "/frontend/#term_API%20function",
    "pt": "Frontends",
    "t": 1,
    "c": "API function"
  },
  {
    "objectID": "/frontend/#term_view%20function",
    "pt": "Frontends",
    "t": 1,
    "c": "view function"
  },
  {
    "objectID": "/frontend/#term_EventStream",
    "pt": "Frontends",
    "t": 1,
    "c": "EventStream"
  },
  {
    "objectID": "/frontend/#term_isolated%20testing%20mode",
    "pt": "Frontends",
    "t": 1,
    "c": "isolated testing mode"
  },
  {
    "objectID": "/frontend/#term_bigNumberify",
    "pt": "Frontends",
    "t": 1,
    "c": "bigNumberify"
  },
  {
    "objectID": "/frontend/#term_isBigNumber",
    "pt": "Frontends",
    "t": 1,
    "c": "isBigNumber"
  },
  {
    "objectID": "/frontend/#term_bigNumberToNumber",
    "pt": "Frontends",
    "t": 1,
    "c": "bigNumberToNumber"
  },
  {
    "objectID": "/frontend/#term_bigNumberToBigInt",
    "pt": "Frontends",
    "t": 1,
    "c": "bigNumberToBigInt"
  },
  {
    "objectID": "/frontend/#term_hasRandom%20(Frontend)",
    "pt": "Frontends",
    "t": 1,
    "c": "hasRandom (Frontend)"
  },
  {
    "objectID": "/frontend/#term_hasConsoleLogger%20(Frontend)",
    "pt": "Frontends",
    "t": 1,
    "c": "hasConsoleLogger (Frontend)"
  },
  {
    "objectID": "/frontend/#term_standard%20unit",
    "pt": "Frontends",
    "t": 1,
    "c": "standard unit"
  },
  {
    "objectID": "/frontend/#term_atomic%20unit",
    "pt": "Frontends",
    "t": 1,
    "c": "atomic unit"
  },
  {
    "objectID": "/frontend/#term_atomic",
    "pt": "Frontends",
    "t": 1,
    "c": "atomic"
  },
  {
    "objectID": "/frontend/#ref-frontends",
    "pt": "Frontends",
    "t": 2,
    "c": "Frontends"
  },
  {
    "objectID": "/frontend/#ref-frontends-js",
    "pt": "Frontends",
    "t": 2,
    "c": "JavaScript"
  },
  {
    "objectID": "/frontend/#ref-frontends-js-types",
    "pt": "Frontends",
    "t": 2,
    "c": "Types"
  },
  {
    "objectID": "/frontend/#ref-frontends-js-loader",
    "pt": "Frontends",
    "t": 2,
    "c": "Loading the Standard Library"
  },
  {
    "objectID": "/frontend/#ref-frontends-js-provider",
    "pt": "Frontends",
    "t": 2,
    "c": "Provider Selection"
  },
  {
    "objectID": "/frontend/#ref-frontends-wallets",
    "pt": "Frontends",
    "t": 2,
    "c": "Providers in Browsers via Wallets"
  },
  {
    "objectID": "/frontend/#ref-frontends-providers-raw",
    "pt": "Frontends",
    "t": 2,
    "c": "Providers not using Wallets"
  },
  {
    "objectID": "/frontend/#provider-utilities",
    "pt": "Frontends",
    "t": 2,
    "c": "Provider Utilities"
  },
  {
    "objectID": "/frontend/#ref-frontends-js-acc",
    "pt": "Frontends",
    "t": 2,
    "c": "Creating an Account Handle"
  },
  {
    "objectID": "/frontend/#using-account-handles",
    "pt": "Frontends",
    "t": 2,
    "c": "Using Account Handles"
  },
  {
    "objectID": "/frontend/#ref-frontends-js-acc-eth",
    "pt": "Frontends",
    "t": 2,
    "c": "EVM-specific (Ethereum)"
  },
  {
    "objectID": "/frontend/#ref-frontends-js-ctc",
    "pt": "Frontends",
    "t": 2,
    "c": "Creating a Contract Handle"
  },
  {
    "objectID": "/frontend/#running-participants--ctcparticipants---ctcp",
    "pt": "Frontends",
    "t": 2,
    "c": "Running Participants: ctc.participants, ctc.p"
  },
  {
    "objectID": "/frontend/#calling-api-functions--ctcapis---ctca",
    "pt": "Frontends",
    "t": 2,
    "c": "Calling API functions: ctc.apis, ctc.a"
  },
  {
    "objectID": "/frontend/#calling-view-functions--ctcviews---ctcv",
    "pt": "Frontends",
    "t": 2,
    "c": "Calling View functions: ctc.views, ctc.v"
  },
  {
    "objectID": "/frontend/#observing-events--ctcevents---ctce",
    "pt": "Frontends",
    "t": 2,
    "c": "Observing Events: ctc.events, ctc.e"
  },
  {
    "objectID": "/frontend/#launching-tokens",
    "pt": "Frontends",
    "t": 2,
    "c": "Launching tokens"
  },
  {
    "objectID": "/frontend/#ref-frontends-js-network",
    "pt": "Frontends",
    "t": 2,
    "c": "Network Utilities"
  },
  {
    "objectID": "/frontend/#ref-frontends-js-utils",
    "pt": "Frontends",
    "t": 2,
    "c": "Utilities"
  },
  {
    "objectID": "/frontend/#ref-frontends-js-ask",
    "pt": "Frontends",
    "t": 2,
    "c": "Reading User Input: ask"
  },
  {
    "objectID": "/frontend/#ref-frontends-js-test",
    "pt": "Frontends",
    "t": 2,
    "c": "Writing tests: test"
  },
  {
    "objectID": "/frontend/#p_0",
    "pt": "Frontends",
    "t": 3,
    "c": "This section describes the libraries provided by Reach version 0.1.13 to support developing frontends."
  },
  {
    "objectID": "/frontend/#p_1",
    "pt": "Frontends",
    "t": 3,
    "c": "Frontends are implemented in JavaScript or via the RPC server and one of the languages with an RPC client: C Sharp, JavaScript, Go, and Python."
  },
  {
    "objectID": "/frontend/#p_2",
    "pt": "Frontends",
    "t": 3,
    "c": "You import the Reach JavaScript standard library by writing"
  },
  {
    "objectID": "/frontend/#p_3",
    "pt": "Frontends",
    "t": 3,
    "c": "When you use {!cmd} reach run or {!cmd} reach react, you don't need to do anything else."
  },
  {
    "objectID": "/frontend/#p_4",
    "pt": "Frontends",
    "t": 3,
    "c": "However, most developers when they stop learning and experimenting will use their own testing or deployment infrastructure. At that point, you should install the @reach-sh/stdlib npm package however you prefer installing packages. For example, you can use {!cmd} npm:"
  },
  {
    "objectID": "/frontend/#p_5",
    "pt": "Frontends",
    "t": 3,
    "c": "You only need to install the package directly if you are running your frontend without reach or using a tool like webpack for deployment."
  },
  {
    "objectID": "/frontend/#p_6",
    "pt": "Frontends",
    "t": 3,
    "c": "If you want to install the standard library for a browser application or library and you are using a bundler without Node polyfills (e.g. Webpack 5, Vite), you can import the library by writing:"
  },
  {
    "objectID": "/frontend/#p_7",
    "pt": "Frontends",
    "t": 3,
    "c": "Whenever you are interacting with the Reach standard library, you need to remember the JavaScript representation of each of the Reach types:"
  },
  {
    "objectID": "/frontend/#p_8",
    "pt": "Frontends",
    "t": 3,
    "c": "For example, the Reach type {!rsh} MInt = Data({None: Null, Some: UInt}) inhabitant {!rsh} MInt.Some(42) is represented as {!rsh} ['Some', 42] in JavaScript."
  },
  {
    "objectID": "/frontend/#p_9",
    "pt": "Frontends",
    "t": 3,
    "c": "{!rsh} Bytes(len) and {!rsh} BytesDyn may be represented as either a 'string' or a Uint8Array byte array. Both types are accepted as input. If the input string is prefixed with {!rsh} 0x, the string will be interpreted as hex. Reach will output a value as a 'string' if the value is able to be encoded in UTF-8. Otherwise, the value will be represented as Uint8Array byte array."
  },
  {
    "objectID": "/frontend/#p_10",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns the standard library based on the provided {!js} env."
  },
  {
    "objectID": "/frontend/#p_11",
    "pt": "Frontends",
    "t": 3,
    "c": "You may call this function multiple times and get completely separate standard libraries, with different (and incompatible!) configuration options."
  },
  {
    "objectID": "/frontend/#p_12",
    "pt": "Frontends",
    "t": 3,
    "c": "In environments where the Reach standard library has implicit access to {!js} process.env, you may omit the {!js} env argument, in which case {!js} process.env will be used. If the standard library is being used with JavaScript bundlers like Webpack ---as it is with React, for example--- then Reach does not have implicit access to {!js} process.env. In such scenarios, we recommend that you call this function like so:"
  },
  {
    "objectID": "/frontend/#p_13",
    "pt": "Frontends",
    "t": 3,
    "c": "Alternatively, you can construct a custom object that has all of the environment keys and fields you need. Each network supports different keys; see Networks for details."
  },
  {
    "objectID": "/frontend/#p_14",
    "pt": "Frontends",
    "t": 3,
    "c": "As a special case, you may instead pass in the string 'ETH' or 'ALGO', to select the desired connector directly."
  },
  {
    "objectID": "/frontend/#p_15",
    "pt": "Frontends",
    "t": 3,
    "c": "By default, this method allows a user to load a standard library for a single connector. That is, this method may not be called multiple times with varying connectors. To bypass this restriction, use {!js} unsafeAllowMultipleStdlibs."
  },
  {
    "objectID": "/frontend/#p_16",
    "pt": "Frontends",
    "t": 3,
    "c": "Calling this function will lift the restriction that {!js} loadStdlib imposes on loading multiple standard libraries."
  },
  {
    "objectID": "/frontend/#p_17",
    "pt": "Frontends",
    "t": 3,
    "c": "The first thing you should do in a frontend is decide if you need to specify a provider. This process works differently in the browser than in console (or \"automated\") contexts."
  },
  {
    "objectID": "/frontend/#p_18",
    "pt": "Frontends",
    "t": 3,
    "c": "By default, in browsers, Reach will automatically attach to a standards-conforming wallet, which is a connector-specific concept:"
  },
  {
    "objectID": "/frontend/#p_19",
    "pt": "Frontends",
    "t": 3,
    "c": "On Ethereum, MetaMask is used as the standard."
  },
  {
    "objectID": "/frontend/#p_20",
    "pt": "Frontends",
    "t": 3,
    "c": "On Algorand, ARC-0011 is used as the standard."
  },
  {
    "objectID": "/frontend/#p_21",
    "pt": "Frontends",
    "t": 3,
    "c": "However, in your user does not have a standards-conforming wallet, then you can set up a fallback for them."
  },
  {
    "objectID": "/frontend/#p_22",
    "pt": "Frontends",
    "t": 3,
    "c": "As of late 2022, almost no Algorand users have ARC-0011 wallets, so you should almost certainly use this function!"
  },
  {
    "objectID": "/frontend/#p_23",
    "pt": "Frontends",
    "t": 3,
    "c": "When you call this function, if no browser wallet is available, then {!js} make will be called to construct one and it will be installed as if there were always a browser wallet."
  },
  {
    "objectID": "/frontend/#p_24",
    "pt": "Frontends",
    "t": 3,
    "c": "The value that {!js} make should conform to the connector-specific standard (mentioned above)."
  },
  {
    "objectID": "/frontend/#p_25",
    "pt": "Frontends",
    "t": 3,
    "c": "Please refer to the algo-wallet-demo example to see a full walkthrough of this discussion."
  },
  {
    "objectID": "/frontend/#p_26",
    "pt": "Frontends",
    "t": 3,
    "c": "Since this function installs a new value as the browser wallet, if you call {!js} stdlib.setWalletFallback twice, then the second is guaranteed to do nothing, even if you are using different standard library instances, because this modifies a global property of the browser. If you want to work around that, then you'd have to delete the property so that Reach cannot find a browser wallet on the second time."
  },
  {
    "objectID": "/frontend/#p_27",
    "pt": "Frontends",
    "t": 3,
    "c": "For example, this is a bad program that is useless:"
  },
  {
    "objectID": "/frontend/#p_28",
    "pt": "Frontends",
    "t": 3,
    "c": "because the second call is useless. If you were using a connector like Algorand, then you'd want to do:"
  },
  {
    "objectID": "/frontend/#p_29",
    "pt": "Frontends",
    "t": 3,
    "c": "But even this will not do what you think, because in f, stdlib1 will still use the global variable {!js} window.algorand, which is the value that make2 returns."
  },
  {
    "objectID": "/frontend/#p_30",
    "pt": "Frontends",
    "t": 3,
    "c": "The solution to this is to explicitly access the wallet using stdlib1, before you reset the wallet:"
  },
  {
    "objectID": "/frontend/#p_31",
    "pt": "Frontends",
    "t": 3,
    "c": "This function returns a value that may be passed to {!js} setWalletFallback to synthesize a wallet for use in browsers that do not supply a compliant wallet. Its customization options, {!js} opts, depend on the connector."
  },
  {
    "objectID": "/frontend/#p_32",
    "pt": "Frontends",
    "t": 3,
    "c": "On Ethereum, it always errors and cannot provide a wallet."
  },
  {
    "objectID": "/frontend/#p_33",
    "pt": "Frontends",
    "t": 3,
    "c": "On Algorand, it can provide a wallet that directly connects to the Algorand network, like {!js} setProviderByName (& {!js} setProviderByEnv), but provide interactive signing. The network connection is specified via the providerEnv key, which may be a string (which is used as an argument to {!js} providerEnvByName) or an environment (which is used as an argument to {!js} setProviderByEnv). Alternatively, a {!js} BasicProvider value can be provided with the key provider (see {!js} stdlib.setProvider's documentation to understand the type of this value)."
  },
  {
    "objectID": "/frontend/#p_34",
    "pt": "Frontends",
    "t": 3,
    "c": "By default, signing is via an interactive browser window prompt, where the user repeatedly provides their mnemonic. But, other fallbacks can be synthesized by providing special arguments in opts."
  },
  {
    "objectID": "/frontend/#p_35",
    "pt": "Frontends",
    "t": 3,
    "c": "If the key MyAlgoConnect is provided, and bound to the default export of @randlabs/myalgo-connect, then MyAlgo will be used for signing. For example, this sets the wallet fallback to be MyAlgo used with Algorand TestNet:"
  },
  {
    "objectID": "/frontend/#p_36",
    "pt": "Frontends",
    "t": 3,
    "c": "Alternatively, you can call the ALGO_MakeAlgoSignerConnect export @reach-sh/stdlib, with the AlgoSigner global object from AlgoSigner and a provider name to use the AlgoSigner extension. For example, this sets the wallet fallback to be AlgoSigner and the Algorand TestNet:"
  },
  {
    "objectID": "/frontend/#p_37",
    "pt": "Frontends",
    "t": 3,
    "c": "If the key WalletConnect is provided, and bound to the result of calling the ALGO_MakeWalletConnect export of @reach-sh/stdlib on the default exports of @walletconnect/client and algorand-walletconnect-qrcode-modal, then WalletConnect is used to connect to the PeraWallet for signing. For example, this sets the wallet fallback to be WalletConnect and the Algorand TestNet:"
  },
  {
    "objectID": "/frontend/#p_38",
    "pt": "Frontends",
    "t": 3,
    "c": "Alternatively, you can call the ALGO_MakePeraConnect export of @reach-sh/stdlib, with PeraWalletConnect from @perawallet/connect, then PeraConnect is used to connect to the PeraWallet for signing. For example, this sets the wallet fallback to be PeraConnect and the Algorand TestNet:"
  },
  {
    "objectID": "/frontend/#p_39",
    "pt": "Frontends",
    "t": 3,
    "c": "This fallback exposes the underlying WalletConnect wrapper object as the wc property on the wallet. Furthermore, it supports using an existing WalletConnect wrapper object by providing the key WalletConnect_wc in the {!js} stdlib.walletFallback options object. (When you're using PeraConnect, the same object/keys/etc are used for the PeraWalletConnect object.)"
  },
  {
    "objectID": "/frontend/#p_40",
    "pt": "Frontends",
    "t": 3,
    "c": "Because these are fallbacks, you need to decide for your users which wallet they'll use, or make a user interface element to let them select which wallet fallback to use."
  },
  {
    "objectID": "/frontend/#p_41",
    "pt": "Frontends",
    "t": 3,
    "c": "Please refer to the algo-wallet-demo example to see a full walkthrough of using wallet fallbacks and all their options."
  },
  {
    "objectID": "/frontend/#p_42",
    "pt": "Frontends",
    "t": 3,
    "c": "If you are not building a browser-based DApp, you may want to set the network provider by using a standard name or using environment variables:"
  },
  {
    "objectID": "/frontend/#p_43",
    "pt": "Frontends",
    "t": 3,
    "c": "Supported provider names are: {!js} 'MainNet', {!js} 'TestNet', {!js} 'BetaNet', and {!js} 'LocalHost'. {!js} 'BetaNet' is sometimes referred to as {!js} 'DevNet'."
  },
  {
    "objectID": "/frontend/#p_44",
    "pt": "Frontends",
    "t": 3,
    "c": "On Ethereum, {!js} 'MainNet' will connect to homestead, and {!js} 'TestNet' to ropsten. Multiple free API providers are used behind the scenes, as implemented by ethers.js."
  },
  {
    "objectID": "/frontend/#p_45",
    "pt": "Frontends",
    "t": 3,
    "c": "On Algorand, {!js} 'MainNet' will connect to MainNet, and {!js} 'TestNet' to TestNet. The default Node provider is AlgoNode, but the free RandLabs API provider can also be used."
  },
  {
    "objectID": "/frontend/#p_46",
    "pt": "Frontends",
    "t": 3,
    "c": "Provider connections are created with the code below:"
  },
  {
    "objectID": "/frontend/#p_47",
    "pt": "Frontends",
    "t": 3,
    "c": "Retrieve configuration information about providers by name."
  },
  {
    "objectID": "/frontend/#p_48",
    "pt": "Frontends",
    "t": 3,
    "c": "Select an API provider by supplying information about it."
  },
  {
    "objectID": "/frontend/#p_49",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} env is a record with string keys and string values."
  },
  {
    "objectID": "/frontend/#p_50",
    "pt": "Frontends",
    "t": 3,
    "c": "The environment object supports the same fields as {!js} stdlib.loadStdlib, which are documented in Networks."
  },
  {
    "objectID": "/frontend/#p_51",
    "pt": "Frontends",
    "t": 3,
    "c": "Finally, Reach provides low-level access to defining a network provider."
  },
  {
    "objectID": "/frontend/#p_52",
    "pt": "Frontends",
    "t": 3,
    "c": "Select an API provider by providing an object satisfying its interface."
  },
  {
    "objectID": "/frontend/#p_53",
    "pt": "Frontends",
    "t": 3,
    "c": "This function's API is considered unstable."
  },
  {
    "objectID": "/frontend/#p_54",
    "pt": "Frontends",
    "t": 3,
    "c": "On Ethereum, {!js} provider is an instance of {!js} ethers.provider. See: https://docs.ethers.io/v5/api/providers/provider/"
  },
  {
    "objectID": "/frontend/#p_55",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_56",
    "pt": "Frontends",
    "t": 3,
    "c": "On Algorand, {!js} provider is an object:"
  },
  {
    "objectID": "/frontend/#p_57",
    "pt": "Frontends",
    "t": 3,
    "c": "The {!js} algodClient and {!js} indexer values are as specified by the Algorand JS SDK. The {!js} algod_bc and {!js} indexer_bc are objects that represent HTTP connections to those values. The {!js} signAndPostTxns function obeys ARC-0008."
  },
  {
    "objectID": "/frontend/#p_58",
    "pt": "Frontends",
    "t": 3,
    "c": "Technically, this function can be used (and IS used) to attach wallets to Reach, but for practical purposes, you don't need to know this."
  },
  {
    "objectID": "/frontend/#p_59",
    "pt": "Frontends",
    "t": 3,
    "c": "Promises a provider, matching the interface specified above."
  },
  {
    "objectID": "/frontend/#p_60",
    "pt": "Frontends",
    "t": 3,
    "c": "There are a few options to customize how Reach interacts with the Provider, however it is found."
  },
  {
    "objectID": "/frontend/#p_61",
    "pt": "Frontends",
    "t": 3,
    "c": "Setting this to a positive number forces outgoing requests to occur one at a time, and limits them to occur no more frequently than one request every ms milliseconds. This is only supported with certain connectors, and applies to all Providers created by the Reach standard library."
  },
  {
    "objectID": "/frontend/#p_62",
    "pt": "Frontends",
    "t": 3,
    "c": "Allows for the installation of a custom hook to observe outgoing HTTP requests. The handler h will be called before and after every request. The handler will be called with one argument: an object e. Inspection of e's fields should be considered an unstable API that may change over time. Currently, it has a field eventName which may be 'before', 'success', or 'error', as well as various other fields describing the HTTP event. This is only supported with certain connectors, and applies to all Providers created by the Reach standard library."
  },
  {
    "objectID": "/frontend/#p_63",
    "pt": "Frontends",
    "t": 3,
    "c": "Allows for the installation of a custom hook to observe signing requests. The handler h will be called on every request. The evt argument is an unstable object that describes the request. The pre argument is a Promise of an unstable object with details about the request, available after the request has been made. The post argument is a Promise of an unstable object with details about the completed request, available after the request has been completed."
  },
  {
    "objectID": "/frontend/#p_64",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_65",
    "pt": "Frontends",
    "t": 3,
    "c": "This sample has a hook of {!js} async and performs an {!js} await for the {!js} Promise of both pre and post."
  },
  {
    "objectID": "/frontend/#p_66",
    "pt": "Frontends",
    "t": 3,
    "c": "The second thing you should do in a frontend is create an account handle."
  },
  {
    "objectID": "/frontend/#p_67",
    "pt": "Frontends",
    "t": 3,
    "c": "In real applications, you will use access the user's account via their wallet with"
  },
  {
    "objectID": "/frontend/#p_68",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise for a Reach account abstraction for a \"default\" account on the consensus network. The meaning of \"default account\" varies between contexts. When running in the browser, the default account will be connected to a wallet. This promise will be rejected with an exception if no sensible default account can be accessed for the current context."
  },
  {
    "objectID": "/frontend/#p_69",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_70",
    "pt": "Frontends",
    "t": 3,
    "c": "This code uses {!js} stdlib.getDefaultAccount to set acc to the account that was connected to the DApp earlier in the code."
  },
  {
    "objectID": "/frontend/#p_71",
    "pt": "Frontends",
    "t": 3,
    "c": "But, when you are testing, you will use"
  },
  {
    "objectID": "/frontend/#p_72",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise for a Reach account abstraction for a new account on the consensus network with a given balance of network tokens. This can only be used in private testing scenarios, because it uses a private faucet to issue network tokens."
  },
  {
    "objectID": "/frontend/#p_73",
    "pt": "Frontends",
    "t": 3,
    "c": "This example from the Trust Fund workshop creates a startingBalance of 100 tokens, and then creates new accounts for the funder, receiver and bystander. Each get funded 100 tokens by setting each {!js} newTestAccount balance to the startingBalance value."
  },
  {
    "objectID": "/frontend/#p_74",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise for an array of {!js} howMany test accounts, using {!js} stdlib.newTestAccount."
  },
  {
    "objectID": "/frontend/#p_75",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_76",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} newTestAccounts sets up 3 new accounts (accA, accB, and accC) and loads them with the startingBalance of tokens so that they are usable for testing."
  },
  {
    "objectID": "/frontend/#p_77",
    "pt": "Frontends",
    "t": 3,
    "c": "Reach also provides some low-level tools for creating account handles. You will probably not use these."
  },
  {
    "objectID": "/frontend/#p_78",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise for a Reach account abstraction for an account on the consensus network specified by the given secret. The secret key must be either a hex string beginning with {!js} '0x', or a {!js} Uint8Array. The number of bytes in the secret differs between connectors."
  },
  {
    "objectID": "/frontend/#p_79",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_80",
    "pt": "Frontends",
    "t": 3,
    "c": "In this code, if the user chooses to not create a new account, then the DApp uses {!rsh} newAccountFromSecret to create a new account. The acc object {!rsh} awaits the user to input the secret and then sets the provided account to itself."
  },
  {
    "objectID": "/frontend/#p_81",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise for a Reach account abstraction for an account on the consensus network specified by the given mnemonic phrase. The mnemonic phrase must be a string of whitespace-separated words from the BIP-39 English wordlist. The number of words required for a mnemonic differs between connectors."
  },
  {
    "objectID": "/frontend/#p_82",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise for a Reach account abstraction for a new account on the consensus network. The account will have an empty balance of network tokens."
  },
  {
    "objectID": "/frontend/#p_83",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_84",
    "pt": "Frontends",
    "t": 3,
    "c": "This code creates an account for accD without a starting balance."
  },
  {
    "objectID": "/frontend/#p_85",
    "pt": "Frontends",
    "t": 3,
    "c": "Adds the given balance of network tokens to a Reach account abstraction. This can only be used in private testing scenarios, as it uses a private faucet to issue network tokens, as well as certain public TestNet scenarios. You can use {!js} canFundFromFaucet to check if {!js} fundFromFaucet can be used."
  },
  {
    "objectID": "/frontend/#p_86",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_87",
    "pt": "Frontends",
    "t": 3,
    "c": "This code funds the account with fundAmount worth of tokens from a faucet. This is used in cases where funding from a normal faucet is difficult or impossible, such as when using large token quantities."
  },
  {
    "objectID": "/frontend/#p_88",
    "pt": "Frontends",
    "t": 3,
    "c": "A Promise that resolves to {!js} true if {!js} fundFromFaucet can be used, {!js} false if not."
  },
  {
    "objectID": "/frontend/#p_89",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_90",
    "pt": "Frontends",
    "t": 3,
    "c": "This React frontend from the Rock, Paper, Scissors tutorial checks if the account can be funded from a faucet using {!js} canFundFromFaucet. If the value returns true, then the account is funded by {!js} fundFromFaucet."
  },
  {
    "objectID": "/frontend/#p_91",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise for a Reach account abstraction for an existing account for the consensus network based on the connector-specific account specification provided by the {!js} networkAccount argument."
  },
  {
    "objectID": "/frontend/#p_92",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_93",
    "pt": "Frontends",
    "t": 3,
    "c": "Here, faucet is set to the previously coded ganacheProvider that has a {!js} getSigner method. This allows {!js} connectAccount to be able to connect faucet to {!js} setFaucet to provide the testing funds."
  },
  {
    "objectID": "/frontend/#p_94",
    "pt": "Frontends",
    "t": 3,
    "c": "Once you have an account handle, you can inspect it"
  },
  {
    "objectID": "/frontend/#p_95",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns the connector-specific account specification of a Reach account abstraction."
  },
  {
    "objectID": "/frontend/#p_96",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_97",
    "pt": "Frontends",
    "t": 3,
    "c": "This code sets aliceAddr to the consensus network format of the wallet address of accAlice using the {!js} networkAccount method."
  },
  {
    "objectID": "/frontend/#p_98",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns the account's address as a string. The format of this string varies across connectors."
  },
  {
    "objectID": "/frontend/#p_99",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_100",
    "pt": "Frontends",
    "t": 3,
    "c": "In this snippet, {!js} getAddress obtains the addresses of Alice and Bob, which were created with the {!js} newTestAccounts method. Next, each address is logged so that participants can see both addresses. This can be useful to verify that the address receiving the payment is the correct address."
  },
  {
    "objectID": "/frontend/#p_101",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns the label used to distinguish an account in debug logs. If no label was previously provided with {!js} acc.setDebugLabel, then the first four digits of the account address will be used."
  },
  {
    "objectID": "/frontend/#p_102",
    "pt": "Frontends",
    "t": 3,
    "c": "An account may set a distinguishing label to use in debug logs. If no label is provided, then the first four digits of the account address will be used."
  },
  {
    "objectID": "/frontend/#p_103",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_104",
    "pt": "Frontends",
    "t": 3,
    "c": "This code uses {!js} setDebugLabel to set accAlice to the label of Alice, and accBob to Bob. This makes debugging much simpler, especially when using a large number of accounts, because each account can be set to a different human-readable string."
  },
  {
    "objectID": "/frontend/#p_105",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise that completes when the Reach account abstraction is ready to accept non-network tokens specified by the {!js} token. This does nothing on some consensus networks, but should always be used to ensure your frontend is blockchain agnostic."
  },
  {
    "objectID": "/frontend/#p_106",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_107",
    "pt": "Frontends",
    "t": 3,
    "c": "Here, Alice and Bob opt-in to the tokens zorkmid and gil using {!js} tokenAccept prior to receiving them."
  },
  {
    "objectID": "/frontend/#p_108",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise that returns if an account may accept a given token. This does nothing on some consensus networks, but should always be used to ensure your frontend is blockchain agnostic."
  },
  {
    "objectID": "/frontend/#p_109",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise for an array of tokens that are accepted by acc. On networks which do not keep track of this information (e.g. Ethereum), this returns an empty array."
  },
  {
    "objectID": "/frontend/#p_110",
    "pt": "Frontends",
    "t": 3,
    "c": "This does nothing on some networks. On others, it opts into the contract ctc."
  },
  {
    "objectID": "/frontend/#p_111",
    "pt": "Frontends",
    "t": 3,
    "c": "On some networks this always returns true. On others, it checks whether the account has opted into the contract specified by info."
  },
  {
    "objectID": "/frontend/#p_112",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise of the metadata for a non-network token specified by the {!js} token."
  },
  {
    "objectID": "/frontend/#p_113",
    "pt": "Frontends",
    "t": 3,
    "c": "Promises the balance of network tokens (or non-network tokens if {!js} token is provided) held by given Reach account abstraction {!js} acc."
  },
  {
    "objectID": "/frontend/#p_114",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_115",
    "pt": "Frontends",
    "t": 3,
    "c": "This code obtains the balance of network tokens for a user, {!js} who, and sets it to the getBalance object. This makes the account balance simpler to reference later in the code, such as displaying balances after transactions, proving that cancelled transactions did not transfer tokens, etc."
  },
  {
    "objectID": "/frontend/#p_116",
    "pt": "Frontends",
    "t": 3,
    "c": "Promises an array of balances that corresponds with the provided array of tokens, {!js} tokens, for a given Reach account {!js} acc. If {!js} tokens contains a {!js} null, the corresponding position in the output array will contain the account's balance of network tokens. This function is more efficient for getting multiple token balances than repeated calls to {!js} stdlib.balanceOf."
  },
  {
    "objectID": "/frontend/#p_117",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_118",
    "pt": "Frontends",
    "t": 3,
    "c": "The eggBal, bknBal, and tstBal array is set equal to the array of egg.id, bkn.id, tst.id using an {!js} await and the {!js} balancesOf method."
  },
  {
    "objectID": "/frontend/#p_119",
    "pt": "Frontends",
    "t": 3,
    "c": "Promises the portion of {!js} balanceOf(acc) which may not be transferred by the given account. Some networks restrict the usage of an account's funds. On networks that do not, this will always return zero."
  },
  {
    "objectID": "/frontend/#p_120",
    "pt": "Frontends",
    "t": 3,
    "c": "Performs a transfer of {!js} amount from {!js} from, which is an account, to {!js} to, which is either an account or an address. If {!js} token is not provided, then the transfer is of network tokens; otherwise, it is of the designated non-network token. The returned {!js} Promise will only be resolved after the transfer completes."
  },
  {
    "objectID": "/frontend/#p_121",
    "pt": "Frontends",
    "t": 3,
    "c": "Possible options to provide in {!js} opts include:"
  },
  {
    "objectID": "/frontend/#p_122",
    "pt": "Frontends",
    "t": 3,
    "c": "Algorand-only options:"
  },
  {
    "objectID": "/frontend/#p_123",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} closeTo An {!js} Address to which all remaining ALGO will be sent before the sender account is closed. If {!js} token is specified, the sender account opts out of the token rather than closing. See this page for more information. The default is no close address."
  },
  {
    "objectID": "/frontend/#p_124",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} note A {!js} Uint8Array for the Note field of the asset creation transaction. The default is a note containing the Reach version used to perform the transfer."
  },
  {
    "objectID": "/frontend/#p_125",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_126",
    "pt": "Frontends",
    "t": 3,
    "c": "This transfers one (1) unit of the network token from Alice's account accAlice, to Bob's account accBob."
  },
  {
    "objectID": "/frontend/#p_127",
    "pt": "Frontends",
    "t": 3,
    "c": "When connected to an EVM-based consensus network, the standard library provides additional functionality."
  },
  {
    "objectID": "/frontend/#p_128",
    "pt": "Frontends",
    "t": 3,
    "c": "Modifies the gas limit for each transaction originating from the given account for the rest of the program. {!js} n must be a value that {!js} bigNumberify will accept."
  },
  {
    "objectID": "/frontend/#p_129",
    "pt": "Frontends",
    "t": 3,
    "c": "On EVM-based consensus networks, the Reach standard library will automatically estimate the required gas necessary to execute transactions, i.e. make publications. However, sometimes this estimation process is inaccurate, especially when Reach programs interact with remote objects. In those cases, it is sometimes useful to specify a particular gas limit. It is common on Ethereum to use gas limits like {!js} 5000000 in testing. If you do this, you should inform your clients that they should pay attention to the gas stipend issued."
  },
  {
    "objectID": "/frontend/#p_130",
    "pt": "Frontends",
    "t": 3,
    "c": "Here, there is a {!js} myGasLimit object created, which is set to {!js} 5000000. This is then applied to both the {!js} accAlice and {!js} accBob by using the {!js} setGasLimit method so that the maximum gas cost is set for each account."
  },
  {
    "objectID": "/frontend/#p_131",
    "pt": "Frontends",
    "t": 3,
    "c": "The third thing you should do in a frontend is create a contract handle, so you can actually interact with your Reach program."
  },
  {
    "objectID": "/frontend/#p_132",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Reach contract handle based on the {!js} bin argument, and optional ContractInfo provided. The {!js} acc.contract form will use the account {!js} acc to interact with the returned contract. The {!js} stdlib.contract form is equivalent to {!js} (await stdlib.createAccount()).contract, generating an account on demand (this means the contract can only be used for read-only operations). This {!js} bin argument is the module produced by {!cmd} reach compile."
  },
  {
    "objectID": "/frontend/#p_133",
    "pt": "Frontends",
    "t": 3,
    "c": "If {!js} info is provided, it must be a {!js} ContractInfo value, or a {!js} Promise that eventually yields a {!js} ContractInfo value. When provided, Reach will verify that the contract given actually matches the bytecode produced by {!cmd} reach compile and will error if it is different in any way."
  },
  {
    "objectID": "/frontend/#p_134",
    "pt": "Frontends",
    "t": 3,
    "c": "Typically, the deployer of a contract will not provide {!js} info, while users of a contract will. In an automated, single instance program, {!rsh} ctc.getInfo() is typically used to acquire {!js} info; while in non-automated programs, an application uses out-of-band communication, such as an external database or user input, to acquire the {!js} info argument."
  },
  {
    "objectID": "/frontend/#p_135",
    "pt": "Frontends",
    "t": 3,
    "c": "The first publishing participant will attempt to deploy a contract for an application. If {!js} info was provided, an error will be thrown. This deployment can only happen one time, so subsequent attempts will fail with an error."
  },
  {
    "objectID": "/frontend/#p_136",
    "pt": "Frontends",
    "t": 3,
    "c": "This function may emit warnings if there is any danger, risk, or subtlety to using this contract on your chosen consensus network. You can omit this warning by setting {!cmd} REACH_NO_WARN, but we recommend that you do not."
  },
  {
    "objectID": "/frontend/#p_137",
    "pt": "Frontends",
    "t": 3,
    "c": "The {!js} acc.contract form of the function does not block."
  },
  {
    "objectID": "/frontend/#p_138",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise for a {!js} ContractInfo value that may be given to {!js} contract to construct a Reach contract handle for this contract. This object may be stringified with {!js} JSON.stringify for printing and parsed again with {!js} JSON.parse without any loss of information."
  },
  {
    "objectID": "/frontend/#p_139",
    "pt": "Frontends",
    "t": 3,
    "c": "If {!js} ctc will deploy the program, then the Promise will only be resolved after the contract is actually deployed on the network, thus you cannot block on this Promise with {!js} await until after the first {!rsh} publish has occurred. Awaiting {!rsh} getInfo too early may cause your program to enter a state of deadlock. It is safer to make an {!rsh} interact function that receives {!rsh} getContract() from the Reach program."
  },
  {
    "objectID": "/frontend/#p_140",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise for the {!js} Address of the connected Reach contract."
  },
  {
    "objectID": "/frontend/#p_141",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns the ABI to the contract in a connector-specific format. When the {!js} showFull argument is not {!js} true, internal implementation details are omitted."
  },
  {
    "objectID": "/frontend/#p_142",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a mapping from event name to the Reach types of the data emitted for that event. This can be used to determine the connector-specific event signature. For example:"
  },
  {
    "objectID": "/frontend/#p_143",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a mapping that associates the steps of a {!js} contract to the {!js} ReachType of its internal state variables."
  },
  {
    "objectID": "/frontend/#p_144",
    "pt": "Frontends",
    "t": 3,
    "c": "This deprecated function is an abbreviation of {!js} acc.contract(bin)."
  },
  {
    "objectID": "/frontend/#p_145",
    "pt": "Frontends",
    "t": 3,
    "c": "This deprecated function is an abbreviation of {!js} acc.contract(bin, info)."
  },
  {
    "objectID": "/frontend/#p_146",
    "pt": "Frontends",
    "t": 3,
    "c": "Contract handles provide access to the {!rsh} Participants of the compiled backend, {!js} bin, that they were constructed with."
  },
  {
    "objectID": "/frontend/#p_147",
    "pt": "Frontends",
    "t": 3,
    "c": "An object where the keys are the participant names and the values are functions that accept an interact object and return a Promise that completes when the participant ends."
  },
  {
    "objectID": "/frontend/#p_148",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} acc.contract(backend).p.Alice(io) is equivalent to {!js} backend.Alice(acc.contract(backend), io), but does not require duplication of the {!js} backend component."
  },
  {
    "objectID": "/frontend/#p_149",
    "pt": "Frontends",
    "t": 3,
    "c": "When you run a participant, you may want to run it up until a particular {!rsh} interact function and then disconnect. If so, then you should use"
  },
  {
    "objectID": "/frontend/#p_150",
    "pt": "Frontends",
    "t": 3,
    "c": "withDisconnect calls the given function f such that any calls to disconnect within f will cause withDisconnect to return immediately. withDisconnect returns the value passed to disconnect."
  },
  {
    "objectID": "/frontend/#p_151",
    "pt": "Frontends",
    "t": 3,
    "c": "disconnect causes the surrounding call to withDisconnect to immediately return t. disconnect must be called from within a function passed to withDisconnect, otherwise an exception will be thrown."
  },
  {
    "objectID": "/frontend/#p_152",
    "pt": "Frontends",
    "t": 3,
    "c": "withDisconnect and disconnect are intended as a utility to exit participant frontends early, like such:"
  },
  {
    "objectID": "/frontend/#p_153",
    "pt": "Frontends",
    "t": 3,
    "c": "Once an account disconnects from the contract, they cannot rejoin as the same participant."
  },
  {
    "objectID": "/frontend/#p_154",
    "pt": "Frontends",
    "t": 3,
    "c": "Contract handles provide access to the {!rsh} APIs of the compiled backend, {!js} bin, that they were constructed with."
  },
  {
    "objectID": "/frontend/#p_155",
    "pt": "Frontends",
    "t": 3,
    "c": "An object that mirrors the API hierarchy, so if X.Y is an API, then {!js} ctc.apis.X.Y is an API function. An API function accepts the arguments of the API and returns a {!js} Promise that results in the value of the API. This function may throw an error if the API is not available."
  },
  {
    "objectID": "/frontend/#p_156",
    "pt": "Frontends",
    "t": 3,
    "c": "If an API was specified without an {!rsh} apiName, for example {!rsh} API({ cast: Fun([String], Null)}), it may be accessed by its property name:"
  },
  {
    "objectID": "/frontend/#p_157",
    "pt": "Frontends",
    "t": 3,
    "c": "This object is the same as {!js} ctc.apis except the API functions return a {!rsh} Maybe value. If the call fails, then {!js} ['None', null] will be returned. If the call succeeds, the return value will be wrapped with {!js} Some, e.g. {!js} ['Some', 4]."
  },
  {
    "objectID": "/frontend/#p_158",
    "pt": "Frontends",
    "t": 3,
    "c": "Contract handles provide access to the {!rsh} Views of the compiled backend, {!js} bin, that they were constructed with."
  },
  {
    "objectID": "/frontend/#p_159",
    "pt": "Frontends",
    "t": 3,
    "c": "Views are defined in application initialization and then they are set in consensus steps. Both of these steps are in Reach. This section is about accessing them in JavaScript frontends."
  },
  {
    "objectID": "/frontend/#p_160",
    "pt": "Frontends",
    "t": 3,
    "c": "An object that mirrors the view hierarchy, so if X.Y is a view, then {!js} ctc.views.X.Y is a view function. A view function accepts the arguments of the view and returns a {!js} Promise that results in the value of the view wrapped in a {!rsh} Maybe type (because the view may not be bound). For example, if NFT.owner is a view with no arguments that represents the {!rsh} Address that owns an NFT, then {!js} await ctc.v.NFT.owner() is either {!js} ['Some', Owner] or {!js} ['None', null]."
  },
  {
    "objectID": "/frontend/#p_161",
    "pt": "Frontends",
    "t": 3,
    "c": "If a View was specified without a {!rsh} viewName, for example {!rsh} View({ owner: Address }), it may be accessed by its property name:"
  },
  {
    "objectID": "/frontend/#p_162",
    "pt": "Frontends",
    "t": 3,
    "c": "If we add an alias for the above view using {!rsh} View({ owner: Address }, { owner: [\"holder\"]}), we could also access the alias:"
  },
  {
    "objectID": "/frontend/#p_163",
    "pt": "Frontends",
    "t": 3,
    "c": "This object is the same as {!js} ctc.views except the value of the view is not wrapped in a {!rsh} Maybe type. If a view is set, the value will be returned as is, without being wrapped in {!rsh} Some. If a view is not set, an error will be thrown."
  },
  {
    "objectID": "/frontend/#p_164",
    "pt": "Frontends",
    "t": 3,
    "c": "This deprecated function is an abbreviation of {!js} ctc.views."
  },
  {
    "objectID": "/frontend/#p_165",
    "pt": "Frontends",
    "t": 3,
    "c": "Contract handles provide access to the {!rsh} Events of the compiled backend, {!js} bin, that they were constructed with."
  },
  {
    "objectID": "/frontend/#p_166",
    "pt": "Frontends",
    "t": 3,
    "c": "An object that mirrors the event hierarchy, so if X.Y is an event, then {!js} ctc.events.X.Y is an EventStream. An EventStream supports the following operations for a given {!rsh} Event:"
  },
  {
    "objectID": "/frontend/#p_167",
    "pt": "Frontends",
    "t": 3,
    "c": "where"
  },
  {
    "objectID": "/frontend/#p_168",
    "pt": "Frontends",
    "t": 3,
    "c": "An {!js} Event is instantiated with it's corresponding type declared in Reach."
  },
  {
    "objectID": "/frontend/#p_169",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} next will wait for the next {!rsh} Event to occur, returning the time the event occurred and the arguments to the event."
  },
  {
    "objectID": "/frontend/#p_170",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} nextUpToTime is the same as {!js} next, except it will only return events up to the given time t (inclusive). If time t has passed and no more events within the time frame are available, it will stop waiting and return undefined."
  },
  {
    "objectID": "/frontend/#p_171",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} seek will set the internal time of the EventStream to the given argument. The EventStream will use this time as the minimum bound when searching for {!rsh} Events."
  },
  {
    "objectID": "/frontend/#p_172",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} seekNow will set the internal time of the EventStream to the latest network time. The EventStream will use this time as the minimum bound when searching for {!rsh} Events."
  },
  {
    "objectID": "/frontend/#p_173",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} lastTime will return the last network time that an {!rsh} Event was emitted."
  },
  {
    "objectID": "/frontend/#p_174",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} monitor accepts a function of type {!js} Event<T> => void as an argument. The provided function will be called whenever the {!rsh} Event occurs."
  },
  {
    "objectID": "/frontend/#p_175",
    "pt": "Frontends",
    "t": 3,
    "c": "The standard library provides a convenient way to launch new non-network tokens."
  },
  {
    "objectID": "/frontend/#p_176",
    "pt": "Frontends",
    "t": 3,
    "c": "Launches a non-network token with the given {!js} name and unit symbol {!js} sym. Launched on the network by {!js} accCreator."
  },
  {
    "objectID": "/frontend/#p_177",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_178",
    "pt": "Frontends",
    "t": 3,
    "c": "The tokens gil and zorkmid are created in this code snippet, and then launched using {!js} stdlib.launchToken by the {!js} accCreator account with the symbols GIL and ZMD."
  },
  {
    "objectID": "/frontend/#p_179",
    "pt": "Frontends",
    "t": 3,
    "c": "Possible options to provide in {!js} opts include:"
  },
  {
    "objectID": "/frontend/#p_180",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} decimals The number of digits to use after the decimal point when displaying the non-network token. The default is the same as the network token."
  },
  {
    "objectID": "/frontend/#p_181",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} supply The total number of atomic token units to create. The default is the maximum possible on the network."
  },
  {
    "objectID": "/frontend/#p_182",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} url A URL where more information about the non-network token can be retrieved. The default is no url."
  },
  {
    "objectID": "/frontend/#p_183",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} metadataHash A hash of some metadata that is relevant to your non-network token. The default is no metadata hash."
  },
  {
    "objectID": "/frontend/#p_184",
    "pt": "Frontends",
    "t": 3,
    "c": "Algorand-only options:"
  },
  {
    "objectID": "/frontend/#p_185",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} clawback Address that can clawback (steal) holdings of the token. The default is no clawback address."
  },
  {
    "objectID": "/frontend/#p_186",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} freeze Address that can freeze holdings of the token. The default is no freeze address."
  },
  {
    "objectID": "/frontend/#p_187",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} defaultFrozen A boolean that indicates whether token holdings are frozen by default. The default is {!js} false."
  },
  {
    "objectID": "/frontend/#p_188",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} reserve Address that should hold reserves of the token. The default is no reserve address."
  },
  {
    "objectID": "/frontend/#p_189",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} manager Address that can manage the configuration of the token and destroy it. The default is no manager address."
  },
  {
    "objectID": "/frontend/#p_190",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} note A {!js} Uint8Array for the Note field of the asset creation transaction. The default is no note."
  },
  {
    "objectID": "/frontend/#p_191",
    "pt": "Frontends",
    "t": 3,
    "c": "For more information on Algorand-only options, see https://developer.algorand.org/docs/get-details/transactions/transactions/#asset-parameters."
  },
  {
    "objectID": "/frontend/#p_192",
    "pt": "Frontends",
    "t": 3,
    "c": "The standard library provides a number of utilities functions for interacting with the connected network."
  },
  {
    "objectID": "/frontend/#p_193",
    "pt": "Frontends",
    "t": 3,
    "c": "Represents the {!js} Connector the {!js} stdlib uses."
  },
  {
    "objectID": "/frontend/#p_194",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise for the current consensus network time, represented as a BigNumber."
  },
  {
    "objectID": "/frontend/#p_195",
    "pt": "Frontends",
    "t": 3,
    "c": "This example obtains the starting time of the DApp by using {!js} getNetworkTime. The network time is then written to the console to provide the information to users. Then, it is converted to seconds using {!js} getTimeSecs, which is also written to the console."
  },
  {
    "objectID": "/frontend/#p_196",
    "pt": "Frontends",
    "t": 3,
    "c": "Like {!js} stdlib.getNetworkTime, but returns a network seconds Promise."
  },
  {
    "objectID": "/frontend/#p_197",
    "pt": "Frontends",
    "t": 3,
    "c": "Takes a network time, such as a value returned from {!js} stdlib.getNetworkTime, and converts it into network seconds."
  },
  {
    "objectID": "/frontend/#p_198",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise that will only be resolved after the specified consensus network time. In isolated testing modes, this will also force time to pass on the network, usually by sending trivial transactions. An isolated testing mode is a REACH_CONNECTOR_MODE that matches $NET-devnet for all valid $NET, or when REACH_ISOLATED_NETWORK is set."
  },
  {
    "objectID": "/frontend/#p_199",
    "pt": "Frontends",
    "t": 3,
    "c": "You may provide an optional {!js} onProgress callback, used for reporting progress, which may be called many times up until the specified network time. It will receive an object with keys {!js} current and {!js} target."
  },
  {
    "objectID": "/frontend/#p_200",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_201",
    "pt": "Frontends",
    "t": 3,
    "c": "The {!js} while statement in this code has an {!js} await that has the code wait the amount of time equal to moment by using {!js} waitUntilTime."
  },
  {
    "objectID": "/frontend/#p_202",
    "pt": "Frontends",
    "t": 3,
    "c": "Like {!js} stdlib.waitUntilTime, but waits for a certain network seconds deadline."
  },
  {
    "objectID": "/frontend/#p_203",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a Promise that will only be resolved after the specified time delta has elapsed. The expression {!js} await stdlib.wait(delta, onProgress) is the same as {!js} await stdlib.waitUntilTime(add(await stdlib.getNetworkTime(), delta), onProgress). As with {!js} stdlib.waitUntilTime, the {!js} onProgress callback is optional."
  },
  {
    "objectID": "/frontend/#p_204",
    "pt": "Frontends",
    "t": 3,
    "c": "One use case example of {!js} stdlib.wait is to emit an event and then call stdlib.wait(delta, onProgress) to ensure the event has time to complete. (In the example below, wt is shorthand for \"wait time\".)"
  },
  {
    "objectID": "/frontend/#p_205",
    "pt": "Frontends",
    "t": 3,
    "c": "Although, it is possible to use {!js} wait to give an event time to execute, it is a better practice to create an explicit synchronization with an event or instruct the deployer to communicate with API callers off-chain."
  },
  {
    "objectID": "/frontend/#p_206",
    "pt": "Frontends",
    "t": 3,
    "c": "Sets the maximum width of the query windows used to query the network for event logs. The value {!js} true indicates that no window size should be used, and queries may span arbitrarily large window sizes. While each connector has a default value that works for most common cases, tweaking this setting may be useful when dealing with layer two networks or custom endpoints that are more restrictive than normal nodes on the network."
  },
  {
    "objectID": "/frontend/#p_207",
    "pt": "Frontends",
    "t": 3,
    "c": "This function, which is available only on the Algorand connector, allows you to adjust the transaction parameters that Reach uses when it creates and signs transactions."
  },
  {
    "objectID": "/frontend/#p_208",
    "pt": "Frontends",
    "t": 3,
    "c": "It accepts a function that takes three arguments:"
  },
  {
    "objectID": "/frontend/#p_209",
    "pt": "Frontends",
    "t": 3,
    "c": "who: a {!js} T_Address value of the sender;"
  },
  {
    "objectID": "/frontend/#p_210",
    "pt": "Frontends",
    "t": 3,
    "c": "sra: an unstable and undocumented object that may help you identify the transaction being created;"
  },
  {
    "objectID": "/frontend/#p_211",
    "pt": "Frontends",
    "t": 3,
    "c": "params: the base Algorand transaction parameters."
  },
  {
    "objectID": "/frontend/#p_212",
    "pt": "Frontends",
    "t": 3,
    "c": "It must return a new Algorand transaction parameter object."
  },
  {
    "objectID": "/frontend/#p_213",
    "pt": "Frontends",
    "t": 3,
    "c": "This is mostly useful for using {!rsh} ALGO.blockSeed, so you can adjust the transaction validity, like in the example above."
  },
  {
    "objectID": "/frontend/#p_214",
    "pt": "Frontends",
    "t": 3,
    "c": "The standard library provides a number of utilities functions for interacting with JavaScript representations of Reach values."
  },
  {
    "objectID": "/frontend/#p_215",
    "pt": "Frontends",
    "t": 3,
    "c": "Asserts that value {!js} x has Reach type {!js} t. An exception is thrown if this is not the case."
  },
  {
    "objectID": "/frontend/#p_216",
    "pt": "Frontends",
    "t": 3,
    "c": "Each of these represent the corresponding Reach type."
  },
  {
    "objectID": "/frontend/#p_217",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a string representation for a given {!js} ReachType. This representation is consistent with the loaded connector's ABI. For example, on ALGO, {!js} stdlib.T_UInt.toString() returns 'uint64', but 'uint256' on ETH."
  },
  {
    "objectID": "/frontend/#p_218",
    "pt": "Frontends",
    "t": 3,
    "c": "Throws an exception if not given {!js} true."
  },
  {
    "objectID": "/frontend/#p_219",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_220",
    "pt": "Frontends",
    "t": 3,
    "c": "This code checks the arguments passed to the {!cmd} ./reach run command. Lines 6 and 7 will not throw an exception if {!cmd} ./reach run index hello \"Mr. Postman\" is run in the terminal, because {!js} process.argv will return the following array:"
  },
  {
    "objectID": "/frontend/#p_221",
    "pt": "Frontends",
    "t": 3,
    "c": "Thereby making {!js} process.argv[2] === 'Hello' and {!js} process.argv[3] === 'Mr. Postman' to evaluate to {!js} true."
  },
  {
    "objectID": "/frontend/#p_222",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns a new array identical to {!js} arr, except that index {!js} idx is {!js} val."
  },
  {
    "objectID": "/frontend/#p_223",
    "pt": "Frontends",
    "t": 3,
    "c": "bigNumberify converts a JavaScript number to a BigNumber, the JavaScript representation of Reach's {!rsh} UInt."
  },
  {
    "objectID": "/frontend/#p_224",
    "pt": "Frontends",
    "t": 3,
    "c": "isBigNumber checks if its input is a BigNumber."
  },
  {
    "objectID": "/frontend/#p_225",
    "pt": "Frontends",
    "t": 3,
    "c": "bigNumberToNumber transparently applies {!js} bigNumberify to its argument and returns a JavaScript number."
  },
  {
    "objectID": "/frontend/#p_226",
    "pt": "Frontends",
    "t": 3,
    "c": "bigNumberToBigInt transparently applies {!js} bigNumberify to its argument and returns a JavaScript bigint."
  },
  {
    "objectID": "/frontend/#p_227",
    "pt": "Frontends",
    "t": 3,
    "c": "These are additional conversion and comparison utilities."
  },
  {
    "objectID": "/frontend/#p_228",
    "pt": "Frontends",
    "t": 3,
    "c": "Hashes the values. If given one type and one value, the result is the same as if the arguments were each wrapped in an array."
  },
  {
    "objectID": "/frontend/#p_229",
    "pt": "Frontends",
    "t": 3,
    "c": "The ExampleeExampleeExampleeExamplee is a string of the Reach type that {!rsh} digest turns into a hash. The maximum string length that can be digested in this example is set to 32 bytes."
  },
  {
    "objectID": "/frontend/#p_230",
    "pt": "Frontends",
    "t": 3,
    "c": "Generates random bits as a {!rsh} UInt. The number of bits generated depends on the particular consensus network."
  },
  {
    "objectID": "/frontend/#p_231",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_232",
    "pt": "Frontends",
    "t": 3,
    "c": "This code is used to generate random bits as a {!rsh} UInt as the unique identifier of Alice stored as id on line 92. Line 93 reveals the id in the console and line 94 returns the id."
  },
  {
    "objectID": "/frontend/#p_233",
    "pt": "Frontends",
    "t": 3,
    "c": "hasRandom (Frontend) A value suitable for use as a participant interact interface requiring a random function, such as {!rsh} hasRandom. Reach does not natively support randomness and leaves random number generation to the frontend implementation. This value is provided out of convenience; it is not mandatory to use this implementation."
  },
  {
    "objectID": "/frontend/#p_234",
    "pt": "Frontends",
    "t": 3,
    "c": "hasConsoleLogger (Frontend) A value suitable for use as a participant interact interface requiring a log function, such as {!rsh} hasConsoleLogger. The {!js} log function provided takes an arbitrary amount of elements and prints them to stdout. This value is provided out of convenience; it is not mandatory to use this implementation."
  },
  {
    "objectID": "/frontend/#p_235",
    "pt": "Frontends",
    "t": 3,
    "c": "Parses a {!rsh} FixedPoint number into a JavaScript number."
  },
  {
    "objectID": "/frontend/#p_236",
    "pt": "Frontends",
    "t": 3,
    "c": "Parses a JavaScript number into a {!rsh} FixedPoint."
  },
  {
    "objectID": "/frontend/#p_237",
    "pt": "Frontends",
    "t": 3,
    "c": "Parses a signed {!rsh} Int into a JavaScript number."
  },
  {
    "objectID": "/frontend/#p_238",
    "pt": "Frontends",
    "t": 3,
    "c": "Parses a JavaScript number into an {!rsh} Int."
  },
  {
    "objectID": "/frontend/#p_239",
    "pt": "Frontends",
    "t": 3,
    "c": "Integer arithmetic on {!rsh} UInt."
  },
  {
    "objectID": "/frontend/#p_240",
    "pt": "Frontends",
    "t": 3,
    "c": "Integer comparisons on {!rsh} UInt."
  },
  {
    "objectID": "/frontend/#p_241",
    "pt": "Frontends",
    "t": 3,
    "c": "Converts the last 8 bytes of a string to an {!rsh} UInt."
  },
  {
    "objectID": "/frontend/#p_242",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_243",
    "pt": "Frontends",
    "t": 3,
    "c": "This code converts the last 8 bytes of b1, b2, b3 and b4 to an {!rsh} UInt on lines 22, 23, 24 and 25, respectively. After which, the {!js} mod method is called on the respective results."
  },
  {
    "objectID": "/frontend/#p_244",
    "pt": "Frontends",
    "t": 3,
    "c": "If the string is less than 8 bytes long, this function will convert the entire string to an {!rsh} UInt."
  },
  {
    "objectID": "/frontend/#p_245",
    "pt": "Frontends",
    "t": 3,
    "c": "The following exports are for dealing with network tokens."
  },
  {
    "objectID": "/frontend/#p_246",
    "pt": "Frontends",
    "t": 3,
    "c": "These functions handle amounts in a network's standard unit and its atomic unit. A standard unit is the network token unit most commonly associated with a network. For example, the standard unit of Ethereum is ETH. An atomic unit is the smallest unit of measure for the standard unit. For example, the atomic unit of Ethereum is WEI. An atomic unit is atomic, which means it cannot be divided into smaller units."
  },
  {
    "objectID": "/frontend/#p_247",
    "pt": "Frontends",
    "t": 3,
    "c": "Some consensus networks, typically those with proof-of-stake, have minimum balances on their accounts, so this is exposed as {!js} minimumBalance."
  },
  {
    "objectID": "/frontend/#p_248",
    "pt": "Frontends",
    "t": 3,
    "c": "Because there are 1,000,000,000,000,000,000 WEI in 1 ETH, BigNumber is used to represet values in WEI."
  },
  {
    "objectID": "/frontend/#p_249",
    "pt": "Frontends",
    "t": 3,
    "c": "Quantities of a network token should always be passed into Reach in the token's atomic unit."
  },
  {
    "objectID": "/frontend/#p_250",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} stdlib.bigNumberify is transparently applied to {!js} stdlib.formatCurrency's and {!js} stdlib.formatWithDecimals's first arguments."
  },
  {
    "objectID": "/frontend/#p_251",
    "pt": "Frontends",
    "t": 3,
    "c": "Formats the address in the way the user would expect to see it:"
  },
  {
    "objectID": "/frontend/#p_252",
    "pt": "Frontends",
    "t": 3,
    "c": "On Ethereum, it is a hex-encoded string starting with {!js} '0x'."
  },
  {
    "objectID": "/frontend/#p_253",
    "pt": "Frontends",
    "t": 3,
    "c": "On Algorand, it is a base32-encoded string, ending with the checksum."
  },
  {
    "objectID": "/frontend/#p_254",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_255",
    "pt": "Frontends",
    "t": 3,
    "c": "This code is a {!rsh} function that takes in addr on line 32. Line 33 formats addr based on the consensus network's encoding. On line 35, the formatted addr (now stored as address) is revealed to the user in the console."
  },
  {
    "objectID": "/frontend/#p_256",
    "pt": "Frontends",
    "t": 3,
    "c": "There is no corresponding {!js} parseAddress function because the user-friendly form is also accepted from the frontend in all places that Reach expects an address."
  },
  {
    "objectID": "/frontend/#p_257",
    "pt": "Frontends",
    "t": 3,
    "c": "The Reach JavaScript standard library provides the ask object for constructing console interfaces to your frontends."
  },
  {
    "objectID": "/frontend/#p_258",
    "pt": "Frontends",
    "t": 3,
    "c": "You do not need to use this module. It is simply provided as a convenience for when you are starting out testing and building simple DApps."
  },
  {
    "objectID": "/frontend/#p_259",
    "pt": "Frontends",
    "t": 3,
    "c": "It provides the following exports:"
  },
  {
    "objectID": "/frontend/#p_260",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} ask.ask is an asynchronous function that asks a question on the console and returns a Promise for the first result that its second argument does not error on."
  },
  {
    "objectID": "/frontend/#p_261",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} ask.yesno is an argument appropriate to give as the second argument to {!js} ask.ask that parses \"Yes\"/\"No\" answers."
  },
  {
    "objectID": "/frontend/#p_262",
    "pt": "Frontends",
    "t": 3,
    "c": "{!js} ask.done indicates that no more questions will be asked."
  },
  {
    "objectID": "/frontend/#p_263",
    "pt": "Frontends",
    "t": 3,
    "c": "Read the Interaction and Independence section the Rock, Paper, Scissors tutorial for a longer use case example of the {!js} ask object."
  },
  {
    "objectID": "/frontend/#p_264",
    "pt": "Frontends",
    "t": 3,
    "c": "The Reach JavaScript standard library provides the test object for constructing automated tests."
  },
  {
    "objectID": "/frontend/#p_265",
    "pt": "Frontends",
    "t": 3,
    "c": "You do not need to use this module. We think it is a great way to write tests, but it doesn't do anything you couldn't do on your own or with any other of the excellent JavaScript testing frameworks."
  },
  {
    "objectID": "/frontend/#p_266",
    "pt": "Frontends",
    "t": 3,
    "c": "On initialization, {!js} test will read the process's command-line arguments and interpret them as a list of tests to run. If no arguments are given, then all tests will be run."
  },
  {
    "objectID": "/frontend/#p_267",
    "pt": "Frontends",
    "t": 3,
    "c": "If you want to inspect this set of tests-to-run, then you can use the functions:"
  },
  {
    "objectID": "/frontend/#p_268",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns {!js} true if x is in the set of tests or if none were given."
  },
  {
    "objectID": "/frontend/#p_269",
    "pt": "Frontends",
    "t": 3,
    "c": "Returns {!js} true if x is in the set of tests."
  },
  {
    "objectID": "/frontend/#p_270",
    "pt": "Frontends",
    "t": 3,
    "c": "The main way to write tests is to call these functions:"
  },
  {
    "objectID": "/frontend/#p_271",
    "pt": "Frontends",
    "t": 3,
    "c": "Runs a check named id that does not fail if actual is the same as expected. Records additional information in the log from xtra."
  },
  {
    "objectID": "/frontend/#p_272",
    "pt": "Frontends",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/frontend/#p_273",
    "pt": "Frontends",
    "t": 3,
    "c": "In this code, the {!js} chk asserts that the unsigned integer i[1] is the same as bn(val)."
  },
  {
    "objectID": "/frontend/#p_274",
    "pt": "Frontends",
    "t": 3,
    "c": "Runs a check named id that expects f to throw an exception that satisfies the regex expected."
  },
  {
    "objectID": "/frontend/#p_275",
    "pt": "Frontends",
    "t": 3,
    "c": "Schedules a test named id which is run by calling f."
  },
  {
    "objectID": "/frontend/#p_276",
    "pt": "Frontends",
    "t": 3,
    "c": "This uses {!js} test.shouldRun to determine if the test should be run."
  },
  {
    "objectID": "/frontend/#p_277",
    "pt": "Frontends",
    "t": 3,
    "c": "Accepts a standard library object ({!js} stdlib) and a compiled backend (like given to {!js} acc.contract) and returns two objects:"
  },
  {
    "objectID": "/frontend/#p_278",
    "pt": "Frontends",
    "t": 3,
    "c": "exports --- The object containing all of the {!rsh} exported functions."
  },
  {
    "objectID": "/frontend/#p_279",
    "pt": "Frontends",
    "t": 3,
    "c": "chkExport --- A function to run tests on a particular function."
  },
  {
    "objectID": "/frontend/#p_280",
    "pt": "Frontends",
    "t": 3,
    "c": "chkExport takes two arguments:"
  },
  {
    "objectID": "/frontend/#p_281",
    "pt": "Frontends",
    "t": 3,
    "c": "fn --- The name of a function to test"
  },
  {
    "objectID": "/frontend/#p_282",
    "pt": "Frontends",
    "t": 3,
    "c": "go --- A function that accepts a customized version of {!js} test.chk and {!js} test.chkErr."
  },
  {
    "objectID": "/frontend/#p_283",
    "pt": "Frontends",
    "t": 3,
    "c": "These customized versions are referred to as:"
  },
  {
    "objectID": "/frontend/#p_284",
    "pt": "Frontends",
    "t": 3,
    "c": "chkf --- A function that accepts a domain and an expected range and ensures that the actual function result matches it."
  },
  {
    "objectID": "/frontend/#p_285",
    "pt": "Frontends",
    "t": 3,
    "c": "chkfErr --- A function that accepts an expected exception value and a domain and ensures that the actual function throws the exception."
  },
  {
    "objectID": "/frontend/#p_286",
    "pt": "Frontends",
    "t": 3,
    "c": "This function uses {!js} test.one internally."
  },
  {
    "objectID": "/frontend/#p_287",
    "pt": "Frontends",
    "t": 3,
    "c": "Runs any tests scheduled with {!js} test.one."
  },
  {
    "objectID": "/frontend/#p_288",
    "pt": "Frontends",
    "t": 3,
    "c": "opts.howManyAtOnce may be a number that determines how many tests to run in parallel. It defaults to {!js} 1."
  },
  {
    "objectID": "/frontend/#p_289",
    "pt": "Frontends",
    "t": 3,
    "c": "opts.exitOnFail may be a boolean that determines whether testing should end whenever the first test fails. It defaults to {!js} true."
  },
  {
    "objectID": "/frontend/#p_290",
    "pt": "Frontends",
    "t": 3,
    "c": "When testing is finished, the process will be exited with an error code signifying whether any tests failed."
  },
  {
    "objectID": "/frontend/#p_291",
    "pt": "Frontends",
    "t": 3,
    "c": "In addition, three lines will be outputed with the following format:"
  },
  {
    "objectID": "/frontend/#p_292",
    "pt": "Frontends",
    "t": 3,
    "c": "where"
  },
  {
    "objectID": "/frontend/#p_293",
    "pt": "Frontends",
    "t": 3,
    "c": "x is the base64 encoding of test results in the JUnit format as accepted by tools like CircleCI."
  },
  {
    "objectID": "/frontend/#p_294",
    "pt": "Frontends",
    "t": 3,
    "c": "y is a single line summary of how many tests failed"
  },
  {
    "objectID": "/frontend/#p_295",
    "pt": "Frontends",
    "t": 3,
    "c": "z is a six character prefix suitable for using with y."
  },
  {
    "objectID": "/frontend/#p_296",
    "pt": "Frontends",
    "t": 3,
    "c": "A convenient way to consume this output is with the following shell code:"
  },
  {
    "objectID": "/frontend/#p_297",
    "pt": "Frontends",
    "t": 3,
    "c": "We use this setup generate messages from CircleCI to Slack for continuous integration."
  },
  {
    "objectID": "/frontend/#p_298",
    "pt": "Frontends",
    "t": 3,
    "c": "opts.noVarOutput may be a boolean that determines whether this print out will NOT be generated. It defaults to {!js} false."
  },
  {
    "objectID": "/guide/#guide",
    "pt": "Guide",
    "t": 2,
    "c": "Guide"
  },
  {
    "objectID": "/guide/#p_0",
    "pt": "Guide",
    "t": 3,
    "c": "These guides discuss some key ideas and concepts used through Reach. They aim to teach the \"Why\" of aspects of some Reach features and discuss the many alternatives available to DApp developers. Indeed, many of these points are relevant to all DApp developers, because the problems appear in all applications."
  },
  {
    "objectID": "/guide/#p_1",
    "pt": "Guide",
    "t": 3,
    "c": "The following guides are available:"
  },
  {
    "objectID": "/rpc/#term_RPC%20methods",
    "pt": "RPC Server",
    "t": 1,
    "c": "RPC methods"
  },
  {
    "objectID": "/rpc/#ref-backends-rpc",
    "pt": "RPC Server",
    "t": 2,
    "c": "RPC Server"
  },
  {
    "objectID": "/rpc/#ref-rpc-method",
    "pt": "RPC Server",
    "t": 2,
    "c": "RPC Methods"
  },
  {
    "objectID": "/rpc/#ref-rpc-method-acc",
    "pt": "RPC Server",
    "t": 2,
    "c": "Account Methods"
  },
  {
    "objectID": "/rpc/#ref-rpc-method-ctc",
    "pt": "RPC Server",
    "t": 2,
    "c": "Contract Methods"
  },
  {
    "objectID": "/rpc/#ref-rpc-method-part",
    "pt": "RPC Server",
    "t": 2,
    "c": "Participant Methods"
  },
  {
    "objectID": "/rpc/#ref-rpc-method-backend",
    "pt": "RPC Server",
    "t": 2,
    "c": "Backend Methods"
  },
  {
    "objectID": "/rpc/#ref-backends-rpc-opts",
    "pt": "RPC Server",
    "t": 2,
    "c": "Reach RPC Client Standard Options"
  },
  {
    "objectID": "/rpc/#p_0",
    "pt": "RPC Server",
    "t": 3,
    "c": "The Reach RPC Server provides access to compiled JavaScript backends via an HTTPS-accessible JSON-based RPC protocol. The server allows frontends to be written in any programming language. Reach provides client libraries for C#, JavaScript, Python, and Go. It is easy to implement a client library yourself. An example frontend written using the Reach RPC Server is shown in the tutorial section on RPC-based frontends."
  },
  {
    "objectID": "/rpc/#p_1",
    "pt": "RPC Server",
    "t": 3,
    "c": "The command"
  },
  {
    "objectID": "/rpc/#p_2",
    "pt": "RPC Server",
    "t": 3,
    "c": "starts an instance of the Reach RPC Server."
  },
  {
    "objectID": "/rpc/#p_3",
    "pt": "RPC Server",
    "t": 3,
    "c": "The Reach RPC Server supports the following RPC methods:"
  },
  {
    "objectID": "/rpc/#p_4",
    "pt": "RPC Server",
    "t": 3,
    "c": "/health returns {!js} true to indicate the server is running properly."
  },
  {
    "objectID": "/rpc/#p_5",
    "pt": "RPC Server",
    "t": 3,
    "c": "/stdlib/$METHOD where $METHOD is a function of the JavaScript standard library."
  },
  {
    "objectID": "/rpc/#p_6",
    "pt": "RPC Server",
    "t": 3,
    "c": "All /stdlib methods are synchronous value RPC methods that accept and produce the same arguments and return values as the corresponding function, encoded as JSON objects, except those that produce or consume account representations."
  },
  {
    "objectID": "/rpc/#p_7",
    "pt": "RPC Server",
    "t": 3,
    "c": "Those methods instead accept and produce account RPC handles, which are random strings that represent the corresponding account representations. For example, /stdlib/newTestAccount does not return an account like {!js} newTestAccount, but instead returns an account RPC handle."
  },
  {
    "objectID": "/rpc/#p_8",
    "pt": "RPC Server",
    "t": 3,
    "c": "/forget/acc accepts an account RPC handle and deletes it from the Reach RPC Server's memory."
  },
  {
    "objectID": "/rpc/#p_9",
    "pt": "RPC Server",
    "t": 3,
    "c": "/acc/$METHOD where $METHOD is a method of an account representation of the JavaScript standard library."
  },
  {
    "objectID": "/rpc/#p_10",
    "pt": "RPC Server",
    "t": 3,
    "c": "All /acc methods are synchronous value RPC methods that accept and produce the same arguments and return values as the corresponding function, encoded as JSON objects, except they accept an additional first argument, which is the account RPC handle returned by a prior RPC method invocation; and, a method that accepts a backend (like /acc/attach (i.e. {!js} acc.attach) or /acc/deploy (i.e. {!js} acc.deploy) does not accept a backend argument, but has it implicitly provided by the Reach RPC Server."
  },
  {
    "objectID": "/rpc/#p_11",
    "pt": "RPC Server",
    "t": 3,
    "c": "Furthermore, those that produce contract representations instead produce contract RPC handles. For example, /acc/deploy does not return a contract representation like {!js} acc.deploy, but instead returns a contract RPC handle."
  },
  {
    "objectID": "/rpc/#p_12",
    "pt": "RPC Server",
    "t": 3,
    "c": "Most /ctc methods are synchronous value RPC methods that accept and produce the same arguments and return values as the corresponding function, encoded as JSON objects, except they accept an additional first argument, which is the contract RPC handle returned by a prior RPC method invocation."
  },
  {
    "objectID": "/rpc/#p_13",
    "pt": "RPC Server",
    "t": 3,
    "c": "/ctc/$METHOD where $METHOD is a method of a contract representation of the JavaScript standard library."
  },
  {
    "objectID": "/rpc/#p_14",
    "pt": "RPC Server",
    "t": 3,
    "c": "/ctc methods can access {!js} ctc.views, {!js} ctc.apis, and {!js} ctc.events. Similar to standard library functions, the full name or first letter can be used when calling the following methods."
  },
  {
    "objectID": "/rpc/#p_15",
    "pt": "RPC Server",
    "t": 3,
    "c": "/ctc/v and /ctc/views provide access to {!rsh} Views."
  },
  {
    "objectID": "/rpc/#p_16",
    "pt": "RPC Server",
    "t": 3,
    "c": "/ctc/a and /ctc/apis make {!rsh} API functions available to the frontend."
  },
  {
    "objectID": "/rpc/#p_17",
    "pt": "RPC Server",
    "t": 3,
    "c": "/ctc/e and /ctc/events provide access to {!rsh} Events."
  },
  {
    "objectID": "/rpc/#p_18",
    "pt": "RPC Server",
    "t": 3,
    "c": "{!rsh} View, {!rsh} API and {!rsh} Events may be accessed with the following syntax:"
  },
  {
    "objectID": "/rpc/#p_19",
    "pt": "RPC Server",
    "t": 3,
    "c": "For example:"
  },
  {
    "objectID": "/rpc/#p_20",
    "pt": "RPC Server",
    "t": 3,
    "c": "Below, in line 45, getRead accesses a {!rsh} View named Reader from the attached contract handle stored in const c."
  },
  {
    "objectID": "/rpc/#p_21",
    "pt": "RPC Server",
    "t": 3,
    "c": "Further into the same file, RPC is used to access the attached Writer {!rsh} API and its arguments."
  },
  {
    "objectID": "/rpc/#p_22",
    "pt": "RPC Server",
    "t": 3,
    "c": "By providing access to {!rsh} Views, {!rsh} APIs, and {!rsh} Events, RPC /ctc methods allow developers to build complete frontend Reach applications in the language of their choice."
  },
  {
    "objectID": "/rpc/#p_23",
    "pt": "RPC Server",
    "t": 3,
    "c": "/forget/ctc accepts a contract RPC handle and deletes it from the Reach RPC Server's memory."
  },
  {
    "objectID": "/rpc/#p_24",
    "pt": "RPC Server",
    "t": 3,
    "c": "/ctc/p/$PARTICIPANT and /ctc/participants/$PARTICIPANT are interactive RPC method alternatives to the /backend/$PARTICIPANT method described below. They accept the same arguments and behave identically."
  },
  {
    "objectID": "/rpc/#p_25",
    "pt": "RPC Server",
    "t": 3,
    "c": "/forget/token accepts a token RPC handle and deletes it from the Reach RPC Server's memory."
  },
  {
    "objectID": "/rpc/#p_26",
    "pt": "RPC Server",
    "t": 3,
    "c": "/backend/$PARTICIPANT where $PARTICIPANT is a participant of the backend compiled by the JavaScript backend."
  },
  {
    "objectID": "/rpc/#p_27",
    "pt": "RPC Server",
    "t": 3,
    "c": "All /backend/$PARTICIPANT methods are interactive RPC methods that accept three arguments:"
  },
  {
    "objectID": "/rpc/#p_28",
    "pt": "RPC Server",
    "t": 3,
    "c": "ctcId --- A contract RPC handle to provide as the contract to the backend"
  },
  {
    "objectID": "/rpc/#p_29",
    "pt": "RPC Server",
    "t": 3,
    "c": "values --- An object containing the non-function components of the participant interact interface of the backend."
  },
  {
    "objectID": "/rpc/#p_30",
    "pt": "RPC Server",
    "t": 3,
    "c": "methods --- An object whose keys correspond to the function components of the participant interact interface of the backend, but whose values are {!js} true."
  },
  {
    "objectID": "/rpc/#p_31",
    "pt": "RPC Server",
    "t": 3,
    "c": "As a special case, if values contains stdlib.hasRandom bound to {!js} true, then the JavaScript standard library's implementation of {!js} hasRandom is provided to the backend."
  },
  {
    "objectID": "/rpc/#p_32",
    "pt": "RPC Server",
    "t": 3,
    "c": "As the backend executes, any of the components of methods invoked will be executed as interactive RPC callbacks as described by the Reach RPC Protocol Specification. Reach RPC Client libraries should expose a function that hides the details of the construction of the values and methods objects and implements interactive RPC callback handlers automatically."
  },
  {
    "objectID": "/rpc/#p_33",
    "pt": "RPC Server",
    "t": 3,
    "c": "/backend/getExports/$EXPORT_NAME where $EXPORT_NAME is an export of the backend compiled by the JavaScript backend."
  },
  {
    "objectID": "/rpc/#p_34",
    "pt": "RPC Server",
    "t": 3,
    "c": "Any Reach module exports, including functions, may be accessed via this method. Field accessors and zero-indexed array references support arbitrarily deep nesting."
  },
  {
    "objectID": "/rpc/#p_35",
    "pt": "RPC Server",
    "t": 3,
    "c": "For example:"
  },
  {
    "objectID": "/rpc/#p_36",
    "pt": "RPC Server",
    "t": 3,
    "c": "Requests for non-existent exports and non-existent nested fields or elements always return null."
  },
  {
    "objectID": "/rpc/#p_37",
    "pt": "RPC Server",
    "t": 3,
    "c": "/kont handles interactive RPC continuation completion during an interactive RPC method. It should not be invoked directly by frontends."
  },
  {
    "objectID": "/rpc/#p_38",
    "pt": "RPC Server",
    "t": 3,
    "c": "/stop quits the server."
  },
  {
    "objectID": "/rpc/#p_39",
    "pt": "RPC Server",
    "t": 3,
    "c": "Reach RPC client libraries must accept a dictionary data structure with the following keys for customizing their behavior:"
  },
  {
    "objectID": "/rpc/#p_40",
    "pt": "RPC Server",
    "t": 3,
    "c": "host --- This value sets the hostname to contact for the Reach RPC Server instance. If it is not present, the client library must default to the value of the environment variable REACH_RPC_SERVER."
  },
  {
    "objectID": "/rpc/#p_41",
    "pt": "RPC Server",
    "t": 3,
    "c": "port --- This value sets the TCP port to contact for the Reach RPC Server instance. If it is not present, the client library must default to the value of the environment variable REACH_RPC_PORT."
  },
  {
    "objectID": "/rpc/#p_42",
    "pt": "RPC Server",
    "t": 3,
    "c": "verify --- This value determines whether to verify the TLS certificate of the Reach RPC Server instance. If it is not present, the client library must default to the value of the environment variable REACH_RPC_TLS_REJECT_UNVERIFIED. If that is not present, it must default to true."
  },
  {
    "objectID": "/rpc/#p_43",
    "pt": "RPC Server",
    "t": 3,
    "c": "To disable verification, set this value to the string: \"0\"; any other value will be considered to mean \"enable\"."
  },
  {
    "objectID": "/rpc/#p_44",
    "pt": "RPC Server",
    "t": 3,
    "c": "timeout --- This value sets the number of seconds to wait for the Reach RPC Server instance to respond to its first request. If it is not present, the client library must default to the value of the environment variable REACH_RPC_TIMEOUT. If that is not present, it must default to 5 seconds."
  },
  {
    "objectID": "/rpc/#p_45",
    "pt": "RPC Server",
    "t": 3,
    "c": "key --- This value sets the API key for the Reach RPC Server instance. If it is not present, the client library must default to the value of the environment variable REACH_RPC_KEY."
  },
  {
    "objectID": "/workshop/#workshop",
    "pt": "Workshop",
    "t": 2,
    "c": "Workshop"
  },
  {
    "objectID": "/workshop/#workshop-rps-fair",
    "pt": "Workshop",
    "t": 2,
    "c": "Fair Rock-Paper-Scissors"
  },
  {
    "objectID": "/workshop/#workshop-rps-eff",
    "pt": "Workshop",
    "t": 2,
    "c": "Efficient Rock-Paper-Scissors"
  },
  {
    "objectID": "/workshop/#workshop-rental",
    "pt": "Workshop",
    "t": 2,
    "c": "Rental Agreement"
  },
  {
    "objectID": "/workshop/#workshop-abstract-simul",
    "pt": "Workshop",
    "t": 2,
    "c": "Simultaneous Games"
  },
  {
    "objectID": "/workshop/#workshop-guardian-account",
    "pt": "Workshop",
    "t": 2,
    "c": "Guardian Account"
  },
  {
    "objectID": "/workshop/#workshop-utility",
    "pt": "Workshop",
    "t": 2,
    "c": "Periodic Payment"
  },
  {
    "objectID": "/workshop/#workshop-nim",
    "pt": "Workshop",
    "t": 2,
    "c": "Nim"
  },
  {
    "objectID": "/workshop/#workshop-ttt",
    "pt": "Workshop",
    "t": 2,
    "c": "Tic-Tac-Toe"
  },
  {
    "objectID": "/workshop/#workshop-secured-loan",
    "pt": "Workshop",
    "t": 2,
    "c": "Secured Loan"
  },
  {
    "objectID": "/workshop/#workshop-atomic-swap",
    "pt": "Workshop",
    "t": 2,
    "c": "Atomic Swap"
  },
  {
    "objectID": "/workshop/#workshop-atomic-swap-auction",
    "pt": "Workshop",
    "t": 2,
    "c": "Atomic Swap Auction"
  },
  {
    "objectID": "/workshop/#workshop-race",
    "pt": "Workshop",
    "t": 2,
    "c": "Race"
  },
  {
    "objectID": "/workshop/#workshop-chicken-race",
    "pt": "Workshop",
    "t": 2,
    "c": "Chicken"
  },
  {
    "objectID": "/workshop/#workshop-popularity-contest",
    "pt": "Workshop",
    "t": 2,
    "c": "Popularity Contest"
  },
  {
    "objectID": "/workshop/#workshop-nft-dumb",
    "pt": "Workshop",
    "t": 2,
    "c": "Simple NFT"
  },
  {
    "objectID": "/workshop/#workshop-nft-auction",
    "pt": "Workshop",
    "t": 2,
    "c": "NFT with Auction"
  },
  {
    "objectID": "/workshop/#workshop-nft-tax",
    "pt": "Workshop",
    "t": 2,
    "c": "NFT with Royalties and Harberger Tax"
  },
  {
    "objectID": "/workshop/#workshop-raffle",
    "pt": "Workshop",
    "t": 2,
    "c": "Raffle"
  },
  {
    "objectID": "/workshop/#workshop-rent-seeking",
    "pt": "Workshop",
    "t": 2,
    "c": "Rent Seeking"
  },
  {
    "objectID": "/workshop/#workshop-remote",
    "pt": "Workshop",
    "t": 2,
    "c": "Remote Objects"
  },
  {
    "objectID": "/workshop/#workshop-oracle",
    "pt": "Workshop",
    "t": 2,
    "c": "Oracle"
  },
  {
    "objectID": "/workshop/#workshop-auction-te",
    "pt": "Workshop",
    "t": 2,
    "c": "Timed English Auction"
  },
  {
    "objectID": "/workshop/#workshop-crowdfund",
    "pt": "Workshop",
    "t": 2,
    "c": "Crowd-funding"
  },
  {
    "objectID": "/workshop/#p_0",
    "pt": "Workshop",
    "t": 3,
    "c": "The workshop is a collection of self-study projects to help you on your way to mastery building decentralized applications through practice by building specific projects in Reach. It is designed to help direct you along the path of learning effective use of Reach and points out for you some of the design decisions that Reach programmers often make."
  },
  {
    "objectID": "/workshop/#p_1",
    "pt": "Workshop",
    "t": 3,
    "c": "Unlike the tutorial, it is not meant for you just to copy code and see what appears; instead, you're meant to work on your own to build a project yourself. This way, you'll learn more and slowly be able to build your own project using Reach."
  },
  {
    "objectID": "/workshop/#p_2",
    "pt": "Workshop",
    "t": 3,
    "c": "At the end of every project, we'll always show a \"final\" version with commentary about why we implemented it the way that we did."
  },
  {
    "objectID": "/workshop/#p_3",
    "pt": "Workshop",
    "t": 3,
    "c": "We would love your feedback on any project, especially the parts that you struggled the most with. This will help us improve the language, our developer tools, and the project materials. The best way is through the GitHub issue tracker or by messaging @team in the Discord community."
  },
  {
    "objectID": "/workshop/#p_4",
    "pt": "Workshop",
    "t": 3,
    "c": "We highly recommend going through the overview and the tutorial before continuing through the workshop. However, you can do most workshops in any order. If there's a pre-requisite, it will be explicitly mentioned."
  },
  {
    "objectID": "/workshop/#p_5",
    "pt": "Workshop",
    "t": 3,
    "c": "Here are the current workshops, in the order we recommend doing them:"
  },
  {
    "objectID": "/workshop/#p_6",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Rock, Paper, Scissors!."
  },
  {
    "objectID": "/workshop/#p_7",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we observe that the tutorial's version of Rock, Paper, Scissors! is unfair in that Alice is responsible for more steps than Bob. On most consensus networks, each action is charged a fee to run, so this means that Alice pays more than Bob for the game to be played. How could you revise the application to make it fair, without requiring a change to the frontend?"
  },
  {
    "objectID": "/workshop/#p_8",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above!"
  },
  {
    "objectID": "/workshop/#p_9",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Fair Rock-Paper-Scissors."
  },
  {
    "objectID": "/workshop/#p_10",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we study how transaction costs on consensus networks can be understood as the constants hidden by asymptotic notations when determining the expense of an algorithm when run on a decentralized application. In typical programming contexts, an algorithm that uses 3 log_2 n + 4 n operations is considered equivalent to an algorithm that uses 5 log_4 n + 22 n operations, because constants and bases are ignored in asymptoptic analysis. However, imagine that a program used n local computations and m consensus computations. We'll call n the \"computations\" and m the \"communications\". In this case, the computations are free from the perspective of the consensus network, because they don't cost network tokens, while the communications cost their price in gas, plus the fee to run them. Therefore, it is often economically efficient to increase n so that m can be smaller."
  },
  {
    "objectID": "/workshop/#p_11",
    "pt": "Workshop",
    "t": 3,
    "c": "For example, in the context of the tutorial's version of Rock, Paper, Scissors!, the application uses 2 + 3r communications for a game with r rounds. This is because it takes two communications to set up the loop, then each round of the loop takes three communications. We could make a more complicated version of the application that is optimized in two ways."
  },
  {
    "objectID": "/workshop/#p_12",
    "pt": "Workshop",
    "t": 3,
    "c": "First, we could optimize for the common case of when there is no draw and bundle a hand into the opening messages, and use 3 + 3(r - 1) = 3r communications for r rounds, for a saving of two communications. This would slightly increase the complexity of our program by duplicating the submission of hands, but we could easily abstract this into a Reach function."
  },
  {
    "objectID": "/workshop/#p_13",
    "pt": "Workshop",
    "t": 3,
    "c": "Second, we could bundle k hands into each communication, so that the number of communications is 3(r//k) for r rounds for a reduction of communications by k times. This is possible through Reach's ability to deal with array values. The exact value of k would be chosen empirically based on the relative difference in cost between increased message sizes and computations versus the fixed cost of having any transaction at all on the consensus network. Reach's ability to abstract away the details of communication patterns allows us to write this program abstractly and only specify the value of k as a compile-time parameter."
  },
  {
    "objectID": "/workshop/#p_14",
    "pt": "Workshop",
    "t": 3,
    "c": "This is a general strategy that is regularly employed in efficient decentralized applications: although a textbook algorithm might say to use a setup phase and many round trips as you divide a space in half each time, it might be vastly more efficient on an actual network to apply meaning-preserving transformations like merging the setup into the loop and dividing the space by a much larger constant, like one hundred."
  },
  {
    "objectID": "/workshop/#p_15",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above!"
  },
  {
    "objectID": "/workshop/#p_16",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Rock, Paper, Scissors!."
  },
  {
    "objectID": "/workshop/#p_17",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we consider a scenario where Alice and Bob are engaged in an indefinite rental agreement where they both made a security deposit to be given to whomever leaves the arrangement first. At some regular interval, both participants submit whether they would like to Stay or Leave. If they both decide to Stay, then they wait for the next round. If they both decide to Leave, then they both get back their deposit. But if only one wants to Leave, then both deposits go to the participant that wants to Stay, based on the assumption that they are harmed by being surprised at the change in circumstances in the next interval."
  },
  {
    "objectID": "/workshop/#p_18",
    "pt": "Workshop",
    "t": 3,
    "c": "This scenario demonstrates the value of decentralization, because in traditional institutions, one party is typically empowered as always dictating the decision to the other who must take it, as is the case for most landlords; or, the two parties must play \"chicken\" with each other to see who will flinch first, as is often the case in divorces; or, the two parties must pay a third-party to act as the arbitrator."
  },
  {
    "objectID": "/workshop/#p_19",
    "pt": "Workshop",
    "t": 3,
    "c": "It turns out that this scenario is structurally identical to Rock, Paper, Scissors!, except with different \"hands\" and a different pay-out structure."
  },
  {
    "objectID": "/workshop/#p_20",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/rental."
  },
  {
    "objectID": "/workshop/#p_21",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Rental Agreement."
  },
  {
    "objectID": "/workshop/#p_22",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we generalize from the tutorial and the rental workshop to build an abstract library that models any game with simultaneous play. This shows the power of Reach's ability to construct and reason about communication abstractions."
  },
  {
    "objectID": "/workshop/#p_23",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/abstract-simul."
  },
  {
    "objectID": "/workshop/#p_24",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Trust Fund."
  },
  {
    "objectID": "/workshop/#p_25",
    "pt": "Workshop",
    "t": 3,
    "c": "In Trust Fund, we developed an application where the entire contents of a trust fund devolve to the receipient after a certain time. In this workshop, we revisit this problem and instead allow portions of the funds to be removed by the funder at her discretion. This is like a \"multi-signature wallet\", where one account originates the funds and approves transactions, while another account solely spends those funds. It might be used to give a child an \"allowance\" from their trust fund. It could be modified to allow the funder to add funds over time if the fund runs low. This is the first workshop on the \"transfer funds\" track that introduces {!rsh} while statements."
  },
  {
    "objectID": "/workshop/#p_26",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/multisig."
  },
  {
    "objectID": "/workshop/#p_27",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Guardian Account."
  },
  {
    "objectID": "/workshop/#p_28",
    "pt": "Workshop",
    "t": 3,
    "c": "In Guardian Account, we developed an application where a funder has discretion over the disbursement on portions of a pre-funded account. In this workshop, we modify this application so that the funder has no discretion and automatically approves transfers out, but the receiver is restricted to only asking for a certain amount at a time and at a particular interval. This could be used to make a periodic payment to a utility company, for example."
  },
  {
    "objectID": "/workshop/#p_29",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above!"
  },
  {
    "objectID": "/workshop/#p_30",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Rock, Paper, Scissors!."
  },
  {
    "objectID": "/workshop/#p_31",
    "pt": "Workshop",
    "t": 3,
    "c": "In the tutorial, we built a version of Rock, Paper, Scissors! where two parties can wager over the results of the game. This application has an interesting communication pattern with information hiding through cryptographic commitments, but the application logic is simple and uninteresting. In this workshop, we implement a version of Nim, where the communication structure is simpler, since it is a combinatorial game, but has a more interesting application logic. Thus, this workshop demonstrates using more interesting data-structures in Reach programs, as well as using compile-time abstractions to simplify DApp structure."
  },
  {
    "objectID": "/workshop/#p_32",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/nim."
  },
  {
    "objectID": "/workshop/#p_33",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Nim."
  },
  {
    "objectID": "/workshop/#p_34",
    "pt": "Workshop",
    "t": 3,
    "c": "Like Nim, this workshop develops an implementation of the combinatorial game, Tic-tac-toe. This workshop demonstrates the use of arrays and more advanced Reach data-structures. We'll discuss two variations of this same application: one where the consensus network verifies the moves of each player; and, another where the consensus network allows illegal moves to be disputed by the other player. These variations demonstrate two DApp patterns that occur commonly in existing DApp designs, each with different usage constraints and performance trade-offs."
  },
  {
    "objectID": "/workshop/#p_35",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/ttt."
  },
  {
    "objectID": "/workshop/#p_36",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Trust Fund."
  },
  {
    "objectID": "/workshop/#p_37",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we implement a secured loan, wherein a Borrower posts collateral and terms to the public, and an arbitrary Lender gives a loan, then after some maturity, the Borrower either repays the loan, plus interest, or sacrifices the collateral. It is easy to model this scenario using only network tokens, but it would be useless, because the premise of a loan is that the participants believe the Borrower can make better use of the funds than the Lender. However, many consensus networks also support custom fungible assets that are like tokens. If this is the case, then a secured loan will typically have different assets as the loan amount and the collateral amount. Thus, the interest rate for the loan is essentially the Lender's prediction of the movement of the exchange rate between the two currencies over the lifetime of the loan. In this workshop, the Borrower pledges non-network tokens as collateral for the loan."
  },
  {
    "objectID": "/workshop/#p_38",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/secured-loan."
  },
  {
    "objectID": "/workshop/#p_39",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Rock, Paper, Scissors!."
  },
  {
    "objectID": "/workshop/#p_40",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we implement an atomic swap, or sell order, wherein a Seller offers an amount of an asset, X of A, in exchange for a prescribed amount of another asset, Y of B, and waits for a Buyer to complete the other side of the trade. This workshop demonstrates the use of non-network tokens."
  },
  {
    "objectID": "/workshop/#p_41",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/atomic-swap."
  },
  {
    "objectID": "/workshop/#p_42",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Atomic Swap."
  },
  {
    "objectID": "/workshop/#p_43",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we extend the Atomic Swap workshop by allowing the Seller to solicit bids for their X of A in a prescribed asset B and accept whichever buyer is willing to provide the most before a preset time."
  },
  {
    "objectID": "/workshop/#p_44",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/atomic-swap-auction."
  },
  {
    "objectID": "/workshop/#p_45",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Rock, Paper, Scissors!."
  },
  {
    "objectID": "/workshop/#p_46",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we implement the example of the {!rsh} race expression discussed in the guide section on races. This provides an introduction to races, as well as a cautionary tale on their danger."
  },
  {
    "objectID": "/workshop/#p_47",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/race."
  },
  {
    "objectID": "/workshop/#p_48",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Race."
  },
  {
    "objectID": "/workshop/#p_49",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we implement a game of Chicken, where each player submits an equal wager, and then competes with the other to submit more transactions to the consensus before a deadline. In other words, they must decide between the risk of losing the entire pot and the risk of overspending on transaction costs. Like Race, this demonstrates the deadweight losses associated with {!rsh} races, as discussed in the guide section on races."
  },
  {
    "objectID": "/workshop/#p_50",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/chicken-race."
  },
  {
    "objectID": "/workshop/#p_51",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Chicken."
  },
  {
    "objectID": "/workshop/#p_52",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we implement a two-party winner-takes-all vote, where a pollster proposes two candidates---Alice and Bob---along with a voting price and a deadline, then a participant class of voters each pay and cast their ballot. Once the deadline passes, the winning candidate takes the entire pot. This workshop introduces effective use of participant classes and {!rsh} parallelReduce."
  },
  {
    "objectID": "/workshop/#p_53",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/popularity-contest."
  },
  {
    "objectID": "/workshop/#p_54",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Race."
  },
  {
    "objectID": "/workshop/#p_55",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we implement a trivial non-fungible token (NFT) where a single creator creates a unique item and initial owns it. The creator and all subsequent owners may transfer ownership of the unique item to a different owner and so on. This workshop uses a participant class to represent owners and is a kind of trivial template before we explore more interesting and in-depth variants of the NFT concept."
  },
  {
    "objectID": "/workshop/#p_56",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/nft-dumb."
  },
  {
    "objectID": "/workshop/#p_57",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Simple NFT."
  },
  {
    "objectID": "/workshop/#p_58",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we extend Simple NFT by adding an auction when the current owner is ready to sell their NFT. This could be extended to give creators (or royalty rights holders) a percentage of the auction yield."
  },
  {
    "objectID": "/workshop/#p_59",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/nft-auction."
  },
  {
    "objectID": "/workshop/#p_60",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Simple NFT."
  },
  {
    "objectID": "/workshop/#p_61",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we extend Simple NFT by incorporating a Harberger Tax (c.f. Arnold Harberger) where owners must state a price at which they are willing to part with the asset and pay a percentage of that price to the creator. They can update this price upwards by paying an additional tax, or decrease it without cost (to free themselves of the asset). This represents an interesting place in the NFT design space where utility increasing transfers are immediate and creators receive royalties."
  },
  {
    "objectID": "/workshop/#p_62",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Popularity Contest."
  },
  {
    "objectID": "/workshop/#p_63",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we implement a raffle, where a sponsor starts a timed raffle and a participant class of ticket buyers each buy tickets. This workshop contains two interesting ideas: first, it uses linear state through the {!rsh} Map structure; second, it uses a commitment pattern structure to acquire safe randomness from the set of buyers."
  },
  {
    "objectID": "/workshop/#p_64",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/raffle."
  },
  {
    "objectID": "/workshop/#p_65",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Raffle."
  },
  {
    "objectID": "/workshop/#p_66",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we implement a rent-seeking competition, where a sponsor attempts to sell a prize (e.g. 10 ETH) and a number of bidders seek to acquire the prize by bidding for it (e.g. 5 ETH). Unlike a \"normal\" auction, however, the bidders lose the money they bid to the sponsor. Thus, while the winner may get more than the bid, and the sponsor may get more than they give away, there is a net transfer away from the bidders to the sponsor. This program also uses linear state."
  },
  {
    "objectID": "/workshop/#p_67",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/rent-seeking."
  },
  {
    "objectID": "/workshop/#p_68",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Rock, Paper, Scissors!."
  },
  {
    "objectID": "/workshop/#p_69",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we demonstrate interaction with a remote object implemented externally to Reach. Rather than connect to an existing contract, this example includes testing code to launch a bespoke contract simply to demonstrate how remote interactions can occur. It may be representative of a DApp that is implemented simultaneously in Reach and the low-level language of the chosen consensus network, in this case Solidity."
  },
  {
    "objectID": "/workshop/#p_70",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above! If you'd like to see a draft version of our code, please visit examples/remote."
  },
  {
    "objectID": "/workshop/#p_71",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Rock, Paper, Scissors!."
  },
  {
    "objectID": "/workshop/#p_72",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we implement a centralized oracle for some property not otherwise computable within a Reach program. Typically oracles are used to connect physical data from outside a consensus network to the agents of the network, such as by reading physical sensors, like a thermometer, and posting the information inside the network."
  },
  {
    "objectID": "/workshop/#p_73",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above!"
  },
  {
    "objectID": "/workshop/#p_74",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Rock, Paper, Scissors!."
  },
  {
    "objectID": "/workshop/#p_75",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we implement a timed English auction wherein a Seller auctions off the right for a Bidder to decide the argument to call a certain external contract method with. This demonstrates the use of collective operations in Reach with finite state."
  },
  {
    "objectID": "/workshop/#p_76",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above!"
  },
  {
    "objectID": "/workshop/#p_77",
    "pt": "Workshop",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Timed English Auction."
  },
  {
    "objectID": "/workshop/#p_78",
    "pt": "Workshop",
    "t": 3,
    "c": "In this workshop, we implement a crowdfunding campaign wherein a Fundraiser requests a funding amount, which is provided by Donors if a reserve is reached before the funding window closes, after which it is either disbursed to the Fundraiser, or returned to the Donors."
  },
  {
    "objectID": "/workshop/#p_79",
    "pt": "Workshop",
    "t": 3,
    "c": "This page is a placeholder for a future more detailed workshop. You could try to implement it yourself though, given the sketch above!"
  },
  {
    "objectID": "/rsh/appinit/#rsh_init",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "init"
  },
  {
    "objectID": "/rsh/appinit/#rsh_deploy",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "deploy"
  },
  {
    "objectID": "/rsh/appinit/#rsh_setOptions",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "setOptions"
  },
  {
    "objectID": "/rsh/appinit/#rsh_verifyArithmetic",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "verifyArithmetic"
  },
  {
    "objectID": "/rsh/appinit/#rsh_verifyPerConnector",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "verifyPerConnector"
  },
  {
    "objectID": "/rsh/appinit/#rsh_connectors",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "connectors"
  },
  {
    "objectID": "/rsh/appinit/#rsh_ETH",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "ETH"
  },
  {
    "objectID": "/rsh/appinit/#rsh_ALGO",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "ALGO"
  },
  {
    "objectID": "/rsh/appinit/#rsh_autoTrackPublishedTokens",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "autoTrackPublishedTokens"
  },
  {
    "objectID": "/rsh/appinit/#rsh_ALGOExitMode",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "ALGOExitMode"
  },
  {
    "objectID": "/rsh/appinit/#rsh_Participant",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "Participant"
  },
  {
    "objectID": "/rsh/appinit/#rsh_ParticipantClass",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "ParticipantClass"
  },
  {
    "objectID": "/rsh/appinit/#rsh_API",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "API"
  },
  {
    "objectID": "/rsh/appinit/#rsh_View",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "View"
  },
  {
    "objectID": "/rsh/appinit/#rsh_Events",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "Events"
  },
  {
    "objectID": "/rsh/appinit/#rsh_ContractCode",
    "pt": "Application Initialization",
    "t": 0,
    "s": "rsh",
    "c": "ContractCode"
  },
  {
    "objectID": "/rsh/appinit/#term_application%20initialization",
    "pt": "Application Initialization",
    "t": 1,
    "c": "application initialization"
  },
  {
    "objectID": "/rsh/appinit/#term_init%20statement",
    "pt": "Application Initialization",
    "t": 1,
    "c": "init statement"
  },
  {
    "objectID": "/rsh/appinit/#term_compilation%20options",
    "pt": "Application Initialization",
    "t": 1,
    "c": "compilation options"
  },
  {
    "objectID": "/rsh/appinit/#term_participant%20interact%20interface",
    "pt": "Application Initialization",
    "t": 1,
    "c": "participant interact interface"
  },
  {
    "objectID": "/rsh/appinit/#term_function%20alias",
    "pt": "Application Initialization",
    "t": 1,
    "c": "function alias"
  },
  {
    "objectID": "/rsh/appinit/#term_API%20member%20function",
    "pt": "Application Initialization",
    "t": 1,
    "c": "API member function"
  },
  {
    "objectID": "/rsh/appinit/#ref-programs-appinit",
    "pt": "Application Initialization",
    "t": 2,
    "c": "Application Initialization"
  },
  {
    "objectID": "/rsh/appinit/#ref-programs-appinit-stmts",
    "pt": "Application Initialization",
    "t": 2,
    "c": "Statements"
  },
  {
    "objectID": "/rsh/appinit/#init",
    "pt": "Application Initialization",
    "t": 2,
    "c": "init"
  },
  {
    "objectID": "/rsh/appinit/#setoptions",
    "pt": "Application Initialization",
    "t": 2,
    "c": "setOptions"
  },
  {
    "objectID": "/rsh/appinit/#ref-programs-appinit-exprs",
    "pt": "Application Initialization",
    "t": 2,
    "c": "Expressions"
  },
  {
    "objectID": "/rsh/appinit/#participant-definition",
    "pt": "Application Initialization",
    "t": 2,
    "c": "Participant Definition"
  },
  {
    "objectID": "/rsh/appinit/#ref-programs-appinit-api",
    "pt": "Application Initialization",
    "t": 2,
    "c": "API Definition"
  },
  {
    "objectID": "/rsh/appinit/#ref-programs-appinit-view",
    "pt": "Application Initialization",
    "t": 2,
    "c": "View Definition"
  },
  {
    "objectID": "/rsh/appinit/#ref-programs-appinit-events",
    "pt": "Application Initialization",
    "t": 2,
    "c": "Events Definition"
  },
  {
    "objectID": "/rsh/appinit/#ref-programs-appinit-contractcode",
    "pt": "Application Initialization",
    "t": 2,
    "c": "Contract code definition"
  },
  {
    "objectID": "/rsh/appinit/#p_0",
    "pt": "Application Initialization",
    "t": 3,
    "c": "The body of {!rsh} Reach.app is an application initialization. It defines the various participants and views of the DApp, as well as sets compilation options. It is finalized with {!rsh} init() and then the application begins in a step."
  },
  {
    "objectID": "/rsh/appinit/#p_1",
    "pt": "Application Initialization",
    "t": 3,
    "c": "Any statements valid for a computation are valid for application initialization. However, some additional statements are allowed."
  },
  {
    "objectID": "/rsh/appinit/#p_2",
    "pt": "Application Initialization",
    "t": 3,
    "c": "A init statement, written {!rsh} init();, finalizes all of the available participants, views, and compilation options."
  },
  {
    "objectID": "/rsh/appinit/#p_3",
    "pt": "Application Initialization",
    "t": 3,
    "c": "In earlier versions of Reach, this was called {!rsh} deploy(), but it was changed because that name was misleading."
  },
  {
    "objectID": "/rsh/appinit/#p_4",
    "pt": "Application Initialization",
    "t": 3,
    "c": "Its continuation is a step, which means its content is specified by Steps. It represents the body of the DApp to be compiled."
  },
  {
    "objectID": "/rsh/appinit/#p_5",
    "pt": "Application Initialization",
    "t": 3,
    "c": "In the example below, see how {!rsh} init(); is used to finalize the available {!rsh} Participant and {!rsh} API. After which a local step is introduced:"
  },
  {
    "objectID": "/rsh/appinit/#p_6",
    "pt": "Application Initialization",
    "t": 3,
    "c": "The compilation options for the DApp may be set by calling {!rsh} setOptions(OBJ_EXPR); where {!rsh} OBJ_EXPR is an object with the following keys and values:"
  },
  {
    "objectID": "/rsh/appinit/#p_7",
    "pt": "Application Initialization",
    "t": 3,
    "c": "{!rsh} verifyArithmetic"
  },
  {
    "objectID": "/rsh/appinit/#p_8",
    "pt": "Application Initialization",
    "t": 3,
    "c": "{!rsh} true or {!rsh} false (default)"
  },
  {
    "objectID": "/rsh/appinit/#p_9",
    "pt": "Application Initialization",
    "t": 3,
    "c": "Determines whether arithmetic operations automatically introduce static assertions that they do not overflow beyond {!rsh} UInt.max."
  },
  {
    "objectID": "/rsh/appinit/#p_10",
    "pt": "Application Initialization",
    "t": 3,
    "c": "See example below:"
  },
  {
    "objectID": "/rsh/appinit/#p_11",
    "pt": "Application Initialization",
    "t": 3,
    "c": "This defaults to {!rsh} false, because it is onerous to verify. We recommend turning it on before final deployment, but leaving it off during development. When it is {!rsh} false, connectors will ensure that overflows do not actually occur on the network."
  },
  {
    "objectID": "/rsh/appinit/#p_12",
    "pt": "Application Initialization",
    "t": 3,
    "c": "{!rsh} verifyPerConnector"
  },
  {
    "objectID": "/rsh/appinit/#p_13",
    "pt": "Application Initialization",
    "t": 3,
    "c": "{!rsh} true or {!rsh} false (default)"
  },
  {
    "objectID": "/rsh/appinit/#p_14",
    "pt": "Application Initialization",
    "t": 3,
    "c": "Determines whether verification is done per connector, or once for a generic connector. When this is {!rsh} true, then connector-specific constants, like {!rsh} UInt.max, will be instantiated to literal numbers. This concretization of these constants can induce performance degradation in the verifier."
  },
  {
    "objectID": "/rsh/appinit/#p_15",
    "pt": "Application Initialization",
    "t": 3,
    "c": "See example below:"
  },
  {
    "objectID": "/rsh/appinit/#p_16",
    "pt": "Application Initialization",
    "t": 3,
    "c": "{!rsh} connectors"
  },
  {
    "objectID": "/rsh/appinit/#p_17",
    "pt": "Application Initialization",
    "t": 3,
    "c": "{!rsh} [ETH, ALGO] (default)"
  },
  {
    "objectID": "/rsh/appinit/#p_18",
    "pt": "Application Initialization",
    "t": 3,
    "c": "A tuple of the connectors that the application should be compiled for. By default, all available connectors are chosen."
  },
  {
    "objectID": "/rsh/appinit/#p_19",
    "pt": "Application Initialization",
    "t": 3,
    "c": "In the example below, only ETH and ALGO are chosen:"
  },
  {
    "objectID": "/rsh/appinit/#p_20",
    "pt": "Application Initialization",
    "t": 3,
    "c": "{!rsh} autoTrackPublishedTokens"
  },
  {
    "objectID": "/rsh/appinit/#p_21",
    "pt": "Application Initialization",
    "t": 3,
    "c": "{!rsh} true (default) or {!rsh} false"
  },
  {
    "objectID": "/rsh/appinit/#p_22",
    "pt": "Application Initialization",
    "t": 3,
    "c": "Enable or disable automatic tracking of the contract's balance of non-network tokens introduced with {!rsh} publish. Tracking tokens takes some amount of extra space, and on some networks costs money. The Reach compiler tries to track only tokens which the contract may receive, but it sometimes fails and unnecessarily tracks a token. If you need to publish a token, but your contract will never receive any of that token, disabling this will remove the chance of unnecessarily tracking the token. If this is set to {!rsh} false, but you still need to track a published token, you can use {!rsh} Token.track."
  },
  {
    "objectID": "/rsh/appinit/#p_23",
    "pt": "Application Initialization",
    "t": 3,
    "c": "Example of manually tracking a published token when {!rsh} autoTrackPublishedTokens is turned off:"
  },
  {
    "objectID": "/rsh/appinit/#p_24",
    "pt": "Application Initialization",
    "t": 3,
    "c": "{!rsh} ALGOExitMode"
  },
  {
    "objectID": "/rsh/appinit/#p_25",
    "pt": "Application Initialization",
    "t": 3,
    "c": "Determines the way that applications on Algorand interpret {!rsh} exit, as follows:"
  },
  {
    "objectID": "/rsh/appinit/#p_26",
    "pt": "Application Initialization",
    "t": 3,
    "c": "(default) {!rsh} 'DeleteAndCloseOutAll_SoundASAs_UnsoundElse': The application will expect the final transaction to be tagged with the DeleteApplication OnCompletion flag and will issue CloseOut transactions for all of the ASAs the application holds and then a CloseOut transaction for the application's account. This is unsound, because Reach does not automatically include {!rsh} asserts that ensure that (a) all child applications are deleted and (b) all boxes are freed. If either of those constraints are not satisfied, then the attempt to close out will fail and the transaction will be reverted, so you should include these assertions yourself to ensure it is sound. (See the api-map example for how to do this effectively.) A future version of Reach will offer more modes that are guaranteed to be sound."
  },
  {
    "objectID": "/rsh/appinit/#p_27",
    "pt": "Application Initialization",
    "t": 3,
    "c": "{!rsh} 'DeleteAndCloseOutASAs': The application will expect the final transaction to be tagged with the DeleteApplication OnCompletion flag and will issue CloseOut transactions for all of the ASAs the application holds and a Pay transaction for the non-minimum balance portion of the application's account. This will always succeed, but it means that some ALGOs will be locked away forever."
  },
  {
    "objectID": "/rsh/appinit/#p_28",
    "pt": "Application Initialization",
    "t": 3,
    "c": "Any expressions valid for a computation are valid for application initialization. However, some additional expressions are allowed."
  },
  {
    "objectID": "/rsh/appinit/#p_29",
    "pt": "Application Initialization",
    "t": 3,
    "c": "A participant and participant class may be declared with"
  },
  {
    "objectID": "/rsh/appinit/#p_30",
    "pt": "Application Initialization",
    "t": 3,
    "c": "and"
  },
  {
    "objectID": "/rsh/appinit/#p_31",
    "pt": "Application Initialization",
    "t": 3,
    "c": "respectively."
  },
  {
    "objectID": "/rsh/appinit/#p_32",
    "pt": "Application Initialization",
    "t": 3,
    "c": "Since {!rsh} ParticipantClass is being deprecated, it is preferable to use {!rsh} API."
  },
  {
    "objectID": "/rsh/appinit/#p_33",
    "pt": "Application Initialization",
    "t": 3,
    "c": "{!rsh} participantName is a string which indicates the name of the participant function in the generated backend code. Each {!rsh} participantName must be unique."
  },
  {
    "objectID": "/rsh/appinit/#p_34",
    "pt": "Application Initialization",
    "t": 3,
    "c": "{!rsh} participantInteractInterface is a participant interact interface, an object where each field indicates the type of a function or value which must be provided to the backend by the frontend for interacting with the participant."
  },
  {
    "objectID": "/rsh/appinit/#p_35",
    "pt": "Application Initialization",
    "t": 3,
    "c": "In the Rock, Paper, and Scissors tutorial, Alice and Bob receive the getHand and seeOutcome interact interfaces from the construct Player in the following sample code:"
  },
  {
    "objectID": "/rsh/appinit/#p_36",
    "pt": "Application Initialization",
    "t": 3,
    "c": "APIs are functions that can be called by other contracts, as well as off-chain."
  },
  {
    "objectID": "/rsh/appinit/#p_37",
    "pt": "Application Initialization",
    "t": 3,
    "c": "An API is defined with {!rsh} API(apiName, apiInterface, ?apiAlias) or {!rsh} API(apiInterface, ?apiAlias), where {!rsh} apiName is a string that labels the API, {!rsh} apiInterface is an object where each field indicates the type of a function provided by the contract as an API, and {!rsh} apiAlias is an optional object that maps function names from the {!rsh} apiInterface to an alias."
  },
  {
    "objectID": "/rsh/appinit/#p_38",
    "pt": "Application Initialization",
    "t": 3,
    "c": "The function alias allows overloaded methods to be created. Many functions may map to the same alias as long as each function domain is unique."
  },
  {
    "objectID": "/rsh/appinit/#p_39",
    "pt": "Application Initialization",
    "t": 3,
    "c": "These APIs are available in frontends via the {!js} ctc.apis object."
  },
  {
    "objectID": "/rsh/appinit/#p_40",
    "pt": "Application Initialization",
    "t": 3,
    "c": "These APIs are available on-chain by using the appropriate network's ABI and are named apiName_f or f is there is no apiName, where f is the name of the field or the alias (if there is one)."
  },
  {
    "objectID": "/rsh/appinit/#p_41",
    "pt": "Application Initialization",
    "t": 3,
    "c": "In backends, the {!rsh} API value is an object wherein fields are the members of {!rsh} apiInterface and may be used in {!rsh} .api components of {!rsh} fork and {!rsh} parallelReduce to specify the behavior of the corresponding call. These are called API member functions. Each function must occur in the entire program and may only appear once in each consensus step."
  },
  {
    "objectID": "/rsh/appinit/#p_42",
    "pt": "Application Initialization",
    "t": 3,
    "c": "This example creates an API that has a name of Investor, and it has two functions. The first function is to invest in the contract, and the second function is to collect the payment if the Entrepreneur fails to form a quorum."
  },
  {
    "objectID": "/rsh/appinit/#p_43",
    "pt": "Application Initialization",
    "t": 3,
    "c": "This section is about defining views during application initialization. Views are set in consensus steps, in your Reach program. But, they are accessed by frontends by using the Reach standard library of the frontend language, such as JavaScript."
  },
  {
    "objectID": "/rsh/appinit/#p_44",
    "pt": "Application Initialization",
    "t": 3,
    "c": "Views are read-only functions that can be called by other contracts, as well as off-chain."
  },
  {
    "objectID": "/rsh/appinit/#p_45",
    "pt": "Application Initialization",
    "t": 3,
    "c": "A view is defined with {!rsh} View(viewName, viewInterface, ?viewAlias) or {!rsh} View(viewInterface, ?viewAlias), where {!rsh} viewName is a string that labels the view, {!rsh} viewInterface is an object where each field indicates the type of a function or value provided by the contract associated with the specified DApp, and {!rsh} viewAlias is an optional object mapping fields from the {!rsh} viewInterface to a tuple of aliases. An alias, which is a string, is another name that the view will be accessible from."
  },
  {
    "objectID": "/rsh/appinit/#p_46",
    "pt": "Application Initialization",
    "t": 3,
    "c": "These views are available in frontends via the {!js} ctc.views object."
  },
  {
    "objectID": "/rsh/appinit/#p_47",
    "pt": "Application Initialization",
    "t": 3,
    "c": "These views are available on-chain by using the appropriate network's ABI and are named viewName_f or f is there is no viewName, where f is the name of the field. An alias uses the same naming convention; it is named viewName_alias, or alias, if there is no viewName."
  },
  {
    "objectID": "/rsh/appinit/#p_48",
    "pt": "Application Initialization",
    "t": 3,
    "c": "The example below demonstrates the on-chain name of views:"
  },
  {
    "objectID": "/rsh/appinit/#p_49",
    "pt": "Application Initialization",
    "t": 3,
    "c": "In backends, the {!rsh} View object as a view object."
  },
  {
    "objectID": "/rsh/appinit/#p_50",
    "pt": "Application Initialization",
    "t": 3,
    "c": "For example, {!rsh} View is used in the code below without a {!rsh} viewName:"
  },
  {
    "objectID": "/rsh/appinit/#p_51",
    "pt": "Application Initialization",
    "t": 3,
    "c": "While the {!rsh} View in the following code contains a {!rsh} viewName:"
  },
  {
    "objectID": "/rsh/appinit/#p_52",
    "pt": "Application Initialization",
    "t": 3,
    "c": "An event is defined with {!rsh} Events(eventName, eventInterface) or {!rsh} Events(eventInterface), where {!rsh} eventName is a string that labels the event and {!rsh} eventInterface is an object where each field is a {!rsh} Tuple of {!rsh} Types, representing the type of values that an event will emit."
  },
  {
    "objectID": "/rsh/appinit/#p_53",
    "pt": "Application Initialization",
    "t": 3,
    "c": "For example, the {!rsh} Events in the code below has no {!rsh} eventName:"
  },
  {
    "objectID": "/rsh/appinit/#p_54",
    "pt": "Application Initialization",
    "t": 3,
    "c": "While the {!rsh} Events in following example has an {!rsh} eventName:"
  },
  {
    "objectID": "/rsh/appinit/#p_55",
    "pt": "Application Initialization",
    "t": 3,
    "c": "These events are available in the frontends via the {!js} ctc.events object. In the DApp, the result of this application argument is referred to as an event object."
  },
  {
    "objectID": "/rsh/appinit/#p_56",
    "pt": "Application Initialization",
    "t": 3,
    "c": "Reach programs can create new child contracts based on predetermined, static code during compile time. This code is specified with {!rsh} ContractCode, documented below, but is actually deployed with {!rsh} new Contract ({!rsh} Contract.new), which you can read about in Contract creation."
  },
  {
    "objectID": "/rsh/appinit/#p_57",
    "pt": "Application Initialization",
    "t": 3,
    "c": "As part of an application's specification, you can indicate some child contracts that may be created with:"
  },
  {
    "objectID": "/rsh/appinit/#p_58",
    "pt": "Application Initialization",
    "t": 3,
    "c": "where connectors is an object with one field for each enabled connector. Each connector expects the code for the child to be specified in a different way."
  },
  {
    "objectID": "/rsh/appinit/#p_59",
    "pt": "Application Initialization",
    "t": 3,
    "c": "The {!rsh} ETH connector accepts:"
  },
  {
    "objectID": "/rsh/appinit/#p_60",
    "pt": "Application Initialization",
    "t": 3,
    "c": "A literal string of the shape ${BASE}.bin, where ${BASE}.bin is a file that contains the ASCII hexadecimal encoding of the EVM bytecode."
  },
  {
    "objectID": "/rsh/appinit/#p_61",
    "pt": "Application Initialization",
    "t": 3,
    "c": "A literal string of the shape ${BASE}.json:${FILE}:${CONTRACT}, where ${BASE}.json is a file that contains the JSON output of the Solidity compiler and ${FILE}:${CONTRACT} is a key in the contracts object therein."
  },
  {
    "objectID": "/rsh/appinit/#p_62",
    "pt": "Application Initialization",
    "t": 3,
    "c": "A literal string of the shape ${BASE}.sol:${CONTRACT}, where ${BASE}.sol is a Solidity file that defines the contract ${CONTRACT}. Reach will call the Solidity compiler it uses internally to compile the file."
  },
  {
    "objectID": "/rsh/appinit/#p_63",
    "pt": "Application Initialization",
    "t": 3,
    "c": "The {!rsh} ALGO connector accepts an object with the keys approval and clearState that may be:"
  },
  {
    "objectID": "/rsh/appinit/#p_64",
    "pt": "Application Initialization",
    "t": 3,
    "c": "A literal string of the shape ${BASE}.tok, where ${BASE}.tok is a file that contains the binary encoding of the AVM bytecode (as produced by {!cmd} goal clerk compile.)"
  },
  {
    "objectID": "/rsh/appinit/#p_65",
    "pt": "Application Initialization",
    "t": 3,
    "c": "A literal string of the shape ${BASE}.teal, where ${BASE}.teal is a TEAL file that defines the program. Reach will call the TEAL compiler it uses internally to compile the file."
  },
  {
    "objectID": "/rsh/appinit/#p_66",
    "pt": "Application Initialization",
    "t": 3,
    "c": "The value returned (cc) can be used with {!rsh} new Contract to actually deploy the child contracts. It embeds the actual bytecode of the child contracts, so it can (potentially drastically) expand the size (and thus cost) of deploying the parent contract."
  },
  {
    "objectID": "/rsh/compute/#rsh_const",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "const"
  },
  {
    "objectID": "/rsh/compute/#rsh_function",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "function"
  },
  {
    "objectID": "/rsh/compute/#rsh_return",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "return"
  },
  {
    "objectID": "/rsh/compute/#rsh_if",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "if"
  },
  {
    "objectID": "/rsh/compute/#rsh_else",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "else"
  },
  {
    "objectID": "/rsh/compute/#rsh_switch",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "switch"
  },
  {
    "objectID": "/rsh/compute/#rsh_case",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "case"
  },
  {
    "objectID": "/rsh/compute/#rsh_default",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "default"
  },
  {
    "objectID": "/rsh/compute/#rsh_'use%20strict'",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "'use strict'"
  },
  {
    "objectID": "/rsh/compute/#rsh_unstrict",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "unstrict"
  },
  {
    "objectID": "/rsh/compute/#rsh_this",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "this"
  },
  {
    "objectID": "/rsh/compute/#rsh_new",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "new"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.new",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.new"
  },
  {
    "objectID": "/rsh/compute/#rsh_Set.new",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Set.new"
  },
  {
    "objectID": "/rsh/compute/#rsh_Token.new",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Token.new"
  },
  {
    "objectID": "/rsh/compute/#rsh_Null",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Null"
  },
  {
    "objectID": "/rsh/compute/#rsh_Bool",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Bool"
  },
  {
    "objectID": "/rsh/compute/#rsh_UInt",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "UInt"
  },
  {
    "objectID": "/rsh/compute/#rsh_UInt.max",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "UInt.max"
  },
  {
    "objectID": "/rsh/compute/#rsh_UInt256",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "UInt256"
  },
  {
    "objectID": "/rsh/compute/#rsh_UInt256.max",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "UInt256.max"
  },
  {
    "objectID": "/rsh/compute/#rsh_Bytes",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Bytes"
  },
  {
    "objectID": "/rsh/compute/#rsh_BytesDyn",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "BytesDyn"
  },
  {
    "objectID": "/rsh/compute/#rsh_StringDyn",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "StringDyn"
  },
  {
    "objectID": "/rsh/compute/#rsh_Digest",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Digest"
  },
  {
    "objectID": "/rsh/compute/#rsh_Address",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Address"
  },
  {
    "objectID": "/rsh/compute/#rsh_Contract",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Contract"
  },
  {
    "objectID": "/rsh/compute/#rsh_Token",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Token"
  },
  {
    "objectID": "/rsh/compute/#rsh_Fun",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Fun"
  },
  {
    "objectID": "/rsh/compute/#rsh_Tuple",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Tuple"
  },
  {
    "objectID": "/rsh/compute/#rsh_Object",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Object"
  },
  {
    "objectID": "/rsh/compute/#rsh_Struct",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Struct"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array"
  },
  {
    "objectID": "/rsh/compute/#rsh_Data",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Data"
  },
  {
    "objectID": "/rsh/compute/#rsh_Refine",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Refine"
  },
  {
    "objectID": "/rsh/compute/#rsh_typeOf",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "typeOf"
  },
  {
    "objectID": "/rsh/compute/#rsh_isType",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "isType"
  },
  {
    "objectID": "/rsh/compute/#rsh_is",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "is"
  },
  {
    "objectID": "/rsh/compute/#rsh_true",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "true"
  },
  {
    "objectID": "/rsh/compute/#rsh_false",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "false"
  },
  {
    "objectID": "/rsh/compute/#rsh_null",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "null"
  },
  {
    "objectID": "/rsh/compute/#rsh_!",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "!"
  },
  {
    "objectID": "/rsh/compute/#rsh_-",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "-"
  },
  {
    "objectID": "/rsh/compute/#rsh_+",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "+"
  },
  {
    "objectID": "/rsh/compute/#rsh_typeof",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "typeof"
  },
  {
    "objectID": "/rsh/compute/#rsh_not",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "not"
  },
  {
    "objectID": "/rsh/compute/#rsh_minus",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "minus"
  },
  {
    "objectID": "/rsh/compute/#rsh_plus",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "plus"
  },
  {
    "objectID": "/rsh/compute/#rsh_void",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "void"
  },
  {
    "objectID": "/rsh/compute/#rsh_&&",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "&&"
  },
  {
    "objectID": "/rsh/compute/#rsh_%7C%7C",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "||"
  },
  {
    "objectID": "/rsh/compute/#rsh_+",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "+"
  },
  {
    "objectID": "/rsh/compute/#rsh_-",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "-"
  },
  {
    "objectID": "/rsh/compute/#rsh_*",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "*"
  },
  {
    "objectID": "/rsh/compute/#rsh_/",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "/"
  },
  {
    "objectID": "/rsh/compute/#rsh_%25",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "%"
  },
  {
    "objectID": "/rsh/compute/#rsh_%7C",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "|"
  },
  {
    "objectID": "/rsh/compute/#rsh_&",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "&"
  },
  {
    "objectID": "/rsh/compute/#rsh_%5E",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "^"
  },
  {
    "objectID": "/rsh/compute/#rsh_%3C%3C",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "<<"
  },
  {
    "objectID": "/rsh/compute/#rsh_%3E%3E",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": ">>"
  },
  {
    "objectID": "/rsh/compute/#rsh_==",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "=="
  },
  {
    "objectID": "/rsh/compute/#rsh_!=",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "!="
  },
  {
    "objectID": "/rsh/compute/#rsh_===",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "==="
  },
  {
    "objectID": "/rsh/compute/#rsh_!==",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "!=="
  },
  {
    "objectID": "/rsh/compute/#rsh_%3E",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": ">"
  },
  {
    "objectID": "/rsh/compute/#rsh_%3E=",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": ">="
  },
  {
    "objectID": "/rsh/compute/#rsh_%3C=",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "<="
  },
  {
    "objectID": "/rsh/compute/#rsh_%3C",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "<"
  },
  {
    "objectID": "/rsh/compute/#rsh_and",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "and"
  },
  {
    "objectID": "/rsh/compute/#rsh_or",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "or"
  },
  {
    "objectID": "/rsh/compute/#rsh_xor",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "xor"
  },
  {
    "objectID": "/rsh/compute/#rsh_add",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "add"
  },
  {
    "objectID": "/rsh/compute/#rsh_sub",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "sub"
  },
  {
    "objectID": "/rsh/compute/#rsh_mul",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "mul"
  },
  {
    "objectID": "/rsh/compute/#rsh_div",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "div"
  },
  {
    "objectID": "/rsh/compute/#rsh_mod",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "mod"
  },
  {
    "objectID": "/rsh/compute/#rsh_polyMod",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "polyMod"
  },
  {
    "objectID": "/rsh/compute/#rsh_eq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "eq"
  },
  {
    "objectID": "/rsh/compute/#rsh_lt",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "lt"
  },
  {
    "objectID": "/rsh/compute/#rsh_le",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "le"
  },
  {
    "objectID": "/rsh/compute/#rsh_ge",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "ge"
  },
  {
    "objectID": "/rsh/compute/#rsh_gt",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "gt"
  },
  {
    "objectID": "/rsh/compute/#rsh_lsh",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "lsh"
  },
  {
    "objectID": "/rsh/compute/#rsh_rsh",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "rsh"
  },
  {
    "objectID": "/rsh/compute/#rsh_band",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "band"
  },
  {
    "objectID": "/rsh/compute/#rsh_bior",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "bior"
  },
  {
    "objectID": "/rsh/compute/#rsh_bxor",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "bxor"
  },
  {
    "objectID": "/rsh/compute/#rsh_polyEq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "polyEq"
  },
  {
    "objectID": "/rsh/compute/#rsh_polyNeq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "polyNeq"
  },
  {
    "objectID": "/rsh/compute/#rsh_safeAdd",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "safeAdd"
  },
  {
    "objectID": "/rsh/compute/#rsh_safeSub",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "safeSub"
  },
  {
    "objectID": "/rsh/compute/#rsh_safeMul",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "safeMul"
  },
  {
    "objectID": "/rsh/compute/#rsh_safeDiv",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "safeDiv"
  },
  {
    "objectID": "/rsh/compute/#rsh_safeMod",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "safeMod"
  },
  {
    "objectID": "/rsh/compute/#rsh_veriAdd",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "veriAdd"
  },
  {
    "objectID": "/rsh/compute/#rsh_veriSub",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "veriSub"
  },
  {
    "objectID": "/rsh/compute/#rsh_veriMul",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "veriMul"
  },
  {
    "objectID": "/rsh/compute/#rsh_veriDiv",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "veriDiv"
  },
  {
    "objectID": "/rsh/compute/#rsh_veriMod",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "veriMod"
  },
  {
    "objectID": "/rsh/compute/#rsh_boolEq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "boolEq"
  },
  {
    "objectID": "/rsh/compute/#rsh_typeEq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "typeEq"
  },
  {
    "objectID": "/rsh/compute/#rsh_intEq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intEq"
  },
  {
    "objectID": "/rsh/compute/#rsh_digestEq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "digestEq"
  },
  {
    "objectID": "/rsh/compute/#rsh_addressEq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "addressEq"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxeq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxeq"
  },
  {
    "objectID": "/rsh/compute/#rsh_ieq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "ieq"
  },
  {
    "objectID": "/rsh/compute/#rsh_Contract.addressEq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Contract.addressEq"
  },
  {
    "objectID": "/rsh/compute/#rsh_boolXor",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "boolXor"
  },
  {
    "objectID": "/rsh/compute/#rsh_Bytes.pad",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Bytes.pad"
  },
  {
    "objectID": "/rsh/compute/#rsh_Bytes.fromHex",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Bytes.fromHex"
  },
  {
    "objectID": "/rsh/compute/#rsh_Bytes.concat",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Bytes.concat"
  },
  {
    "objectID": "/rsh/compute/#rsh_StringDyn.concat",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "StringDyn.concat"
  },
  {
    "objectID": "/rsh/compute/#rsh_array",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "array"
  },
  {
    "objectID": "/rsh/compute/#rsh_Tuple.length",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Tuple.length"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.length",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.length"
  },
  {
    "objectID": "/rsh/compute/#rsh_length",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "length"
  },
  {
    "objectID": "/rsh/compute/#rsh_Tuple.set",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Tuple.set"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.set",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.set"
  },
  {
    "objectID": "/rsh/compute/#rsh_set",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "set"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.elemType",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.elemType"
  },
  {
    "objectID": "/rsh/compute/#rsh_elemType",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "elemType"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.forEach",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.forEach"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.forEach",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.forEach"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.forEach",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.forEach"
  },
  {
    "objectID": "/rsh/compute/#rsh_forEach",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "forEach"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.all",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.all"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.all",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.all"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.all",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.all"
  },
  {
    "objectID": "/rsh/compute/#rsh_all",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "all"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.any",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.any"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.any",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.any"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.any",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.any"
  },
  {
    "objectID": "/rsh/compute/#rsh_any",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "any"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.or",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.or"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.or",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.or"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.or",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.or"
  },
  {
    "objectID": "/rsh/compute/#rsh_or",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "or"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.and",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.and"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.and",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.and"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.and",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.and"
  },
  {
    "objectID": "/rsh/compute/#rsh_and",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "and"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.includes",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.includes"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.includes",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.includes"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.includes",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.includes"
  },
  {
    "objectID": "/rsh/compute/#rsh_Tuple.includes",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Tuple.includes"
  },
  {
    "objectID": "/rsh/compute/#rsh_includes",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "includes"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.count",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.count"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.count",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.count"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.count",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.count"
  },
  {
    "objectID": "/rsh/compute/#rsh_count",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "count"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.size",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.size"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.size",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.size"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.size",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.size"
  },
  {
    "objectID": "/rsh/compute/#rsh_size",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "size"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.min",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.min"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.min",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.min"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.min",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.min"
  },
  {
    "objectID": "/rsh/compute/#rsh_min",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "min"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.max",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.max"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.max",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.max"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.max",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.max"
  },
  {
    "objectID": "/rsh/compute/#rsh_max",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "max"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.sum",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.sum"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.sum",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.sum"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.sum",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.sum"
  },
  {
    "objectID": "/rsh/compute/#rsh_sum",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "sum"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.product",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.product"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.product",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.product"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.product",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.product"
  },
  {
    "objectID": "/rsh/compute/#rsh_product",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "product"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.average",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.average"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.average",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.average"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.average",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.average"
  },
  {
    "objectID": "/rsh/compute/#rsh_average",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "average"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.imin",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.imin"
  },
  {
    "objectID": "/rsh/compute/#rsh_Foldable.imax",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Foldable.imax"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.imin",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.imin"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.imax",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.imax"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.imin",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.imin"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.imax",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.imax"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.iota",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.iota"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array_replicate",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array_replicate"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.replicate",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.replicate"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.concat",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.concat"
  },
  {
    "objectID": "/rsh/compute/#rsh_concat",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "concat"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array_empty",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array_empty"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.empty",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.empty"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.zip",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.zip"
  },
  {
    "objectID": "/rsh/compute/#rsh_zip",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "zip"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.map",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.map"
  },
  {
    "objectID": "/rsh/compute/#rsh_map",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "map"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.mapWithIndex",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.mapWithIndex"
  },
  {
    "objectID": "/rsh/compute/#rsh_mapWithIndex",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "mapWithIndex"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.forEachWithIndex",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.forEachWithIndex"
  },
  {
    "objectID": "/rsh/compute/#rsh_forEachWithIndex",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "forEachWithIndex"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.reduce",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.reduce"
  },
  {
    "objectID": "/rsh/compute/#rsh_reduce",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "reduce"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.reduceWithIndex",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.reduceWithIndex"
  },
  {
    "objectID": "/rsh/compute/#rsh_reduceWithIndex",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "reduceWithIndex"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.indexOf",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.indexOf"
  },
  {
    "objectID": "/rsh/compute/#rsh_indexOf",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "indexOf"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.findIndex",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.findIndex"
  },
  {
    "objectID": "/rsh/compute/#rsh_findIndex",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "findIndex"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.find",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.find"
  },
  {
    "objectID": "/rsh/compute/#rsh_find",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "find"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.withIndex",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.withIndex"
  },
  {
    "objectID": "/rsh/compute/#rsh_withIndex",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "withIndex"
  },
  {
    "objectID": "/rsh/compute/#rsh_Array.slice",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Array.slice"
  },
  {
    "objectID": "/rsh/compute/#rsh_slice",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "slice"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.reduce",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.reduce"
  },
  {
    "objectID": "/rsh/compute/#rsh_Map.reduceWithKey",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Map.reduceWithKey"
  },
  {
    "objectID": "/rsh/compute/#rsh_Object.fields",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Object.fields"
  },
  {
    "objectID": "/rsh/compute/#rsh_Object.set",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Object.set"
  },
  {
    "objectID": "/rsh/compute/#rsh_Object_set",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Object_set"
  },
  {
    "objectID": "/rsh/compute/#rsh_Object.setIfUnset",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Object.setIfUnset"
  },
  {
    "objectID": "/rsh/compute/#rsh_Object_setIfUnset",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Object_setIfUnset"
  },
  {
    "objectID": "/rsh/compute/#rsh_Object.has",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Object.has"
  },
  {
    "objectID": "/rsh/compute/#rsh_Struct.toObject",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Struct.toObject"
  },
  {
    "objectID": "/rsh/compute/#rsh_Struct.toTuple",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Struct.toTuple"
  },
  {
    "objectID": "/rsh/compute/#rsh_Struct.fields",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Struct.fields"
  },
  {
    "objectID": "/rsh/compute/#rsh_isDataVariant",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "isDataVariant"
  },
  {
    "objectID": "/rsh/compute/#rsh_Maybe",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Maybe"
  },
  {
    "objectID": "/rsh/compute/#rsh_Maybe.Some",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Maybe.Some"
  },
  {
    "objectID": "/rsh/compute/#rsh_Maybe.None",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Maybe.None"
  },
  {
    "objectID": "/rsh/compute/#rsh_fromMaybe",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fromMaybe"
  },
  {
    "objectID": "/rsh/compute/#rsh_isNone",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "isNone"
  },
  {
    "objectID": "/rsh/compute/#rsh_isSome",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "isSome"
  },
  {
    "objectID": "/rsh/compute/#rsh_fromSome",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fromSome"
  },
  {
    "objectID": "/rsh/compute/#rsh_maybe",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "maybe"
  },
  {
    "objectID": "/rsh/compute/#rsh_Either",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Either"
  },
  {
    "objectID": "/rsh/compute/#rsh_Either.Left",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Either.Left"
  },
  {
    "objectID": "/rsh/compute/#rsh_Either.Right",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Either.Right"
  },
  {
    "objectID": "/rsh/compute/#rsh_either",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "either"
  },
  {
    "objectID": "/rsh/compute/#rsh_isLeft",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "isLeft"
  },
  {
    "objectID": "/rsh/compute/#rsh_isRight",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "isRight"
  },
  {
    "objectID": "/rsh/compute/#rsh_fromLeft",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fromLeft"
  },
  {
    "objectID": "/rsh/compute/#rsh_fromRight",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fromRight"
  },
  {
    "objectID": "/rsh/compute/#rsh_match",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "match"
  },
  {
    "objectID": "/rsh/compute/#rsh_?",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "?"
  },
  {
    "objectID": "/rsh/compute/#rsh_ite",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "ite"
  },
  {
    "objectID": "/rsh/compute/#rsh_=%3E",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "=>"
  },
  {
    "objectID": "/rsh/compute/#rsh_makeEnum",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "makeEnum"
  },
  {
    "objectID": "/rsh/compute/#rsh_assert",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "assert"
  },
  {
    "objectID": "/rsh/compute/#rsh_check",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "check"
  },
  {
    "objectID": "/rsh/compute/#rsh_enforce",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "enforce"
  },
  {
    "objectID": "/rsh/compute/#rsh_forall",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "forall"
  },
  {
    "objectID": "/rsh/compute/#rsh_possible",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "possible"
  },
  {
    "objectID": "/rsh/compute/#rsh_digest",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "digest"
  },
  {
    "objectID": "/rsh/compute/#rsh_balance",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "balance"
  },
  {
    "objectID": "/rsh/compute/#rsh_getContract",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "getContract"
  },
  {
    "objectID": "/rsh/compute/#rsh_getAddress",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "getAddress"
  },
  {
    "objectID": "/rsh/compute/#rsh_getCompanion",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "getCompanion"
  },
  {
    "objectID": "/rsh/compute/#rsh_lastConsensusTime",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "lastConsensusTime"
  },
  {
    "objectID": "/rsh/compute/#rsh_lastConsensusSecs",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "lastConsensusSecs"
  },
  {
    "objectID": "/rsh/compute/#rsh_thisConsensusTime",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "thisConsensusTime"
  },
  {
    "objectID": "/rsh/compute/#rsh_thisConsensusSecs",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "thisConsensusSecs"
  },
  {
    "objectID": "/rsh/compute/#rsh_baseWaitTime",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "baseWaitTime"
  },
  {
    "objectID": "/rsh/compute/#rsh_baseWaitSecs",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "baseWaitSecs"
  },
  {
    "objectID": "/rsh/compute/#rsh_relativeTime",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "relativeTime"
  },
  {
    "objectID": "/rsh/compute/#rsh_absoluteTime",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "absoluteTime"
  },
  {
    "objectID": "/rsh/compute/#rsh_relativeSecs",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "relativeSecs"
  },
  {
    "objectID": "/rsh/compute/#rsh_absoluteSecs",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "absoluteSecs"
  },
  {
    "objectID": "/rsh/compute/#rsh_verifyRelativeTime",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "verifyRelativeTime"
  },
  {
    "objectID": "/rsh/compute/#rsh_verifyAbsoluteTime",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "verifyAbsoluteTime"
  },
  {
    "objectID": "/rsh/compute/#rsh_verifyRelativeSecs",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "verifyRelativeSecs"
  },
  {
    "objectID": "/rsh/compute/#rsh_verifyAbsoluteSecs",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "verifyAbsoluteSecs"
  },
  {
    "objectID": "/rsh/compute/#rsh_makeDeadline",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "makeDeadline"
  },
  {
    "objectID": "/rsh/compute/#rsh_implies",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "implies"
  },
  {
    "objectID": "/rsh/compute/#rsh_ensure",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "ensure"
  },
  {
    "objectID": "/rsh/compute/#rsh_hasRandom",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "hasRandom"
  },
  {
    "objectID": "/rsh/compute/#rsh_hasRandom.random",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "hasRandom.random"
  },
  {
    "objectID": "/rsh/compute/#rsh_hasConsoleLogger",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "hasConsoleLogger"
  },
  {
    "objectID": "/rsh/compute/#rsh_hasConsoleLogger.log",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "hasConsoleLogger.log"
  },
  {
    "objectID": "/rsh/compute/#rsh_compose",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "compose"
  },
  {
    "objectID": "/rsh/compute/#rsh_muldiv",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "muldiv"
  },
  {
    "objectID": "/rsh/compute/#rsh_veriMuldiv",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "veriMuldiv"
  },
  {
    "objectID": "/rsh/compute/#rsh_safeMuldiv",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "safeMuldiv"
  },
  {
    "objectID": "/rsh/compute/#rsh_verifyMuldiv",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "verifyMuldiv"
  },
  {
    "objectID": "/rsh/compute/#rsh_sqrt",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "sqrt"
  },
  {
    "objectID": "/rsh/compute/#rsh_sqrtApprox",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "sqrtApprox"
  },
  {
    "objectID": "/rsh/compute/#rsh_pow",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "pow"
  },
  {
    "objectID": "/rsh/compute/#rsh_Int",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Int"
  },
  {
    "objectID": "/rsh/compute/#rsh_Pos",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Pos"
  },
  {
    "objectID": "/rsh/compute/#rsh_Neg",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Neg"
  },
  {
    "objectID": "/rsh/compute/#rsh_int",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "int"
  },
  {
    "objectID": "/rsh/compute/#rsh_iadd",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "iadd"
  },
  {
    "objectID": "/rsh/compute/#rsh_isub",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "isub"
  },
  {
    "objectID": "/rsh/compute/#rsh_imul",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "imul"
  },
  {
    "objectID": "/rsh/compute/#rsh_idiv",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "idiv"
  },
  {
    "objectID": "/rsh/compute/#rsh_imod",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "imod"
  },
  {
    "objectID": "/rsh/compute/#rsh_ilt",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "ilt"
  },
  {
    "objectID": "/rsh/compute/#rsh_ile",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "ile"
  },
  {
    "objectID": "/rsh/compute/#rsh_igt",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "igt"
  },
  {
    "objectID": "/rsh/compute/#rsh_ige",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "ige"
  },
  {
    "objectID": "/rsh/compute/#rsh_ieq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "ieq"
  },
  {
    "objectID": "/rsh/compute/#rsh_ine",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "ine"
  },
  {
    "objectID": "/rsh/compute/#rsh_imax",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "imax"
  },
  {
    "objectID": "/rsh/compute/#rsh_abs",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "abs"
  },
  {
    "objectID": "/rsh/compute/#rsh_FixedPoint",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "FixedPoint"
  },
  {
    "objectID": "/rsh/compute/#rsh_fx",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fx"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxint",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxint"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxrescale",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxrescale"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxunify",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxunify"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxadd",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxadd"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxsub",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxsub"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxmul",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxmul"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxdiv",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxdiv"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxmod",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxmod"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxfloor",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxfloor"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxsqrt",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxsqrt"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxsqrtApprox",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxsqrtApprox"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxpow",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxpow"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxpowi",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxpowi"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxpowui",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxpowui"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxcmp",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxcmp"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxlt",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxlt"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxle",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxle"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxgt",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxgt"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxge",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxge"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxeq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxeq"
  },
  {
    "objectID": "/rsh/compute/#rsh_fxne",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "fxne"
  },
  {
    "objectID": "/rsh/compute/#rsh_Anybody",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Anybody"
  },
  {
    "objectID": "/rsh/compute/#rsh_Interval",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Interval"
  },
  {
    "objectID": "/rsh/compute/#rsh_isInterval",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "isInterval"
  },
  {
    "objectID": "/rsh/compute/#rsh_IntervalType",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "IntervalType"
  },
  {
    "objectID": "/rsh/compute/#rsh_isIntervalType",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "isIntervalType"
  },
  {
    "objectID": "/rsh/compute/#rsh_Closed",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Closed"
  },
  {
    "objectID": "/rsh/compute/#rsh_Open",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "Open"
  },
  {
    "objectID": "/rsh/compute/#rsh_interval",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "interval"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalCC",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalCC"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalCO",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalCO"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalOC",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalOC"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalOO",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalOO"
  },
  {
    "objectID": "/rsh/compute/#rsh_leftEndpoint",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "leftEndpoint"
  },
  {
    "objectID": "/rsh/compute/#rsh_rightEndpoint",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "rightEndpoint"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalEq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalEq"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalNeq",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalNeq"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalLt",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalLt"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalLte",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalLte"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalGt",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalGt"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalGte",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalGte"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalAdd",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalAdd"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalSub",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalSub"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalMul",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalMul"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalDiv",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalDiv"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalIntersection",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalIntersection"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalUnion",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalUnion"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalWidth",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalWidth"
  },
  {
    "objectID": "/rsh/compute/#rsh_intervalAbs",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "intervalAbs"
  },
  {
    "objectID": "/rsh/compute/#rsh_getUntrackedFunds",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "getUntrackedFunds"
  },
  {
    "objectID": "/rsh/compute/#rsh_distinct",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "distinct"
  },
  {
    "objectID": "/rsh/compute/#rsh_currentMode",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "currentMode"
  },
  {
    "objectID": "/rsh/compute/#rsh_mixin",
    "pt": "Computations",
    "t": 0,
    "s": "rsh",
    "c": "mixin"
  },
  {
    "objectID": "/rsh/compute/#term_single-line%20comment",
    "pt": "Computations",
    "t": 1,
    "c": "single-line comment"
  },
  {
    "objectID": "/rsh/compute/#term_multi-line%20comment",
    "pt": "Computations",
    "t": 1,
    "c": "multi-line comment"
  },
  {
    "objectID": "/rsh/compute/#term_block",
    "pt": "Computations",
    "t": 1,
    "c": "block"
  },
  {
    "objectID": "/rsh/compute/#term_statements",
    "pt": "Computations",
    "t": 1,
    "c": "statements"
  },
  {
    "objectID": "/rsh/compute/#term_tail",
    "pt": "Computations",
    "t": 1,
    "c": "tail"
  },
  {
    "objectID": "/rsh/compute/#term_continuations",
    "pt": "Computations",
    "t": 1,
    "c": "continuations"
  },
  {
    "objectID": "/rsh/compute/#term_terminator%20statement",
    "pt": "Computations",
    "t": 1,
    "c": "terminator statement"
  },
  {
    "objectID": "/rsh/compute/#term_identifier%20definition",
    "pt": "Computations",
    "t": 1,
    "c": "identifier definition"
  },
  {
    "objectID": "/rsh/compute/#term_bound%20identifier",
    "pt": "Computations",
    "t": 1,
    "c": "bound identifier"
  },
  {
    "objectID": "/rsh/compute/#term_identifiers",
    "pt": "Computations",
    "t": 1,
    "c": "identifiers"
  },
  {
    "objectID": "/rsh/compute/#term_value%20definition",
    "pt": "Computations",
    "t": 1,
    "c": "value definition"
  },
  {
    "objectID": "/rsh/compute/#term_function%20definition",
    "pt": "Computations",
    "t": 1,
    "c": "function definition"
  },
  {
    "objectID": "/rsh/compute/#term_function%20body",
    "pt": "Computations",
    "t": 1,
    "c": "function body"
  },
  {
    "objectID": "/rsh/compute/#term_rest%20parameter",
    "pt": "Computations",
    "t": 1,
    "c": "rest parameter"
  },
  {
    "objectID": "/rsh/compute/#term_unbound",
    "pt": "Computations",
    "t": 1,
    "c": "unbound"
  },
  {
    "objectID": "/rsh/compute/#term_return%20statement",
    "pt": "Computations",
    "t": 1,
    "c": "return statement"
  },
  {
    "objectID": "/rsh/compute/#term_tail%20position",
    "pt": "Computations",
    "t": 1,
    "c": "tail position"
  },
  {
    "objectID": "/rsh/compute/#term_conditional%20statement",
    "pt": "Computations",
    "t": 1,
    "c": "conditional statement"
  },
  {
    "objectID": "/rsh/compute/#term_switch%20statement",
    "pt": "Computations",
    "t": 1,
    "c": "switch statement"
  },
  {
    "objectID": "/rsh/compute/#term_block%20statement",
    "pt": "Computations",
    "t": 1,
    "c": "block statement"
  },
  {
    "objectID": "/rsh/compute/#term_try%20statement",
    "pt": "Computations",
    "t": 1,
    "c": "try statement"
  },
  {
    "objectID": "/rsh/compute/#term_throw%20statement",
    "pt": "Computations",
    "t": 1,
    "c": "throw statement"
  },
  {
    "objectID": "/rsh/compute/#term_strict%20mode",
    "pt": "Computations",
    "t": 1,
    "c": "strict mode"
  },
  {
    "objectID": "/rsh/compute/#term_expressions",
    "pt": "Computations",
    "t": 1,
    "c": "expressions"
  },
  {
    "objectID": "/rsh/compute/#term_function%20application",
    "pt": "Computations",
    "t": 1,
    "c": "function application"
  },
  {
    "objectID": "/rsh/compute/#term_type",
    "pt": "Computations",
    "t": 1,
    "c": "type"
  },
  {
    "objectID": "/rsh/compute/#term_function%20type",
    "pt": "Computations",
    "t": 1,
    "c": "function type"
  },
  {
    "objectID": "/rsh/compute/#term_unconstrained%20domain%20function%20type",
    "pt": "Computations",
    "t": 1,
    "c": "unconstrained domain function type"
  },
  {
    "objectID": "/rsh/compute/#term_negative%20position",
    "pt": "Computations",
    "t": 1,
    "c": "negative position"
  },
  {
    "objectID": "/rsh/compute/#term_positive%20position",
    "pt": "Computations",
    "t": 1,
    "c": "positive position"
  },
  {
    "objectID": "/rsh/compute/#term_literal%20value",
    "pt": "Computations",
    "t": 1,
    "c": "literal value"
  },
  {
    "objectID": "/rsh/compute/#term_null%20literal",
    "pt": "Computations",
    "t": 1,
    "c": "null literal"
  },
  {
    "objectID": "/rsh/compute/#term_Numeric%20literal",
    "pt": "Computations",
    "t": 1,
    "c": "Numeric literal"
  },
  {
    "objectID": "/rsh/compute/#term_bit%20width",
    "pt": "Computations",
    "t": 1,
    "c": "bit width"
  },
  {
    "objectID": "/rsh/compute/#term_Exponential%20notation",
    "pt": "Computations",
    "t": 1,
    "c": "Exponential notation"
  },
  {
    "objectID": "/rsh/compute/#term_Boolean%20literal",
    "pt": "Computations",
    "t": 1,
    "c": "Boolean literal"
  },
  {
    "objectID": "/rsh/compute/#term_String%20literal",
    "pt": "Computations",
    "t": 1,
    "c": "String literal"
  },
  {
    "objectID": "/rsh/compute/#term_operator",
    "pt": "Computations",
    "t": 1,
    "c": "operator"
  },
  {
    "objectID": "/rsh/compute/#term_unary%20expression",
    "pt": "Computations",
    "t": 1,
    "c": "unary expression"
  },
  {
    "objectID": "/rsh/compute/#term_unary%20operator",
    "pt": "Computations",
    "t": 1,
    "c": "unary operator"
  },
  {
    "objectID": "/rsh/compute/#term_binary%20expression",
    "pt": "Computations",
    "t": 1,
    "c": "binary expression"
  },
  {
    "objectID": "/rsh/compute/#term_binary%20operator",
    "pt": "Computations",
    "t": 1,
    "c": "binary operator"
  },
  {
    "objectID": "/rsh/compute/#term_padded",
    "pt": "Computations",
    "t": 1,
    "c": "padded"
  },
  {
    "objectID": "/rsh/compute/#term_tuple",
    "pt": "Computations",
    "t": 1,
    "c": "tuple"
  },
  {
    "objectID": "/rsh/compute/#term_array",
    "pt": "Computations",
    "t": 1,
    "c": "array"
  },
  {
    "objectID": "/rsh/compute/#term_reference",
    "pt": "Computations",
    "t": 1,
    "c": "reference"
  },
  {
    "objectID": "/rsh/compute/#term_object",
    "pt": "Computations",
    "t": 1,
    "c": "object"
  },
  {
    "objectID": "/rsh/compute/#term_object%20splice",
    "pt": "Computations",
    "t": 1,
    "c": "object splice"
  },
  {
    "objectID": "/rsh/compute/#term_object%20reference",
    "pt": "Computations",
    "t": 1,
    "c": "object reference"
  },
  {
    "objectID": "/rsh/compute/#term_field",
    "pt": "Computations",
    "t": 1,
    "c": "field"
  },
  {
    "objectID": "/rsh/compute/#term_struct",
    "pt": "Computations",
    "t": 1,
    "c": "struct"
  },
  {
    "objectID": "/rsh/compute/#term_data%20instance",
    "pt": "Computations",
    "t": 1,
    "c": "data instance"
  },
  {
    "objectID": "/rsh/compute/#term_match%20expression",
    "pt": "Computations",
    "t": 1,
    "c": "match expression"
  },
  {
    "objectID": "/rsh/compute/#term_conditional%20expression",
    "pt": "Computations",
    "t": 1,
    "c": "conditional expression"
  },
  {
    "objectID": "/rsh/compute/#term_arrow%20expression",
    "pt": "Computations",
    "t": 1,
    "c": "arrow expression"
  },
  {
    "objectID": "/rsh/compute/#term_enumeration",
    "pt": "Computations",
    "t": 1,
    "c": "enumeration"
  },
  {
    "objectID": "/rsh/compute/#term_enum",
    "pt": "Computations",
    "t": 1,
    "c": "enum"
  },
  {
    "objectID": "/rsh/compute/#term_balance",
    "pt": "Computations",
    "t": 1,
    "c": "balance"
  },
  {
    "objectID": "/rsh/compute/#term_getContract",
    "pt": "Computations",
    "t": 1,
    "c": "getContract"
  },
  {
    "objectID": "/rsh/compute/#term_getAddress",
    "pt": "Computations",
    "t": 1,
    "c": "getAddress"
  },
  {
    "objectID": "/rsh/compute/#term_lastConsensusTime",
    "pt": "Computations",
    "t": 1,
    "c": "lastConsensusTime"
  },
  {
    "objectID": "/rsh/compute/#term_lastConsensusSecs",
    "pt": "Computations",
    "t": 1,
    "c": "lastConsensusSecs"
  },
  {
    "objectID": "/rsh/compute/#term_thisConsensusTime",
    "pt": "Computations",
    "t": 1,
    "c": "thisConsensusTime"
  },
  {
    "objectID": "/rsh/compute/#term_thisConsensusSecs",
    "pt": "Computations",
    "t": 1,
    "c": "thisConsensusSecs"
  },
  {
    "objectID": "/rsh/compute/#term_time%20arguments",
    "pt": "Computations",
    "t": 1,
    "c": "time arguments"
  },
  {
    "objectID": "/rsh/compute/#ref-programs-compute",
    "pt": "Computations",
    "t": 2,
    "c": "Computations"
  },
  {
    "objectID": "/rsh/compute/#comments",
    "pt": "Computations",
    "t": 2,
    "c": "Comments"
  },
  {
    "objectID": "/rsh/compute/#blocks",
    "pt": "Computations",
    "t": 2,
    "c": "Blocks"
  },
  {
    "objectID": "/rsh/compute/#ref-programs-compute-stmts",
    "pt": "Computations",
    "t": 2,
    "c": "Statements"
  },
  {
    "objectID": "/rsh/compute/#const--and--function",
    "pt": "Computations",
    "t": 2,
    "c": "const and function"
  },
  {
    "objectID": "/rsh/compute/#return",
    "pt": "Computations",
    "t": 2,
    "c": "return"
  },
  {
    "objectID": "/rsh/compute/#if",
    "pt": "Computations",
    "t": 2,
    "c": "if"
  },
  {
    "objectID": "/rsh/compute/#switch",
    "pt": "Computations",
    "t": 2,
    "c": "switch"
  },
  {
    "objectID": "/rsh/compute/#block-statements",
    "pt": "Computations",
    "t": 2,
    "c": "Block statements"
  },
  {
    "objectID": "/rsh/compute/#trycatch--throw-statements",
    "pt": "Computations",
    "t": 2,
    "c": "Try/Catch & Throw Statements"
  },
  {
    "objectID": "/rsh/compute/#use-strict",
    "pt": "Computations",
    "t": 2,
    "c": "'use strict'"
  },
  {
    "objectID": "/rsh/compute/#expression-statements",
    "pt": "Computations",
    "t": 2,
    "c": "Expression statements"
  },
  {
    "objectID": "/rsh/compute/#ref-programs-compute-exprs",
    "pt": "Computations",
    "t": 2,
    "c": "Expressions"
  },
  {
    "objectID": "/rsh/compute/#unstrict",
    "pt": "Computations",
    "t": 2,
    "c": "unstrict"
  },
  {
    "objectID": "/rsh/compute/#identifier-reference",
    "pt": "Computations",
    "t": 2,
    "c": "Identifier reference"
  },
  {
    "objectID": "/rsh/compute/#function-application",
    "pt": "Computations",
    "t": 2,
    "c": "Function application"
  },
  {
    "objectID": "/rsh/compute/#ref-programs-types",
    "pt": "Computations",
    "t": 2,
    "c": "Types"
  },
  {
    "objectID": "/rsh/compute/#literal-values",
    "pt": "Computations",
    "t": 2,
    "c": "Literal values"
  },
  {
    "objectID": "/rsh/compute/#operator-expression",
    "pt": "Computations",
    "t": 2,
    "c": "Operator expression"
  },
  {
    "objectID": "/rsh/compute/#numeric-casting",
    "pt": "Computations",
    "t": 2,
    "c": "Numeric Casting"
  },
  {
    "objectID": "/rsh/compute/#string-conversion",
    "pt": "Computations",
    "t": 2,
    "c": "String Conversion"
  },
  {
    "objectID": "/rsh/compute/#contract-and-address-comparisons",
    "pt": "Computations",
    "t": 2,
    "c": "Contract and Address Comparisons"
  },
  {
    "objectID": "/rsh/compute/#boolxor",
    "pt": "Computations",
    "t": 2,
    "c": "boolXor"
  },
  {
    "objectID": "/rsh/compute/#padding",
    "pt": "Computations",
    "t": 2,
    "c": "Padding"
  },
  {
    "objectID": "/rsh/compute/#bytesfromhex",
    "pt": "Computations",
    "t": 2,
    "c": "Bytes.fromHex"
  },
  {
    "objectID": "/rsh/compute/#bytes-concatenation",
    "pt": "Computations",
    "t": 2,
    "c": "Bytes Concatenation"
  },
  {
    "objectID": "/rsh/compute/#string-concatenation",
    "pt": "Computations",
    "t": 2,
    "c": "String Concatenation"
  },
  {
    "objectID": "/rsh/compute/#parenthesized-expression",
    "pt": "Computations",
    "t": 2,
    "c": "Parenthesized expression"
  },
  {
    "objectID": "/rsh/compute/#ref-programs-tuples",
    "pt": "Computations",
    "t": 2,
    "c": "Tuples"
  },
  {
    "objectID": "/rsh/compute/#ref-programs-arrays",
    "pt": "Computations",
    "t": 2,
    "c": "Arrays"
  },
  {
    "objectID": "/rsh/compute/#element-reference",
    "pt": "Computations",
    "t": 2,
    "c": "Element reference"
  },
  {
    "objectID": "/rsh/compute/#array--tuple-length--tuplelength---arraylength--and--length",
    "pt": "Computations",
    "t": 2,
    "c": "Array & tuple length: Tuple.length, Array.length, and .length"
  },
  {
    "objectID": "/rsh/compute/#array--tuple-update--tupleset---arrayset--and--set",
    "pt": "Computations",
    "t": 2,
    "c": "Array & tuple update: Tuple.set, Array.set, and .set"
  },
  {
    "objectID": "/rsh/compute/#array-element-type--arrayelemtype--and--elemtype",
    "pt": "Computations",
    "t": 2,
    "c": "Array element type: Array.elemType and .elemType"
  },
  {
    "objectID": "/rsh/compute/#foldable-operations",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable operations"
  },
  {
    "objectID": "/rsh/compute/#foldableforeach----foreach",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.forEach && .forEach"
  },
  {
    "objectID": "/rsh/compute/#foldableall----all",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.all && .all"
  },
  {
    "objectID": "/rsh/compute/#foldableany----any",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.any && .any"
  },
  {
    "objectID": "/rsh/compute/#foldableor----or",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.or && .or"
  },
  {
    "objectID": "/rsh/compute/#foldableand----and",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.and && .and"
  },
  {
    "objectID": "/rsh/compute/#foldableincludes----includes",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.includes && .includes"
  },
  {
    "objectID": "/rsh/compute/#foldablecount----count",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.count && .count"
  },
  {
    "objectID": "/rsh/compute/#foldablesize----size",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.size && .size"
  },
  {
    "objectID": "/rsh/compute/#foldablemin----min",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.min && .min"
  },
  {
    "objectID": "/rsh/compute/#foldablemax----max",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.max && .max"
  },
  {
    "objectID": "/rsh/compute/#foldablesum----sum",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.sum && .sum"
  },
  {
    "objectID": "/rsh/compute/#foldableproduct----product",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.product && .product"
  },
  {
    "objectID": "/rsh/compute/#foldableaverage----average",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.average && .average"
  },
  {
    "objectID": "/rsh/compute/#foldableimin----foldableimax",
    "pt": "Computations",
    "t": 2,
    "c": "Foldable.imin && Foldable.imax"
  },
  {
    "objectID": "/rsh/compute/#array-group-operations",
    "pt": "Computations",
    "t": 2,
    "c": "Array group operations"
  },
  {
    "objectID": "/rsh/compute/#arrayiota",
    "pt": "Computations",
    "t": 2,
    "c": "Array.iota"
  },
  {
    "objectID": "/rsh/compute/#arrayreplicate",
    "pt": "Computations",
    "t": 2,
    "c": "Array.replicate"
  },
  {
    "objectID": "/rsh/compute/#arrayconcat----concat",
    "pt": "Computations",
    "t": 2,
    "c": "Array.concat && .concat"
  },
  {
    "objectID": "/rsh/compute/#arrayempty",
    "pt": "Computations",
    "t": 2,
    "c": "Array.empty"
  },
  {
    "objectID": "/rsh/compute/#arrayzip----zip",
    "pt": "Computations",
    "t": 2,
    "c": "Array.zip && .zip"
  },
  {
    "objectID": "/rsh/compute/#arraymap----map",
    "pt": "Computations",
    "t": 2,
    "c": "Array.map && .map"
  },
  {
    "objectID": "/rsh/compute/#arraymapwithindex----mapwithindex",
    "pt": "Computations",
    "t": 2,
    "c": "Array.mapWithIndex && .mapWithIndex"
  },
  {
    "objectID": "/rsh/compute/#arrayforeachwithindex----foreachwithindex",
    "pt": "Computations",
    "t": 2,
    "c": "Array.forEachWithIndex && .forEachWithIndex"
  },
  {
    "objectID": "/rsh/compute/#arrayreduce----reduce",
    "pt": "Computations",
    "t": 2,
    "c": "Array.reduce && .reduce"
  },
  {
    "objectID": "/rsh/compute/#arrayreducewithindex----reducewithindex",
    "pt": "Computations",
    "t": 2,
    "c": "Array.reduceWithIndex && .reduceWithIndex"
  },
  {
    "objectID": "/rsh/compute/#arrayindexof----indexof",
    "pt": "Computations",
    "t": 2,
    "c": "Array.indexOf && .indexOf"
  },
  {
    "objectID": "/rsh/compute/#arrayfindindex----findindex",
    "pt": "Computations",
    "t": 2,
    "c": "Array.findIndex && .findIndex"
  },
  {
    "objectID": "/rsh/compute/#arrayfind----find",
    "pt": "Computations",
    "t": 2,
    "c": "Array.find && .find"
  },
  {
    "objectID": "/rsh/compute/#arraywithindex----withindex",
    "pt": "Computations",
    "t": 2,
    "c": "Array.withIndex && .withIndex"
  },
  {
    "objectID": "/rsh/compute/#arrayslice----slice",
    "pt": "Computations",
    "t": 2,
    "c": "Array.slice && .slice"
  },
  {
    "objectID": "/rsh/compute/#mapping-group-operations",
    "pt": "Computations",
    "t": 2,
    "c": "Mapping group operations"
  },
  {
    "objectID": "/rsh/compute/#mapreduce----reduce",
    "pt": "Computations",
    "t": 2,
    "c": "Map.reduce && .reduce"
  },
  {
    "objectID": "/rsh/compute/#mapreducewithkey----reducewithkey",
    "pt": "Computations",
    "t": 2,
    "c": "Map.reduceWithKey && .reduceWithKey"
  },
  {
    "objectID": "/rsh/compute/#ref-programs-objects",
    "pt": "Computations",
    "t": 2,
    "c": "Objects"
  },
  {
    "objectID": "/rsh/compute/#field-reference",
    "pt": "Computations",
    "t": 2,
    "c": "Field reference"
  },
  {
    "objectID": "/rsh/compute/#objectfields",
    "pt": "Computations",
    "t": 2,
    "c": "Object.fields"
  },
  {
    "objectID": "/rsh/compute/#objectset",
    "pt": "Computations",
    "t": 2,
    "c": "Object.set"
  },
  {
    "objectID": "/rsh/compute/#objectsetifunset",
    "pt": "Computations",
    "t": 2,
    "c": "Object.setIfUnset"
  },
  {
    "objectID": "/rsh/compute/#objecthas",
    "pt": "Computations",
    "t": 2,
    "c": "Object.has"
  },
  {
    "objectID": "/rsh/compute/#ref-programs-structs",
    "pt": "Computations",
    "t": 2,
    "c": "Structs"
  },
  {
    "objectID": "/rsh/compute/#ref-programs-data",
    "pt": "Computations",
    "t": 2,
    "c": "Data"
  },
  {
    "objectID": "/rsh/compute/#maybe",
    "pt": "Computations",
    "t": 2,
    "c": "Maybe"
  },
  {
    "objectID": "/rsh/compute/#either",
    "pt": "Computations",
    "t": 2,
    "c": "Either"
  },
  {
    "objectID": "/rsh/compute/#match",
    "pt": "Computations",
    "t": 2,
    "c": "match"
  },
  {
    "objectID": "/rsh/compute/#conditional-expression",
    "pt": "Computations",
    "t": 2,
    "c": "Conditional expression"
  },
  {
    "objectID": "/rsh/compute/#arrow-expression",
    "pt": "Computations",
    "t": 2,
    "c": "Arrow expression"
  },
  {
    "objectID": "/rsh/compute/#makeenum",
    "pt": "Computations",
    "t": 2,
    "c": "makeEnum"
  },
  {
    "objectID": "/rsh/compute/#assert",
    "pt": "Computations",
    "t": 2,
    "c": "assert"
  },
  {
    "objectID": "/rsh/compute/#check",
    "pt": "Computations",
    "t": 2,
    "c": "check"
  },
  {
    "objectID": "/rsh/compute/#enforce",
    "pt": "Computations",
    "t": 2,
    "c": "enforce"
  },
  {
    "objectID": "/rsh/compute/#forall",
    "pt": "Computations",
    "t": 2,
    "c": "forall"
  },
  {
    "objectID": "/rsh/compute/#possible",
    "pt": "Computations",
    "t": 2,
    "c": "possible"
  },
  {
    "objectID": "/rsh/compute/#digest",
    "pt": "Computations",
    "t": 2,
    "c": "digest"
  },
  {
    "objectID": "/rsh/compute/#balance",
    "pt": "Computations",
    "t": 2,
    "c": "balance"
  },
  {
    "objectID": "/rsh/compute/#getcontract",
    "pt": "Computations",
    "t": 2,
    "c": "getContract"
  },
  {
    "objectID": "/rsh/compute/#getaddress",
    "pt": "Computations",
    "t": 2,
    "c": "getAddress"
  },
  {
    "objectID": "/rsh/compute/#getcompanion",
    "pt": "Computations",
    "t": 2,
    "c": "getCompanion"
  },
  {
    "objectID": "/rsh/compute/#lastconsensustime--and--lastconsensussecs",
    "pt": "Computations",
    "t": 2,
    "c": "lastConsensusTime and lastConsensusSecs"
  },
  {
    "objectID": "/rsh/compute/#thisconsensustime--and--thisconsensussecs",
    "pt": "Computations",
    "t": 2,
    "c": "thisConsensusTime and thisConsensusSecs"
  },
  {
    "objectID": "/rsh/compute/#basewaittime--and--basewaitsecs",
    "pt": "Computations",
    "t": 2,
    "c": "baseWaitTime and baseWaitSecs"
  },
  {
    "objectID": "/rsh/compute/#time-arguments----relativetime---absolutetime---relativesecs---absolutesecs",
    "pt": "Computations",
    "t": 2,
    "c": "Time arguments - relativeTime, absoluteTime, relativeSecs, absoluteSecs"
  },
  {
    "objectID": "/rsh/compute/#time-verification----verifyrelativetime---verifyabsolutetime---verifyrelativesecs---verifyabsolutesecs",
    "pt": "Computations",
    "t": 2,
    "c": "Time verification - verifyRelativeTime, verifyAbsoluteTime, verifyRelativeSecs, verifyAbsoluteSecs"
  },
  {
    "objectID": "/rsh/compute/#makedeadline",
    "pt": "Computations",
    "t": 2,
    "c": "makeDeadline"
  },
  {
    "objectID": "/rsh/compute/#implies",
    "pt": "Computations",
    "t": 2,
    "c": "implies"
  },
  {
    "objectID": "/rsh/compute/#ensure",
    "pt": "Computations",
    "t": 2,
    "c": "ensure"
  },
  {
    "objectID": "/rsh/compute/#hasrandom",
    "pt": "Computations",
    "t": 2,
    "c": "hasRandom"
  },
  {
    "objectID": "/rsh/compute/#hasconsolelogger",
    "pt": "Computations",
    "t": 2,
    "c": "hasConsoleLogger"
  },
  {
    "objectID": "/rsh/compute/#compose",
    "pt": "Computations",
    "t": 2,
    "c": "compose"
  },
  {
    "objectID": "/rsh/compute/#muldiv",
    "pt": "Computations",
    "t": 2,
    "c": "muldiv"
  },
  {
    "objectID": "/rsh/compute/#verimuldiv",
    "pt": "Computations",
    "t": 2,
    "c": "veriMuldiv"
  },
  {
    "objectID": "/rsh/compute/#safemuldiv",
    "pt": "Computations",
    "t": 2,
    "c": "safeMuldiv"
  },
  {
    "objectID": "/rsh/compute/#verifymuldiv",
    "pt": "Computations",
    "t": 2,
    "c": "verifyMuldiv"
  },
  {
    "objectID": "/rsh/compute/#sqrt",
    "pt": "Computations",
    "t": 2,
    "c": "sqrt"
  },
  {
    "objectID": "/rsh/compute/#sqrtapprox",
    "pt": "Computations",
    "t": 2,
    "c": "sqrtApprox"
  },
  {
    "objectID": "/rsh/compute/#pow",
    "pt": "Computations",
    "t": 2,
    "c": "pow"
  },
  {
    "objectID": "/rsh/compute/#signed-integers",
    "pt": "Computations",
    "t": 2,
    "c": "Signed Integers"
  },
  {
    "objectID": "/rsh/compute/#fixed-point-numbers",
    "pt": "Computations",
    "t": 2,
    "c": "Fixed-Point Numbers"
  },
  {
    "objectID": "/rsh/compute/#anybody",
    "pt": "Computations",
    "t": 2,
    "c": "Anybody"
  },
  {
    "objectID": "/rsh/compute/#intervals",
    "pt": "Computations",
    "t": 2,
    "c": "Intervals"
  },
  {
    "objectID": "/rsh/compute/#constructors",
    "pt": "Computations",
    "t": 2,
    "c": "Constructors"
  },
  {
    "objectID": "/rsh/compute/#accessors",
    "pt": "Computations",
    "t": 2,
    "c": "Accessors"
  },
  {
    "objectID": "/rsh/compute/#relational-operations",
    "pt": "Computations",
    "t": 2,
    "c": "Relational Operations"
  },
  {
    "objectID": "/rsh/compute/#arithmetic-operations",
    "pt": "Computations",
    "t": 2,
    "c": "Arithmetic Operations"
  },
  {
    "objectID": "/rsh/compute/#other-operations",
    "pt": "Computations",
    "t": 2,
    "c": "Other Operations"
  },
  {
    "objectID": "/rsh/compute/#getuntrackedfunds",
    "pt": "Computations",
    "t": 2,
    "c": "getUntrackedFunds"
  },
  {
    "objectID": "/rsh/compute/#distinct",
    "pt": "Computations",
    "t": 2,
    "c": "distinct"
  },
  {
    "objectID": "/rsh/compute/#currentmode",
    "pt": "Computations",
    "t": 2,
    "c": "currentMode"
  },
  {
    "objectID": "/rsh/compute/#mixin",
    "pt": "Computations",
    "t": 2,
    "c": "mixin"
  },
  {
    "objectID": "/rsh/compute/#p_0",
    "pt": "Computations",
    "t": 3,
    "c": "This section describes the common features available in all Reach contexts."
  },
  {
    "objectID": "/rsh/compute/#p_1",
    "pt": "Computations",
    "t": 3,
    "c": "Comments are text that is ignored by the compiler. Text starting with // up until the end of the line forms a single-line comment. Text enclosed with /* and */ forms a multi-line comment. It is invalid to nest a multi-line comment within a multi-line comment."
  },
  {
    "objectID": "/rsh/compute/#p_2",
    "pt": "Computations",
    "t": 3,
    "c": "A block is a sequence of statements surrounded by braces, i.e. { and }."
  },
  {
    "objectID": "/rsh/compute/#p_3",
    "pt": "Computations",
    "t": 3,
    "c": "This section describes the statements which are allowed in any Reach context."
  },
  {
    "objectID": "/rsh/compute/#p_4",
    "pt": "Computations",
    "t": 3,
    "c": "Each statement affects the meaning of the subsequent statements, which is called its tail. For example, if {!rsh} {X; Y; Z;} is a block, then {!rsh} X's tail is {!rsh} {Y; Z;} and {!rsh} Y's tail is {!rsh} {Z;}."
  },
  {
    "objectID": "/rsh/compute/#p_5",
    "pt": "Computations",
    "t": 3,
    "c": "Distinct from tails are continuations which include everything after the statement. For example, in {!rsh} { {X; Y;}; Z;}, {!rsh} X's tail is just {!rsh} Y, but its continuation is {!rsh} {Y;}; Z;."
  },
  {
    "objectID": "/rsh/compute/#p_6",
    "pt": "Computations",
    "t": 3,
    "c": "Tails are statically apparent from the structure of the program source code, while continuations are influenced by function calls."
  },
  {
    "objectID": "/rsh/compute/#p_7",
    "pt": "Computations",
    "t": 3,
    "c": "A sequence of statements that does not end in a terminator statement (a statement with no tail), such as a return statement, continue statement, or exit statement is treated as if it ended with {!rsh} return null;."
  },
  {
    "objectID": "/rsh/compute/#p_8",
    "pt": "Computations",
    "t": 3,
    "c": "The remainder of this section enumerates each kind of statement."
  },
  {
    "objectID": "/rsh/compute/#p_9",
    "pt": "Computations",
    "t": 3,
    "c": "An identifier definition is either a value definition or a function definition. Each of these introduces one or more bound identifiers."
  },
  {
    "objectID": "/rsh/compute/#p_10",
    "pt": "Computations",
    "t": 3,
    "c": "Valid identifiers follow the same rules as JavaScript identifiers: they may consist of Unicode alphanumeric characters, or {!rsh} _ or {!rsh} $, but may not begin with a digit."
  },
  {
    "objectID": "/rsh/compute/#p_11",
    "pt": "Computations",
    "t": 3,
    "c": "A value definition is written {!rsh} const LHS = RHS;."
  },
  {
    "objectID": "/rsh/compute/#p_12",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} LHS must obey the grammar:"
  },
  {
    "objectID": "/rsh/compute/#p_13",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} RHS must be compatible with the given {!rsh} LHS. That is, if a {!rsh} LHS is an LHS-tuple-seq, then the corresponding {!rsh} RHS must be a tuple with the correct number of elements. If a {!rsh} LHS is an LHS-obj-seq, then the corresponding {!rsh} RHS must be an object with the correct fields."
  },
  {
    "objectID": "/rsh/compute/#p_14",
    "pt": "Computations",
    "t": 3,
    "c": "Those values are available as their corresponding bound identifiers in the statement's tail."
  },
  {
    "objectID": "/rsh/compute/#p_15",
    "pt": "Computations",
    "t": 3,
    "c": "A function definition, written {!rsh} function FUN(LHS_0, ..., LHS_n) BLOCK;, defines {!rsh} FUN as a function which abstracts its function body, the block {!rsh} BLOCK, over the left-hand sides {!rsh} LHS_0 through {!rsh} LHS_n."
  },
  {
    "objectID": "/rsh/compute/#p_16",
    "pt": "Computations",
    "t": 3,
    "c": "Function parameters may specify default arguments. The expressions used to instantiate these parameters have access to any variables in the scope of which the function was defined. Additionally, these expressions may reference previous arguments of the function definition. Parameters with default arguments must come after all other parameters."
  },
  {
    "objectID": "/rsh/compute/#p_17",
    "pt": "Computations",
    "t": 3,
    "c": "The last parameter of a function may be a rest parameter, which allows the function to be called with an arbitrary number of arguments. A rest parameter is specified via {!rsh} ...IDENT, where {!rsh} IDENT is bound to a {!rsh} Tuple containing all the remaining arguments."
  },
  {
    "objectID": "/rsh/compute/#p_18",
    "pt": "Computations",
    "t": 3,
    "c": "All identifiers in Reach programs must be unbound at the position of the program where they are bound, i.e., it is invalid to shadow identifiers with new definitions. For example,"
  },
  {
    "objectID": "/rsh/compute/#p_19",
    "pt": "Computations",
    "t": 3,
    "c": "is invalid. This restriction is independent of whether a binding is only known to a single participant. For example,"
  },
  {
    "objectID": "/rsh/compute/#p_20",
    "pt": "Computations",
    "t": 3,
    "c": "is invalid."
  },
  {
    "objectID": "/rsh/compute/#p_21",
    "pt": "Computations",
    "t": 3,
    "c": "The special identifier {!rsh} _ is an exception to this rule. The {!rsh} _ binding is always considered to be unbound. This means means that {!rsh} _ is both an identifier that can never be read, as well as an identifier that may be bound many times. This may be useful for ignoring unwanted values, for example:"
  },
  {
    "objectID": "/rsh/compute/#p_22",
    "pt": "Computations",
    "t": 3,
    "c": "A return statement, written {!rsh} return EXPR;, where {!rsh} EXPR is an expression, evaluates to the same value as {!rsh} EXPR. As a special case, {!rsh} return; is interpreted the same as {!rsh} return null;."
  },
  {
    "objectID": "/rsh/compute/#p_23",
    "pt": "Computations",
    "t": 3,
    "c": "A return statement returns its value to the surrounding function application."
  },
  {
    "objectID": "/rsh/compute/#p_24",
    "pt": "Computations",
    "t": 3,
    "c": "A return statement is a terminator statement, so it must have an empty tail. For example,"
  },
  {
    "objectID": "/rsh/compute/#p_25",
    "pt": "Computations",
    "t": 3,
    "c": "is invalid, because the first {!rsh} return's tail is not empty."
  },
  {
    "objectID": "/rsh/compute/#p_26",
    "pt": "Computations",
    "t": 3,
    "c": "Furthermore, a {!rsh} return must have an empty continuation (i.e. it must be in tail position.)"
  },
  {
    "objectID": "/rsh/compute/#p_27",
    "pt": "Computations",
    "t": 3,
    "c": "A conditional statement, written {!rsh} if (COND) NOT_FALSE else FALSE, where {!rsh} COND is an expression and {!rsh} NOT_FALSE and {!rsh} FALSE as statements (potentially block statements), selects between the {!rsh} NOT_FALSE statement and {!rsh} FALSE statement based on whether {!rsh} COND evaluates to {!rsh} false."
  },
  {
    "objectID": "/rsh/compute/#p_28",
    "pt": "Computations",
    "t": 3,
    "c": "Both {!rsh} NOT_FALSE and {!rsh} FALSE have empty tails, i.e. the tail of the conditional statement is not propagated. For example,"
  },
  {
    "objectID": "/rsh/compute/#p_29",
    "pt": "Computations",
    "t": 3,
    "c": "is erroneous, because the identifier {!rsh} z is not bound outside the conditional statement."
  },
  {
    "objectID": "/rsh/compute/#p_30",
    "pt": "Computations",
    "t": 3,
    "c": "A conditional statement may only include a consensus transfer in {!rsh} NOT_FALSE or {!rsh} FALSE if it is within a consensus step, because its statements are in the same context as the conditional statement itself."
  },
  {
    "objectID": "/rsh/compute/#p_31",
    "pt": "Computations",
    "t": 3,
    "c": "If one branch of a conditional contains a {!rsh} return, then both must."
  },
  {
    "objectID": "/rsh/compute/#p_32",
    "pt": "Computations",
    "t": 3,
    "c": "A switch statement, written {!rsh} switch (VAR) { CASE ... }, where {!rsh} VAR is a variable bound to a data instance and {!rsh} CASE is either {!rsh} case VARIANT: STMT ..., where {!rsh} VARIANT is a variant, or {!rsh} default: STMT ..., and {!rsh} STMT is a sequence of statements, selects the appropriate sequence of statements based on which variant {!rsh} VAR holds. Within the body of a {!rsh} switch case, {!rsh} VAR has the type of variant; i.e. in a {!rsh} Some case of a {!rsh} Maybe(UInt) {!rsh} switch, the variable is bound to an integer."
  },
  {
    "objectID": "/rsh/compute/#p_33",
    "pt": "Computations",
    "t": 3,
    "c": "All cases have empty tails, i.e. the tail of the switch statement is not propagated."
  },
  {
    "objectID": "/rsh/compute/#p_34",
    "pt": "Computations",
    "t": 3,
    "c": "A switch statement may only include a consensus transfer in its cases if it is within a consensus step, because its statements are in the same context as the conditional statement itself."
  },
  {
    "objectID": "/rsh/compute/#p_35",
    "pt": "Computations",
    "t": 3,
    "c": "It is invalid for a case to appear multiple times, or be missing, or to be superfluous (i.e. for a variant that does not exist in the {!rsh} Data type of {!rsh} VAR)."
  },
  {
    "objectID": "/rsh/compute/#p_36",
    "pt": "Computations",
    "t": 3,
    "c": "If one case of a {!rsh} switch contains a {!rsh} return, then all must."
  },
  {
    "objectID": "/rsh/compute/#p_37",
    "pt": "Computations",
    "t": 3,
    "c": "A block statement is when a block occurs in a statement position, then it establishes a local, separate scope for the definitions of identifiers within that block. In other words, the block is evaluated for effect, but the tail of the statements within the block are isolated from the surrounding tail. For example,"
  },
  {
    "objectID": "/rsh/compute/#p_38",
    "pt": "Computations",
    "t": 3,
    "c": "evaluates to {!rsh} 4, but"
  },
  {
    "objectID": "/rsh/compute/#p_39",
    "pt": "Computations",
    "t": 3,
    "c": "is erroneous, because the identifier {!rsh} x is not bound outside the block statement."
  },
  {
    "objectID": "/rsh/compute/#p_40",
    "pt": "Computations",
    "t": 3,
    "c": "A try statement, written {!rsh} try BLOCK catch (VAR) BLOCK, allows a block of code to execute with a specified handler should an exception be thrown."
  },
  {
    "objectID": "/rsh/compute/#p_41",
    "pt": "Computations",
    "t": 3,
    "c": "A throw statement, written {!rsh} throw EXPR, will transfer control flow to the exception handler, binding EXPR to VAR. Any value that is able to exist at runtime may be thrown. For example, {!rsh} Ints and {!rsh} Arrays are valid values to throw, but a function is not. A {!rsh} throw must have an empty tail."
  },
  {
    "objectID": "/rsh/compute/#p_42",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} 'use strict' enables unused variables checks for all subsequent declarations within the current scope. If a variable is declared, but never used, there will be an error emitted at compile time."
  },
  {
    "objectID": "/rsh/compute/#p_43",
    "pt": "Computations",
    "t": 3,
    "c": "strict mode will reject some code that is normally valid and limit how dynamic Reach's type system is. For example, normally Reach will permit expressions like the following to be evaluated:"
  },
  {
    "objectID": "/rsh/compute/#p_44",
    "pt": "Computations",
    "t": 3,
    "c": "Reach allows {!rsh} o to be either an object with a {!rsh} b field or {!rsh} false because it partially evaluates the program at compile time. So, without {!rsh} 'use strict', Reach will not evaluate {!rsh} o.b when {!rsh} o = false and this code will compile successfully."
  },
  {
    "objectID": "/rsh/compute/#p_45",
    "pt": "Computations",
    "t": 3,
    "c": "But, in strict mode, Reach will ensure that this program treats {!rsh} o as having a single type and detect an error in the program as follows:"
  },
  {
    "objectID": "/rsh/compute/#p_46",
    "pt": "Computations",
    "t": 3,
    "c": "The correct way to write a program like this in strict mode is to use {!rsh} Maybe. Like this:"
  },
  {
    "objectID": "/rsh/compute/#p_47",
    "pt": "Computations",
    "t": 3,
    "c": "An expression, {!rsh} E, in a statement position is equivalent to the block statement {!rsh} { return E; }."
  },
  {
    "objectID": "/rsh/compute/#p_48",
    "pt": "Computations",
    "t": 3,
    "c": "This section describes the expressions which are allowed in any Reach context. There are a large variety of different expressions in Reach programs."
  },
  {
    "objectID": "/rsh/compute/#p_49",
    "pt": "Computations",
    "t": 3,
    "c": "The remainder of this section enumerates each kind of expression."
  },
  {
    "objectID": "/rsh/compute/#p_50",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} unstrict applies a thunk, ignoring any usage of strict mode. This can be useful when dealing with libraries that are written in strict mode."
  },
  {
    "objectID": "/rsh/compute/#p_51",
    "pt": "Computations",
    "t": 3,
    "c": "An identifier, written {!rsh} ID, is an expression that evaluates to the value of the bound identifier."
  },
  {
    "objectID": "/rsh/compute/#p_52",
    "pt": "Computations",
    "t": 3,
    "c": "The identifier {!rsh} this has a special meaning inside of a local step (i.e. the body of an {!rsh} only or {!rsh} each expression), as well as in a consensus step (i.e. the tail of {!rsh} publish or {!rsh} pay statement and before a {!rsh} commit statement). For details, see this and this."
  },
  {
    "objectID": "/rsh/compute/#p_53",
    "pt": "Computations",
    "t": 3,
    "c": "A function application, written {!rsh} EXPR_rator(EXPR_rand_0, ..., EXPR_rand_n), is an expression where {!rsh} EXPR_rator and {!rsh} EXPR_rand_0 through {!rsh} EXPR_rand_n are expressions that evaluate to one value. {!rsh} EXPR_rator must evaluate to an abstraction over {!rsh} n values or a primitive of arity {!rsh} n. A spread expression ({!rsh} ...expr) may appear in the list of operands to a function application, in which case the elements of the expr are spliced in place. {!rsh} EXPR_rator and {!rsh} EXPR_rand_n are evaluated in left-to-right order, starting with {!rsh} EXPR_rator, then {!rsh} EXPR_rand_0, {!rsh} EXPR_rand_1, etc."
  },
  {
    "objectID": "/rsh/compute/#p_54",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} new f(a) is equivalent to {!rsh} f.new(a) and is a convenient short-hand for writing class-oriented programs."
  },
  {
    "objectID": "/rsh/compute/#p_55",
    "pt": "Computations",
    "t": 3,
    "c": "Reach's types are represented in programs by the following identifiers and constructors:"
  },
  {
    "objectID": "/rsh/compute/#p_56",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Null."
  },
  {
    "objectID": "/rsh/compute/#p_57",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Bool, which denotes a boolean."
  },
  {
    "objectID": "/rsh/compute/#p_58",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} UInt, which denotes an unsigned integer. {!rsh} UInt.max is the largest value that may be assigned to a {!rsh} UInt."
  },
  {
    "objectID": "/rsh/compute/#p_59",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} UInt256, which denotes an unsigned integer with 256 bits. {!rsh} UInt256.max is the largest value that may be assigned to a {!rsh} UInt256."
  },
  {
    "objectID": "/rsh/compute/#p_60",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Int, which denotes a signed integer."
  },
  {
    "objectID": "/rsh/compute/#p_61",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} FixedPoint, which denotes a fractional number."
  },
  {
    "objectID": "/rsh/compute/#p_62",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Bytes(length), which denotes a sequence of bytes of length at most {!rsh} length. Bytes of different lengths are not compatible; however the shorter bytes may be padded."
  },
  {
    "objectID": "/rsh/compute/#p_63",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} BytesDyn, which denotes a sequence of bytes of dynamic length. Bytes of fixed length and bytes of dynamic length are totally incompatible, but bytes of fixed length can be casted into {!rsh} BytesDyn with {!rsh} BytesDyn applied as a function."
  },
  {
    "objectID": "/rsh/compute/#p_64",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} StringDyn, which denotes a string of UTF-8 code points of dynamic length. Strings and bytes are totally incompatible, but static bytes can be casted into dynamic strings with {!rsh} StringDyn applied as function."
  },
  {
    "objectID": "/rsh/compute/#p_65",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Digest, which denotes a digest."
  },
  {
    "objectID": "/rsh/compute/#p_66",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Address, which denotes an account address."
  },
  {
    "objectID": "/rsh/compute/#p_67",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Contract, which denotes the identifying information of a contract."
  },
  {
    "objectID": "/rsh/compute/#p_68",
    "pt": "Computations",
    "t": 3,
    "c": "Reach has different representations of contracts across connectors. For example, on Algorand a {!rsh} Contract is an Application ID, but on Ethereum it is an Address."
  },
  {
    "objectID": "/rsh/compute/#p_69",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Token, which denotes a non-network token. Networks discusses how {!rsh} Tokens are represented on specific networks."
  },
  {
    "objectID": "/rsh/compute/#p_70",
    "pt": "Computations",
    "t": 3,
    "c": "Reach assumes that every {!rsh} Token in your program refers to a different non-network token. It will automatically insert {!rsh} require statements that enforce this constraint."
  },
  {
    "objectID": "/rsh/compute/#p_71",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Fun([Domain_0, ..., Domain_N], Range), which denotes a function type, when {!rsh} Domain_i and {!rsh} Range are types. The domain of a function is negative position. The range of a function is positive position."
  },
  {
    "objectID": "/rsh/compute/#p_72",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Fun(true, Range), which denotes an unconstrained domain function type, when {!rsh} Range is a type. These functions may only appear in participant interact interfaces."
  },
  {
    "objectID": "/rsh/compute/#p_73",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Tuple(Field_0, ..., FieldN), which denotes a tuple. (Refer to Tuples for constructing tuples.)"
  },
  {
    "objectID": "/rsh/compute/#p_74",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Object({key_0: Type_0, ..., key_N: Type_N}), which denotes an object. (Refer to Objects for constructing objects.)"
  },
  {
    "objectID": "/rsh/compute/#p_75",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Struct([[key_0, Type_0], ..., [key_N, Type_N]]), which denotes a struct. (Refer to Structs for constructing structs.)"
  },
  {
    "objectID": "/rsh/compute/#p_76",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array(Type_0, size), which denotes a statically-sized array. {!rsh} Type_0 must be a type that can exist at runtime (i.e., not a function type.) (Refer to Arrays for constructing arrays.)"
  },
  {
    "objectID": "/rsh/compute/#p_77",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Data({variant_0: Type_0, ..., variant_N: Type_N}), which denotes a tagged union (or sum type). (Refer to Data for constructing data instances.)"
  },
  {
    "objectID": "/rsh/compute/#p_78",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Refine(Type_0, Predicate, ?Message), where {!rsh} Predicate is a unary function returning a boolean, which denotes a refinement type, that is instances of {!rsh} Type_0 that satisfy {!rsh} Predicate. When a refinement type appears in a negative position (such as in an {!rsh} is or in the domain of a {!rsh} Fun of a participant interact interface), it introduces an {!rsh} assert; while when it is in a positive position, it introduces an {!rsh} assume. {!rsh} Message is an optional string to display if the predicate fails verification."
  },
  {
    "objectID": "/rsh/compute/#p_79",
    "pt": "Computations",
    "t": 3,
    "c": "For example, if {!rsh} f had type"
  },
  {
    "objectID": "/rsh/compute/#p_80",
    "pt": "Computations",
    "t": 3,
    "c": "then {!rsh} const z = f(y) is equivalent to"
  },
  {
    "objectID": "/rsh/compute/#p_81",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Refine(Type_0, PreCondition, PostCondition, ?Messages), where {!rsh} Type_0 is a function type, {!rsh} PreCondition is a unary function that accepts a tuple of the domain and returns a boolean, and {!rsh} PostCondition is a binary function that accepts a tuple of the domain and the range and returns a boolean, denotes a function type with a precondition and postcondition. Preconditions are enforced with {!rsh} assert and postconditions are enforced with {!rsh} assume. {!rsh} Messages is an optional two-tuple of {!rsh} Bytes. The first message will be displayed when the precondition fails verification and the second when the postcondition fails verification."
  },
  {
    "objectID": "/rsh/compute/#p_82",
    "pt": "Computations",
    "t": 3,
    "c": "For example, {!rsh} Refine(Fun([UInt, UInt], UInt), ([x, y] => x < y), (([x, y], z) => x + y < z)) is a function that requires its second argument to be larger than its first and its result to be larger than its input."
  },
  {
    "objectID": "/rsh/compute/#p_83",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Object and {!rsh} Data are commonly used to implemented algebraic data types in Reach."
  },
  {
    "objectID": "/rsh/compute/#p_84",
    "pt": "Computations",
    "t": 3,
    "c": "The {!rsh} typeOf primitive function is the same as {!rsh} typeof: it returns the type of its argument."
  },
  {
    "objectID": "/rsh/compute/#p_85",
    "pt": "Computations",
    "t": 3,
    "c": "The {!rsh} isType function returns {!rsh} true if its argument is a type. Any expression satisfying {!rsh} isType is compiled away and does not exist at runtime."
  },
  {
    "objectID": "/rsh/compute/#p_86",
    "pt": "Computations",
    "t": 3,
    "c": "The {!rsh} is function returns its first argument if it satisfies the type specified by the second argument. If it is not, then the program is invalid. For example, {!rsh} is(5, UInt) returns {!rsh} 5, while {!rsh} is(5, Bool) is an invalid program. The value returned by {!rsh} is may not be identical to the input, because in some cases, such as for functions, it will record the applied to type and enforce it on future invocations. These applications are considered negative positions for {!rsh} Refine."
  },
  {
    "objectID": "/rsh/compute/#p_87",
    "pt": "Computations",
    "t": 3,
    "c": "A literal value, written {!rsh} VALUE, is an expression that evaluates to the given value."
  },
  {
    "objectID": "/rsh/compute/#p_88",
    "pt": "Computations",
    "t": 3,
    "c": "The null literal may be written as {!rsh} null."
  },
  {
    "objectID": "/rsh/compute/#p_89",
    "pt": "Computations",
    "t": 3,
    "c": "Numeric literals may be written in decimal, hexadecimal, octal, or scientific (exponential) notation. Numeric literals must obey the bit width of {!rsh} UInt if they are used as {!rsh} UInt values at runtime, but if they only appear at compile-time, then they may be any positive number. Reach provides abstractions for working with {!rsh} Ints and signed {!rsh} FixedPoint numbers. {!rsh} Ints may be defined by applying the unary {!rsh} + and {!rsh} - operators to values of type {!rsh} UInt. Reach provides syntactic sugar for defining signed {!rsh} FixedPoint numbers, in base 10, with decimal syntax. Numeric literals may contain underscore separators as a visual aid (e.g. {!rsh} 123_456 is the same as {!rsh} 123456)."
  },
  {
    "objectID": "/rsh/compute/#p_90",
    "pt": "Computations",
    "t": 3,
    "c": "Exponential notation may be written as {!rsh} <coefficient>(e|E)<exponent>, where coefficient may be of type UInt, Int, or FixedPoint and exponent may be of type UInt | Int. The evaluated number will have the precision of the coefficient or negative exponent, whichever is more precise. Below are examples of exponential notation:"
  },
  {
    "objectID": "/rsh/compute/#p_91",
    "pt": "Computations",
    "t": 3,
    "c": "Boolean literals may be written as {!rsh} true or {!rsh} false."
  },
  {
    "objectID": "/rsh/compute/#p_92",
    "pt": "Computations",
    "t": 3,
    "c": "String literals (aka byte strings) may be written between double or single quotes (with no distinction between the different styles) and use the same escaping rules as JavaScript. Since {!rsh} Bytes types are specialized in their length, literals typically need to be padded to be useful."
  },
  {
    "objectID": "/rsh/compute/#p_93",
    "pt": "Computations",
    "t": 3,
    "c": "Static byte strings can be converted into static strings by calling {!rsh} StringDyn as a function, like {!rsh} StringDyn(\"normally bytes\")."
  },
  {
    "objectID": "/rsh/compute/#p_94",
    "pt": "Computations",
    "t": 3,
    "c": "An operator is a special identifier, which is either a unary operator, or a binary operator."
  },
  {
    "objectID": "/rsh/compute/#p_95",
    "pt": "Computations",
    "t": 3,
    "c": "A unary expression, written {!rsh} UNAOP EXPR_rhs, where {!rsh} EXPR_rhs is an expression and {!rsh} UNAOP is one of the unary operators: ! - + typeof void. All the unary operators, besides {!rsh} typeof, have a corresponding named version in the standard library."
  },
  {
    "objectID": "/rsh/compute/#p_96",
    "pt": "Computations",
    "t": 3,
    "c": "It is invalid to use unary operations on the wrong types of values."
  },
  {
    "objectID": "/rsh/compute/#p_97",
    "pt": "Computations",
    "t": 3,
    "c": "When applied to values of type {!rsh} UInt, unary {!rsh} - and {!rsh} + operators will cast their arguments to type {!rsh} Int. The unary {!rsh} - and {!rsh} + operations are defined for values of type: {!rsh} Int, and {!rsh} FixedPoint."
  },
  {
    "objectID": "/rsh/compute/#p_98",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} void a evaluates to {!rsh} null for all arguments."
  },
  {
    "objectID": "/rsh/compute/#p_99",
    "pt": "Computations",
    "t": 3,
    "c": "Bitwise operations are not supported by all consensus networks and greatly decrease the efficiency of verification."
  },
  {
    "objectID": "/rsh/compute/#p_100",
    "pt": "Computations",
    "t": 3,
    "c": "A binary expression is written {!rsh} EXPR_lhs BINOP EXPR_rhs, where {!rsh} EXPR_lhs and {!rsh} EXPR_rhs are expressions and {!rsh} BINOP is one of the binary operators: && || + - * / % | & ^ << >> == != === !== > >= <= <. Numeric operations, like {!rsh} + and {!rsh} >, only operate on numbers. Since all numbers in Reach are integers, operations like {!rsh} / truncate their result. Boolean operations, like {!rsh} &&, only operate on booleans. {!rsh} xor operates on {!rsh} UInts, {!rsh} UInt256s, {!rsh} Bools, {!rsh} Digests, and {!rsh} Bytes of the same length. {!rsh} polyMod operates on {!rsh} UInts and {!rsh} UInt256. The first argument may be a {!rsh} Digest or {!rsh} Bytes. It is invalid to use binary operations on the wrong types of values."
  },
  {
    "objectID": "/rsh/compute/#p_101",
    "pt": "Computations",
    "t": 3,
    "c": "All binary expression operators have a corresponding named function in the standard library. The named arithmetic functions prefixed with {!rsh} safe, e.g. {!rsh} safeAdd, bypass {!rsh} verifyArithmetic and are not statically verified; they are only checked at runtime. The named arithmetic functions prefixed with {!rsh} veri, e.g. {!rsh} veriAdd, are statically verified, regardless of {!rsh} verifyArithmetic; no runtime checks will be generated for these verified operations. The {!rsh} veri functions enable you to verify arithmetic in specific parts of a program, as opposed to using {!rsh} verifyArithmetic throughout the whole application. While {!rsh} && and {!rsh} || may not evaluate their second argument, their corresponding named functions {!rsh} and, {!rsh} or, and {!rsh} xor, always do."
  },
  {
    "objectID": "/rsh/compute/#p_102",
    "pt": "Computations",
    "t": 3,
    "c": "Equality functions, like {!rsh} ==, {!rsh} ===, {!rsh} !=, and {!rsh} !==, operate on all types. However, values with different types are always not equal. Both arguments must be of the same type. Specialized functions exist for equality checking on each supported type."
  },
  {
    "objectID": "/rsh/compute/#p_103",
    "pt": "Computations",
    "t": 3,
    "c": "If {!rsh} verifyArithmetic is {!rsh} true, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks. If it is {!rsh} false, then the connector will ensure this dynamically."
  },
  {
    "objectID": "/rsh/compute/#p_104",
    "pt": "Computations",
    "t": 3,
    "c": "Reach has different unsigned integer types, {!rsh} UInt and {!rsh} UInt256. These values can be casted from one to the other by calling the type as a function with a value."
  },
  {
    "objectID": "/rsh/compute/#p_105",
    "pt": "Computations",
    "t": 3,
    "c": "For example, if x is a {!rsh} UInt, then {!rsh} UInt256(x) is x zero-extended to 256 bits. This is demonstrated in the code below:"
  },
  {
    "objectID": "/rsh/compute/#p_106",
    "pt": "Computations",
    "t": 3,
    "c": "However, if y is a {!rsh} UInt256, then {!rsh} UInt(y) is y with as many bits as {!rsh} UInt has. This is demonstrated in the code below:"
  },
  {
    "objectID": "/rsh/compute/#p_107",
    "pt": "Computations",
    "t": 3,
    "c": "In the second case above, where {!rsh} UInt256 is casted to {!rsh} UInt, if {!rsh} UInt256 has any non-zero bits that would be lost by the truncation, then the cast will fail at runtime. This is guaranteed to not happen when you compile with {!rsh} verifyArithmetic."
  },
  {
    "objectID": "/rsh/compute/#p_108",
    "pt": "Computations",
    "t": 3,
    "c": "If you wish to explicitly truncate a {!rsh} UInt* type into a smaller size, you can pass a second, {!rsh} Bool argument to the cast call. Passing {!rsh} true truncates the number. Passing {!rsh} false causes the cast to fail, as describe above. This is the default behavior."
  },
  {
    "objectID": "/rsh/compute/#p_109",
    "pt": "Computations",
    "t": 3,
    "c": "You may specify a third argument, that is of type {!rsh} Bool, when performing a cast. When {!rsh} true, the cast will be statically verified. When {!rsh} false, the cast will only be checked at runtime. If unspecified, it will default to whatever {!rsh} verifyArithmetic is set to."
  },
  {
    "objectID": "/rsh/compute/#p_110",
    "pt": "Computations",
    "t": 3,
    "c": "Numeric literals in your program are considered {!rsh} UInt. If they are cast to {!rsh} UInt256, then your program can contain constant {!rsh} UInt256 values."
  },
  {
    "objectID": "/rsh/compute/#p_111",
    "pt": "Computations",
    "t": 3,
    "c": "Some values, specifically unsigned integers and bytes, can be converted into dynamically sized strings by calling {!rsh} StringDyn as a function. For example:"
  },
  {
    "objectID": "/rsh/compute/#p_112",
    "pt": "Computations",
    "t": 3,
    "c": "Although {!rsh} Contract and {!rsh} Address are not necessarily the same type, they often have a connection. {!rsh} Contract.addressEq(ctc, addr) returns a boolean that is {!rsh} true if {!rsh} ctc refers to the same contract as {!rsh} addr."
  },
  {
    "objectID": "/rsh/compute/#p_113",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} boolXor(Bool, Bool) returns {!rsh} true only when the inputs differ in value. This function is specialized to {!rsh} Bools; {!rsh} xor supports more types."
  },
  {
    "objectID": "/rsh/compute/#p_114",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Bytes are like {!rsh} Arrays in that they are fixed and exactly sized. This means that two {!rsh} Bytes of different lengths are not interchangeable."
  },
  {
    "objectID": "/rsh/compute/#p_115",
    "pt": "Computations",
    "t": 3,
    "c": "For example, {!rsh} 'You win!' and {!rsh} 'You lose!' cannot both be provided to an {!rsh} interact function, because the second is one character longer. Most of the time this is good, because it is a signal that you should use a {!rsh} Data type instead, so that the formatting and display logic is entirely controlled by the frontend."
  },
  {
    "objectID": "/rsh/compute/#p_116",
    "pt": "Computations",
    "t": 3,
    "c": "But, sometimes it is necessary and useful to extend one byte string into a larger size. Each {!rsh} Bytes type has a pad field that is bound to a function that extends its argument to the needed size. A byte string extended in this way is called padded, because it is extended with additional NUL bytes at the end of the string."
  },
  {
    "objectID": "/rsh/compute/#p_117",
    "pt": "Computations",
    "t": 3,
    "c": "The code below shows how {!rsh} Padding can be done:"
  },
  {
    "objectID": "/rsh/compute/#p_118",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Bytes.fromHex(BYTES) allows a value of {!rsh} Bytes(n) to be constructed with hexadecimal notation. The value of BYTES must be known at compile time. n is determined by the length of BYTES."
  },
  {
    "objectID": "/rsh/compute/#p_119",
    "pt": "Computations",
    "t": 3,
    "c": "Concatenates two static length {!rsh} Bytes values into a static length Bytes value. For example, if x is 5 bytes and y is 6 bytes, then the result is 11 bytes, with the x bytes first and the y bytes second. ({!rsh} \"ABCDE\".concat(\"012345\") is `{!rsh} \"ABCDE012345\".)"
  },
  {
    "objectID": "/rsh/compute/#p_120",
    "pt": "Computations",
    "t": 3,
    "c": "Concatenates two {!rsh} StringDyn values into a single dynamically sized string."
  },
  {
    "objectID": "/rsh/compute/#p_121",
    "pt": "Computations",
    "t": 3,
    "c": "An expression may be parenthesized, as in {!rsh} (EXPR)."
  },
  {
    "objectID": "/rsh/compute/#p_122",
    "pt": "Computations",
    "t": 3,
    "c": "A tuple literal, written {!rsh} [ EXPR_0, ..., EXPR_n ], is an expression which evaluates to a tuple of {!rsh} n values, where {!rsh} EXPR_0 through {!rsh} EXPR_n are expressions."
  },
  {
    "objectID": "/rsh/compute/#p_123",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} ...expr may appear inside tuple expressions, in which case the spreaded expression must evaluate to a tuple or array, which is spliced in place."
  },
  {
    "objectID": "/rsh/compute/#p_124",
    "pt": "Computations",
    "t": 3,
    "c": "Tuples can be non-homogeneous, as in this example. This tuple is four (4) different expressions (loanAmt, interest, nft, and deadline) that are created at the same time, and then a {!rsh} declassify is performed to make them knowable to other users."
  },
  {
    "objectID": "/rsh/compute/#p_125",
    "pt": "Computations",
    "t": 3,
    "c": "Converts a tuple of homogeneous values of the specific type into an array."
  },
  {
    "objectID": "/rsh/compute/#p_126",
    "pt": "Computations",
    "t": 3,
    "c": "A reference, written {!rsh} REF_EXPR[IDX_EXPR], where {!rsh} REF_EXPR is an expression that evaluates to an array, a tuple, an object, or a struct and {!rsh} IDX_EXPR is an expression that evaluates to a natural number which is less than the size of the array, selects the element at the given index of the array. Indices start at zero."
  },
  {
    "objectID": "/rsh/compute/#p_127",
    "pt": "Computations",
    "t": 3,
    "c": "If {!rsh} REF_EXPR is a tuple, then {!rsh} IDX_EXPR must be a compile-time constant, because tuples do not support dynamic access, because each element may be a different type."
  },
  {
    "objectID": "/rsh/compute/#p_128",
    "pt": "Computations",
    "t": 3,
    "c": "If {!rsh} REF_EXPR is a mapping and {!rsh} IDX_EXPR evaluates to an address, then this reference evaluates to a value of type {!rsh} Maybe(TYPE), where {!rsh} TYPE is the type of the mapping."
  },
  {
    "objectID": "/rsh/compute/#p_129",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Tuple.length Returns the length of the given tuple."
  },
  {
    "objectID": "/rsh/compute/#p_130",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.length Returns the length of the given array."
  },
  {
    "objectID": "/rsh/compute/#p_131",
    "pt": "Computations",
    "t": 3,
    "c": "Both may be abbreviated as {!rsh} expr.length where {!rsh} expr evaluates to a tuple or an array."
  },
  {
    "objectID": "/rsh/compute/#p_132",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Tuple.set Returns a new tuple identical to {!rsh} tup, except that index {!rsh} idx is replaced with {!rsh} val. The {!rsh} idx must be a compile-time constant, because tuples do not support dynamic access, because each element may be a different type."
  },
  {
    "objectID": "/rsh/compute/#p_133",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.set Returns a new array identical to {!rsh} arr, except that index {!rsh} idx is replaced with {!rsh} val."
  },
  {
    "objectID": "/rsh/compute/#p_134",
    "pt": "Computations",
    "t": 3,
    "c": "Both may be abbreviated as {!rsh} expr.set(idx, val) where {!rsh} expr evaluates to a tuple or an array."
  },
  {
    "objectID": "/rsh/compute/#p_135",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.elemType Returns the {!rsh} Type of elements that the array contains."
  },
  {
    "objectID": "/rsh/compute/#p_136",
    "pt": "Computations",
    "t": 3,
    "c": "The following methods are available on any {!rsh} Foldable containers, such as: {!rsh} Arrays and {!rsh} Maps."
  },
  {
    "objectID": "/rsh/compute/#p_137",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.forEach(c, f) iterates the function {!rsh} f over the elements of a container {!rsh} c, discarding the result. This may be abbreviated as {!rsh} c.forEach(f)."
  },
  {
    "objectID": "/rsh/compute/#p_138",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.all(c, f) determines whether the predicate, f, is satisfied by every element of the container, c."
  },
  {
    "objectID": "/rsh/compute/#p_139",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.any(c, f) determines whether the predicate, f, is satisfied by at least one element of the container, c."
  },
  {
    "objectID": "/rsh/compute/#p_140",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.or(c) returns the disjunction of a container of {!rsh} Bools."
  },
  {
    "objectID": "/rsh/compute/#p_141",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.and(c) returns the conjunction of a container of {!rsh} Bools."
  },
  {
    "objectID": "/rsh/compute/#p_142",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.includes(c, x) determines whether the container includes the element, x."
  },
  {
    "objectID": "/rsh/compute/#p_143",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.count(c, f) returns the number of elements in c that satisfy the predicate, f."
  },
  {
    "objectID": "/rsh/compute/#p_144",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.size(c) returns the number of elements in c."
  },
  {
    "objectID": "/rsh/compute/#p_145",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.min(c) returns the lowest number in a container of UInts."
  },
  {
    "objectID": "/rsh/compute/#p_146",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.max(c) returns the largest number in a container of UInts."
  },
  {
    "objectID": "/rsh/compute/#p_147",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.sum(c) returns the sum of a container of UInts."
  },
  {
    "objectID": "/rsh/compute/#p_148",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.product(c) returns the product of a container of UInts."
  },
  {
    "objectID": "/rsh/compute/#p_149",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.average(c) returns the mean of a container of UInts. Note that because this uses integer division, the result is effectively truncated."
  },
  {
    "objectID": "/rsh/compute/#p_150",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Foldable.imin(c) and {!rsh} Foldable.imax(c) return the minimum and maximum of a container of Ints, respectively."
  },
  {
    "objectID": "/rsh/compute/#p_151",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array is a {!rsh} Foldable container. Along with the methods of {!rsh} Foldable, the following methods may be used with {!rsh} Arrays."
  },
  {
    "objectID": "/rsh/compute/#p_152",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.iota(len) returns an array of length {!rsh} len, where each element is the same as its index. For example, {!rsh} Array.iota(4) returns {!rsh} [0, 1, 2, 3]. The given {!rsh} len must evaluate to an integer at compile-time."
  },
  {
    "objectID": "/rsh/compute/#p_153",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.replicate(len, val) returns an array of length {!rsh} len, where each element is {!rsh} val. For example, {!rsh} Array.replicate(4, \"four\") returns {!rsh} [\"four\", \"four\", \"four\", \"four\"]. The given {!rsh} len must evaluate to an integer at compile-time."
  },
  {
    "objectID": "/rsh/compute/#p_154",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.concat(x, y) concatenates the two arrays {!rsh} x and {!rsh} y. This may be abbreviated as {!rsh} x.concat(y)."
  },
  {
    "objectID": "/rsh/compute/#p_155",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.empty is an array with no elements. It is the identity element of {!rsh} Array.concat. It may also be written {!rsh} Array_empty."
  },
  {
    "objectID": "/rsh/compute/#p_156",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.zip(x, y) returns a new array the same size as {!rsh} x and {!rsh} y (which must be the same size) whose elements are tuples of the elements of {!rsh} x and {!rsh} y. This may be abbreviated as {!rsh} x.zip(y). This function is generalized to an arbitrary number of arrays of the same size."
  },
  {
    "objectID": "/rsh/compute/#p_157",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.map(arr, f) returns a new array, {!rsh} arr_mapped, the same size as {!rsh} arr, where {!rsh} arr_mapped[i] = f(arr[i]) for all {!rsh} i. For example, {!rsh} Array.iota(4).map(x => x+1) returns {!rsh} [1, 2, 3, 4]. This may be abbreviated as {!rsh} arr.map(f)."
  },
  {
    "objectID": "/rsh/compute/#p_158",
    "pt": "Computations",
    "t": 3,
    "c": "This function is generalized to an arbitrary number of arrays of the same size, which are provided before the {!rsh} f argument. For example, {!rsh} Array.iota(4).map(Array.iota(4), add) returns {!rsh} [0, 2, 4, 6]."
  },
  {
    "objectID": "/rsh/compute/#p_159",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.mapWithIndex(arr, f) is similar to {!rsh} Array.map, except it provides {!rsh} f with an additional argument, which is the index of the current element in {!rsh} arr. The index argument is the last argument of the given function {!rsh} f."
  },
  {
    "objectID": "/rsh/compute/#p_160",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.forEachWithIndex(arr, f) is similar to {!rsh} Array.forEach, except it provides {!rsh} f with an additional argument, which is the index of the current element in {!rsh} arr. Unlike {!rsh} Array.forEach, this function is not generalized to an arbitrary number of arrays; it only accepts one array."
  },
  {
    "objectID": "/rsh/compute/#p_161",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.reduce(arr, z, f) returns the left fold of the function {!rsh} f over the given array with the initial value {!rsh} z. For example, {!rsh} Array.iota(4).reduce(0, add) returns {!rsh} ((0 + 1) + 2) + 3 = 6. This may be abbreviated as {!rsh} arr.reduce(z, f)."
  },
  {
    "objectID": "/rsh/compute/#p_162",
    "pt": "Computations",
    "t": 3,
    "c": "This function is generalized to an arbitrary number of arrays of the same size, which are provided before the {!rsh} z argument. For example, {!rsh} Array.iota(4).reduce(Array.iota(4), 0, (x, y, z) => (z + x + y)) returns {!rsh} ((((0 + 0 + 0) + 1 + 1) + 2 + 2) + 3 + 3)."
  },
  {
    "objectID": "/rsh/compute/#p_163",
    "pt": "Computations",
    "t": 3,
    "c": "The supplied function {!rsh} f is in the form {!rsh} (ACCUM, A0_i, A1_i, ...) => BODY. In the example {!rsh} a1.reduce(a2, a3, 0, (accum, v1, v2, v3) => 0), the {!rsh} vN values are drawn from the corresponding {!rsh} aN arrays."
  },
  {
    "objectID": "/rsh/compute/#p_164",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.reduceWithIndex(arr, z, f) is similar to {!rsh} Array.reduce, except it provides {!rsh} f with an additional argument, which is the index of the current element in {!rsh} arr. The index argument is the last argument of the given function {!rsh} f."
  },
  {
    "objectID": "/rsh/compute/#p_165",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.indexOf(arr, x) returns the index of the first element in the given array that is equal to x. The return value is of type {!rsh} Maybe(UInt). If the value is not present in the array, {!rsh} None is returned."
  },
  {
    "objectID": "/rsh/compute/#p_166",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.findIndex(arr, f) returns the index of the first element in the given array that satisfies the predicate f. The return value is of type {!rsh} Maybe(UInt). If no value in the array satisfies the predicate, {!rsh} None is returned."
  },
  {
    "objectID": "/rsh/compute/#p_167",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.find(arr, f) returns the first element in the array, {!rsh} arr, that satisfies the predicate {!rsh} f. The return value is of type {!rsh} Maybe. If no value in the array satisfies the predicate, {!rsh} None is returned."
  },
  {
    "objectID": "/rsh/compute/#p_168",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.withIndex(arr) returns an array where every element of {!rsh} arr is paired with its index. For example, {!rsh} array(Bool, [false, true]).withIndex() returns {!rsh} array(Tuple(Bool, UInt), [[false, 0], [true, 1]])."
  },
  {
    "objectID": "/rsh/compute/#p_169",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Array.slice(arr, start, length) returns a portion of {!rsh} arr, starting from the {!rsh} start index, up to the {!rsh} start + length index."
  },
  {
    "objectID": "/rsh/compute/#p_170",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Map is a {!rsh} Foldable container. Mappings may be aggregated with the following operations and those of {!rsh} Foldable within the {!rsh} invariant of a {!rsh} while loop."
  },
  {
    "objectID": "/rsh/compute/#p_171",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Map.reduce(map, z, f) returns the left fold of the function {!rsh} f over the values of the given mapping with the initial value {!rsh} z. This may be abbreviated as {!rsh} map.reduce(z, f). For example, {!rsh} m.reduce(0, (acc, v) => acc + v) sums the elements of the mapping."
  },
  {
    "objectID": "/rsh/compute/#p_172",
    "pt": "Computations",
    "t": 3,
    "c": "The function {!rsh} f must satisfy the property, for all {!rsh} z, {!rsh} a, {!rsh} b, {!rsh} f(f(z, b), a) == f(f(z, a), b), because the order of evaluation is unpredictable."
  },
  {
    "objectID": "/rsh/compute/#p_173",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Map.reduceWithKey(map, z, f) returns the left fold of the function {!rsh} f over the keys and values of the given mapping with the initial value {!rsh} z. This may be abbreviated as {!rsh} map.reduceWithKey(z, f). For example, {!rsh} m.reduce(0, (acc, k, v) => acc + k + v) sums the keys and values of the mapping."
  },
  {
    "objectID": "/rsh/compute/#p_174",
    "pt": "Computations",
    "t": 3,
    "c": "The function {!rsh} f must satisfy the property, for all z, k1, a, k2, b, {!rsh} f(f(z, k2, b), k1, a) == f(f(z, k1, a), k2, b), because the order of evaluation is unpredictable."
  },
  {
    "objectID": "/rsh/compute/#p_175",
    "pt": "Computations",
    "t": 3,
    "c": "An object, typically written {!rsh} { KEY_0: EXPR_0, ..., KEY_n: EXPR_n }, where {!rsh} KEY_0 through {!rsh} KEY_n are identifiers or string literals and {!rsh} EXPR_0 through {!rsh} EXPR_n are expressions, is an expression which evaluates to an object with fields {!rsh} KEY_0 through {!rsh} KEY_n."
  },
  {
    "objectID": "/rsh/compute/#p_176",
    "pt": "Computations",
    "t": 3,
    "c": "Additional object literal syntax exists for convenience, such as:"
  },
  {
    "objectID": "/rsh/compute/#p_177",
    "pt": "Computations",
    "t": 3,
    "c": "An object splice, where all fields from {!rsh} obj are copied into the object; these fields may be accompanied by additional fields specified afterwards."
  },
  {
    "objectID": "/rsh/compute/#p_178",
    "pt": "Computations",
    "t": 3,
    "c": "Shorthand for {!rsh} { x: x, z: 5}, where {!rsh} x is any bound identifier."
  },
  {
    "objectID": "/rsh/compute/#p_179",
    "pt": "Computations",
    "t": 3,
    "c": "An object reference, written {!rsh} OBJ.FIELD, where {!rsh} OBJ is an expression that evaluates to an object or a struct, and {!rsh} FIELD is a valid identifier, accesses the FIELD field of object OBJ."
  },
  {
    "objectID": "/rsh/compute/#p_180",
    "pt": "Computations",
    "t": 3,
    "c": "Takes an object type and returns an object describing the fields of that type. It's useful for creating extended type values."
  },
  {
    "objectID": "/rsh/compute/#p_181",
    "pt": "Computations",
    "t": 3,
    "c": "Returns a new object identical to {!rsh} obj, except that field {!rsh} fld is replaced with {!rsh} val."
  },
  {
    "objectID": "/rsh/compute/#p_182",
    "pt": "Computations",
    "t": 3,
    "c": "Returns a new object identical to {!rsh} obj, except that field {!rsh} fld is {!rsh} val if {!rsh} fld is not already present in {!rsh} obj."
  },
  {
    "objectID": "/rsh/compute/#p_183",
    "pt": "Computations",
    "t": 3,
    "c": "Returns a boolean indicating whether the object has the field {!rsh} fld. This is statically known."
  },
  {
    "objectID": "/rsh/compute/#p_184",
    "pt": "Computations",
    "t": 3,
    "c": "A struct is a combination of a tuple and an object. It has named elements, like an object, but is ordered like a tuple, so its elements may be accessed by either name or position. Structs exist for interfacing with non-Reach remote objects, where both parties must agree to the runtime representation of the values."
  },
  {
    "objectID": "/rsh/compute/#p_185",
    "pt": "Computations",
    "t": 3,
    "c": "A struct instance may be constructed by calling the {!rsh} fromTuple method of a struct type instance (like {!rsh} Posn) with a tuple of the appropriate length."
  },
  {
    "objectID": "/rsh/compute/#p_186",
    "pt": "Computations",
    "t": 3,
    "c": "A struct instance may be constructed by calling the {!rsh} fromObject method of a struct type instance (like {!rsh} Posn) with an object with the appropriate fields."
  },
  {
    "objectID": "/rsh/compute/#p_187",
    "pt": "Computations",
    "t": 3,
    "c": "Structs may be converted into a corresponding tuple or object via the {!rsh} toTuple and {!rsh} toObject methods on the {!rsh} Struct value (as well as struct type instances, like {!rsh} Posn in the example above):"
  },
  {
    "objectID": "/rsh/compute/#p_188",
    "pt": "Computations",
    "t": 3,
    "c": "The names of elements may be restricted to avoid conflicting with reserved words of the specified connectors."
  },
  {
    "objectID": "/rsh/compute/#p_189",
    "pt": "Computations",
    "t": 3,
    "c": "The {!rsh} Struct.fields function takes a struct type and returns a tuple describing a struct's fields that is suitable for creating extended versions of structs."
  },
  {
    "objectID": "/rsh/compute/#p_190",
    "pt": "Computations",
    "t": 3,
    "c": "A data instance is written {!rsh} DATA.VARIANT(VALUE), where {!rsh} DATA is {!rsh} Data type, {!rsh} VARIANT is the name of one of {!rsh} DATA's variants, and {!rsh} VALUE is a value matching the type of the variant. As a special case, when the type of a variant is {!rsh} Null, the {!rsh} VALUE may be omitted, as shown in the definition of {!rsh} burger in the same above."
  },
  {
    "objectID": "/rsh/compute/#p_191",
    "pt": "Computations",
    "t": 3,
    "c": "Data instances are consumed by {!rsh} switch statements and {!rsh} match expressions."
  },
  {
    "objectID": "/rsh/compute/#p_192",
    "pt": "Computations",
    "t": 3,
    "c": "Data instances may be checked against particular variants with the {!rsh} isDataVariant function."
  },
  {
    "objectID": "/rsh/compute/#p_193",
    "pt": "Computations",
    "t": 3,
    "c": "The above use of {!rsh} isDataVariant is like the following switch, but more efficient:"
  },
  {
    "objectID": "/rsh/compute/#p_194",
    "pt": "Computations",
    "t": 3,
    "c": "Option types are represented in Reach through the built-in {!rsh} Data type, {!rsh} Maybe, which has two variants: {!rsh} Some and {!rsh} None."
  },
  {
    "objectID": "/rsh/compute/#p_195",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Maybe is defined by"
  },
  {
    "objectID": "/rsh/compute/#p_196",
    "pt": "Computations",
    "t": 3,
    "c": "This means it is a function that returns a {!rsh} Data type specialized to a particular type in the {!rsh} Some variant."
  },
  {
    "objectID": "/rsh/compute/#p_197",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Maybe instances can be conveniently consumed by {!rsh} fromMaybe(mValue, onNone, onSome), where {!rsh} onNone is a function of no arguments which is called when {!rsh} mValue is {!rsh} None, {!rsh} onSome is a function of one argument which is called with the value when {!rsh} mValue is {!rsh} Some, and {!rsh} mValue is a data instance of {!rsh} Maybe."
  },
  {
    "objectID": "/rsh/compute/#p_198",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} isNone is a convenience method that determines whether the variant is {!rsh} None."
  },
  {
    "objectID": "/rsh/compute/#p_199",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} isSome is a convenience method that determines whether the variant is {!rsh} Some."
  },
  {
    "objectID": "/rsh/compute/#p_200",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fromSome receives a {!rsh} Maybe value and a default value as arguments and will return the value inside of the {!rsh} Some variant or the default value otherwise."
  },
  {
    "objectID": "/rsh/compute/#p_201",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} maybe(m, defaultVal, f) receives a {!rsh} Maybe value, a default value, and a unary function as arguments. The function will either return the application of the function, {!rsh} f, to the {!rsh} Some value or return the default value provided."
  },
  {
    "objectID": "/rsh/compute/#p_202",
    "pt": "Computations",
    "t": 3,
    "c": "The following examples demonstrate different usage of {!rsh} Maybe:"
  },
  {
    "objectID": "/rsh/compute/#p_203",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Either is defined by"
  },
  {
    "objectID": "/rsh/compute/#p_204",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Either can be used to represent values with two possible types."
  },
  {
    "objectID": "/rsh/compute/#p_205",
    "pt": "Computations",
    "t": 3,
    "c": "Similar to Maybe, Either may be used to represent values that are correct or erroneous. A successful result is stored, by convention, in Right. Unlike None, Left may carry additional information about the error."
  },
  {
    "objectID": "/rsh/compute/#p_206",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} either(e, onLeft, onRight) will either apply the function onLeft or onRight depending on e."
  },
  {
    "objectID": "/rsh/compute/#p_207",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} isLeft is a convenience method that determines whether the variant is Left."
  },
  {
    "objectID": "/rsh/compute/#p_208",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} isRight is a convenience method that determines whether the variant is Right."
  },
  {
    "objectID": "/rsh/compute/#p_209",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fromLeft(e, default) is a convenience method that returns the value in Left, or default if the variant is Right."
  },
  {
    "objectID": "/rsh/compute/#p_210",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fromRight(e, default) is a convenience method that returns the value in Right, or default if the variant is Left."
  },
  {
    "objectID": "/rsh/compute/#p_211",
    "pt": "Computations",
    "t": 3,
    "c": "This snippet demonstrates the convenience methods:"
  },
  {
    "objectID": "/rsh/compute/#p_212",
    "pt": "Computations",
    "t": 3,
    "c": "A match expression, written {!rsh} VAR.match({ CASE ... }), where VAR is a variable bound to a data instance and CASE is VARIANT: FUNCTION, where VARIANT is a variant or {!rsh} default, and FUNCTION is a function that takes the same arguments as the variant constructor. If the variant has a type of {!rsh} Null, then the function is allowed to take no arguments. {!rsh} default functions must always take an argument, even if all defaulted variants have type {!rsh} Null."
  },
  {
    "objectID": "/rsh/compute/#p_213",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} match is similar to a switch statement, but since it is an expression, it can be conveniently used in places like the right hand side of an assignment statement."
  },
  {
    "objectID": "/rsh/compute/#p_214",
    "pt": "Computations",
    "t": 3,
    "c": "Similar to a switch statement, the cases are expected to be exhaustive and nonredundant, all cases have empty tails, and it may only include a consensus transfer in its cases if it is within a consensus step."
  },
  {
    "objectID": "/rsh/compute/#p_215",
    "pt": "Computations",
    "t": 3,
    "c": "A conditional expression, written {!rsh} COND_E ? NOT_FALSE_E : FALSE_E, where {!rsh} COND_E, {!rsh} NOT_FALSE_E, and {!rsh} FALSE_E are expressions, selects between the values which {!rsh} NOT_FALSE_E and {!rsh} FALSE_E evaluate to based on whether {!rsh} COND_E evaluates to {!rsh} false. This expression will evaluate both the false and not-false sides of the computation if they are considered pure. Arithmetic is considered pure if you enable {!rsh} verifyArithmetic} or use {!rsh} veri* functions, like {!rsh} safeAdd. Arithmetic is not considered pure if you do not enable {!rsh} verifyArithmetic, or use {!rsh} safe* functions, like {!rsh} safeAdd, which may cause arithmetic faults."
  },
  {
    "objectID": "/rsh/compute/#p_216",
    "pt": "Computations",
    "t": 3,
    "c": "Conditional expressions may also be written with the {!rsh} ite function, however, note that this function always evaluates both of its branches."
  },
  {
    "objectID": "/rsh/compute/#p_217",
    "pt": "Computations",
    "t": 3,
    "c": "An arrow expression, written {!rsh} (LHS_0, ..., LHS_n) => EXPR, where {!rsh} LHS_0 through {!rsh} LHS_n are left-hand sides and {!rsh} EXPR is an expression, evaluates to a function which is an abstraction of {!rsh} EXPR over {!rsh} n values compatible with the respective left-hand side. Like function definitions, arrow expressions may use default argument notation and rest parameters."
  },
  {
    "objectID": "/rsh/compute/#p_218",
    "pt": "Computations",
    "t": 3,
    "c": "An enumeration (or enum, for short), can be created by calling the {!rsh} makeEnum function, as in {!rsh} makeEnum(N), where {!rsh} N is the number of distinct values in the enum. This produces a tuple of {!rsh} N+1 values, where the first value is a {!rsh} Fun([UInt], Bool) which tells you if its argument is one of the enum's values, and the next N values are distinct {!rsh} UInts."
  },
  {
    "objectID": "/rsh/compute/#p_219",
    "pt": "Computations",
    "t": 3,
    "c": "isOutcome is a function that takes a {!rsh} UInt and returns {!rsh} true or {!rsh} false depending on if the {!rsh} UInt passed to it is a member of that enumeration or not. LENDER_TIMEOUT and BORROWER_TIMEOUT are {!rsh} UInts."
  },
  {
    "objectID": "/rsh/compute/#p_220",
    "pt": "Computations",
    "t": 3,
    "c": "So isOutcome(LENDER_TIMEOUT) would return {!rsh} true while isOutcome(SCISSORS) would return {!rsh} false."
  },
  {
    "objectID": "/rsh/compute/#p_221",
    "pt": "Computations",
    "t": 3,
    "c": "A static assertion which is only valid if {!rsh} claim always evaluates to {!rsh} true."
  },
  {
    "objectID": "/rsh/compute/#p_222",
    "pt": "Computations",
    "t": 3,
    "c": "For example, the following assertions were made in the Rock, Paper, Scissors tutorial:"
  },
  {
    "objectID": "/rsh/compute/#p_223",
    "pt": "Computations",
    "t": 3,
    "c": "The Reach compiler will produce a counter-example (i.e. an assignment of the identifiers in the program to falsify the {!rsh} claim) when an invalid {!rsh} claim is provided. It is possible to write a {!rsh} claim that actually always evaluates to {!rsh} true, but for which our current approach cannot prove always evaluates to {!rsh} true; if this is the case, Reach will fail to compile the program, reporting that its analysis is incomplete. Reach will never produce an erroneous counter-example."
  },
  {
    "objectID": "/rsh/compute/#p_224",
    "pt": "Computations",
    "t": 3,
    "c": "It accepts an optional bytes argument, which is included in any reported violation."
  },
  {
    "objectID": "/rsh/compute/#p_225",
    "pt": "Computations",
    "t": 3,
    "c": "See the guide section on verification to better understand how and what to verify in your program."
  },
  {
    "objectID": "/rsh/compute/#p_226",
    "pt": "Computations",
    "t": 3,
    "c": "A dynamic assertion that {!rsh} claim evaluates to {!rsh} true, which expands to either a {!rsh} require or {!rsh} assume depending on where it is used in a program. It accepts an optional bytes argument, which is included in any reported violation."
  },
  {
    "objectID": "/rsh/compute/#p_227",
    "pt": "Computations",
    "t": 3,
    "c": "For example, A makes the following {!rsh} check with a second (optional) argument on line 21:"
  },
  {
    "objectID": "/rsh/compute/#p_228",
    "pt": "Computations",
    "t": 3,
    "c": "While the {!rsh} check in the following example, takes just the first argument on line 62:"
  },
  {
    "objectID": "/rsh/compute/#p_229",
    "pt": "Computations",
    "t": 3,
    "c": "A dynamic assertion that {!rsh} claim evaluates to {!rsh} true. Since this is neither {!rsh} assume or {!rsh} require it is not part of Reach's rely-guarantee reasoning analysis, thus you should avoid it as much as possible. It accepts an optional bytes argument, which is included in any reported violation."
  },
  {
    "objectID": "/rsh/compute/#p_230",
    "pt": "Computations",
    "t": 3,
    "c": "The single argument version returns an abstract value of the given type. It may only be referenced inside of assertions; any other reference is invalid."
  },
  {
    "objectID": "/rsh/compute/#p_231",
    "pt": "Computations",
    "t": 3,
    "c": "The two argument version is an abbreviation of calling the second argument with the result of {!rsh} forall(Type). This is convenient for writing general claims about expressions, such as"
  },
  {
    "objectID": "/rsh/compute/#p_232",
    "pt": "Computations",
    "t": 3,
    "c": "The following code sample uses a couple of {!rsh} forall arguments to assert that winner always provides a valid outcome."
  },
  {
    "objectID": "/rsh/compute/#p_233",
    "pt": "Computations",
    "t": 3,
    "c": "A possibility assertion which is only valid if it is possible for {!rsh} claim to evaluate to {!rsh} true with honest frontends and participants. It accepts an optional bytes argument, which is included in any reported violation."
  },
  {
    "objectID": "/rsh/compute/#p_234",
    "pt": "Computations",
    "t": 3,
    "c": "The digest primitive performs a cryptographic hash of the binary encoding of the given arguments. This returns a {!rsh} Digest value. The exact algorithm used depends on the connector."
  },
  {
    "objectID": "/rsh/compute/#p_235",
    "pt": "Computations",
    "t": 3,
    "c": "This sample digests password, _pass into a hash, passDigest, so that it can be shared safely on the consensus network without eavesdroppers learning the password."
  },
  {
    "objectID": "/rsh/compute/#p_236",
    "pt": "Computations",
    "t": 3,
    "c": "The balance primitive returns the balance of the contract account for the DApp. It takes an optional non-network token value, in which case it returns the balance of the given token."
  },
  {
    "objectID": "/rsh/compute/#p_237",
    "pt": "Computations",
    "t": 3,
    "c": "The example below shows non-network tokens being passed as arguments to the {!rsh} balance primitives:"
  },
  {
    "objectID": "/rsh/compute/#p_238",
    "pt": "Computations",
    "t": 3,
    "c": "While in the following example, {!rsh} balance takes no argument:"
  },
  {
    "objectID": "/rsh/compute/#p_239",
    "pt": "Computations",
    "t": 3,
    "c": "The getContract primitive returns the {!rsh} Contract value for the deployed contract. This function may not be called until after the first publication (which creates the contract)."
  },
  {
    "objectID": "/rsh/compute/#p_240",
    "pt": "Computations",
    "t": 3,
    "c": "In line 26, D publishes the values for x and tok. After the {!rsh} publish, {!rsh} getContract returns the value x in token tok."
  },
  {
    "objectID": "/rsh/compute/#p_241",
    "pt": "Computations",
    "t": 3,
    "c": "The getAddress primitive returns the {!rsh} Address value of the deployed contract's account. This function may not be called until after the first publication (which creates the contract)."
  },
  {
    "objectID": "/rsh/compute/#p_242",
    "pt": "Computations",
    "t": 3,
    "c": "In the sample above, Alice publishes to create the contract. Then, an object named info references {!rsh} getContract which pulls in the contract information. Another object, addr, references {!rsh} getAddress to obtain the address of Alice. Both {!rsh} info and {!rsh} addr are then used in the local step of Alice in her {!rsh} interact object."
  },
  {
    "objectID": "/rsh/compute/#p_243",
    "pt": "Computations",
    "t": 3,
    "c": "The {!rsh} getCompanion primitive returns the {!rsh} Contract value of the deployed contract's companion, wrapped in a {!rsh} Maybe value, because not all contracts have a companion."
  },
  {
    "objectID": "/rsh/compute/#p_244",
    "pt": "Computations",
    "t": 3,
    "c": "This is useful on Algorand if contract A calls contract B and contract B needs a companion. Contract A will need to use the {!rsh} REMOTE_FUN.ALGO.apps options and include B's companion in the call."
  },
  {
    "objectID": "/rsh/compute/#p_245",
    "pt": "Computations",
    "t": 3,
    "c": "The lastConsensusTime primitive returns the network time of the last publication of the DApp. This may not be available if there was no such previous publication, such as at the beginning of an application before the first publication."
  },
  {
    "objectID": "/rsh/compute/#p_246",
    "pt": "Computations",
    "t": 3,
    "c": "In this code, {!rsh} lastConsensusTime is called on line 17 after the publication on line 12. The entry function on line 15 takes step as an argument and produces an array. The array contains the destructured step, lab that was passed into the parent function (aStep), {!rsh} lastConsensusTime() and {!rsh} lastConsensusSecs()."
  },
  {
    "objectID": "/rsh/compute/#p_247",
    "pt": "Computations",
    "t": 3,
    "c": "lastConsensusSecs is like {!rsh} lastConsensusTime, except it returns the network seconds."
  },
  {
    "objectID": "/rsh/compute/#p_248",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} lastConsensusSecs is used to make a check on line 14. This happened after the publication on line 9."
  },
  {
    "objectID": "/rsh/compute/#p_249",
    "pt": "Computations",
    "t": 3,
    "c": "The thisConsensusTime primitive returns the network time of the current publication of the DApp."
  },
  {
    "objectID": "/rsh/compute/#p_250",
    "pt": "Computations",
    "t": 3,
    "c": "Some networks do not support observing the time of a consensus operation until after it has finalized."
  },
  {
    "objectID": "/rsh/compute/#p_251",
    "pt": "Computations",
    "t": 3,
    "c": "thisConsensusSecs is like {!rsh} thisConsensusTime, except it returns the network seconds."
  },
  {
    "objectID": "/rsh/compute/#p_252",
    "pt": "Computations",
    "t": 3,
    "c": "In this code, three variables are created that set lastTime to {!rsh} thisConsensusTime, lastSecs to {!rsh} thisConsensusSecs and i to 0. Then, an invariant is set to make sure that lastTime is greater than {!rsh} lastConsensusTime, lastTime is equal to {!rsh} thisConsensusTime, lastSecs is either equal or greater than {!rsh} lastConsensusSecs and that the {!rsh} balance is equal to 0. This makes sure that the order of blocks matches the order of time."
  },
  {
    "objectID": "/rsh/compute/#p_253",
    "pt": "Computations",
    "t": 3,
    "c": "These primitives return the network time (network seconds) that a relative time argument refers to. This is either the same as {!rsh} lastConsensusTime ({!rsh} lastConsensusSecs) or the deadline of the previous {!rsh} wait or {!rsh} .timeout."
  },
  {
    "objectID": "/rsh/compute/#p_254",
    "pt": "Computations",
    "t": 3,
    "c": "This code creates three variables of lastTime, lastSecs, and i. It then sets lastTime to {!rsh} thisConsensusTime, lastSecs to {!rsh} baseWaitSecs and i to 0. Then, an invariant is created to make sure that lastTime is greater than {!rsh} baseWaitTime, lastTime is equal to {!rsh} thisConsensusTime, lastSecs is either equal or greater than {!rsh} baseWaitSecs and that the {!rsh} balance is equal to 0. This makes sure that the order of blocks matches the order of time."
  },
  {
    "objectID": "/rsh/compute/#p_255",
    "pt": "Computations",
    "t": 3,
    "c": "These functions return time arguments, which are instances of the type {!rsh} Either(UInt, UInt), where {!rsh} Left variants refer to absolute network time and {!rsh} Right variants refer to absolute network seconds."
  },
  {
    "objectID": "/rsh/compute/#p_256",
    "pt": "Computations",
    "t": 3,
    "c": "These functions take an optional function argument, claim, which will be used to verify arithmetic when necessary. In most cases, one would pass {!rsh} check or {!rsh} assert. This argument is only needed when verifyArithmetic is enabled. The default value of this argument is a no-op."
  },
  {
    "objectID": "/rsh/compute/#p_257",
    "pt": "Computations",
    "t": 3,
    "c": "The {!rsh} absoluteTime and {!rsh} absoluteSecs are equivalent to {!rsh} Left and {!rsh} Right variant tags, respectively."
  },
  {
    "objectID": "/rsh/compute/#p_258",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_259",
    "pt": "Computations",
    "t": 3,
    "c": "This code takes {!rsh} absoluteTime as the {!rsh} Left variant tag in the {!rsh} timeout method. In the following sample, {!rsh} absoluteSecs is used in the anonymous {!rsh} function as the {!rsh} Right variant tag:"
  },
  {
    "objectID": "/rsh/compute/#p_260",
    "pt": "Computations",
    "t": 3,
    "c": "The {!rsh} relativeTime and {!rsh} relativeSecs functions add {!rsh} baseWaitTime and {!rsh} baseWaitSecs to their arguments before tagging with the appropriate variant."
  },
  {
    "objectID": "/rsh/compute/#p_261",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_262",
    "pt": "Computations",
    "t": 3,
    "c": "This code adds deadline (i.e {!rsh} baseWaitTime) to the {!rsh} timeout method using {!rsh} relativeTime while the code below adds 25 seconds (i.e {!rsh} baseWaitSecs) to the {!rsh} timeout method using {!rsh} relativeSecs:"
  },
  {
    "objectID": "/rsh/compute/#p_263",
    "pt": "Computations",
    "t": 3,
    "c": "If a time argument is required, an integer value is allowed and is interpreted as a {!rsh} relativeTime, but this behavior is deprecated and you will see a warning."
  },
  {
    "objectID": "/rsh/compute/#p_264",
    "pt": "Computations",
    "t": 3,
    "c": "Be sure to read RW0006 if you use network seconds."
  },
  {
    "objectID": "/rsh/compute/#p_265",
    "pt": "Computations",
    "t": 3,
    "c": "When using verifyArithmetic and a dynamic timeout argument, it will be necessary to verify that the timeout calculation will not overflow. When producing the interact timeout value, you will want to use these functions to make {!rsh} check claims about the value. For example:"
  },
  {
    "objectID": "/rsh/compute/#p_266",
    "pt": "Computations",
    "t": 3,
    "c": "Use the identity function as the claim for use inside of invariants."
  },
  {
    "objectID": "/rsh/compute/#p_267",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} makeDeadline(deadline) takes a {!rsh} UInt as an argument and returns a pair of functions that can be used for dealing with absolute deadlines. It internally determines the end time based off of the deadline and the last consensus time—at the time of calling {!rsh} makeDeadline. timeRemaining will calculate the difference between the end time and the current last consensus time. keepGoing determines whether the current last consensus time is less than the end time. It is typical to use the two fields for the while and timeout field of a {!rsh} parallelReduce expression. For example:"
  },
  {
    "objectID": "/rsh/compute/#p_268",
    "pt": "Computations",
    "t": 3,
    "c": "This pattern is so common that it can be abbreviated as {!rsh} .timeRemaining."
  },
  {
    "objectID": "/rsh/compute/#p_269",
    "pt": "Computations",
    "t": 3,
    "c": "As can be seen in this code block from the Raffle example, {!rsh} makeDeadline is being used to set the {!rsh} deadline to double the original amount of network blocks if someone returns a ticket."
  },
  {
    "objectID": "/rsh/compute/#p_270",
    "pt": "Computations",
    "t": 3,
    "c": "Returns {!rsh} true if {!rsh} x is {!rsh} false or {!rsh} y is {!rsh} true."
  },
  {
    "objectID": "/rsh/compute/#p_271",
    "pt": "Computations",
    "t": 3,
    "c": "On line 54, {!rsh} implies would return {!rsh} true if {!rsh} when is {!rsh} false or {!rsh} isNone(randomsM[this]) evaluates to {!rsh} true."
  },
  {
    "objectID": "/rsh/compute/#p_272",
    "pt": "Computations",
    "t": 3,
    "c": "Makes a static assertion that {!rsh} pred(x) is {!rsh} true and returns {!rsh} x."
  },
  {
    "objectID": "/rsh/compute/#p_273",
    "pt": "Computations",
    "t": 3,
    "c": "A participant interact interface which specifies random as a function that takes no arguments and returns an unsigned integer of bit width bits. Reach provides a default frontend implementation via hasRandom (Frontend)."
  },
  {
    "objectID": "/rsh/compute/#p_274",
    "pt": "Computations",
    "t": 3,
    "c": "This code section gives the {!rsh} Player object the method {!rsh} hasRandom so that a random number is used to select a hand in the Rock, Paper, Scissors! tutorial."
  },
  {
    "objectID": "/rsh/compute/#p_275",
    "pt": "Computations",
    "t": 3,
    "c": "A participant interact interface which specifies log with an unconstrained domain function type that returns {!rsh} Null. Reach provides a default frontend implementation via {!js} stdlib.hasConsoleLogger."
  },
  {
    "objectID": "/rsh/compute/#p_276",
    "pt": "Computations",
    "t": 3,
    "c": "In this project, notice how {!rsh} hasConsoleLogger is accessed through the standard library on line 8 of the frontend. It is then passed to the backend on line 6."
  },
  {
    "objectID": "/rsh/compute/#p_277",
    "pt": "Computations",
    "t": 3,
    "c": "Creates a new function that applies its argument to g, then pipes the result to the function f. The argument type of f must be the return type of g."
  },
  {
    "objectID": "/rsh/compute/#p_278",
    "pt": "Computations",
    "t": 3,
    "c": "Currently, wide arithmetic operations are only suported on Algorand."
  },
  {
    "objectID": "/rsh/compute/#p_279",
    "pt": "Computations",
    "t": 3,
    "c": "Multiplies {!rsh} a by {!rsh} b, then immediately divides the product by {!rsh} c. The intermediate value may be larger than {!rsh} UInt.max if the connector supports wide arithmetic operations. The resulting quotient must be less than {!rsh} UInt.max."
  },
  {
    "objectID": "/rsh/compute/#p_280",
    "pt": "Computations",
    "t": 3,
    "c": "On line 31, totalAmount would be multiplied by the result of (curTime - start). The output would then be divided by duration immediately."
  },
  {
    "objectID": "/rsh/compute/#p_281",
    "pt": "Computations",
    "t": 3,
    "c": "Behaves the same as {!rsh} muldiv. This operation is statically verified regardless of {!rsh} verifyArithmetic. No runtime checks will be generated for this operation."
  },
  {
    "objectID": "/rsh/compute/#p_282",
    "pt": "Computations",
    "t": 3,
    "c": "Behaves the same as {!rsh} muldiv. This operation is not statically verified regardless of {!rsh} verifyArithmetic. Runtime checks will be generated for this operation."
  },
  {
    "objectID": "/rsh/compute/#p_283",
    "pt": "Computations",
    "t": 3,
    "c": "verifyMuldiv is required to verify {!rsh} muldiv when using verifyArithmetic"
  },
  {
    "objectID": "/rsh/compute/#p_284",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} verifyMuldiv generates a claim that the result of applying the same arguments to {!rsh} muldiv will not overflow. When used inside of a local step or export, it will generate an {!rsh} assume claim. When used inside of a consensus step, it will generate a {!rsh} require claim. When used inside of any other step, it will generate an {!rsh} assert claim."
  },
  {
    "objectID": "/rsh/compute/#p_285",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} muldiv is used on line 36 to multiply x and y. After which, the product of x and y is immediately divided by the product of cx and cy. On line 41, {!rsh} verifyMuldiv is used with the same arguments passed to {!rsh} muldiv on line 36. In this case, however, it is used to generate a claim that the result of applying the same arguments to {!rsh} muldiv will not overflow."
  },
  {
    "objectID": "/rsh/compute/#p_286",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} sqrt(x) returns the largest integer i such that i * i <= x."
  },
  {
    "objectID": "/rsh/compute/#p_287",
    "pt": "Computations",
    "t": 3,
    "c": "This code checks if z is equivalent to the square root of x on line 18. For example, if z is 9 and x is 81, that line would return {!rsh} true."
  },
  {
    "objectID": "/rsh/compute/#p_288",
    "pt": "Computations",
    "t": 3,
    "c": "Calculates an approximate square root of the first argument. This method utilizes the Babylonian Method for computing the square root. The second argument must be a {!rsh} UInt whose value is known at compile time, which represents the number of iterations the algorithm should perform."
  },
  {
    "objectID": "/rsh/compute/#p_289",
    "pt": "Computations",
    "t": 3,
    "c": "For reference, when performing {!rsh} 5 iterations, the algorithm can reliably calculate the square root up to 32 squared, or 1,024. When performing {!rsh} 10 iterations, the algorithm can reliably calculate the square root up to 580 squared, or 336,400."
  },
  {
    "objectID": "/rsh/compute/#p_290",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} pow(base, power, precision) calculates the approximate value of raising base to power. The third argument must be a {!rsh} UInt whose value is known at compile time, which represents the number of iterations the algorithm should perform."
  },
  {
    "objectID": "/rsh/compute/#p_291",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_292",
    "pt": "Computations",
    "t": 3,
    "c": "This code computes the finalOutcome of the Rock, Paper, Scissors game using the {!rsh} pow method. It takes outcome as the base, the sum of handAlice and handBob as the power, and 10 as the precision."
  },
  {
    "objectID": "/rsh/compute/#p_293",
    "pt": "Computations",
    "t": 3,
    "c": "For reference, 6 iterations provides enough accuracy to calculate up to 2^64 - 1, so the largest power it can compute is 2^63. If the number of iterations is not large enough to compute the power, then the result is completely inaccurate. It is recommended to create {!rsh} assert tests to ensure the possible values your program can compute are accurate."
  },
  {
    "objectID": "/rsh/compute/#p_294",
    "pt": "Computations",
    "t": 3,
    "c": "The standard library provides abstractions for dealing with signed integers. The following definitions are used to represent {!rsh} Ints:"
  },
  {
    "objectID": "/rsh/compute/#p_295",
    "pt": "Computations",
    "t": 3,
    "c": "Int is represented as an object, as opposed to a scalar value, because some platforms that Reach targets do not provide native support for signed integers."
  },
  {
    "objectID": "/rsh/compute/#p_296",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} int(Bool, UInt) is shorthand for defining an {!rsh} Int record. You may also use the {!rsh} + and {!rsh} - unary operators to declare integers instead of {!rsh} UInts."
  },
  {
    "objectID": "/rsh/compute/#p_297",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} iadd(x, y) adds the {!rsh} Int x and the {!rsh} Int y."
  },
  {
    "objectID": "/rsh/compute/#p_298",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} isub(x, y) subtracts the {!rsh} Int y from the {!rsh} Int x."
  },
  {
    "objectID": "/rsh/compute/#p_299",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} imul(x, y) multiplies the {!rsh} Int x and the {!rsh} Int y."
  },
  {
    "objectID": "/rsh/compute/#p_300",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} idiv(x, y) divides the {!rsh} Int x by the {!rsh} Int y."
  },
  {
    "objectID": "/rsh/compute/#p_301",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} imod(x, y) finds the remainder of dividing the {!rsh} Int x by the {!rsh} Int y."
  },
  {
    "objectID": "/rsh/compute/#p_302",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} ilt(x, y) determines whether x is less than y."
  },
  {
    "objectID": "/rsh/compute/#p_303",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} ile(x, y) determines whether x is less than or equal to y."
  },
  {
    "objectID": "/rsh/compute/#p_304",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} igt(x, y) determines whether x is greather than y."
  },
  {
    "objectID": "/rsh/compute/#p_305",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} ige(x, y) determines whether x is greater than or equal to y."
  },
  {
    "objectID": "/rsh/compute/#p_306",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} ieq(x, y) determines whether x is equal to y."
  },
  {
    "objectID": "/rsh/compute/#p_307",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} ine(x, y) determines whether x is not equal to y."
  },
  {
    "objectID": "/rsh/compute/#p_308",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} imax(x, y) returns the larger of two {!rsh} Ints."
  },
  {
    "objectID": "/rsh/compute/#p_309",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} abs(i) returns the absolute value of an {!rsh} Int. The return value is of type {!rsh} UInt."
  },
  {
    "objectID": "/rsh/compute/#p_310",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} FixedPoint is defined by"
  },
  {
    "objectID": "/rsh/compute/#p_311",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} FixedPoint can be used to represent numbers with a fixed number of digits after the decimal point. They are handy for representing fractional values, especially in base 10. The value of a fixed point number is determined by dividing the underlying integer value, i, by its scale factor, scale. For example, we could represent the value {!rsh} 1.234 with {!rsh} { sign: Pos, i: { scale: 1000, i : 1234 } } or {!rsh} fx(1000)(Pos, 1234). Alternatively, Reach provides syntactic sugar for defining {!rsh} FixedPoint numbers. One can simply write {!rsh} 1.234, which will assume the value is in base 10. A scale factor of 1000 correlates to 3 decimal places of precision. Similarly, a scale factor of 100 would have 2 decimal places of precision."
  },
  {
    "objectID": "/rsh/compute/#p_312",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fx(scale)(i) will return a function that can be used to instantiate fixed point numbers with a particular scale factor."
  },
  {
    "objectID": "/rsh/compute/#p_313",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxint(Int) will cast the {!rsh} Int arg as a {!rsh} FixedPoint number with a scale of 1."
  },
  {
    "objectID": "/rsh/compute/#p_314",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxrescale(x, scale) will convert a fixed point number from using one scale to another. This operation can result in loss of precision, as demonstrated in the above example."
  },
  {
    "objectID": "/rsh/compute/#p_315",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxunify(x, y) will convert the fixed point numbers to use the same scale. The larger scale of the two arguments will be chosen. The function will return a 3-tuple consisting of the common scale and the newly scaled values."
  },
  {
    "objectID": "/rsh/compute/#p_316",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxadd(x, y) adds two fixed point numbers."
  },
  {
    "objectID": "/rsh/compute/#p_317",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxsub(x, y) subtracts two fixed point numbers."
  },
  {
    "objectID": "/rsh/compute/#p_318",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxmul(x, y) multiplies two fixed point numbers."
  },
  {
    "objectID": "/rsh/compute/#p_319",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxdiv(x, y, scale_factor) divides two fixed point numbers. The numerator, x, will be multiplied by the scale factor to provide a more precise answer. For example,"
  },
  {
    "objectID": "/rsh/compute/#p_320",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxmod(x, y) finds the remainder of dividing x by y."
  },
  {
    "objectID": "/rsh/compute/#p_321",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxfloor(x) returns the greatest integer not greater than x."
  },
  {
    "objectID": "/rsh/compute/#p_322",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxsqrt(x, k) returns the square root of the fixed number, x."
  },
  {
    "objectID": "/rsh/compute/#p_323",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxsqrtApprox(x, k) approximates the square root of the fixed number, x, using k iterations of the {!rsh} sqrtApprox algorithm."
  },
  {
    "objectID": "/rsh/compute/#p_324",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} const base = 2.0; const power = 0.33; fxpow(base, power, 10, 1000); // 1.260 fxpow(base, power, 10, 10000); // 1.2599 fxpow(base, power, 10, 1000000); // 1.259921 "
  },
  {
    "objectID": "/rsh/compute/#p_325",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxpow(base, power, precision, scalePrecision) approximates the power of the fixed number, base, raised to the fixed point number, power. The third argument must be a {!rsh} UInt whose value is known at compile time, which represents the number of iterations the algorithm should perform. The scalePrecision argument must be a UInt and represents the scale of the return value. Choosing a larger scalePrecision allows for more precision when approximating the power, as demonstrated in the example below:"
  },
  {
    "objectID": "/rsh/compute/#p_326",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxpowi(base, power, precision) approximates the power of the fixed number, base, raised to the {!rsh} Int, power. The third argument must be a {!rsh} UInt whose value is known at compile time, which represents the number of iterations the algorithm should perform. For reference, 6 iterations provides enough accuracy to calculate up to 2^64 - 1, so the largest power it can compute is 63."
  },
  {
    "objectID": "/rsh/compute/#p_327",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxpowui(5.8, 3, 10); // 195.112 "
  },
  {
    "objectID": "/rsh/compute/#p_328",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxpowui(base, power, precision) approximates the power of the fixed number, base, raised to the {!rsh} UInt, power. The third argument must be a {!rsh} UInt whose value is known at compile time."
  },
  {
    "objectID": "/rsh/compute/#p_329",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxcmp(op, x, y) applies the comparison operator to the two fixed point numbers after unifying their scales."
  },
  {
    "objectID": "/rsh/compute/#p_330",
    "pt": "Computations",
    "t": 3,
    "c": "There are convenience methods defined for comparing fixed point numbers:"
  },
  {
    "objectID": "/rsh/compute/#p_331",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxlt(x, y) tests whether x is less than y."
  },
  {
    "objectID": "/rsh/compute/#p_332",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxle(x, y) tests whether x is less than or equal to y."
  },
  {
    "objectID": "/rsh/compute/#p_333",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxgt(x, y) tests whether x is greater than y."
  },
  {
    "objectID": "/rsh/compute/#p_334",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxge(x, y) tests whether x is greater than or equal to y."
  },
  {
    "objectID": "/rsh/compute/#p_335",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxeq(x, y) tests whether x is equal to y."
  },
  {
    "objectID": "/rsh/compute/#p_336",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} fxne(x, y) tests whether x is not equal to y."
  },
  {
    "objectID": "/rsh/compute/#p_337",
    "pt": "Computations",
    "t": 3,
    "c": "Reach provides a shorthand, {!rsh} Anybody, which serves as a {!rsh} race between all participants. This shorthand can be useful for situations where it does not matter who {!rsh} publishes, such as in a {!rsh} timeout."
  },
  {
    "objectID": "/rsh/compute/#p_338",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} Anybody is strictly an abbreviation of a {!rsh} race involving all of the named participants of the application."
  },
  {
    "objectID": "/rsh/compute/#p_339",
    "pt": "Computations",
    "t": 3,
    "c": "In this code, the {!rsh} Participants are defined on lines 11 and 12. At the moment of {!rsh} timeout, line 47 permits any of the {!rsh} Participants to make a publication."
  },
  {
    "objectID": "/rsh/compute/#p_340",
    "pt": "Computations",
    "t": 3,
    "c": "In an application with a participant class, this means any principal at all, because there is no restriction on which principals (i.e. addresses) may serve as a member of that class. In an application without any participant classes, {!rsh} Anybody instead would mean only the actual previously-bound participants."
  },
  {
    "objectID": "/rsh/compute/#p_341",
    "pt": "Computations",
    "t": 3,
    "c": "An {!rsh} Interval is defined by"
  },
  {
    "objectID": "/rsh/compute/#p_342",
    "pt": "Computations",
    "t": 3,
    "c": "where {!rsh} IntervalType is defined by"
  },
  {
    "objectID": "/rsh/compute/#p_343",
    "pt": "Computations",
    "t": 3,
    "c": "An interval may be constructed with its tuple notation or by function:"
  },
  {
    "objectID": "/rsh/compute/#p_344",
    "pt": "Computations",
    "t": 3,
    "c": "For convenience, Reach provides a number of functions for constructing intervals:"
  },
  {
    "objectID": "/rsh/compute/#p_345",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} interval(IntervalType, Int, Int, IntervalType) constructs an interval where the first and second argument represent the left endpoint and whether it's open or closed; the third and fourth argument represent the right endpoint and whether it's open or closed."
  },
  {
    "objectID": "/rsh/compute/#p_346",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalCC(l, r) constructs a closed interval from two endpoints of type {!rsh} Int."
  },
  {
    "objectID": "/rsh/compute/#p_347",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_348",
    "pt": "Computations",
    "t": 3,
    "c": "This code creates an interval that is closed on both sides using +43 and +14 for the left and right endpoints respectively on line 39."
  },
  {
    "objectID": "/rsh/compute/#p_349",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalCO(l, r) constructs a half-open interval from two endpoints of type {!rsh} Int where the left endpoint is closed and the right endpoint is open."
  },
  {
    "objectID": "/rsh/compute/#p_350",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_351",
    "pt": "Computations",
    "t": 3,
    "c": "This code creates an interval that is closed on the left and opened on the right. It uses +7 and +9 for the left and right endpoints respectively on line 15."
  },
  {
    "objectID": "/rsh/compute/#p_352",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalOC(l, r) constructs a half-open interval from two endpoints of type {!rsh} Int where the left endpoint is open and the right endpoint is closed."
  },
  {
    "objectID": "/rsh/compute/#p_353",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_354",
    "pt": "Computations",
    "t": 3,
    "c": "This code creates an interval that is opened on the left and closed on the right. It uses +3 and +11 for the left and right endpoints respectively on line 23."
  },
  {
    "objectID": "/rsh/compute/#p_355",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalOO(l, r) constructs an open interval from two endpoints of type {!rsh} Int."
  },
  {
    "objectID": "/rsh/compute/#p_356",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_357",
    "pt": "Computations",
    "t": 3,
    "c": "This code creates an interval that is opened on both sides using +4 and +45 for the left and right endpoints respectively on line 28."
  },
  {
    "objectID": "/rsh/compute/#p_358",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} leftEndpoint(i) will return the {!rsh} Int that represents the left endpoint of an interval."
  },
  {
    "objectID": "/rsh/compute/#p_359",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_360",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that the {!rsh} leftEndpoint of y is equivalent to +2 on line 6."
  },
  {
    "objectID": "/rsh/compute/#p_361",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} rightEndpoint(i) will return the {!rsh} Int that represents the right endpoint of an interval."
  },
  {
    "objectID": "/rsh/compute/#p_362",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_363",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that the {!rsh} rightEndpoint of x is not equivalent to {!rsh} rightEndpoint of y on line 12."
  },
  {
    "objectID": "/rsh/compute/#p_364",
    "pt": "Computations",
    "t": 3,
    "c": "Intervals may be compared with the following functions:"
  },
  {
    "objectID": "/rsh/compute/#p_365",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalEq(l, r) tests whether the intervals are equal."
  },
  {
    "objectID": "/rsh/compute/#p_366",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_367",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that the result of testing whether {!rsh} intervalOO(+1, +1) and {!rsh} intervalOO(+1, +1) are eqaul, must evaluate to {!rsh} true on line 4."
  },
  {
    "objectID": "/rsh/compute/#p_368",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalNeq(l, r) tests whether the intervals are not equal."
  },
  {
    "objectID": "/rsh/compute/#p_369",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_370",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that the result of testing whether {!rsh} intervalCC(+1, +2)and {!rsh} intervalCC(+4, +5) are not eqaul, must evaluate to {!rsh} true on line 10."
  },
  {
    "objectID": "/rsh/compute/#p_371",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalLt(l, r) tests whether the left interval is less than the right interval."
  },
  {
    "objectID": "/rsh/compute/#p_372",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_373",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that the result of testing whether {!rsh} intervalCC(+1, +2)is less than {!rsh} intervalCC(+3, +5), must evaluate to {!rsh} true on line 15."
  },
  {
    "objectID": "/rsh/compute/#p_374",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalLte(l, r) tests whether the left interval is less than or equal to the right interval."
  },
  {
    "objectID": "/rsh/compute/#p_375",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_376",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that the result of testing whether {!rsh} intervalOO(+3, +4)is less than or equal to {!rsh} intervalOO(+5, +7), must evaluate to {!rsh} true on line 19."
  },
  {
    "objectID": "/rsh/compute/#p_377",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalGt(l, r) tests whether the left interval is greater than the right interval."
  },
  {
    "objectID": "/rsh/compute/#p_378",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_379",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that the result of testing whether {!rsh} intervalCC(+5, +7)is greater than {!rsh} intervalCC(+3, +4), must evaluate to {!rsh} true on line 25."
  },
  {
    "objectID": "/rsh/compute/#p_380",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalGte(l, r) tests whether the left interval is greater than or equal to the right interval."
  },
  {
    "objectID": "/rsh/compute/#p_381",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_382",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that the result of testing whether {!rsh} intervalCC(+2, +2)is greater than or equal to {!rsh} intervalCC(+2, +2), must evaluate to {!rsh} true on line 30."
  },
  {
    "objectID": "/rsh/compute/#p_383",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalAdd(l, r) adds the two intervals."
  },
  {
    "objectID": "/rsh/compute/#p_384",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_385",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that ex is equivalent to the sum of i1 and i2."
  },
  {
    "objectID": "/rsh/compute/#p_386",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalSub(l, r) subtracts the two intervals."
  },
  {
    "objectID": "/rsh/compute/#p_387",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_388",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that ex is equivalent to the difference of i1 and i2."
  },
  {
    "objectID": "/rsh/compute/#p_389",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalMul(l, r) multiplies the two intervals."
  },
  {
    "objectID": "/rsh/compute/#p_390",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_391",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that ex is equivalent to the product of i1 and i2."
  },
  {
    "objectID": "/rsh/compute/#p_392",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalDiv(l, r) divides the two intervals."
  },
  {
    "objectID": "/rsh/compute/#p_393",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_394",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that ex is equivalent to the outcome of the division of i1 and i2."
  },
  {
    "objectID": "/rsh/compute/#p_395",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalIntersection(x, y) returns the intersection of two intervals."
  },
  {
    "objectID": "/rsh/compute/#p_396",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_397",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that ii is equivalent to the intersection of i1 and i2."
  },
  {
    "objectID": "/rsh/compute/#p_398",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalUnion(x, y) returns the union of two intervals."
  },
  {
    "objectID": "/rsh/compute/#p_399",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_400",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that iu is equivalent to the union of i1 and i2."
  },
  {
    "objectID": "/rsh/compute/#p_401",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalWidth(i) returns the width of an interval."
  },
  {
    "objectID": "/rsh/compute/#p_402",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_403",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that +41 is equivalent to the width of interval i."
  },
  {
    "objectID": "/rsh/compute/#p_404",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} intervalAbs(i) returns the absolute value of an interval."
  },
  {
    "objectID": "/rsh/compute/#p_405",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_406",
    "pt": "Computations",
    "t": 3,
    "c": "This code {!rsh} asserts that +10 is equivalent to the absolute value of interval i."
  },
  {
    "objectID": "/rsh/compute/#p_407",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} getUntrackedFunds(?token) takes an optional {!rsh} Token argument and returns the difference between the actual balance of the contract and Reach's expectation of the balance for the given token, or network token if no argument is provided. For example, if funds were externally sent to the contract or rewards were earned, this function gives you access to them. Once this function is called, the amount returned is incorporated into Reach's expectation of the balance. So, the amount returned must eventually be transferred out of the contract to satisfy the token linearity property."
  },
  {
    "objectID": "/rsh/compute/#p_408",
    "pt": "Computations",
    "t": 3,
    "c": "If a contract were to have its funds improperly removed, through clawback or other means, and the actual balance is less than Reach's expectation, this function will return {!rsh} 0."
  },
  {
    "objectID": "/rsh/compute/#p_409",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_410",
    "pt": "Computations",
    "t": 3,
    "c": "The untracked tokens are set to x and then transferred to B."
  },
  {
    "objectID": "/rsh/compute/#p_411",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} distinct(...args) evaluates to {!rsh} true when all its arguments are distinct from each other."
  },
  {
    "objectID": "/rsh/compute/#p_412",
    "pt": "Computations",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/compute/#p_413",
    "pt": "Computations",
    "t": 3,
    "c": "This code makes an assumption that all the {!rsh} tokens passed into the {!rsh} distinct method are clearly different from each other."
  },
  {
    "objectID": "/rsh/compute/#p_414",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} currentMode() evaluates to a {!rsh} Data instance with variants Module, AppInit, Step, Local, Consensus, and Export, corresponding to the current mode of the Reach application."
  },
  {
    "objectID": "/rsh/compute/#p_415",
    "pt": "Computations",
    "t": 3,
    "c": "mixin is an implementation of mixins (see Wikipedia or the Racket Documentation for an explanation of mixins) for composing contract interfaces. (These mixins are only for the interface, not the implementation.)"
  },
  {
    "objectID": "/rsh/compute/#p_416",
    "pt": "Computations",
    "t": 3,
    "c": "The function takes an object that optionally contains the fields IDs, View, Events, and API. This object represents the interface of a contract, where IDs is a {!rsh} Tuple of constants, View is a {!rsh} Tuple of arguments to {!rsh} View, Events is a {!rsh} Tuple of arguments to {!rsh} Events, and API is a {!rsh} Tuple of arguments to {!rsh} API. The object optionally also contains a Base field, which will be used as a default base interface when constructing the combined contract interface."
  },
  {
    "objectID": "/rsh/compute/#p_417",
    "pt": "Computations",
    "t": 3,
    "c": "{!rsh} mixin returns a function, which, when called, combines all of the base interfaces and constructs the final API, View, and Events (using the {!rsh} API, {!rsh} View, and {!rsh} Events constructors respectively). The returned function also takes an optional Base parameter, which will be used instead of the base interface found in the Base field passed to {!rsh} mixin. (It is useful to modify the Base to implement a specific order of instantiation to implement multiple inheritance.)"
  },
  {
    "objectID": "/rsh/compute/#p_418",
    "pt": "Computations",
    "t": 3,
    "c": "After composition, the individual components can be access normally. For example, {!rsh} mixin(....)().View.v.set(vv) would set the v {!rsh} View regardless of where the interface was defined. The IDs component is intended to hold byte strings that represent ERC-165 interface identifiers."
  },
  {
    "objectID": "/rsh/compute/#p_419",
    "pt": "Computations",
    "t": 3,
    "c": "For example, we define all of the interfaces that are part of the ERC-721 NFT specification using {!rsh} mixin:"
  },
  {
    "objectID": "/rsh/compute/#p_420",
    "pt": "Computations",
    "t": 3,
    "c": "Then, we construct the final mixed contract, and overriding ERC721EnumerablePartial's base with ERC721Metadata (because we want both extensions to ERC-721):"
  },
  {
    "objectID": "/rsh/consensus/#rsh_commit",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "commit"
  },
  {
    "objectID": "/rsh/consensus/#rsh_Participant.set",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "Participant.set"
  },
  {
    "objectID": "/rsh/consensus/#rsh_while",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "while"
  },
  {
    "objectID": "/rsh/consensus/#rsh_var",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "var"
  },
  {
    "objectID": "/rsh/consensus/#rsh_invariant",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "invariant"
  },
  {
    "objectID": "/rsh/consensus/#rsh_continue",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "continue"
  },
  {
    "objectID": "/rsh/consensus/#rsh_parallelReduce",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "parallelReduce"
  },
  {
    "objectID": "/rsh/consensus/#rsh_parallelReduce.define",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "parallelReduce.define"
  },
  {
    "objectID": "/rsh/consensus/#rsh_parallelReduce.invariant",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "parallelReduce.invariant"
  },
  {
    "objectID": "/rsh/consensus/#rsh_parallelReduce.while",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "parallelReduce.while"
  },
  {
    "objectID": "/rsh/consensus/#rsh_parallelReduce.paySpec",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "parallelReduce.paySpec"
  },
  {
    "objectID": "/rsh/consensus/#rsh_parallelReduce.case",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "parallelReduce.case"
  },
  {
    "objectID": "/rsh/consensus/#rsh_parallelReduce.api",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "parallelReduce.api"
  },
  {
    "objectID": "/rsh/consensus/#rsh_parallelReduce.api_",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "parallelReduce.api_"
  },
  {
    "objectID": "/rsh/consensus/#rsh_parallelReduce.timeout",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "parallelReduce.timeout"
  },
  {
    "objectID": "/rsh/consensus/#rsh_parallelReduce.timeRemaining",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "parallelReduce.timeRemaining"
  },
  {
    "objectID": "/rsh/consensus/#rsh_parallelReduce.throwTimeout",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "parallelReduce.throwTimeout"
  },
  {
    "objectID": "/rsh/consensus/#rsh_transfer",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "transfer"
  },
  {
    "objectID": "/rsh/consensus/#rsh_transfer.to",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "transfer.to"
  },
  {
    "objectID": "/rsh/consensus/#rsh_require",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "require"
  },
  {
    "objectID": "/rsh/consensus/#rsh_checkCommitment",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "checkCommitment"
  },
  {
    "objectID": "/rsh/consensus/#rsh_burn",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "burn"
  },
  {
    "objectID": "/rsh/consensus/#rsh_Token.burn",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "Token.burn"
  },
  {
    "objectID": "/rsh/consensus/#rsh_destroy",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "destroy"
  },
  {
    "objectID": "/rsh/consensus/#rsh_Token.destroy",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "Token.destroy"
  },
  {
    "objectID": "/rsh/consensus/#rsh_supply",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "supply"
  },
  {
    "objectID": "/rsh/consensus/#rsh_Token.supply",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "Token.supply"
  },
  {
    "objectID": "/rsh/consensus/#rsh_destroyed",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "destroyed"
  },
  {
    "objectID": "/rsh/consensus/#rsh_Token.destroyed",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "Token.destroyed"
  },
  {
    "objectID": "/rsh/consensus/#rsh_Token.track",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "Token.track"
  },
  {
    "objectID": "/rsh/consensus/#rsh_Token.accepted",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "Token.accepted"
  },
  {
    "objectID": "/rsh/consensus/#rsh_remote",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "remote"
  },
  {
    "objectID": "/rsh/consensus/#rsh_REMOTE_FUN",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "REMOTE_FUN"
  },
  {
    "objectID": "/rsh/consensus/#rsh_bill",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "bill"
  },
  {
    "objectID": "/rsh/consensus/#rsh_withBill",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "withBill"
  },
  {
    "objectID": "/rsh/consensus/#rsh_remote.ALGO",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "remote.ALGO"
  },
  {
    "objectID": "/rsh/consensus/#rsh_Contract.fromAddress",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "Contract.fromAddress"
  },
  {
    "objectID": "/rsh/consensus/#rsh_Map",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "Map"
  },
  {
    "objectID": "/rsh/consensus/#rsh_Set",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "Set"
  },
  {
    "objectID": "/rsh/consensus/#rsh_Set.insert",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "Set.insert"
  },
  {
    "objectID": "/rsh/consensus/#rsh_Set.remove",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "Set.remove"
  },
  {
    "objectID": "/rsh/consensus/#rsh_Set.member",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "Set.member"
  },
  {
    "objectID": "/rsh/consensus/#rsh_Set.Map",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "Set.Map"
  },
  {
    "objectID": "/rsh/consensus/#rsh_new%20Contract",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "new Contract"
  },
  {
    "objectID": "/rsh/consensus/#rsh_Contract.new",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "Contract.new"
  },
  {
    "objectID": "/rsh/consensus/#rsh_ALGO.blockSeed",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "ALGO.blockSeed"
  },
  {
    "objectID": "/rsh/consensus/#rsh_ALGO.blockSecs",
    "pt": "Consensus Steps",
    "t": 0,
    "s": "rsh",
    "c": "ALGO.blockSecs"
  },
  {
    "objectID": "/rsh/consensus/#term_commit%20statement",
    "pt": "Consensus Steps",
    "t": 1,
    "c": "commit statement"
  },
  {
    "objectID": "/rsh/consensus/#term_view%20object",
    "pt": "Consensus Steps",
    "t": 1,
    "c": "view object"
  },
  {
    "objectID": "/rsh/consensus/#term_event%20object",
    "pt": "Consensus Steps",
    "t": 1,
    "c": "event object"
  },
  {
    "objectID": "/rsh/consensus/#term_while%20statement",
    "pt": "Consensus Steps",
    "t": 1,
    "c": "while statement"
  },
  {
    "objectID": "/rsh/consensus/#term_loop%20invariant",
    "pt": "Consensus Steps",
    "t": 1,
    "c": "loop invariant"
  },
  {
    "objectID": "/rsh/consensus/#term_continue%20statement",
    "pt": "Consensus Steps",
    "t": 1,
    "c": "continue statement"
  },
  {
    "objectID": "/rsh/consensus/#term_parallel%20reduce%20statement",
    "pt": "Consensus Steps",
    "t": 1,
    "c": "parallel reduce statement"
  },
  {
    "objectID": "/rsh/consensus/#term_transfer%20expression",
    "pt": "Consensus Steps",
    "t": 1,
    "c": "transfer expression"
  },
  {
    "objectID": "/rsh/consensus/#term_token%20minting",
    "pt": "Consensus Steps",
    "t": 1,
    "c": "token minting"
  },
  {
    "objectID": "/rsh/consensus/#term_burn",
    "pt": "Consensus Steps",
    "t": 1,
    "c": "burn"
  },
  {
    "objectID": "/rsh/consensus/#term_remote%20object",
    "pt": "Consensus Steps",
    "t": 1,
    "c": "remote object"
  },
  {
    "objectID": "/rsh/consensus/#term_remote%20functions",
    "pt": "Consensus Steps",
    "t": 1,
    "c": "remote functions"
  },
  {
    "objectID": "/rsh/consensus/#ref-programs-consensus",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "Consensus Steps"
  },
  {
    "objectID": "/rsh/consensus/#ref-programs-consensus-stmts",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "Statements"
  },
  {
    "objectID": "/rsh/consensus/#commit",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "commit"
  },
  {
    "objectID": "/rsh/consensus/#ref-programs-only-consensus",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "only and each"
  },
  {
    "objectID": "/rsh/consensus/#ref-programs-consensus-view",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "View Objects"
  },
  {
    "objectID": "/rsh/consensus/#ref-programs-consensus-events",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "Event Objects"
  },
  {
    "objectID": "/rsh/consensus/#participantset--and--set",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "Participant.set and .set"
  },
  {
    "objectID": "/rsh/consensus/#while",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "while"
  },
  {
    "objectID": "/rsh/consensus/#continue",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "continue"
  },
  {
    "objectID": "/rsh/consensus/#parallelreduce",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "parallelReduce"
  },
  {
    "objectID": "/rsh/consensus/#timeremaining",
    "pt": "Consensus Steps",
    "t": 2,
    "c": ".timeRemaining"
  },
  {
    "objectID": "/rsh/consensus/#throwtimeout",
    "pt": "Consensus Steps",
    "t": 2,
    "c": ".throwTimeout"
  },
  {
    "objectID": "/rsh/consensus/#parallelreduce--intuition",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "parallelReduce intuition"
  },
  {
    "objectID": "/rsh/consensus/#ref-programs-consensus-exprs",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "Expressions"
  },
  {
    "objectID": "/rsh/consensus/#ref-programs-consensus-this",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "this"
  },
  {
    "objectID": "/rsh/consensus/#transfer",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "transfer"
  },
  {
    "objectID": "/rsh/consensus/#require",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "require"
  },
  {
    "objectID": "/rsh/consensus/#checkcommitment",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "checkCommitment"
  },
  {
    "objectID": "/rsh/consensus/#ref-programs-consensus-token-minting",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "Token minting"
  },
  {
    "objectID": "/rsh/consensus/#remote-objects",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "Remote objects"
  },
  {
    "objectID": "/rsh/consensus/#contractfromaddress",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "Contract.fromAddress"
  },
  {
    "objectID": "/rsh/consensus/#mappings-creation-and-modification",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "Mappings: creation and modification"
  },
  {
    "objectID": "/rsh/consensus/#sets-creation-and-modification",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "Sets: creation and modification"
  },
  {
    "objectID": "/rsh/consensus/#ref-programs-consensus-new-contract",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "Contract creation"
  },
  {
    "objectID": "/rsh/consensus/#algorand-specific-block-data-access",
    "pt": "Consensus Steps",
    "t": 2,
    "c": "Algorand-specific block data access"
  },
  {
    "objectID": "/rsh/consensus/#p_0",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A Reach consensus step occurs in the continuation of a consensus transfer statement. It represents the actions taken by the consensus network contract of an application."
  },
  {
    "objectID": "/rsh/consensus/#p_1",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Any statements valid for a computation are valid for a consensus step. However, some additional statements are allowed."
  },
  {
    "objectID": "/rsh/consensus/#p_2",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A commit statement, written {!rsh} commit();, commits to statement's continuation as the next step of the DApp computation. In other words, it ends the current consensus step and allows more local steps."
  },
  {
    "objectID": "/rsh/consensus/#p_3",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "For example, in the code below, the {!rsh} commit(); on line 79 allows Alice to perform a local step after a consensus step:"
  },
  {
    "objectID": "/rsh/consensus/#p_4",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "only and each are allowed in consensus steps and are executed by backends once they observe the completion of the consensus step (i.e., after the associated commit statement.)"
  },
  {
    "objectID": "/rsh/consensus/#p_5",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Views are defined in application initialization in Reach. They are accessed by frontends by using the Reach standard library of the frontend language, such as JavaScript. This section is about defining the value of a view in your Reach program."
  },
  {
    "objectID": "/rsh/consensus/#p_6",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "If {!rsh} VIEW is a view object, then its fields are the elements of the associated view. Each of these fields are bound to an object with a set method that accepts the function or value to be bound to that view at the current step, and all steps dominated by the current step (unless otherwise overridden). If this function is not provided with an argument, then the corresponding view is unset."
  },
  {
    "objectID": "/rsh/consensus/#p_7",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "For example, consider the following program:"
  },
  {
    "objectID": "/rsh/consensus/#p_8",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "In this program, the Reach backend calls the frontend {!rsh} interact function, {!rsh} checkView with the expected value of the views at each point in the program. The frontend compares that value with what is returned by"
  },
  {
    "objectID": "/rsh/consensus/#p_9",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "When a view is bound to a function, it may inspect any values in its scope, including linear state."
  },
  {
    "objectID": "/rsh/consensus/#p_10",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "If {!rsh} EVENT is an event object, then its fields are the elements of the associated event. Each of these fields are a function, whose domain is specified by the {!rsh} Events interface."
  },
  {
    "objectID": "/rsh/consensus/#p_11",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "For example, consider the following program:"
  },
  {
    "objectID": "/rsh/consensus/#p_12",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "In this program, there is an announcement made every loop; an event is emitted with the published {!rsh} ctc and its corresponding index {!rsh} i. A frontend may observe the values of these events with {!js} await ctc.e.Announcer.announce.next() or {!js} await ctc.e.Announcer.announce.monitor(announceHandler) where {!js} announceHandler is a function."
  },
  {
    "objectID": "/rsh/consensus/#p_13",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "After execution, the given participant is fixed to the given address. It is invalid to attempt to {!rsh} .set a participant class. If a backend is running for this participant and its address does not match the given address, then it will abort. This may only occur within a consensus step."
  },
  {
    "objectID": "/rsh/consensus/#p_14",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Relay Account is a good introductory project that demonstrates how to use this feature of Reach."
  },
  {
    "objectID": "/rsh/consensus/#p_15",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/consensus/#p_16",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Alice first publishes the amount and the participant, relay, that will receive the amount, and then completes a {!rsh} pay action. Then, the address of Relay is {!rsh} set in the consensus step, to make sure it is remembered by the consensus. This code is also an assert that relay is the address of the participant Relay."
  },
  {
    "objectID": "/rsh/consensus/#p_17",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A while statement may occur within a consensus step and is written:"
  },
  {
    "objectID": "/rsh/consensus/#p_18",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "where {!rsh} LHS is a valid left-hand side of an identifier definition where the expression {!rsh} INIT_EXPR is the right-hand side, and {!rsh} DEFINE_BLOCK is an optional block that may define bindings that use the {!rsh} LHS values which are bound inside the rest of the {!rsh} while and its tail, and {!rsh} INVARIANT_EXPR is an expression, called the loop invariant, that must be true before and after every execution of the block {!rsh} BLOCK—it may be specified multiple times, INVARIANT_MSG is an optional bytes argument, which is included in any reported violation, and if {!rsh} COND_EXPR is true, then the block executes, and if not, then the loop terminates and control transfers to the continuation of the while statement. The identifiers bound by {!rsh} LHS are bound within {!rsh} DEFINE_BLOCK, {!rsh} INVARIANT_EXPR, {!rsh} COND_EXPR, {!rsh} BLOCK, and the tail of the while statement."
  },
  {
    "objectID": "/rsh/consensus/#p_19",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The identifier {!rsh} this is not bound within {!rsh} DEFINE_BLOCK, {!rsh} INVARIANT_EXPR, {!rsh} COND_EXPR, {!rsh} BLOCK, or after the {!rsh} while. This is because it will almost never mean what you think it means: you may think it means the actor, but it actually means the previous actor."
  },
  {
    "objectID": "/rsh/consensus/#p_20",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Read about finding loop invariants in the Reach guide."
  },
  {
    "objectID": "/rsh/consensus/#p_21",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A continue statement may occur within a while statement's block and is written:"
  },
  {
    "objectID": "/rsh/consensus/#p_22",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "where the identifiers bound by {!rsh} LHS are a subset of the variables bound by the nearest enclosing while statement and {!rsh} UPDATE_EXPR is an expression which may be bound by {!rsh} LHS."
  },
  {
    "objectID": "/rsh/consensus/#p_23",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A continue statement is a terminator statement, so it must have an empty tail."
  },
  {
    "objectID": "/rsh/consensus/#p_24",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A continue statement may be written without the preceding identifier update, which is equivalent to writing"
  },
  {
    "objectID": "/rsh/consensus/#p_25",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A continue statement must be dominated by a consensus transfer, which means that the body of a while statement must always {!rsh} commit(); before calling {!rsh} continue;. This restriction may be lifted in future versions of Reach, which will perform termination checking."
  },
  {
    "objectID": "/rsh/consensus/#p_26",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "As a special case, a continue statement may occur in a step, if the {!rsh} UPDATE_EXPR transitions to a consensus step. In other words, this is a valid program:"
  },
  {
    "objectID": "/rsh/consensus/#p_27",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The following example displays how a {!rsh} continue is used inside of a {!rsh} while loop that started in line 43. Bob and Alice race to be the first to {!rsh} publish and therefore be the round winner. When one of them publishes, the keepGoing function returns false, and the program hits {!rsh} continue where it exits the {!rsh} race and moves on with the rest of the program."
  },
  {
    "objectID": "/rsh/consensus/#p_28",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "If you're unsure of what kind of consensus transfer to use, you may want to read the explanation of the differences in the Guide."
  },
  {
    "objectID": "/rsh/consensus/#p_29",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A parallel reduce statement is written:"
  },
  {
    "objectID": "/rsh/consensus/#p_30",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The {!rsh} LHS and {!rsh} INIT_EXPR are like the initialization component of a {!rsh} while loop; and, the {!rsh} .invariant and {!rsh} .while components are like the invariant and condition of a {!rsh} while loop; multiple .invariants may be specified; the {!rsh} DEFINE_BLOCK is like the {!rsh} DEFINE_BLOCK of a {!rsh} while loop. It may be specified multiple times; while the {!rsh} .case, {!rsh} .api, {!rsh} .api_, {!rsh} .timeout, and {!rsh} .paySpec components are like the corresponding components of a {!rsh} fork statement."
  },
  {
    "objectID": "/rsh/consensus/#p_31",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The {!rsh} .case component may be repeated many times, just like in a {!rsh} fork statement."
  },
  {
    "objectID": "/rsh/consensus/#p_32",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The {!rsh} .define component may define bindings that reference the {!rsh} LHS values. These bindings are accessible from every component of the {!rsh} parallelReduce statement, except for the {!rsh} INIT_EXPR."
  },
  {
    "objectID": "/rsh/consensus/#p_33",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Like a {!rsh} while, the {!rsh} this variable is not bound anywhere except for {!rsh} INIT_EXPR."
  },
  {
    "objectID": "/rsh/consensus/#p_34",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "When dealing with absolute deadlines in {!rsh} parallelReduce, there is a common pattern in the {!rsh} TIMEOUT_BLOCK to have participants {!rsh} race to {!rsh} publish and return the accumulator. There is a shorthand, {!rsh} .timeRemaining, available for this situation:"
  },
  {
    "objectID": "/rsh/consensus/#p_35",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "which will expand to:"
  },
  {
    "objectID": "/rsh/consensus/#p_36",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} .throwTimeout is a shorthand that will throw the accumulator as an exception when a timeout occurs. Therefore, a {!rsh} parallelReduce that uses this branch must be inside of a try statement. For example,"
  },
  {
    "objectID": "/rsh/consensus/#p_37",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "will expand {!rsh} throwTimeout to:"
  },
  {
    "objectID": "/rsh/consensus/#p_38",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A parallel reduce statement is essentially an abbreviation of pattern of a {!rsh} while loop combined with a {!rsh} fork statement that you could write yourself. This is an extremely common pattern in decentralized applications."
  },
  {
    "objectID": "/rsh/consensus/#p_39",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The idea is that there are some values (the {!rsh} LHS) which after intialization will be repeatedly updated uniquely by each of the racing participants until the condition does not hold."
  },
  {
    "objectID": "/rsh/consensus/#p_40",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Any expressions valid for a computation are valid for a consensus step. However, some additional expressions are allowed."
  },
  {
    "objectID": "/rsh/consensus/#p_41",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Inside of a consensus step, {!rsh} this refers to the address of the participant that performed the consensus transfer. This is useful when the consensus transfer was initiated by a {!rsh} race expression."
  },
  {
    "objectID": "/rsh/consensus/#p_42",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A transfer expression, written {!rsh} transfer(PAY_AMOUNT_EXPR).to(ADDR_EXPR), where {!rsh} PAY_AMOUNT_EXPR is an expression that evaluates to a pay amount, and {!rsh} ADDR_EXPR evaluates to an address, performs a transfer of network tokens or non-network tokens from the contract to the named participant. The amount transfered must evaluate to less than or equal to the balance of the network and non-network tokens in the contract account."
  },
  {
    "objectID": "/rsh/consensus/#p_43",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A transfer expression may only occur within a consensus step."
  },
  {
    "objectID": "/rsh/consensus/#p_44",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The first {!rsh} transfer example from the Simple NFT Auction pays the lastPrice to the NFT Creator. The second {!rsh} transfer example gives the sale quantity of the NFT to the {!rsh} Participant that bid the highest price."
  },
  {
    "objectID": "/rsh/consensus/#p_45",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A requirement where {!rsh} claim evaluates to {!rsh} true with honest participants. This may only appear in a consensus step. It accepts an optional bytes argument, which is included in any reported violation."
  },
  {
    "objectID": "/rsh/consensus/#p_46",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "If a publication would violate the requirement, the consensus network rejects the transaction."
  },
  {
    "objectID": "/rsh/consensus/#p_47",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The example above has Alice publish two tokens named token1 and token2 and the {!rsh} require statement checks if they are different tokens. If they are not different tokens, then the transaction is rejected."
  },
  {
    "objectID": "/rsh/consensus/#p_48",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Makes a requirement that {!rsh} commitment is the digest of {!rsh} salt and {!rsh} x. This is used in a consensus step after {!rsh} makeCommitment was used in a local step."
  },
  {
    "objectID": "/rsh/consensus/#p_49",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The example below shows {!rsh} checkCommitment being used in a consensus step on line 87 after {!rsh} makeCommitment was used in a local step on line 66:"
  },
  {
    "objectID": "/rsh/consensus/#p_50",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Networks discusses how Reach supports token minting on specific consensus networks."
  },
  {
    "objectID": "/rsh/consensus/#p_51",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "We refer to creation of a new non-network token as token minting. It is written with the expression {!rsh} new Token(PARAMS), where {!rsh} PARAMS is an object with the following keys:"
  },
  {
    "objectID": "/rsh/consensus/#p_52",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "name: A value of type {!rsh} Bytes(32); defaults to empty."
  },
  {
    "objectID": "/rsh/consensus/#p_53",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "symbol: A value of type {!rsh} Bytes(8); defaults to empty."
  },
  {
    "objectID": "/rsh/consensus/#p_54",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "url: A value of type {!rsh} Bytes(96); defaults to empty."
  },
  {
    "objectID": "/rsh/consensus/#p_55",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "metadata: A value of type {!rsh} Bytes(32); defaults to empty. This value is intended to be a digest of a larger metadata document."
  },
  {
    "objectID": "/rsh/consensus/#p_56",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "supply: A value of type {!rsh} UInt; defaults to {!rsh} UInt.max."
  },
  {
    "objectID": "/rsh/consensus/#p_57",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "decimals: A value of type {!rsh} UInt; defaults to {!rsh} 6 on Algorand, and {!rsh} 18 on Ethereum."
  },
  {
    "objectID": "/rsh/consensus/#p_58",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The following examples demonstrate how the details above may be used:"
  },
  {
    "objectID": "/rsh/consensus/#p_59",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "This returns a {!rsh} Token value and deposits a {!rsh} supply amount of the new non-network tokens into the contract account associated with the DApp. These tokens must be destroyed by the end of the DApp."
  },
  {
    "objectID": "/rsh/consensus/#p_60",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Reach assumes that network tokens and non-network tokens behave identically, but often they do not; this article discusses the causes and consequences of this."
  },
  {
    "objectID": "/rsh/consensus/#p_61",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} Token.burn(tok, amt?), or {!rsh} tok.burn(amt?), where {!rsh} tok is a {!rsh} Token value and {!rsh} amt is a {!rsh} UInt value, may be used to burn tokens in the contract account, meaning that they are utterly destroyed and can never be recovered. If {!rsh} amt is not given, the current balance of the token will be used."
  },
  {
    "objectID": "/rsh/consensus/#p_62",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} Token.destroy(tok), or {!rsh} tok.destroy(), where {!rsh} tok is a {!rsh} Token value, may be used to destroy the token so that it may never be used again by any users on the consensus network. This must be called before the application exits."
  },
  {
    "objectID": "/rsh/consensus/#p_63",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} Token.destroyed(tok), or {!rsh} tok.destroyed(), where {!rsh} tok is a {!rsh} Token value, returns whether {!rsh} destroy has been called on {!rsh} tok yet."
  },
  {
    "objectID": "/rsh/consensus/#p_64",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} Token.supply(tok), or {!rsh} tok.supply(), where {!rsh} tok is a {!rsh} Token value, may be used to query the current supply of tokens, i.e. the number of tokens which have not been burnt."
  },
  {
    "objectID": "/rsh/consensus/#p_65",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} Token.track(tok), or {!rsh} tok.track(), where {!rsh} tok is a {!rsh} Token value, may be used to explicitly start tracking the balance of a non-network token in an application. This operation is useful for tracking a token that is received from an API call or published within a container, like an {!rsh} Array or {!rsh} Data object."
  },
  {
    "objectID": "/rsh/consensus/#p_66",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} Token.accepted(acc, tok), where {!rsh} acc is an {!rsh} Account value and {!rsh} tok is a {!rsh} Token value, returns true if {!rsh} acc is ready to accept non-network tokens specified by {!rsh} tok, and false otherwise. This always returns true on some consensus networks, but could be useful on others where accounts need to explicitly agree to receive non-network tokens."
  },
  {
    "objectID": "/rsh/consensus/#p_67",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Networks discusses how Reach supports remote objects on specific consensus networks."
  },
  {
    "objectID": "/rsh/consensus/#p_68",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A remote object represents a foreign contract in a Reach application. During a consensus step, a Reach computation may consensually communicate with such an object via a prescribed interface."
  },
  {
    "objectID": "/rsh/consensus/#p_69",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A remote object is constructed by calling the {!rsh} remote function with a {!rsh} Contract, an interface---an object where each key is bound to a function type, and an optional object of aliases. The alias object maps function names from the interface to function names on the remote contract. It allows users to bind specific instances of an overloaded remote function. For example:"
  },
  {
    "objectID": "/rsh/consensus/#p_70",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "In this example, the random oracle contract has an overloaded method, random. This random method accepts 0 or 1 parameters. We explicitly specify that getRandom refers to calling the random function with no arguments, and getRandom1 refers to calling the random function with 1 argument."
  },
  {
    "objectID": "/rsh/consensus/#p_71",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Once constructed, the fields of a remote object represent those remote contract interactions, referred to as remote functions. For example, {!rsh} randomOracle.getRandom, {!rsh} token.balanceOf, and {!rsh} token.transferTo are remote functions in the example."
  },
  {
    "objectID": "/rsh/consensus/#p_72",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A remote function may be invoked by calling it with the appropriate arguments, whereupon it returns the specified output. In addition, a remote function may be augmented with one of the following operations:"
  },
  {
    "objectID": "/rsh/consensus/#p_73",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} REMOTE_FUN.pay(AMT) --- Returns a remote function that receives a pay amount, {!rsh} AMT, from the caller when it is called."
  },
  {
    "objectID": "/rsh/consensus/#p_74",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} REMOTE_FUN.bill(AMT) --- Returns a remote function that provides a pay amount, {!rsh} AMT, to the caller when it returns."
  },
  {
    "objectID": "/rsh/consensus/#p_75",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} REMOTE_FUN.withBill() --- Returns a remote function that provides some number of network tokens and, possibly, non-network tokens to the caller when it returns. The exact amount is returned from the invocation by wrapping the original result in a tuple."
  },
  {
    "objectID": "/rsh/consensus/#p_76",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} REMOTE_FUN.ALGO(opts) --- Returns a remote function that records the need for additional resources on Algorand.76 {!rsh} opts.fees records extra fees. If this is needed, and not included, then the consensus transfer to the current consensus step will fail with an insufficient fee error.77 {!rsh} opts.accounts records extra accounts. If this is needed, and not included, then the consensus transfer to the current consensus step will fail with an invalid account reference.78 {!rsh} opts.boxes records extra boxes. The values may be tuples of length two where the first is the application index (as a {!rsh} Contract or {!rsh} UInt) and the second is the box name (as anything that consumes 64 bytes or fewer bytes). Alternatively, the values may be tuples of length three where the first is the application index, the second is the Reach {!rsh} Map index, and the third is the Reach {!rsh} Map key for the box. (In this case, Reach will use its box name resolution algorithm to compute the box name.) If this is needed, and not included, then the consensus transfer to the current consensus step will fail with an invalid box reference.79 {!rsh} opts.assets records extra assets. If this is needed, and not included, then the consensus transfer to the current consensus step will fail with an invalid asset reference.80 {!rsh} opts.apps records extra applications. If this is needed, and not included, then the consensus transfer to the current consensus step will fail with an invalid application reference.81 {!rsh} opts.addressToAccount changes {!rsh} Address arguments to Account array references. If this is needed, and not included, then the consensus transfer to the current consensus step will fail because an incorrectly typed argument was provided to the remote object.82 {!rsh} opts.onCompletion sets the OnCompletion field of the transaction. The value is a string for the field value; e.g., {!rsh} 'DeleteApplication'. It is dangerous to call this with OptIn, because the minimum balance of the calling contract will increase and Reach cannot track that, because it is not statically available. The minimum balance will decrease on a CloseOut or ClearState transaction.83 {!rsh} opts.strictPay does not optimize away pay or axfer transactions that are statically zero. If this is needed, and not included, then {!rsh} remote calls that require a payment transaction to always be present, even if the amount is zero, could fail.84 {!rsh} opts.rawCall is a boolean (default {!rsh} false) that when {!rsh} true omits the ABI method selector from the call.85 {!rsh} opts.simNetRecv is an integer field (default {!rsh} 0). The field represents how many network tokens Reach will assume your contract received from the remote call, for the purposes of transaction simulation. This is useful when using {!rsh} withBill and {!rsh} enforce to enforce that your contract received a certain number network tokens from the remote call.86 {!rsh} opts.simTokensRecv is a tuple-of-integers field (default all zeros). The field represents how many of each non-network token Reach will assume your contract received from the remote call, for the purposes of transaction simulation. Amounts must be specified in the same order as in the call to {!rsh} bill or {!rsh} withBill. This is useful when using {!rsh} withBill and {!rsh} enforce to enforce that your contract received a certain number non-network tokens from the remote call.87 {!rsh} opts.simReturnVal is a field whose type must match the returned type of the remote function (default depends on return type). The field represents the return value of the remote function, for the purposes of transaction simulation. This is useful when using {!rsh} enforce on the return value of the remote function.88 {!rsh} opts.txnOrderForward is a boolean (default {!rsh} false) that when {!rsh} true has the payment transactions in the forward order (net and then assets in order) rather than the reverse order (assets in reverse order and then net). The default is suited for calling Reach servers."
  },
  {
    "objectID": "/rsh/consensus/#p_77",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} opts.fees records extra fees. If this is needed, and not included, then the consensus transfer to the current consensus step will fail with an insufficient fee error."
  },
  {
    "objectID": "/rsh/consensus/#p_78",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} opts.accounts records extra accounts. If this is needed, and not included, then the consensus transfer to the current consensus step will fail with an invalid account reference."
  },
  {
    "objectID": "/rsh/consensus/#p_79",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} opts.boxes records extra boxes. The values may be tuples of length two where the first is the application index (as a {!rsh} Contract or {!rsh} UInt) and the second is the box name (as anything that consumes 64 bytes or fewer bytes). Alternatively, the values may be tuples of length three where the first is the application index, the second is the Reach {!rsh} Map index, and the third is the Reach {!rsh} Map key for the box. (In this case, Reach will use its box name resolution algorithm to compute the box name.) If this is needed, and not included, then the consensus transfer to the current consensus step will fail with an invalid box reference."
  },
  {
    "objectID": "/rsh/consensus/#p_80",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} opts.assets records extra assets. If this is needed, and not included, then the consensus transfer to the current consensus step will fail with an invalid asset reference."
  },
  {
    "objectID": "/rsh/consensus/#p_81",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} opts.apps records extra applications. If this is needed, and not included, then the consensus transfer to the current consensus step will fail with an invalid application reference."
  },
  {
    "objectID": "/rsh/consensus/#p_82",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} opts.addressToAccount changes {!rsh} Address arguments to Account array references. If this is needed, and not included, then the consensus transfer to the current consensus step will fail because an incorrectly typed argument was provided to the remote object."
  },
  {
    "objectID": "/rsh/consensus/#p_83",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} opts.onCompletion sets the OnCompletion field of the transaction. The value is a string for the field value; e.g., {!rsh} 'DeleteApplication'. It is dangerous to call this with OptIn, because the minimum balance of the calling contract will increase and Reach cannot track that, because it is not statically available. The minimum balance will decrease on a CloseOut or ClearState transaction."
  },
  {
    "objectID": "/rsh/consensus/#p_84",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} opts.strictPay does not optimize away pay or axfer transactions that are statically zero. If this is needed, and not included, then {!rsh} remote calls that require a payment transaction to always be present, even if the amount is zero, could fail."
  },
  {
    "objectID": "/rsh/consensus/#p_85",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} opts.rawCall is a boolean (default {!rsh} false) that when {!rsh} true omits the ABI method selector from the call."
  },
  {
    "objectID": "/rsh/consensus/#p_86",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} opts.simNetRecv is an integer field (default {!rsh} 0). The field represents how many network tokens Reach will assume your contract received from the remote call, for the purposes of transaction simulation. This is useful when using {!rsh} withBill and {!rsh} enforce to enforce that your contract received a certain number network tokens from the remote call."
  },
  {
    "objectID": "/rsh/consensus/#p_87",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} opts.simTokensRecv is a tuple-of-integers field (default all zeros). The field represents how many of each non-network token Reach will assume your contract received from the remote call, for the purposes of transaction simulation. Amounts must be specified in the same order as in the call to {!rsh} bill or {!rsh} withBill. This is useful when using {!rsh} withBill and {!rsh} enforce to enforce that your contract received a certain number non-network tokens from the remote call."
  },
  {
    "objectID": "/rsh/consensus/#p_88",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} opts.simReturnVal is a field whose type must match the returned type of the remote function (default depends on return type). The field represents the return value of the remote function, for the purposes of transaction simulation. This is useful when using {!rsh} enforce on the return value of the remote function."
  },
  {
    "objectID": "/rsh/consensus/#p_89",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} opts.txnOrderForward is a boolean (default {!rsh} false) that when {!rsh} true has the payment transactions in the forward order (net and then assets in order) rather than the reverse order (assets in reverse order and then net). The default is suited for calling Reach servers."
  },
  {
    "objectID": "/rsh/consensus/#p_90",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "If the remote contract is not expected to return non-network tokens then a pair is returned, where the amount of network tokens received is the first element, and the original result is the second element."
  },
  {
    "objectID": "/rsh/consensus/#p_91",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "If the remote contract is expected to return non-network tokens then a triple is returned, where the amount of network tokens received is the first element, a tuple of the non-network tokens received is the second element, and the original result is the third element. If the caller expects to receive non-network tokens, they must provide a tuple of tokens as an argument to {!rsh} withBill. The ordering of tokens in the argument is preserved when returning the amounts received. For example,"
  },
  {
    "objectID": "/rsh/consensus/#p_92",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "might be the way to communicate with a random oracle that receives a conservative approximation of its actual cost and returns what it does not use, along with some amount of network tokens, GIL, and ZMD. This operation may not be used with {!rsh} REMOTE_FUN.bill."
  },
  {
    "objectID": "/rsh/consensus/#p_93",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Takes an {!rsh} Address} and returns a {!rsh} Maybe(Contract)."
  },
  {
    "objectID": "/rsh/consensus/#p_94",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "On Algorand this always returns {!rsh} None. On Ethereum, it returns {!rsh} None for addresses of externally owned accounts, and it returns {!rsh} Some for addresses of contracts under most circumstances. However, it also returns {!rsh} None for addresses of contracts that are under construction, for addresses of contracts that have been destroyed, and for addresses of contracts that have not yet been created."
  },
  {
    "objectID": "/rsh/consensus/#p_95",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A new mapping of linear state may be constructed in a consensus step by writing {!rsh} new Map(VAL_TYPE_EXPR) or {!rsh} new Map(KEY_TYPE_EXPR, VAL_TYPE_EXPR), where {!rsh} KEY_TYPE_EXPR and {!rsh} VAL_TYPE_EXPR are types. If {!rsh} KEY_TYPE_EXPR is not specified, it will default to {!rsh} Address."
  },
  {
    "objectID": "/rsh/consensus/#p_96",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "For example the code below contains only the {!rsh} VAL_TYPE_EXPR:"
  },
  {
    "objectID": "/rsh/consensus/#p_97",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "While the following code contains both the {!rsh} KEY_TYPE_EXPR and {!rsh} VAL_TYPE_EXPR:"
  },
  {
    "objectID": "/rsh/consensus/#p_98",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "These examples return a value which may be used to dereference particular mappings via {!rsh} map[EXPR]. Such dereferences return a value of type {!rsh} Maybe(VAL_TYPE_EXPR), because the mapping may not contain a value for {!rsh} EXPR."
  },
  {
    "objectID": "/rsh/consensus/#p_99",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A mapping may be modified by writing {!rsh} map[EXPR] = VALUE_EXPR to install {!rsh} VALUE_EXPR (of type {!rsh} VAL_TYPE_EXPR) at {!rsh} EXPR, or by writing {!rsh} delete map[EXPR] to remove the mapping entry. Such modifications may only occur in a consensus step."
  },
  {
    "objectID": "/rsh/consensus/#p_100",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "N+2 relations can be created by using a {!rsh} Tuple as the Map key. For example, a nested mapping: {!rsh} Map(Address, Map(Address, UInt)), can be simulated by coalescing the Map keys into a {!rsh} Tuple: {!rsh} Map(Tuple(Address, Address), UInt)."
  },
  {
    "objectID": "/rsh/consensus/#p_101",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A {!rsh} Set is another container for linear state. It is simply a type alias of {!rsh} Map(Null); it is only useful for tracking {!rsh} Addresses. Because a {!rsh} Set is internally a {!rsh} Map, it may only be constructed in a consensus step."
  },
  {
    "objectID": "/rsh/consensus/#p_102",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "A {!rsh} Set may be modified by writing {!rsh} s.insert(ADDRESS) to install {!rsh} ADDRESS in the set, {!rsh} s, or {!rsh} s.remove(ADDRESS) to remove the {!rsh} ADDRESS from the set. Such modifications may only occur in a consensus step."
  },
  {
    "objectID": "/rsh/consensus/#p_103",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The following example shows the usage of {!rsh} s.insert(ADDRESS):"
  },
  {
    "objectID": "/rsh/consensus/#p_104",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "While the example below shows the usage of {!rsh} s.remove(ADDRESS)"
  },
  {
    "objectID": "/rsh/consensus/#p_105",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "To check whether an address is in the set, {!rsh} s.member(ADDRESS) is used."
  },
  {
    "objectID": "/rsh/consensus/#p_106",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The following example shows the usage of {!rsh} s.member(ADDRESS)"
  },
  {
    "objectID": "/rsh/consensus/#p_107",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} s.Map will return the underlying {!rsh} Map, so you can use foldable instance methods."
  },
  {
    "objectID": "/rsh/consensus/#p_108",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Reach programs can create new child contracts based on predetermined, static code during compile time. This code is specified with {!rsh} ContractCode, which you can read about in Contract code definition, or a {!rsh} Reach.App."
  },
  {
    "objectID": "/rsh/consensus/#p_109",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Given a {!rsh} Reach.App, indicated by the variable {!rsh} app, you can create a constructor function with:"
  },
  {
    "objectID": "/rsh/consensus/#p_110",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Given some child contract code, indicated by the variable {!rsh} cc, you can create a constructor function with:"
  },
  {
    "objectID": "/rsh/consensus/#p_111",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "where opts is an optional object. Each enabled connector accepts its own options in a field with the name of the connector."
  },
  {
    "objectID": "/rsh/consensus/#p_112",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The {!rsh} ETH connector accepts no options."
  },
  {
    "objectID": "/rsh/consensus/#p_113",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The {!rsh} ALGO connector accepts the keys:"
  },
  {
    "objectID": "/rsh/consensus/#p_114",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} opts.globalUints --- The number of unsigned integers in the global storage of the contract."
  },
  {
    "objectID": "/rsh/consensus/#p_115",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} opts.globalBytes --- The number of byte strings in the global storage of the contract."
  },
  {
    "objectID": "/rsh/consensus/#p_116",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} opts.localUints --- The number of unsigned integers in the local storage of the contract."
  },
  {
    "objectID": "/rsh/consensus/#p_117",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "{!rsh} opts.localBytes --- The number of byte strings in the local storage of the contract."
  },
  {
    "objectID": "/rsh/consensus/#p_118",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "If these options are required, but not present, then the contract will behave incorrectly."
  },
  {
    "objectID": "/rsh/consensus/#p_119",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "When providing a {!rsh} Reach.App, the Reach compiler will automatically derive the necessary options to launch the contract."
  },
  {
    "objectID": "/rsh/consensus/#p_120",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "The constructor function must be called to actually create the contract. It is like a {!rsh} REMOTE_FUN}, but it cannot be augmented, nor can it receive payment. It returns a {!rsh} Contract value for the newly created contract."
  },
  {
    "objectID": "/rsh/consensus/#p_121",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Why can't you augment constructor calls?"
  },
  {
    "objectID": "/rsh/consensus/#p_122",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "Some constructor augmentations, like those specific for a particular network, could work, but are not supported by Reach presently. Others, such as token payments, cannot work at all, because given that the contract doesn't exist yet, there's no way to know where to send the tokens to."
  },
  {
    "objectID": "/rsh/consensus/#p_123",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "On some connectors, like {!rsh} ALGO, it is necessary to delete child contracts before the parent exits. Reach does not yet enforce this property during verification, so if you fail to obey it, then your program will not be able to finish."
  },
  {
    "objectID": "/rsh/consensus/#p_124",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "These functions return (respectively) the seed and the timestamp of the given block. The return data types are {!rsh} Maybe(Bytes(32)) and {!rsh} Maybe(UInt)."
  },
  {
    "objectID": "/rsh/consensus/#p_125",
    "pt": "Consensus Steps",
    "t": 3,
    "c": "These functions always return {!rsh} Maybe.None, unless called on Algorand on a block between \"txn.LastValid-1002 and txn.FirstValid (exclusive)\", in which case they return {!rsh} Maybe.Some. Because of this constraint on the transaction validity time, it is not really possible to use these functions correctly without using {!js} stdlib.setAdjustTxnParams."
  },
  {
    "objectID": "/rsh/errors/#rsh_async",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "async"
  },
  {
    "objectID": "/rsh/errors/#rsh_await",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "await"
  },
  {
    "objectID": "/rsh/errors/#rsh_break",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "break"
  },
  {
    "objectID": "/rsh/errors/#rsh_catch",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "catch"
  },
  {
    "objectID": "/rsh/errors/#rsh_class",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "class"
  },
  {
    "objectID": "/rsh/errors/#rsh_debugger",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "debugger"
  },
  {
    "objectID": "/rsh/errors/#rsh_delete",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "delete"
  },
  {
    "objectID": "/rsh/errors/#rsh_do",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "do"
  },
  {
    "objectID": "/rsh/errors/#rsh_enum",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "enum"
  },
  {
    "objectID": "/rsh/errors/#rsh_extends",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "extends"
  },
  {
    "objectID": "/rsh/errors/#rsh_for",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "for"
  },
  {
    "objectID": "/rsh/errors/#rsh_in",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "in"
  },
  {
    "objectID": "/rsh/errors/#rsh_instanceOf",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "instanceOf"
  },
  {
    "objectID": "/rsh/errors/#rsh_let",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "let"
  },
  {
    "objectID": "/rsh/errors/#rsh_of",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "of"
  },
  {
    "objectID": "/rsh/errors/#rsh_static",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "static"
  },
  {
    "objectID": "/rsh/errors/#rsh_throw",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "throw"
  },
  {
    "objectID": "/rsh/errors/#rsh_try",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "try"
  },
  {
    "objectID": "/rsh/errors/#rsh_with",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "with"
  },
  {
    "objectID": "/rsh/errors/#rsh_yield",
    "pt": "Error Codes",
    "t": 0,
    "s": "rsh",
    "c": "yield"
  },
  {
    "objectID": "/rsh/errors/#ref-error-codes",
    "pt": "Error Codes",
    "t": 2,
    "c": "Error Codes"
  },
  {
    "objectID": "/rsh/errors/#how-to-read-errors",
    "pt": "Error Codes",
    "t": 2,
    "c": "How to read error messages and stack traces"
  },
  {
    "objectID": "/rsh/errors/#how-to-read-verification-failures",
    "pt": "Error Codes",
    "t": 2,
    "c": "How to read verification failures"
  },
  {
    "objectID": "/rsh/errors/#RA0000",
    "pt": "Error Codes",
    "t": 2,
    "c": "RA0000"
  },
  {
    "objectID": "/rsh/errors/#RA0001",
    "pt": "Error Codes",
    "t": 2,
    "c": "RA0001"
  },
  {
    "objectID": "/rsh/errors/#RC0000",
    "pt": "Error Codes",
    "t": 2,
    "c": "RC0000"
  },
  {
    "objectID": "/rsh/errors/#RE0000",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0000"
  },
  {
    "objectID": "/rsh/errors/#RE0001",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0001"
  },
  {
    "objectID": "/rsh/errors/#RE0002",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0002"
  },
  {
    "objectID": "/rsh/errors/#RE0003",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0003"
  },
  {
    "objectID": "/rsh/errors/#RE0004",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0004"
  },
  {
    "objectID": "/rsh/errors/#RE0005",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0005"
  },
  {
    "objectID": "/rsh/errors/#RE0006",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0006"
  },
  {
    "objectID": "/rsh/errors/#RE0007",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0007"
  },
  {
    "objectID": "/rsh/errors/#RE0008",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0008"
  },
  {
    "objectID": "/rsh/errors/#RE0009",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0009"
  },
  {
    "objectID": "/rsh/errors/#RE0010",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0010"
  },
  {
    "objectID": "/rsh/errors/#RE0011",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0011"
  },
  {
    "objectID": "/rsh/errors/#RE0012",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0012"
  },
  {
    "objectID": "/rsh/errors/#RE0013",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0013"
  },
  {
    "objectID": "/rsh/errors/#RE0014",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0014"
  },
  {
    "objectID": "/rsh/errors/#RE0015",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0015"
  },
  {
    "objectID": "/rsh/errors/#RE0016",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0016"
  },
  {
    "objectID": "/rsh/errors/#RE0017",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0017"
  },
  {
    "objectID": "/rsh/errors/#RE0018",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0018"
  },
  {
    "objectID": "/rsh/errors/#RE0019",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0019"
  },
  {
    "objectID": "/rsh/errors/#RE0020",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0020"
  },
  {
    "objectID": "/rsh/errors/#RE0021",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0021"
  },
  {
    "objectID": "/rsh/errors/#RE0022",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0022"
  },
  {
    "objectID": "/rsh/errors/#RE0023",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0023"
  },
  {
    "objectID": "/rsh/errors/#RE0024",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0024"
  },
  {
    "objectID": "/rsh/errors/#RE0025",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0025"
  },
  {
    "objectID": "/rsh/errors/#RE0026",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0026"
  },
  {
    "objectID": "/rsh/errors/#RE0027",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0027"
  },
  {
    "objectID": "/rsh/errors/#RE0028",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0028"
  },
  {
    "objectID": "/rsh/errors/#RE0029",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0029"
  },
  {
    "objectID": "/rsh/errors/#RE0030",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0030"
  },
  {
    "objectID": "/rsh/errors/#RE0031",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0031"
  },
  {
    "objectID": "/rsh/errors/#RE0032",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0032"
  },
  {
    "objectID": "/rsh/errors/#RE0033",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0033"
  },
  {
    "objectID": "/rsh/errors/#RE0034",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0034"
  },
  {
    "objectID": "/rsh/errors/#RE0035",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0035"
  },
  {
    "objectID": "/rsh/errors/#RE0036",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0036"
  },
  {
    "objectID": "/rsh/errors/#RE0037",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0037"
  },
  {
    "objectID": "/rsh/errors/#RE0038",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0038"
  },
  {
    "objectID": "/rsh/errors/#RE0039",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0039"
  },
  {
    "objectID": "/rsh/errors/#RE0040",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0040"
  },
  {
    "objectID": "/rsh/errors/#RE0041",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0041"
  },
  {
    "objectID": "/rsh/errors/#RE0042",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0042"
  },
  {
    "objectID": "/rsh/errors/#RE0043",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0043"
  },
  {
    "objectID": "/rsh/errors/#RE0044",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0044"
  },
  {
    "objectID": "/rsh/errors/#RE0045",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0045"
  },
  {
    "objectID": "/rsh/errors/#RE0046",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0046"
  },
  {
    "objectID": "/rsh/errors/#RE0047",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0047"
  },
  {
    "objectID": "/rsh/errors/#RE0048",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0048"
  },
  {
    "objectID": "/rsh/errors/#RE0049",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0049"
  },
  {
    "objectID": "/rsh/errors/#RE0050",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0050"
  },
  {
    "objectID": "/rsh/errors/#RE0051",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0051"
  },
  {
    "objectID": "/rsh/errors/#RE0052",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0052"
  },
  {
    "objectID": "/rsh/errors/#RE0053",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0053"
  },
  {
    "objectID": "/rsh/errors/#RE0054",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0054"
  },
  {
    "objectID": "/rsh/errors/#RE0055",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0055"
  },
  {
    "objectID": "/rsh/errors/#RE0056",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0056"
  },
  {
    "objectID": "/rsh/errors/#RE0057",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0057"
  },
  {
    "objectID": "/rsh/errors/#RE0058",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0058"
  },
  {
    "objectID": "/rsh/errors/#RE0059",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0059"
  },
  {
    "objectID": "/rsh/errors/#RE0060",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0060"
  },
  {
    "objectID": "/rsh/errors/#RE0061",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0061"
  },
  {
    "objectID": "/rsh/errors/#RE0062",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0062"
  },
  {
    "objectID": "/rsh/errors/#RE0063",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0063"
  },
  {
    "objectID": "/rsh/errors/#RE0064",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0064"
  },
  {
    "objectID": "/rsh/errors/#RE0065",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0065"
  },
  {
    "objectID": "/rsh/errors/#RE0066",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0066"
  },
  {
    "objectID": "/rsh/errors/#RE0067",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0067"
  },
  {
    "objectID": "/rsh/errors/#RE0068",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0068"
  },
  {
    "objectID": "/rsh/errors/#RE0069",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0069"
  },
  {
    "objectID": "/rsh/errors/#RE0070",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0070"
  },
  {
    "objectID": "/rsh/errors/#RE0071",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0071"
  },
  {
    "objectID": "/rsh/errors/#RE0072",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0072"
  },
  {
    "objectID": "/rsh/errors/#RE0073",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0073"
  },
  {
    "objectID": "/rsh/errors/#RE0074",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0074"
  },
  {
    "objectID": "/rsh/errors/#RE0075",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0075"
  },
  {
    "objectID": "/rsh/errors/#RE0076",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0076"
  },
  {
    "objectID": "/rsh/errors/#RE0077",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0077"
  },
  {
    "objectID": "/rsh/errors/#RE0078",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0078"
  },
  {
    "objectID": "/rsh/errors/#RE0079",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0079"
  },
  {
    "objectID": "/rsh/errors/#RE0080",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0080"
  },
  {
    "objectID": "/rsh/errors/#RE0081",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0081"
  },
  {
    "objectID": "/rsh/errors/#RE0082",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0082"
  },
  {
    "objectID": "/rsh/errors/#RE0083",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0083"
  },
  {
    "objectID": "/rsh/errors/#RE0084",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0084"
  },
  {
    "objectID": "/rsh/errors/#RE0085",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0085"
  },
  {
    "objectID": "/rsh/errors/#RE0086",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0086"
  },
  {
    "objectID": "/rsh/errors/#RE0087",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0087"
  },
  {
    "objectID": "/rsh/errors/#RE0088",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0088"
  },
  {
    "objectID": "/rsh/errors/#RE0089",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0089"
  },
  {
    "objectID": "/rsh/errors/#RE0090",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0090"
  },
  {
    "objectID": "/rsh/errors/#RE0091",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0091"
  },
  {
    "objectID": "/rsh/errors/#RE0092",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0092"
  },
  {
    "objectID": "/rsh/errors/#RE0093",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0093"
  },
  {
    "objectID": "/rsh/errors/#RE0094",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0094"
  },
  {
    "objectID": "/rsh/errors/#RE0095",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0095"
  },
  {
    "objectID": "/rsh/errors/#RE0096",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0096"
  },
  {
    "objectID": "/rsh/errors/#RE0097",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0097"
  },
  {
    "objectID": "/rsh/errors/#RE0098",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0098"
  },
  {
    "objectID": "/rsh/errors/#RE0099",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0099"
  },
  {
    "objectID": "/rsh/errors/#RE0100",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0100"
  },
  {
    "objectID": "/rsh/errors/#RE0101",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0101"
  },
  {
    "objectID": "/rsh/errors/#RE0102",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0102"
  },
  {
    "objectID": "/rsh/errors/#RE0103",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0103"
  },
  {
    "objectID": "/rsh/errors/#RE0104",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0104"
  },
  {
    "objectID": "/rsh/errors/#RE0105",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0105"
  },
  {
    "objectID": "/rsh/errors/#RE0106",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0106"
  },
  {
    "objectID": "/rsh/errors/#RE0107",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0107"
  },
  {
    "objectID": "/rsh/errors/#RE0108",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0108"
  },
  {
    "objectID": "/rsh/errors/#RE0109",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0109"
  },
  {
    "objectID": "/rsh/errors/#RE0110",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0110"
  },
  {
    "objectID": "/rsh/errors/#RE0111",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0111"
  },
  {
    "objectID": "/rsh/errors/#RE0112",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0112"
  },
  {
    "objectID": "/rsh/errors/#RE0113",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0113"
  },
  {
    "objectID": "/rsh/errors/#RE0114",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0114"
  },
  {
    "objectID": "/rsh/errors/#RE0115",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0115"
  },
  {
    "objectID": "/rsh/errors/#RE0116",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0116"
  },
  {
    "objectID": "/rsh/errors/#RE0117",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0117"
  },
  {
    "objectID": "/rsh/errors/#RE0118",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0118"
  },
  {
    "objectID": "/rsh/errors/#RE0119",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0119"
  },
  {
    "objectID": "/rsh/errors/#RE0120",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0120"
  },
  {
    "objectID": "/rsh/errors/#RE0121",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0121"
  },
  {
    "objectID": "/rsh/errors/#RE0122",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0122"
  },
  {
    "objectID": "/rsh/errors/#RE0123",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0123"
  },
  {
    "objectID": "/rsh/errors/#RE0124",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0124"
  },
  {
    "objectID": "/rsh/errors/#RE0125",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0125"
  },
  {
    "objectID": "/rsh/errors/#RE0126",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0126"
  },
  {
    "objectID": "/rsh/errors/#RE0127",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0127"
  },
  {
    "objectID": "/rsh/errors/#RE0128",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0128"
  },
  {
    "objectID": "/rsh/errors/#RE0129",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0129"
  },
  {
    "objectID": "/rsh/errors/#RE0130",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0130"
  },
  {
    "objectID": "/rsh/errors/#RE0131",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0131"
  },
  {
    "objectID": "/rsh/errors/#RE0132",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0132"
  },
  {
    "objectID": "/rsh/errors/#RE0133",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0133"
  },
  {
    "objectID": "/rsh/errors/#RE0134",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0134"
  },
  {
    "objectID": "/rsh/errors/#RE0135",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0135"
  },
  {
    "objectID": "/rsh/errors/#RE0136",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0136"
  },
  {
    "objectID": "/rsh/errors/#RE0137",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0137"
  },
  {
    "objectID": "/rsh/errors/#RE0138",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0138"
  },
  {
    "objectID": "/rsh/errors/#RE0139",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0139"
  },
  {
    "objectID": "/rsh/errors/#RE0140",
    "pt": "Error Codes",
    "t": 2,
    "c": "RE0140"
  },
  {
    "objectID": "/rsh/errors/#RETH0001",
    "pt": "Error Codes",
    "t": 2,
    "c": "RETH0001"
  },
  {
    "objectID": "/rsh/errors/#REP0000",
    "pt": "Error Codes",
    "t": 2,
    "c": "REP0000"
  },
  {
    "objectID": "/rsh/errors/#REP0001",
    "pt": "Error Codes",
    "t": 2,
    "c": "REP0001"
  },
  {
    "objectID": "/rsh/errors/#REP0002",
    "pt": "Error Codes",
    "t": 2,
    "c": "REP0002"
  },
  {
    "objectID": "/rsh/errors/#RI0000",
    "pt": "Error Codes",
    "t": 2,
    "c": "RI0000"
  },
  {
    "objectID": "/rsh/errors/#RI0001",
    "pt": "Error Codes",
    "t": 2,
    "c": "RI0001"
  },
  {
    "objectID": "/rsh/errors/#RI0002",
    "pt": "Error Codes",
    "t": 2,
    "c": "RI0002"
  },
  {
    "objectID": "/rsh/errors/#RI0003",
    "pt": "Error Codes",
    "t": 2,
    "c": "RI0003"
  },
  {
    "objectID": "/rsh/errors/#RI0004",
    "pt": "Error Codes",
    "t": 2,
    "c": "RI0004"
  },
  {
    "objectID": "/rsh/errors/#RL0000",
    "pt": "Error Codes",
    "t": 2,
    "c": "RL0000"
  },
  {
    "objectID": "/rsh/errors/#RP0000",
    "pt": "Error Codes",
    "t": 2,
    "c": "RP0000"
  },
  {
    "objectID": "/rsh/errors/#RP0001",
    "pt": "Error Codes",
    "t": 2,
    "c": "RP0001"
  },
  {
    "objectID": "/rsh/errors/#RP0002",
    "pt": "Error Codes",
    "t": 2,
    "c": "RP0002"
  },
  {
    "objectID": "/rsh/errors/#RP0003",
    "pt": "Error Codes",
    "t": 2,
    "c": "RP0003"
  },
  {
    "objectID": "/rsh/errors/#RP0004",
    "pt": "Error Codes",
    "t": 2,
    "c": "RP0004"
  },
  {
    "objectID": "/rsh/errors/#RP0005",
    "pt": "Error Codes",
    "t": 2,
    "c": "RP0005"
  },
  {
    "objectID": "/rsh/errors/#RP0006",
    "pt": "Error Codes",
    "t": 2,
    "c": "RP0006"
  },
  {
    "objectID": "/rsh/errors/#RP0007",
    "pt": "Error Codes",
    "t": 2,
    "c": "RP0007"
  },
  {
    "objectID": "/rsh/errors/#RP0008",
    "pt": "Error Codes",
    "t": 2,
    "c": "RP0008"
  },
  {
    "objectID": "/rsh/errors/#RP0009",
    "pt": "Error Codes",
    "t": 2,
    "c": "RP0009"
  },
  {
    "objectID": "/rsh/errors/#RP0010",
    "pt": "Error Codes",
    "t": 2,
    "c": "RP0010"
  },
  {
    "objectID": "/rsh/errors/#RP0011",
    "pt": "Error Codes",
    "t": 2,
    "c": "RP0011"
  },
  {
    "objectID": "/rsh/errors/#RP0012",
    "pt": "Error Codes",
    "t": 2,
    "c": "RP0012"
  },
  {
    "objectID": "/rsh/errors/#RX0000",
    "pt": "Error Codes",
    "t": 2,
    "c": "RX0000"
  },
  {
    "objectID": "/rsh/errors/#RAPI0000",
    "pt": "Error Codes",
    "t": 2,
    "c": "RAPI0000"
  },
  {
    "objectID": "/rsh/errors/#RAPI0001",
    "pt": "Error Codes",
    "t": 2,
    "c": "RAPI0001"
  },
  {
    "objectID": "/rsh/errors/#RAPI0002",
    "pt": "Error Codes",
    "t": 2,
    "c": "RAPI0002"
  },
  {
    "objectID": "/rsh/errors/#RAPI0003",
    "pt": "Error Codes",
    "t": 2,
    "c": "RAPI0003"
  },
  {
    "objectID": "/rsh/errors/#RAPI0004",
    "pt": "Error Codes",
    "t": 2,
    "c": "RAPI0004"
  },
  {
    "objectID": "/rsh/errors/#RW0000",
    "pt": "Error Codes",
    "t": 2,
    "c": "RW0000"
  },
  {
    "objectID": "/rsh/errors/#RW0001",
    "pt": "Error Codes",
    "t": 2,
    "c": "RW0001"
  },
  {
    "objectID": "/rsh/errors/#RW0002",
    "pt": "Error Codes",
    "t": 2,
    "c": "RW0002"
  },
  {
    "objectID": "/rsh/errors/#RW0003",
    "pt": "Error Codes",
    "t": 2,
    "c": "RW0003"
  },
  {
    "objectID": "/rsh/errors/#RW0004",
    "pt": "Error Codes",
    "t": 2,
    "c": "RW0004"
  },
  {
    "objectID": "/rsh/errors/#problematic-code",
    "pt": "Error Codes",
    "t": 2,
    "c": "Problematic code:"
  },
  {
    "objectID": "/rsh/errors/#correct-code",
    "pt": "Error Codes",
    "t": 2,
    "c": "Correct code:"
  },
  {
    "objectID": "/rsh/errors/#RW0005",
    "pt": "Error Codes",
    "t": 2,
    "c": "RW0005"
  },
  {
    "objectID": "/rsh/errors/#problematic-code-1",
    "pt": "Error Codes",
    "t": 2,
    "c": "Problematic code:"
  },
  {
    "objectID": "/rsh/errors/#correct-code-1",
    "pt": "Error Codes",
    "t": 2,
    "c": "Correct code:"
  },
  {
    "objectID": "/rsh/errors/#RW0006",
    "pt": "Error Codes",
    "t": 2,
    "c": "RW0006"
  },
  {
    "objectID": "/rsh/errors/#problematic-code-2",
    "pt": "Error Codes",
    "t": 2,
    "c": "Problematic code:"
  },
  {
    "objectID": "/rsh/errors/#correct-code-2",
    "pt": "Error Codes",
    "t": 2,
    "c": "Correct code:"
  },
  {
    "objectID": "/rsh/errors/#RV0000",
    "pt": "Error Codes",
    "t": 2,
    "c": "RV0000"
  },
  {
    "objectID": "/rsh/errors/#p_0",
    "pt": "Error Codes",
    "t": 3,
    "c": "This section provides an in depth explanation of the error codes produced from the Reach compiler."
  },
  {
    "objectID": "/rsh/errors/#p_1",
    "pt": "Error Codes",
    "t": 3,
    "c": "Suppose you try to run the following program:"
  },
  {
    "objectID": "/rsh/errors/#p_2",
    "pt": "Error Codes",
    "t": 3,
    "c": "This program contains an error on line 8. It tries to pass {!rsh} \"five\" to a function that expects a number."
  },
  {
    "objectID": "/rsh/errors/#p_3",
    "pt": "Error Codes",
    "t": 3,
    "c": "When you try to compile this program, you will get the following error:"
  },
  {
    "objectID": "/rsh/errors/#p_4",
    "pt": "Error Codes",
    "t": 3,
    "c": "The first block (lines 1-4) provides the category (error in this case, but could be warning), a code (RE0088), and an explanation (These types are mismatched). Each code has a corresponding section in this document that explains the error in more detail. See for example RE0088."
  },
  {
    "objectID": "/rsh/errors/#p_5",
    "pt": "Error Codes",
    "t": 3,
    "c": "The second block (lines 5-7) provides an excerpt of the line of code that the error occurred on. Sometimes this block is missing when Reach cannot track the source location of your error."
  },
  {
    "objectID": "/rsh/errors/#p_6",
    "pt": "Error Codes",
    "t": 3,
    "c": "The third block (lines 9-11) provides a stack trace that shows how this line of code was arrived at. The stack trace shows the newest frames at the top and the oldest frames at the bottom. Each frame contains information about the name of the function, where it is defined, and where it was called from."
  },
  {
    "objectID": "/rsh/errors/#p_7",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, this error says that the error was detected on line 7 and column 25: the {!rsh} +. This was being run inside the function defined on line 7 column 20 (the {!rsh} =>) whose name is g and that it was called on line 8 column 21 (the {!rsh} ( after g). This was being run inside the function defined on line 8 column 17 (the {!rsh} =>) and that it was called on line 9 column 16 (the {!rsh} ( in the definition of ten)."
  },
  {
    "objectID": "/rsh/errors/#p_8",
    "pt": "Error Codes",
    "t": 3,
    "c": "Finally, the last block (line 13) contains a link to the explanation of the given error."
  },
  {
    "objectID": "/rsh/errors/#p_9",
    "pt": "Error Codes",
    "t": 3,
    "c": "If you use Reach for anything but the most trivial programs, you are going to see some verification failure messages. Every time you compile your program, Reach is going to attempt to prove a variety of theorems about your code. If it cannot prove those theorems, then it will generate a description of what went wrong."
  },
  {
    "objectID": "/rsh/errors/#p_10",
    "pt": "Error Codes",
    "t": 3,
    "c": "This description can be exhaustively exhausting and learning how to interpret them effectively is extremely valuable in writing Reach programs effectively. Please use this guide to aid you in learning how to do that."
  },
  {
    "objectID": "/rsh/errors/#p_11",
    "pt": "Error Codes",
    "t": 3,
    "c": "You have to actually read and try to understand these messages. They will never be \"Google-able\", because they are intimately connected with your particular program."
  },
  {
    "objectID": "/rsh/errors/#p_12",
    "pt": "Error Codes",
    "t": 3,
    "c": "For this guide, we will take as an example the erroneous program from the fourth step of the Rock, Paper, Scissors! tutorial, Trust and Commitments. Here's a sample of and link to that program:"
  },
  {
    "objectID": "/rsh/errors/#p_13",
    "pt": "Error Codes",
    "t": 3,
    "c": "The problem with this program is that it pays out only one wager when Alice wins, rather than two. When you compile this program, Reach detects the problem and produces a lot of output; let's look at each line and explain it."
  },
  {
    "objectID": "/rsh/errors/#p_14",
    "pt": "Error Codes",
    "t": 3,
    "c": "First, Reach will check knowledge assertions that are introduced by {!rsh} unknowable. This program does not have a violation of knowledge assertions, so there is no message."
  },
  {
    "objectID": "/rsh/errors/#p_15",
    "pt": "Error Codes",
    "t": 3,
    "c": "Next, Reach begins checking the body of your code. Normally, it performs this check abstractly with a \"generic\" network. The generic network is more abstract (and thus more strict) than any particular connector. For example, the value of {!rsh} UInt.max could be anything. If you want to check with the actual connectors you will use, then you can use the {!rsh} verifyPerConnector option in {!rsh} setOptions."
  },
  {
    "objectID": "/rsh/errors/#p_16",
    "pt": "Error Codes",
    "t": 3,
    "c": "Next, Reach will check your program when the participants in it are \"honest\". This means that it will trust {!rsh} assume statements and try to enforce {!rsh} require statements. You will get extra errors in this mode if you include a {!rsh} require, but forget the corresponding {!rsh} assume."
  },
  {
    "objectID": "/rsh/errors/#p_17",
    "pt": "Error Codes",
    "t": 3,
    "c": "Later (line 34), Reach will check when all the participants are not honest. This means that it will ignore all {!rsh} assume statements and instead turn the {!rsh} require statements into assumptions. You will get extra errors in this mode if you include an {!rsh} assume, but forget the corresponding {!rsh} require."
  },
  {
    "objectID": "/rsh/errors/#p_18",
    "pt": "Error Codes",
    "t": 3,
    "c": "When Reach finds a problem, it will output a block of text that starts like this. First, it tells you that the verification failed (line 4) and what the mode is (line 5). Next (line 6), it tells you what kind of theorem it was. This is typically assert for an assertion that you put in your program or that Reach put in. It is also very common to see invariant for when a loop invariant is being checked. Finally (lines 7 and 8), Reach will tell you the message that was attached to the theorem and where it occurred in your program. If Reach inserted the theorem for you, then the line number may not be in an intuitive place."
  },
  {
    "objectID": "/rsh/errors/#p_19",
    "pt": "Error Codes",
    "t": 3,
    "c": "In this case, the error says that at the end of the program (\"application exit\"), the balance of the contract was supposed to be zero, but that the proof failed."
  },
  {
    "objectID": "/rsh/errors/#p_20",
    "pt": "Error Codes",
    "t": 3,
    "c": "In the next section of text, Reach is going to provide information about the \"violation witness\". Every theorem failure means that there is input to your program that would result in something bad happening. The failure is called a \"violation\", because the theorem was supposed to always be true, but that assumption was \"violated\". Reach can synthesize example inputs to provide evidence that the violation is possible; that evidence is called a \"witness\"."
  },
  {
    "objectID": "/rsh/errors/#p_21",
    "pt": "Error Codes",
    "t": 3,
    "c": "Reach will report the values of all the variables that are unconstrained by your program; that is, the ones that are input. In this case, since we are checking with a generic connector, it first tells us that the maximum value of numbers on this connector is 2. This is a ridiculously small number. You should rarely read too much into this number... effectively, Reach is telling you that it didn't need to do a lot of numeric exploration to find this problem, since your program uses so few numbers."
  },
  {
    "objectID": "/rsh/errors/#p_22",
    "pt": "Error Codes",
    "t": 3,
    "c": "This is a more interesting witness. Line 14 says that Alice's wager field of her {!rsh} interact object is bound inside the program to the variable wager. (wager is annotated with 81, because Reach will index every variable in your program with a number, in case you use the same variable (I'm looking at you, x!) in different places, so that you and Reach can keep track of them.) Line 15 says that it could equal 1, meaning that 1 atomic network unit is being wagered. Line 16 gives you source location information for where this variable was actually defined. It is referring to this line:"
  },
  {
    "objectID": "/rsh/errors/#p_23",
    "pt": "Error Codes",
    "t": 3,
    "c": "This variable is free, because Alice can choose anything she wants for the wager."
  },
  {
    "objectID": "/rsh/errors/#p_24",
    "pt": "Error Codes",
    "t": 3,
    "c": "Next, we see two more free variables: the handles that Alice and Bob choose when they play the game. In this case (line 18), Alice chose 0 (Rock) and Bob chose 2 (Scissors), which means that Alice won, which is exactly where we know the problem in the program happens. When Reach prints out the definition of the variable, it adds more information than you normally see in your program. For example, we see that getHand has to be a {!rsh} UInt. This information is in your program in the definition of getHand, but we can't see that right here, so Reach is adding extra context for you to better understand the witness."
  },
  {
    "objectID": "/rsh/errors/#p_25",
    "pt": "Error Codes",
    "t": 3,
    "c": "After showing the violation witness, Reach switches and shows you the way that it has represented the theorem \"balance zero at application exit\" as a program. This is called the \"formalization\" of the theorem."
  },
  {
    "objectID": "/rsh/errors/#p_26",
    "pt": "Error Codes",
    "t": 3,
    "c": "This section looks like the witness section, except that the phrase could is going to be replaced with would, because these variables are not freely chosen by your users, but instead are determined by the program text."
  },
  {
    "objectID": "/rsh/errors/#p_27",
    "pt": "Error Codes",
    "t": 3,
    "c": "Here we see Reach reporting that the outcome of the game would be 2 (Alice wins), which we expect. It also reports the definition of the variable, so we can remind ourselves of that."
  },
  {
    "objectID": "/rsh/errors/#p_28",
    "pt": "Error Codes",
    "t": 3,
    "c": "Next, we see Reach reporting what the internal variable v110 would be. This variable is the tuple that is on the right-hand side of line 35 of the source program (shown above) that is immediately deconstructed into the variables forAlice and forBob. Since the program doesn't give this variable a name, Reach can't show a name and instead uses the generic v110."
  },
  {
    "objectID": "/rsh/errors/#p_29",
    "pt": "Error Codes",
    "t": 3,
    "c": "Finally, we see the definition of the property being checked. The property is that 0 must be equal to wager + wager (the total number of wagers) less what Alice gets (v110[0] * wager) and what Bob gets (v110[1] * wager). Reach reports that this would be {!rsh} false."
  },
  {
    "objectID": "/rsh/errors/#p_30",
    "pt": "Error Codes",
    "t": 3,
    "c": "If you step through these definitions, you can see why:"
  },
  {
    "objectID": "/rsh/errors/#p_31",
    "pt": "Error Codes",
    "t": 3,
    "c": "Basically, we've been shown that there would be 1 atomic network unit left in the contract if we ran this program, so the theorem is false."
  },
  {
    "objectID": "/rsh/errors/#p_32",
    "pt": "Error Codes",
    "t": 3,
    "c": "The rest of the output shows that the other mode is checked and summarizes the run. Reach will not print the same violation multiple times. That's why this violation is only printed in one mode, but Reach did check it and that's why Reach reports that there were 2 errors, but 1 was repeated and so its report is omitted."
  },
  {
    "objectID": "/rsh/errors/#p_33",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a program, targeting the Algorand connector, is attempting to transfer a {!rsh} Token in the same consensus step it was created in. It is impossible to perform this action because one must opt-in to receive a token on Algorand. To opt-in, one must know the id, however the id of the token cannot be known until after the transaction that created it."
  },
  {
    "objectID": "/rsh/errors/#p_34",
    "pt": "Error Codes",
    "t": 3,
    "c": "The following code erroneously tries to transfer a newly created {!rsh} Token:"
  },
  {
    "objectID": "/rsh/errors/#p_35",
    "pt": "Error Codes",
    "t": 3,
    "c": "This can be fixed by performing a {!rsh} commit after creating the token and transferring the token in the next consensus step:"
  },
  {
    "objectID": "/rsh/errors/#p_36",
    "pt": "Error Codes",
    "t": 3,
    "c": "The frontend can have {!rsh} Alice opt-in to the token in {!rsh} informOfTokenId by utilizing {!js} acc.tokenAccept()."
  },
  {
    "objectID": "/rsh/errors/#p_37",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a program, targeting the Algorand connector, is attempting to pay a {!rsh} Token at the same time it is published. It is impossible to perform this action because one must opt-in to receive a token on Algorand. To opt-in, one must know the id, however the application cannot learn the application until after it has received the publication, which must occur after all pay transactions."
  },
  {
    "objectID": "/rsh/errors/#p_38",
    "pt": "Error Codes",
    "t": 3,
    "c": "The following code has this error:"
  },
  {
    "objectID": "/rsh/errors/#p_39",
    "pt": "Error Codes",
    "t": 3,
    "c": "This can be fixed by performing the {!rsh} publish and {!rsh} pay in two steps: token in the next consensus step:"
  },
  {
    "objectID": "/rsh/errors/#p_40",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the program uses a number that is beyond the range of acceptable numbers for the given connector."
  },
  {
    "objectID": "/rsh/errors/#p_41",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below uses a value too large for the {!rsh} ALGO connector:"
  },
  {
    "objectID": "/rsh/errors/#p_42",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by having your frontend provide the value and accessing it via the participant interact interface:"
  },
  {
    "objectID": "/rsh/errors/#p_43",
    "pt": "Error Codes",
    "t": 3,
    "c": "Alternatively, you can fix this by not compiling to the given connector, in which case, your application will no longer be blockchain agnostic."
  },
  {
    "objectID": "/rsh/errors/#p_44",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you provided an incorrect number of arguments to a function."
  },
  {
    "objectID": "/rsh/errors/#p_45",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below applies one value to {!rsh} f:"
  },
  {
    "objectID": "/rsh/errors/#p_46",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by providing the same amount of arguments expected:"
  },
  {
    "objectID": "/rsh/errors/#p_47",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a program uses an invalid assignment operator. Reach only supports assignment using the {!rsh} = operator. Any other operator, such as {!rsh} +=, *=, ... is not allowed."
  },
  {
    "objectID": "/rsh/errors/#p_48",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously tries to re-assign {!rsh} x at the end of a {!rsh} while loop:"
  },
  {
    "objectID": "/rsh/errors/#p_49",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by explicitly writing out the operation on the right hand side of {!rsh} =:"
  },
  {
    "objectID": "/rsh/errors/#p_50",
    "pt": "Error Codes",
    "t": 3,
    "c": "Keep in mind, that the assignment operator is a form of mutation and is only allowed immediately before a {!rsh} continue."
  },
  {
    "objectID": "/rsh/errors/#p_51",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a program uses an invalid statement. Reach is a strict subset of JavaScript and does not accept every statement that is valid JavaScript. It may be necessary to express your program with different constructs than you would JavaScript."
  },
  {
    "objectID": "/rsh/errors/#p_52",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously uses a {!js} for loop, which is not supported in Reach:"
  },
  {
    "objectID": "/rsh/errors/#p_53",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by either using a {!rsh} while loop or a combination of {!rsh} Array.iota and {!rsh} Array.map/Array.forEach:"
  },
  {
    "objectID": "/rsh/errors/#p_54",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a statement block returns a non-null value although a {!rsh} null value is expected. The block should either use a {!rsh} return null; statement or no return statement at all."
  },
  {
    "objectID": "/rsh/errors/#p_55",
    "pt": "Error Codes",
    "t": 3,
    "c": "This statement block has a {!rsh} return of 1, but it should not have a {!rsh} return."
  },
  {
    "objectID": "/rsh/errors/#p_56",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error can be corrected by putting the {!rsh} return inside of a {!rsh} const statement block:"
  },
  {
    "objectID": "/rsh/errors/#p_57",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the program uses {!rsh} var incorrectly. In Reach, {!rsh} var is only allowed immediately before a while loop and its {!rsh} invariant."
  },
  {
    "objectID": "/rsh/errors/#p_58",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, this code erroneously tries to declare {!rsh} x as a mutable variable then re-assign it at some point:"
  },
  {
    "objectID": "/rsh/errors/#p_59",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by using {!rsh} const and either creating fresh variables or collapsing the logic if simple enough:"
  },
  {
    "objectID": "/rsh/errors/#p_60",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates an incorrect use of {!rsh} while. {!rsh} while must be immediately prefaced by a {!rsh} var and {!rsh} invariant declaration."
  },
  {
    "objectID": "/rsh/errors/#p_61",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, this code erroneously tries to run a continuous loop where Alice pays {!rsh} 1 network token per loop:"
  },
  {
    "objectID": "/rsh/errors/#p_62",
    "pt": "Error Codes",
    "t": 3,
    "c": "Reach requires the {!rsh} invariant to reason about the {!rsh} while loop during verification. You can fix this by adding a {!rsh} var and {!rsh} invariant declaration before the loop:"
  },
  {
    "objectID": "/rsh/errors/#p_63",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_64",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that {!rsh} return may not be used within the current statement block."
  },
  {
    "objectID": "/rsh/errors/#p_65",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the {!rsh} timeout branch of a statement such as {!rsh} publish, pay, fork has been given the wrong arguments."
  },
  {
    "objectID": "/rsh/errors/#p_66",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the following code erroneously attempts to {!rsh} closeTo(Bob) in the event that {!rsh} Alice does not publish in time:"
  },
  {
    "objectID": "/rsh/errors/#p_67",
    "pt": "Error Codes",
    "t": 3,
    "c": "However, the second argument of the {!rsh} timeout branch must be a syntactic thunk. You can fix this by wrapping {!rsh} closeTo(Bob) in an arrow expression:"
  },
  {
    "objectID": "/rsh/errors/#p_68",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a {!rsh} timeout branch of a statement such as {!rsh} publish, pay, fork has not been given a block of code to execute in the event of a {!rsh} timeout."
  },
  {
    "objectID": "/rsh/errors/#p_69",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously provides a {!rsh} timeout delay, but does not specify a function to run if the timeout occurs:"
  },
  {
    "objectID": "/rsh/errors/#p_70",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by providing a function as a second argument to {!rsh} timeout:"
  },
  {
    "objectID": "/rsh/errors/#p_71",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the pay amount provided states the amount of network tokens more than once."
  },
  {
    "objectID": "/rsh/errors/#p_72",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously provides two atomic values in the pay amount, which are both interpreted as the amount of network tokens to pay:"
  },
  {
    "objectID": "/rsh/errors/#p_73",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by deleting one of the atomic values:"
  },
  {
    "objectID": "/rsh/errors/#p_74",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1.8."
  },
  {
    "objectID": "/rsh/errors/#p_75",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the pay amount provided states the amount of a specific non-network token more than once."
  },
  {
    "objectID": "/rsh/errors/#p_76",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously provides two tuples in the pay amount, both of which specify the amount of the same token:"
  },
  {
    "objectID": "/rsh/errors/#p_77",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by deleting one of the tuples:"
  },
  {
    "objectID": "/rsh/errors/#p_78",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the pay amount provided does not provide values of the correct type."
  },
  {
    "objectID": "/rsh/errors/#p_79",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously provides a pay amount that consists of a one element tuple:"
  },
  {
    "objectID": "/rsh/errors/#p_80",
    "pt": "Error Codes",
    "t": 3,
    "c": "However, a tuple in a pay amount must specify the amount and the {!rsh} Token. You can fix this by adding the {!rsh} Token to the tuple:"
  },
  {
    "objectID": "/rsh/errors/#p_81",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a participant interact interface field has a type that is not first-order. That is, an interact function has a return type of a function, which is not allowed in Reach."
  },
  {
    "objectID": "/rsh/errors/#p_82",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously provides an interact function that returns another function:"
  },
  {
    "objectID": "/rsh/errors/#p_83",
    "pt": "Error Codes",
    "t": 3,
    "c": "the frontend may look like this:"
  },
  {
    "objectID": "/rsh/errors/#p_84",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by decoupling the functions and calling them sequentially. This technique requires changes to the frontend as well since we are changing the signature:"
  },
  {
    "objectID": "/rsh/errors/#p_85",
    "pt": "Error Codes",
    "t": 3,
    "c": "the frontend may look like this:"
  },
  {
    "objectID": "/rsh/errors/#p_86",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you provided an unrecognized option to {!rsh} setOptions. There is most likely a typo in your code."
  },
  {
    "objectID": "/rsh/errors/#p_87",
    "pt": "Error Codes",
    "t": 3,
    "c": "Please review the recognized options in the documentation for {!rsh} setOptions."
  },
  {
    "objectID": "/rsh/errors/#p_88",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you did not provide an acceptable value for a specific option in {!rsh} setOptions."
  },
  {
    "objectID": "/rsh/errors/#p_89",
    "pt": "Error Codes",
    "t": 3,
    "c": "Please review the eligible values listed in the documentation for {!rsh} setOptions."
  },
  {
    "objectID": "/rsh/errors/#p_90",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that your participant interact interface does not provide a {!rsh} Type for a given field."
  },
  {
    "objectID": "/rsh/errors/#p_91",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, in the erroneous code below, {!rsh} x is assigned {!rsh} 3 in the participant interact interface of {!rsh} Alice:"
  },
  {
    "objectID": "/rsh/errors/#p_92",
    "pt": "Error Codes",
    "t": 3,
    "c": "However, the interact interface specifies the type of values that will be provided at runtime. You can fix this by either making {!rsh} x a variable within Alice's scope inside the program:"
  },
  {
    "objectID": "/rsh/errors/#p_93",
    "pt": "Error Codes",
    "t": 3,
    "c": "or by putting {!rsh} 3 as the value of {!rsh} x in your frontend and adjusting the participant interact interface to list the type:"
  },
  {
    "objectID": "/rsh/errors/#p_94",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the arguments passed to {!rsh} Reach.App are incorrect. {!rsh} Reach.App accepts a single thunk as its argument."
  },
  {
    "objectID": "/rsh/errors/#p_95",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously declares a {!rsh} Reach.App without too many arguments:"
  },
  {
    "objectID": "/rsh/errors/#p_96",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by ensuring only one argument is passed to {!rsh} Reach.App, which is a function with no arguments:"
  },
  {
    "objectID": "/rsh/errors/#p_97",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the name of the {!rsh} Participant or {!rsh} View provided is invalid. These names must satisfy the regex {!rsh} [a-zA-Z][_a-zA-Z0-9]*."
  },
  {
    "objectID": "/rsh/errors/#p_98",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below provides a Participant name that is unsatisfactory:"
  },
  {
    "objectID": "/rsh/errors/#p_99",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by removing any illegal characters and replacing spaces with underscores:"
  },
  {
    "objectID": "/rsh/errors/#p_100",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that an invalid expression is used on the left hand side of an assignment."
  },
  {
    "objectID": "/rsh/errors/#p_101",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously puts an arithmetic expression on the left hand side of an assignment:"
  },
  {
    "objectID": "/rsh/errors/#p_102",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by moving all the arithmetic to the right hand side, leaving only the variable on the left:"
  },
  {
    "objectID": "/rsh/errors/#p_103",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that an object spread is occurring before the last position in a destructuring assignment. It must come last due to the fact it binds the remaining elements to the given variable."
  },
  {
    "objectID": "/rsh/errors/#p_104",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously attempts to destructure one element {!rsh} y and the remaining elements into {!rsh} x:"
  },
  {
    "objectID": "/rsh/errors/#p_105",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by moving {!rsh} ...x to the last position:"
  },
  {
    "objectID": "/rsh/errors/#p_106",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that an array spread is occurring before the last position in a destructuring assignment. It must come last due to the fact it binds the remaining elements to the given variable."
  },
  {
    "objectID": "/rsh/errors/#p_107",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously attempts to destructure one element {!rsh} y and the remaining elements into {!rsh} x:"
  },
  {
    "objectID": "/rsh/errors/#p_108",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by moving {!rsh} ...x to the last position:"
  },
  {
    "objectID": "/rsh/errors/#p_109",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the compiler expected to receive a closure, but it was given a different value."
  },
  {
    "objectID": "/rsh/errors/#p_110",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously attempts to provide a value for the {!rsh} match case of a nullary {!rsh} Data constructor:"
  },
  {
    "objectID": "/rsh/errors/#p_111",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by wrapping the value {!rsh} 0 in an arrow expression because {!rsh} match expects all cases to be bound to closures:"
  },
  {
    "objectID": "/rsh/errors/#p_112",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there was an invalid declaration. This error will occur when attempting to bind multiple variables within a single {!rsh} const."
  },
  {
    "objectID": "/rsh/errors/#p_113",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously attempts to bind {!rsh} x and {!rsh} y within one {!rsh} const assignment:"
  },
  {
    "objectID": "/rsh/errors/#p_114",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by breaking apart the declarations into two {!rsh} const statements:"
  },
  {
    "objectID": "/rsh/errors/#p_115",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_116",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there was an invalid declaration."
  },
  {
    "objectID": "/rsh/errors/#p_117",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is an attempt to unpack an {!rsh} array, but the binding does not expect the same amount of values that the {!rsh} array contains."
  },
  {
    "objectID": "/rsh/errors/#p_118",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously tries to unpack an {!rsh} array of 3 values into 2 variables:"
  },
  {
    "objectID": "/rsh/errors/#p_119",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by either binding or ignoring, via {!rsh} _, the last element of the {!rsh} array:"
  },
  {
    "objectID": "/rsh/errors/#p_120",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is an attempt to access a field of an {!rsh} object that does not exist. Ensure that you are referring to the correct name, or add the needed field to the {!rsh} object if necessary."
  },
  {
    "objectID": "/rsh/errors/#p_121",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the {!rsh} continue statement is used outside of a {!rsh} while loop."
  },
  {
    "objectID": "/rsh/errors/#p_122",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_123",
    "pt": "Error Codes",
    "t": 3,
    "c": "To fix this issue, delete the erroneous {!rsh} continue, or move it to the end of your {!rsh} while loop."
  },
  {
    "objectID": "/rsh/errors/#p_124",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_125",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is an attempt to consult the consensus time before the first publication. This situation is not allowed, because before the first publication, there is no consensual agreement on time in the decentralized computation."
  },
  {
    "objectID": "/rsh/errors/#p_126",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by having a {!rsh} Participant {!rsh} publish first:"
  },
  {
    "objectID": "/rsh/errors/#p_127",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a the variable update inside of a loop, e.g. {!rsh} while, is attempting to mutate variables that are not mutable. For a {!rsh} while loop, this means the variable was not declared with {!rsh} var prior to the loop."
  },
  {
    "objectID": "/rsh/errors/#p_128",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously attempts to mutate {!rsh} y which has not been defined via {!rsh} var:"
  },
  {
    "objectID": "/rsh/errors/#p_129",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by either deleting {!rsh} y or adding it to the variable list:"
  },
  {
    "objectID": "/rsh/errors/#p_130",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates an attempt to bind a {!rsh} ParticipantClass to a specific {!rsh} Address."
  },
  {
    "objectID": "/rsh/errors/#p_131",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the example code below erroneously tries to {!rsh} set a {!rsh} ParticipantClass to a specific address:"
  },
  {
    "objectID": "/rsh/errors/#p_132",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by using a {!rsh} Participant, which may be associated with a single address:"
  },
  {
    "objectID": "/rsh/errors/#p_133",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates an attempt to re-bind a {!rsh} Participant to another {!rsh} Address. Once a {!rsh} Participant is bound to an {!rsh} Address, either by making a publication or explicitly via {!rsh} Participant.set, they may not be re-bound."
  },
  {
    "objectID": "/rsh/errors/#p_134",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously has {!rsh} Bob make a publication, then later, attempts to bind him to a specific address:"
  },
  {
    "objectID": "/rsh/errors/#p_135",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by deleting one of the statements (depending on the logic of your application)."
  },
  {
    "objectID": "/rsh/errors/#p_136",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to use a specific statement or expression in the wrong mode. Consult the documentation for the specific keyword to learn more about what mode is expected. Additionally, see the figure on Language for a diagram regarding the modes of a Reach application."
  },
  {
    "objectID": "/rsh/errors/#p_137",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to mutate a variable in an inappropriate place. Variable mutation is only allowed to occur on variables declared via {!rsh} var and immediately before a {!rsh} continue statement of a loop."
  },
  {
    "objectID": "/rsh/errors/#p_138",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below attempts to mutate a loop variable improperly:"
  },
  {
    "objectID": "/rsh/errors/#p_139",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this issue by moving the mutation directly before the {!rsh} continue:"
  },
  {
    "objectID": "/rsh/errors/#p_140",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates you are using an illegal JavaScript expression in Reach. Not all JavaScript expressions are valid Reach, as they are not applicable to the language."
  },
  {
    "objectID": "/rsh/errors/#p_141",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is nowhere to return to in the current statement block. This may occur if you write a {!rsh} return statement at the top level of a file or if you've already wrote a {!rsh} return statement."
  },
  {
    "objectID": "/rsh/errors/#p_142",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below has two {!rsh} return statements, the first of which will always occur, since it is not within a conditional:"
  },
  {
    "objectID": "/rsh/errors/#p_143",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by removing the second {!rsh} return which is dead code:"
  },
  {
    "objectID": "/rsh/errors/#p_144",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a value, which is not a function, is being applied as if it were a function. Ensure you are writing the correct name of the function you intend to use."
  },
  {
    "objectID": "/rsh/errors/#p_145",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below has two variables: {!rsh} f and {!rsh} g:"
  },
  {
    "objectID": "/rsh/errors/#p_146",
    "pt": "Error Codes",
    "t": 3,
    "c": "{!rsh} g is being applied as if it were a function, although we really intended on calling {!rsh} f. This can be fixed by ensuring we call a function:"
  },
  {
    "objectID": "/rsh/errors/#p_147",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1.9."
  },
  {
    "objectID": "/rsh/errors/#p_148",
    "pt": "Error Codes",
    "t": 3,
    "c": "It means the same thing as RE0035."
  },
  {
    "objectID": "/rsh/errors/#p_149",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a value, which is not an {!rsh} Object, is being treated as if it were an {!rsh} Object. This error occurs when you try to access a field of an erroneous value. This issue is most likely caused by a typo in your program."
  },
  {
    "objectID": "/rsh/errors/#p_150",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a value, which is not an {!rsh} Array or {!rsh} Tuple, is being treated as if it were. This error occurs when you try to access an element of an erroneous value. This issue is most likely caused by a typo in your program."
  },
  {
    "objectID": "/rsh/errors/#p_151",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is an attempt to dereference an {!rsh} Array or {!rsh} Tuple with a non-numerical value. You must use a value of type {!rsh} UInt to dereference an {!rsh} Array."
  },
  {
    "objectID": "/rsh/errors/#p_152",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are using a dynamic value to dereference a value which is not an {!rsh} Array. This issue is most likely caused by a typo. Please ensure you are dereferencing an {!rsh} Array."
  },
  {
    "objectID": "/rsh/errors/#p_153",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is an attempt to statically dereference an {!rsh} Array beyond its bounds. Ensure you are using an index that is between 0 and 1 less than the length of the {!rsh} Array."
  },
  {
    "objectID": "/rsh/errors/#p_154",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is an attempt to reference an identifier that is not in scope. This issue may be caused by a typo, a scoping issue, or a missing {!rsh} import."
  },
  {
    "objectID": "/rsh/errors/#p_155",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below declares a function with a variable {!rsh} x declared within it. Attempting to reference {!rsh} x outside of the function will result in an error:"
  },
  {
    "objectID": "/rsh/errors/#p_156",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this issue by returning the value of {!rsh} x from the function:"
  },
  {
    "objectID": "/rsh/errors/#p_157",
    "pt": "Error Codes",
    "t": 3,
    "c": "If you are attempting to use a value from a library, simply add the necessary {!rsh} import to the top of the Reach file."
  },
  {
    "objectID": "/rsh/errors/#p_158",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is a mismatch between the expected security levels of a variable and the actual one provided. This may happen if you use a public variable where a secret is expected, or vice versa."
  },
  {
    "objectID": "/rsh/errors/#p_159",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously declassifies the variable {!rsh} x, which is not secret:"
  },
  {
    "objectID": "/rsh/errors/#p_160",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this issue by simply assigning {!rsh} y to {!rsh} x."
  },
  {
    "objectID": "/rsh/errors/#p_161",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you provided an incorrect number of arguments to a function. You can fix this by providing the same amount of arguments expected."
  },
  {
    "objectID": "/rsh/errors/#p_162",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that an anonymous function was provided a name, which is not allowed."
  },
  {
    "objectID": "/rsh/errors/#p_163",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below names the anonymous function {!rsh} m:"
  },
  {
    "objectID": "/rsh/errors/#p_164",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by removing the function name:"
  },
  {
    "objectID": "/rsh/errors/#p_165",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there was an invalid syntax used for an {!rsh} import. The acceptable {!rsh} import formats are defined in the documentation for the keyword."
  },
  {
    "objectID": "/rsh/errors/#p_166",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously performs a default {!rsh} import:"
  },
  {
    "objectID": "/rsh/errors/#p_167",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by explicitly importing the bindings you want:"
  },
  {
    "objectID": "/rsh/errors/#p_168",
    "pt": "Error Codes",
    "t": 3,
    "c": "or by binding all the exports to an identifier:"
  },
  {
    "objectID": "/rsh/errors/#p_169",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_170",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there was a {!rsh} return statement at the top level."
  },
  {
    "objectID": "/rsh/errors/#p_171",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the Reach file does not have a header at the top of the file. The first top level statement of a Reach module must indicate what version of Reach the file uses."
  },
  {
    "objectID": "/rsh/errors/#p_172",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously exports an application without specifying what version of Reach it uses:"
  },
  {
    "objectID": "/rsh/errors/#p_173",
    "pt": "Error Codes",
    "t": 3,
    "c": "Fix this by adding a header to the file:"
  },
  {
    "objectID": "/rsh/errors/#p_174",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that an {!rsh} object has been given a field that is not an identifier or a {!rsh} string."
  },
  {
    "objectID": "/rsh/errors/#p_175",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously uses a dynamic string as an object key:"
  },
  {
    "objectID": "/rsh/errors/#p_176",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by using a static string as the key."
  },
  {
    "objectID": "/rsh/errors/#p_177",
    "pt": "Error Codes",
    "t": 3,
    "c": "This code snippet uses a static string as an object key instead of using a dynamic string. The object keys T and S are computable at compile time."
  },
  {
    "objectID": "/rsh/errors/#p_178",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_179",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates an {!rsh} Object has an incorrect number of values associated with a field."
  },
  {
    "objectID": "/rsh/errors/#p_180",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the field of an {!rsh} Object uses the incorrect syntax for defining a function."
  },
  {
    "objectID": "/rsh/errors/#p_181",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below declares a field as a function with the following syntax:"
  },
  {
    "objectID": "/rsh/errors/#p_182",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by using the following arrow expression syntax:"
  },
  {
    "objectID": "/rsh/errors/#p_183",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a {!rsh} UInt has been used as the key of an {!rsh} Object. However, only identifiers and values of type {!rsh} Bytes are valid object keys."
  },
  {
    "objectID": "/rsh/errors/#p_184",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this issue by replacing the erroneous key with a static string."
  },
  {
    "objectID": "/rsh/errors/#p_185",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to spread a value that is not an object. This issue is most likely caused by a typo in your program."
  },
  {
    "objectID": "/rsh/errors/#p_186",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the argument provided to {!rsh} Array.iota is not static. {!rsh} Array.iota requires its argument to be computable at compile time."
  },
  {
    "objectID": "/rsh/errors/#p_187",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this issue by providing a static {!rsh} UInt to the function."
  },
  {
    "objectID": "/rsh/errors/#p_188",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error occurs when you provide a primitive operation with the incorrect number of arguments or arguments of the wrong type. Please review the documentation for the function you are attempting to use and provide it with the correct arguments."
  },
  {
    "objectID": "/rsh/errors/#p_189",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to create a variable, although another variable in the scope uses the same name."
  },
  {
    "objectID": "/rsh/errors/#p_190",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_191",
    "pt": "Error Codes",
    "t": 3,
    "c": "In Reach, identifier shadowing is not allowed. You can fix this issue by renaming your variable or moving one of the variable declarations to another scope where it does not conflict with the other."
  },
  {
    "objectID": "/rsh/errors/#p_192",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_193",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the compiler expected the tail of a statement block to be empty, but it wasn't. This issue may arise if there are statements beyond a {!rsh} return or {!rsh} exit statement. These statements are dead code and you can fix this issue by deleting them."
  },
  {
    "objectID": "/rsh/errors/#p_194",
    "pt": "Error Codes",
    "t": 3,
    "c": "The {!rsh} return statement on line 19 will never be executed. The {!rsh} return statement in the {!rsh} if ... else ... block already handled what is needed for the g {!rsh} function."
  },
  {
    "objectID": "/rsh/errors/#p_195",
    "pt": "Error Codes",
    "t": 3,
    "c": "To fix the code remove line 19:"
  },
  {
    "objectID": "/rsh/errors/#p_196",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_197",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you tried to use the {!rsh} publish keyword twice in a publication."
  },
  {
    "objectID": "/rsh/errors/#p_198",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_199",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is a function at the top level without a name. You can fix this by naming your function."
  },
  {
    "objectID": "/rsh/errors/#p_200",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_201",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is an illegal {!rsh} while loop {!rsh} invariant. You can fix this issue by providing only one expression to {!rsh} invariant."
  },
  {
    "objectID": "/rsh/errors/#p_202",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_203",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that {!rsh} Participant.only was not supplied a single thunk as its argument."
  },
  {
    "objectID": "/rsh/errors/#p_204",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by providing the expected value to the function."
  },
  {
    "objectID": "/rsh/errors/#p_205",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_206",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that {!rsh} each was not given a {!rsh} Tuple of {!rsh} Participants as its first argument."
  },
  {
    "objectID": "/rsh/errors/#p_207",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by providing the expected value to the function."
  },
  {
    "objectID": "/rsh/errors/#p_208",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a given function expects a {!rsh} Participant or {!rsh} ParticipantClass as an argument, but it was given something else."
  },
  {
    "objectID": "/rsh/errors/#p_209",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously provides {!rsh} false instead of a {!rsh} Participant to {!rsh} unknowable:"
  },
  {
    "objectID": "/rsh/errors/#p_210",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by passing a {!rsh} Participant as the first argument to {!rsh} unknowable:"
  },
  {
    "objectID": "/rsh/errors/#p_211",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the program is attempting to transfer funds to a {!rsh} Participant that is not yet bound to an {!rsh} Address."
  },
  {
    "objectID": "/rsh/errors/#p_212",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below transfers funds to {!rsh} Bob before he has a set {!rsh} Address:"
  },
  {
    "objectID": "/rsh/errors/#p_213",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by using {!rsh} Participant.set first or having {!rsh} Bob publish before the {!rsh} transfer:"
  },
  {
    "objectID": "/rsh/errors/#p_214",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to {!rsh} transfer funds to a {!rsh} ParticipantClass. This is not possible because {!rsh} transfer expects a single {!rsh} Address to transfer to."
  },
  {
    "objectID": "/rsh/errors/#p_215",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously attempts to transfer the {!rsh} balance of the contract to a class:"
  },
  {
    "objectID": "/rsh/errors/#p_216",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by specifying a specific {!rsh} Address to use. For example, the class could {!rsh} race to specify their own address:"
  },
  {
    "objectID": "/rsh/errors/#p_217",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the state of the program differs in the continuation of a branching statement. That is, if a Reach program may execute multiple different code paths at runtime, the continuation of those branches must make the same assumption about state."
  },
  {
    "objectID": "/rsh/errors/#p_218",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, this error may be caused by having one branch end in consensus step and the other in a step. You can fix this by ensuring both branches end in the same mode."
  },
  {
    "objectID": "/rsh/errors/#p_219",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_220",
    "pt": "Error Codes",
    "t": 3,
    "c": "This fork ends in two different states, Step and Consensus, but after removing the {!rsh} commit both fork statements end in Consensus Step."
  },
  {
    "objectID": "/rsh/errors/#p_221",
    "pt": "Error Codes",
    "t": 3,
    "c": "Another example is a {!rsh} Participant makes their first publication in the branch of a conditional. You can fix this by having the {!rsh} Participant make their first publication before the conditional statement."
  },
  {
    "objectID": "/rsh/errors/#p_222",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to bind a secret value to an identifier of the wrong format. secret identifiers must be prefixed with {!rsh} _."
  },
  {
    "objectID": "/rsh/errors/#p_223",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously assigns a secret value to a public identifier, {!rsh} x:"
  },
  {
    "objectID": "/rsh/errors/#p_224",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by either changing the identifier to start with {!rsh} _ or using {!rsh} declassify to make the value public:"
  },
  {
    "objectID": "/rsh/errors/#p_225",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to bind a public value to an identifier of the wrong format. public identifiers cannot be prefixed with {!rsh} _."
  },
  {
    "objectID": "/rsh/errors/#p_226",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously assigns a public value to a secret identifier, {!rsh} _x:"
  },
  {
    "objectID": "/rsh/errors/#p_227",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by removing the {!rsh} _ prefix:"
  },
  {
    "objectID": "/rsh/errors/#p_228",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to read the value of {!rsh} _. Any binding to {!rsh} _ is ignored and therefore cannot be read from."
  },
  {
    "objectID": "/rsh/errors/#p_229",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_230",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by using another identifier and referencing it as usual."
  },
  {
    "objectID": "/rsh/errors/#p_231",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to spread a value as if it were a {!rsh} Tuple, {!rsh} Array, or {!rsh} Struct, but it is not. This issue is likely caused by a typo in your code."
  },
  {
    "objectID": "/rsh/errors/#p_232",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously spreads the wrong values:"
  },
  {
    "objectID": "/rsh/errors/#p_233",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by spreading a tuple-like value for the second argument of {!rsh} add:"
  },
  {
    "objectID": "/rsh/errors/#p_234",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the two {!rsh} Arrays given to {!rsh} Array.zip are not of equal length. You can fix this error by providing two {!rsh} Arrays of equal length to the function."
  },
  {
    "objectID": "/rsh/errors/#p_235",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a {!rsh} switch statement was supplied with a value that is not a {!rsh} Data instance."
  },
  {
    "objectID": "/rsh/errors/#p_236",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below expects a {!rsh} Maybe type, but is erroneously provided with a {!rsh} UInt:"
  },
  {
    "objectID": "/rsh/errors/#p_237",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by providing a value with the correct {!rsh} Type to the {!rsh} switch statement:"
  },
  {
    "objectID": "/rsh/errors/#p_238",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there are multiple cases for the same variant in a {!rsh} switch statement or {!rsh} match expression."
  },
  {
    "objectID": "/rsh/errors/#p_239",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_240",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by deleting one of the branches, ensuring there is only one branch per variant."
  },
  {
    "objectID": "/rsh/errors/#p_241",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_242",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a {!rsh} switch statement or {!rsh} match expression does not have a case for every variant of a {!rsh} Data instance."
  },
  {
    "objectID": "/rsh/errors/#p_243",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_244",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this issue by adding the missing cases listed in the error message."
  },
  {
    "objectID": "/rsh/errors/#p_245",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_246",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a {!rsh} switch statement or {!rsh} match expression contains cases for unknown variants. These erroneous variants are not listed in the {!rsh} Data definition."
  },
  {
    "objectID": "/rsh/errors/#p_247",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_248",
    "pt": "Error Codes",
    "t": 3,
    "c": "Mone is not added to the {!rsh} Data field and so is an unknown variant. You can fix this issue by adding the unknown variant to the {!rsh} Data definition or removing the case."
  },
  {
    "objectID": "/rsh/errors/#p_249",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the {!rsh} Type of a value you provided to a function or operation does not match the expected {!rsh} Type."
  },
  {
    "objectID": "/rsh/errors/#p_250",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously provides a number as the second argument to {!rsh} assert:"
  },
  {
    "objectID": "/rsh/errors/#p_251",
    "pt": "Error Codes",
    "t": 3,
    "c": "However, the second argument of {!rsh} assert is expected to be of type {!rsh} Bytes. You can fix this issue by providing a value of the correct type:"
  },
  {
    "objectID": "/rsh/errors/#p_252",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the depth of recursion for a function call exceeded the limit allowed. This issue may indicate that the recursive function does not have a base case."
  },
  {
    "objectID": "/rsh/errors/#p_253",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_254",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this issue by rewriting the recursive function as an iterative set of statements, e.g. a {!rsh} while loop."
  },
  {
    "objectID": "/rsh/errors/#p_255",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the program is no longer live by the time it reaches a publication. That is, the program will have already {!rsh} exited before the given point."
  },
  {
    "objectID": "/rsh/errors/#p_256",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below will always {!rsh} exit before calling {!rsh} publish:"
  },
  {
    "objectID": "/rsh/errors/#p_257",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by wrapping the {!rsh} exit in a conditional:"
  },
  {
    "objectID": "/rsh/errors/#p_258",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_259",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a statement is being used in place of an expression. Refer to the documentation for the statement you are attempting to use for more information on how to use it."
  },
  {
    "objectID": "/rsh/errors/#p_260",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is an attempt to conditionally transition to consensus without a {!rsh} timeout. When making a conditional publication, such as {!rsh} A.publish(x).when(shouldPublish), there needs to be a timeout associated with the publication if {!rsh} shouldPublish is not statically {!rsh} true."
  },
  {
    "objectID": "/rsh/errors/#p_261",
    "pt": "Error Codes",
    "t": 3,
    "c": "In {!rsh} parallelReduce or {!rsh} fork, a {!rsh} timeout is required unless one {!rsh} Participant always races, the {!rsh} when field in their PUBLISH_EXPR is statically {!rsh} true, or if one {!rsh} ParticipantClass or {!rsh} API will attempt to race."
  },
  {
    "objectID": "/rsh/errors/#p_262",
    "pt": "Error Codes",
    "t": 3,
    "c": "Since {!rsh} ParticipantClass is being deprecated, it is preferable to use {!rsh} API."
  },
  {
    "objectID": "/rsh/errors/#p_263",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously attempts to publish a value if a certain condition holds:"
  },
  {
    "objectID": "/rsh/errors/#p_264",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this issue by providing a {!rsh} timeout case for"
  },
  {
    "objectID": "/rsh/errors/#p_265",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the result of PUBLISH_EXPR for a {!rsh} fork or {!rsh} parallelReduce is not of the right {!rsh} Type. It is expected to be an {!rsh} Object with a {!rsh} when field, and optionally a {!rsh} msg field."
  },
  {
    "objectID": "/rsh/errors/#p_266",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously tries to publish a value in a {!rsh} parallelReduce case:"
  },
  {
    "objectID": "/rsh/errors/#p_267",
    "pt": "Error Codes",
    "t": 3,
    "c": "This code can be fixed by using an {!rsh} Object and assigning the value to be published to the {!rsh} msg field of the object:"
  },
  {
    "objectID": "/rsh/errors/#p_268",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the parameters of a CONSENSUS_EXPR in a {!rsh} fork or {!rsh} parallelReduce are incorrect. The function provided should either accept zero parameters or one parameter, which represents the {!rsh} msg of the {!rsh} PUBLISH_EXPR."
  },
  {
    "objectID": "/rsh/errors/#p_269",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously tries to publish multiple values and bind them in the function provided to CONSENSUS_EXPR:"
  },
  {
    "objectID": "/rsh/errors/#p_270",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by changing the arrow expression to accept one parameter. You can either destructure the argument with a {!rsh} const assignment or as part of the function syntax:"
  },
  {
    "objectID": "/rsh/errors/#p_271",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that not all the components of the {!rsh} parallelReduce statement are provided. Please refer to the documentation of {!rsh} parallelReduce to see the required components."
  },
  {
    "objectID": "/rsh/errors/#p_272",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by adding any components the compiler has listed."
  },
  {
    "objectID": "/rsh/errors/#p_273",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example of the issue:"
  },
  {
    "objectID": "/rsh/errors/#p_274",
    "pt": "Error Codes",
    "t": 3,
    "c": "To fix this, make sure the {!rsh} parallelReduce has all required elements."
  },
  {
    "objectID": "/rsh/errors/#p_275",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you have provided the wrong number of arguments to a component of {!rsh} parallelReduce. Please refer to the documentation for the specific component you are trying to use."
  },
  {
    "objectID": "/rsh/errors/#p_276",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously supplies a closure as the second argument to {!rsh} timeRemaining."
  },
  {
    "objectID": "/rsh/errors/#p_277",
    "pt": "Error Codes",
    "t": 3,
    "c": "However, {!rsh} timeRemaining is a shorthand for a timeout which automatically publishes and returns the {!rsh} parallelReduce accumulator. The component only expects one argument. You can fix this code by removing the second argument supplied."
  },
  {
    "objectID": "/rsh/errors/#p_278",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that your program would contain a value at runtime which would not be allowed. This error usually stems from not fully applying a primitive function or using a value incorrectly, such as the participant interact interface of a {!rsh} Participant."
  },
  {
    "objectID": "/rsh/errors/#p_279",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously tries to publish {!rsh} Alice's interact interface:"
  },
  {
    "objectID": "/rsh/errors/#p_280",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by specifying a specific field of {!rsh} Alice's interact interface to {!rsh} publish:"
  },
  {
    "objectID": "/rsh/errors/#p_281",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the {!rsh} Type of a value cannot exist at runtime. This error may be caused by a {!rsh} Fun in a participant interact interface having a return type of another {!rsh} Fun."
  },
  {
    "objectID": "/rsh/errors/#p_282",
    "pt": "Error Codes",
    "t": 3,
    "c": "For examples of this error and how to fix it, see RE0012."
  },
  {
    "objectID": "/rsh/errors/#p_283",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_284",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to apply a non-function value as if it were a function. This issue is most likely caused by a typo with an identifier."
  },
  {
    "objectID": "/rsh/errors/#p_285",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is a mismatch between the actual {!rsh} Type of a value and the expected {!rsh} Type of a value."
  },
  {
    "objectID": "/rsh/errors/#p_286",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously returns a {!rsh} Bool when the type annotation states that the function should return a {!rsh} UInt."
  },
  {
    "objectID": "/rsh/errors/#p_287",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by returning a {!rsh} UInt from the function or changing the return type of the function."
  },
  {
    "objectID": "/rsh/errors/#p_288",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error may be caused by using a value of the incorrect type in an operation. The code below erroneously uses a {!rsh} Maybe value in a {!rsh} + expression:"
  },
  {
    "objectID": "/rsh/errors/#p_289",
    "pt": "Error Codes",
    "t": 3,
    "c": "In this code, {!rsh} mi is still of {!rsh} Maybe type. You can fix this code by changing {!rsh} default to {!rsh} case Some, which will re-bind {!rsh} mi to the value contained within {!rsh} Some:"
  },
  {
    "objectID": "/rsh/errors/#p_290",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a {!rsh} Map.reduce is being performed outside of an {!rsh} invariant, which is the only place map reductions are allowed to occur."
  },
  {
    "objectID": "/rsh/errors/#p_291",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously attempts to keep the sum of the {!rsh} Map as a loop variable:"
  },
  {
    "objectID": "/rsh/errors/#p_292",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by moving any {!rsh} Map reductions to inside the {!rsh} invariant:"
  },
  {
    "objectID": "/rsh/errors/#p_293",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a {!rsh} Map was expected in an expression, but a value of a different type was provided. This issue is most likely caused by a typo in an identifier."
  },
  {
    "objectID": "/rsh/errors/#p_294",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to create a {!rsh} Foldable value, which is not possible. {!rsh} Foldable is an interface that {!rsh} Array and {!rsh} Map implement."
  },
  {
    "objectID": "/rsh/errors/#p_295",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously tries to create a {!rsh} Foldable value:"
  },
  {
    "objectID": "/rsh/errors/#p_296",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by instead creating a {!rsh} Map or an {!rsh} Array."
  },
  {
    "objectID": "/rsh/errors/#p_297",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there are normal parameters listed after parameters with default arguments in a function definition. Parameters with default arguments must come after all other arguments."
  },
  {
    "objectID": "/rsh/errors/#p_298",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously lists its parameters:"
  },
  {
    "objectID": "/rsh/errors/#p_299",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by rearranging the parameters so that the ones with default arguments are last:"
  },
  {
    "objectID": "/rsh/errors/#p_300",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to bind an effect or statement, which is not allowed."
  },
  {
    "objectID": "/rsh/errors/#p_301",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below supplies a statement as an argument to a function:"
  },
  {
    "objectID": "/rsh/errors/#p_302",
    "pt": "Error Codes",
    "t": 3,
    "c": "The result of {!rsh} each cannot be bound as a function argument. You can fix this code by wrapping the statement in an arrow expression:"
  },
  {
    "objectID": "/rsh/errors/#p_303",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there are unused variables in your program. This error will only occur with {!rsh} 'use strict'."
  },
  {
    "objectID": "/rsh/errors/#p_304",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by either replacing the unused variable names with {!rsh} _ or subsequently using {!rsh} void(x)."
  },
  {
    "objectID": "/rsh/errors/#p_305",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a field in a {!rsh} Remote object is not a function. You can fix this by ensuring your {!rsh} Remote object only contains fields that are functions. This fix may require changes to the foreign contract you are attempting to connect to."
  },
  {
    "objectID": "/rsh/errors/#p_306",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the key supplied to a {!rsh} Struct does not match the required regex. {!rsh} Struct keys must satisfy the regex: [_a-zA-Z][_a-zA-Z0-9]*."
  },
  {
    "objectID": "/rsh/errors/#p_307",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below provides an erroneous key value:"
  },
  {
    "objectID": "/rsh/errors/#p_308",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by removing any illegal characters:"
  },
  {
    "objectID": "/rsh/errors/#p_309",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a key in a {!rsh} Struct has been used more than once. Every key must be unique in a {!rsh} Struct."
  },
  {
    "objectID": "/rsh/errors/#p_310",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously uses the same key twice:"
  },
  {
    "objectID": "/rsh/errors/#p_311",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by renaming one of the {!rsh} \"x\" fields:"
  },
  {
    "objectID": "/rsh/errors/#p_312",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to export a name that the Reach backend already produces. For example, the names provided in {!rsh} Participant, {!rsh} ParticipantClass, {!rsh} API, and {!rsh} View will be exported by the Reach backend."
  },
  {
    "objectID": "/rsh/errors/#p_313",
    "pt": "Error Codes",
    "t": 3,
    "c": "Reach exports a few names from the backend automatically, such as {!rsh} getExports. Therefore, you cannot export a {!rsh} Participant named {!rsh} getExports as such:"
  },
  {
    "objectID": "/rsh/errors/#p_314",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by choosing a different name."
  },
  {
    "objectID": "/rsh/errors/#p_315",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to use a value that is not a {!rsh} Bool in a condition, while using strict mode."
  },
  {
    "objectID": "/rsh/errors/#p_316",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously uses a number as the condition to {!rsh} if:"
  },
  {
    "objectID": "/rsh/errors/#p_317",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by using a {!rsh} Bool instead. The following code will consider any number that is not {!rsh} 0 {!rsh} true:"
  },
  {
    "objectID": "/rsh/errors/#p_318",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there are multiple {!rsh} throw statements inside a {!rsh} try block and the values thrown are of different {!rsh} Types."
  },
  {
    "objectID": "/rsh/errors/#p_319",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by ensuring that every value thrown is of the same type. It may be necessary to create a new {!rsh} Data instance that can handle different types."
  },
  {
    "objectID": "/rsh/errors/#p_320",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously throws a {!rsh} UInt and a {!rsh} Bool:"
  },
  {
    "objectID": "/rsh/errors/#p_321",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by abstracting the {!rsh} Types of values thrown into a new {!rsh} Data type:"
  },
  {
    "objectID": "/rsh/errors/#p_322",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error occurs when you attempt to use a {!rsh} throw statement outside of a {!rsh} try block."
  },
  {
    "objectID": "/rsh/errors/#p_323",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_324",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by moving your {!rsh} throw statement inside the appropriate block of code or wrapping the necessary code into a {!rsh} try/{!rsh} catch block."
  },
  {
    "objectID": "/rsh/errors/#p_325",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_326",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to {!rsh} pay on the first publication. This is not possible, because the contract will not yet exist, and receiving tokens depends on knowing the address of a contract first on those networks."
  },
  {
    "objectID": "/rsh/errors/#p_327",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_328",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by paying into the contract after the first publication."
  },
  {
    "objectID": "/rsh/errors/#p_329",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_330",
    "pt": "Error Codes",
    "t": 3,
    "c": "Alice creates the wager and the deadline, then declassifies them in the {!rsh} interact object to create the contract. Alice is then able to {!rsh} publish both wager and deadline, and pay the wager because the contract has already been created."
  },
  {
    "objectID": "/rsh/errors/#p_331",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to {!rsh} publish a {!rsh} Token within a {!rsh} while loop. This is not currently possible in Reach. You must publish {!rsh} Token values outside of loops."
  },
  {
    "objectID": "/rsh/errors/#p_332",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously publishes a {!rsh} Token inside a loop:"
  },
  {
    "objectID": "/rsh/errors/#p_333",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by publishing {!rsh} tok before the loop:"
  },
  {
    "objectID": "/rsh/errors/#p_334",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to reference a {!rsh} Token that was computed dynamically. Reach does not yet support this."
  },
  {
    "objectID": "/rsh/errors/#p_335",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below attempts to transfer the balance of an {!rsh} array of {!rsh} Tokens to a {!rsh} Participant:"
  },
  {
    "objectID": "/rsh/errors/#p_336",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can work around this issue by writing out the {!rsh} Token values explicitly:"
  },
  {
    "objectID": "/rsh/errors/#p_337",
    "pt": "Error Codes",
    "t": 3,
    "c": "Sometimes this is caused when you did not include {!rsh} paySpec in a use of {!rsh} fork or {!rsh} parallelReduce."
  },
  {
    "objectID": "/rsh/errors/#p_338",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the incorrect arguments were supplied to {!rsh} withBill. {!rsh} withBill either expects zero arguments, when only receiving network tokens, or a {!rsh} Tuple of {!rsh} Tokens when receiving non-network tokens."
  },
  {
    "objectID": "/rsh/errors/#p_339",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously provides multiple non-network tokens to {!rsh} withBill:"
  },
  {
    "objectID": "/rsh/errors/#p_340",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by wrapping all the arguments into a single {!rsh} Tuple:"
  },
  {
    "objectID": "/rsh/errors/#p_341",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a program declared multiple {!rsh} Views with the same name."
  },
  {
    "objectID": "/rsh/errors/#p_342",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by renaming the duplicate {!rsh} Views, ensuring that every name is unique."
  },
  {
    "objectID": "/rsh/errors/#p_343",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_344",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the value of a {!rsh} View cannot be exposed. This would only occur if the value cannot be represented at runtime."
  },
  {
    "objectID": "/rsh/errors/#p_345",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a {!rsh} View function has an unconstrained domain. Every {!rsh} View must explicitly state the {!rsh} Type of function arguments it accepts."
  },
  {
    "objectID": "/rsh/errors/#p_346",
    "pt": "Error Codes",
    "t": 3,
    "c": "If your {!rsh} View function relies on a varying number of arguments or {!rsh} Types, you can either abstract the arguments into a new {!rsh} Data type or make separate {!rsh} Views."
  },
  {
    "objectID": "/rsh/errors/#p_347",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_348",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there are multiple {!rsh} APIs, {!rsh} Participants or {!rsh} ParticipantClasses with the same name."
  },
  {
    "objectID": "/rsh/errors/#p_349",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_350",
    "pt": "Error Codes",
    "t": 3,
    "c": "Each participant name must be unique."
  },
  {
    "objectID": "/rsh/errors/#p_351",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by renaming the duplicate names."
  },
  {
    "objectID": "/rsh/errors/#p_352",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_353",
    "pt": "Error Codes",
    "t": 3,
    "c": "Since {!rsh} ParticipantClass is being deprecated, it is preferable to use {!rsh} API."
  },
  {
    "objectID": "/rsh/errors/#p_354",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a {!rsh} Struct contains an invalid field name. A field name may be invalid if it is a reserved word in the connector you are targeting."
  },
  {
    "objectID": "/rsh/errors/#p_355",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously uses the field name {!rsh} \"super\", which is reserved in the ETH connector:"
  },
  {
    "objectID": "/rsh/errors/#p_356",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by renaming the erroneous field names:"
  },
  {
    "objectID": "/rsh/errors/#p_357",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that an unexpected key was provided to the {!rsh} Token constructor. You may find the acceptable parameters in the following section: token minting."
  },
  {
    "objectID": "/rsh/errors/#p_358",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to perform an invalid operation on a {!rsh} Token. Some {!rsh} Token methods such as {!rsh} destroy, {!rsh} burn, and {!rsh} supply are only valid for tokens that were created in your program."
  },
  {
    "objectID": "/rsh/errors/#p_359",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by removing the erroneous statement."
  },
  {
    "objectID": "/rsh/errors/#p_360",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you provided an incorrect value to the {!rsh} .define component of a {!rsh} parallelReduce statement. The argument to {!rsh} .define should be of the form: {!rsh} () => DEFINE_BLOCK. Please review the {!rsh} parallelReduce documentation for information on how {!rsh} .define works."
  },
  {
    "objectID": "/rsh/errors/#p_361",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you provided an incorrect value to a function. The function expected to receive a {!rsh} Type, but received something else. This issue can arise when a {!rsh} Type constructor does not have any arguments applied to it."
  },
  {
    "objectID": "/rsh/errors/#p_362",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously creates an {!rsh} Object type with a field {!rsh} name:"
  },
  {
    "objectID": "/rsh/errors/#p_363",
    "pt": "Error Codes",
    "t": 3,
    "c": "This code is incorrect because {!rsh} Bytes is not a type; it is a function that accepts a {!rsh} UInt and returns a {!rsh} Type. This code can be fixed by providing an argument to {!rsh} Bytes that represents the length:"
  },
  {
    "objectID": "/rsh/errors/#p_364",
    "pt": "Error Codes",
    "t": 3,
    "c": "For more information about data types, visit Types."
  },
  {
    "objectID": "/rsh/errors/#p_365",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a time argument's type is not known at compile-time."
  },
  {
    "objectID": "/rsh/errors/#p_366",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, if {!rsh} x is not known at compile-time, then"
  },
  {
    "objectID": "/rsh/errors/#p_367",
    "pt": "Error Codes",
    "t": 3,
    "c": "results in this error."
  },
  {
    "objectID": "/rsh/errors/#p_368",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error means that a {!rsh} return statement, typically inside of an {!rsh} if statement, does not occur in tail position."
  },
  {
    "objectID": "/rsh/errors/#p_369",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, this function would have this error:"
  },
  {
    "objectID": "/rsh/errors/#p_370",
    "pt": "Error Codes",
    "t": 3,
    "c": "The third {!rsh} return can never be reached, so the way to correct the program is to remove it."
  },
  {
    "objectID": "/rsh/errors/#p_371",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error means that only one branch of a conditional ({!rsh} if or {!rsh} switch) contains a {!rsh} return statement."
  },
  {
    "objectID": "/rsh/errors/#p_372",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, this function would have this error:"
  },
  {
    "objectID": "/rsh/errors/#p_373",
    "pt": "Error Codes",
    "t": 3,
    "c": "It should be corrected by moving the tail of the {!rsh} if into the {!rsh} else branch:"
  },
  {
    "objectID": "/rsh/errors/#p_374",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a switch case is unreachable. This issue will occur when a {!rsh} case is listed after {!rsh} default."
  },
  {
    "objectID": "/rsh/errors/#p_375",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously puts a {!rsh} case after {!rsh} default:"
  },
  {
    "objectID": "/rsh/errors/#p_376",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error can be corrected by either removing the {!rsh} Some case or placing it before the {!rsh} default case:"
  },
  {
    "objectID": "/rsh/errors/#p_377",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you have inspected the details about a publication, such as via {!rsh} didPublish(), before there has been a publication. This is impossible, so the expression must be moved after the first publication."
  },
  {
    "objectID": "/rsh/errors/#p_378",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously puts {!rsh} didPublish() before {!rsh} publish:"
  },
  {
    "objectID": "/rsh/errors/#p_379",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error can be corrected by placing {!rsh} publish before {!rsh} didPublish():"
  },
  {
    "objectID": "/rsh/errors/#p_380",
    "pt": "Error Codes",
    "t": 3,
    "c": "Notice that the Sponsor {!rsh} published on line 35. On Line 62, {!rsh} didPublish() is used to make a check."
  },
  {
    "objectID": "/rsh/errors/#p_381",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that an actor who is not a {!rsh} Participant, e.g. a {!rsh} ParticipantClass, is attempting to make the first publication of a Reach program."
  },
  {
    "objectID": "/rsh/errors/#p_382",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by assigning the first publication to one of your {!rsh} Participants. Additionally, you can create a new {!rsh} Participant to specifically perform this action."
  },
  {
    "objectID": "/rsh/errors/#p_383",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that one of an API's interface members is not a function. For example:"
  },
  {
    "objectID": "/rsh/errors/#p_384",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version 0.1.7."
  },
  {
    "objectID": "/rsh/errors/#p_385",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the left-hand side of a {!rsh} call assignment is not a pair of the domain and a function to return a result to the function. For example:"
  },
  {
    "objectID": "/rsh/errors/#p_386",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the name provided to a {!rsh} Participant, {!rsh} ParticipantClass, {!rsh} API, or {!rsh} View is already in use. There is a single namespace for all of these entities."
  },
  {
    "objectID": "/rsh/errors/#p_387",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously uses the same name multiple times:"
  },
  {
    "objectID": "/rsh/errors/#p_388",
    "pt": "Error Codes",
    "t": 3,
    "c": "{!rsh} 'Flower_girl' is used multiple times because every method of an {!rsh} API will introduce a binding, of the format: <API name>_<method name>, into the namespace."
  },
  {
    "objectID": "/rsh/errors/#p_389",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by using different names:"
  },
  {
    "objectID": "/rsh/errors/#p_390",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is an attempt to make a publication in your program, but there are no {!rsh} Participants or {!rsh} ParticipantClasses declared."
  },
  {
    "objectID": "/rsh/errors/#p_391",
    "pt": "Error Codes",
    "t": 3,
    "c": "This issue can arise when you use {!rsh} Anybody.publish(). To fix this issue, ensure you declare a {!rsh} Participant or {!rsh} ParticipantClass."
  },
  {
    "objectID": "/rsh/errors/#p_392",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the program below erroneously uses {!rsh} Anybody.publish() without declaring any {!rsh} Participant or {!rsh} ParticipantClass:"
  },
  {
    "objectID": "/rsh/errors/#p_393",
    "pt": "Error Codes",
    "t": 3,
    "c": "However, the correct thing to do is to declare at least one {!rsh} Participant or {!rsh} ParticipantClass before using {!rsh} Anybody.publish() like in the program below:"
  },
  {
    "objectID": "/rsh/errors/#p_394",
    "pt": "Error Codes",
    "t": 3,
    "c": "Since {!rsh} ParticipantClass is being deprecated, it is preferable to use {!rsh} API."
  },
  {
    "objectID": "/rsh/errors/#p_395",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that an {!rsh} API is explicitly attempting to make a publication, e.g. {!rsh} api.publish(). An API may only make a publication through a {!rsh} fork, {!rsh} parallelReduce, or {!rsh} call."
  },
  {
    "objectID": "/rsh/errors/#p_396",
    "pt": "Error Codes",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/errors/#p_397",
    "pt": "Error Codes",
    "t": 3,
    "c": "Depending on your program, you can fix this error by performing a {!rsh} call or adding an {!rsh} .api case to your {!rsh} fork or {!rsh} parallelReduce statement."
  },
  {
    "objectID": "/rsh/errors/#p_398",
    "pt": "Error Codes",
    "t": 3,
    "c": "This snippet {!rsh} calls the {!rsh} API instead of publishing."
  },
  {
    "objectID": "/rsh/errors/#p_399",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is a {!rsh} fork or {!rsh} parallelReduce in the program that does not specify a {!rsh} .case or {!rsh} .api component. At least one of these components must be specified."
  },
  {
    "objectID": "/rsh/errors/#p_400",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by adding a {!rsh} .case or {!rsh} .api component to your statement."
  },
  {
    "objectID": "/rsh/errors/#p_401",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the .paySpec component of a parallelReduce, or fork does not provide a syntactic tuple of identifiers."
  },
  {
    "objectID": "/rsh/errors/#p_402",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below provides .paySpec with a variable that is equal to a tuple of {!rsh} Token identifiers:"
  },
  {
    "objectID": "/rsh/errors/#p_403",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by inlining the tuple directly:"
  },
  {
    "objectID": "/rsh/errors/#p_404",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to update loop variables to a {!rsh} Tuple of different length. This error can occur in the assignments before a {!rsh} while loop's {!rsh} continue, or the {!rsh} return expression in a {!rsh} parallelReduce case."
  },
  {
    "objectID": "/rsh/errors/#p_405",
    "pt": "Error Codes",
    "t": 3,
    "c": "The code below erroneously attempts to update the loop variable to a 2-tuple in the timeout, although the loop variable is a 1-tuple:"
  },
  {
    "objectID": "/rsh/errors/#p_406",
    "pt": "Error Codes",
    "t": 3,
    "c": "Depending on the intended behavior of the program, you can fix this error in different ways:"
  },
  {
    "objectID": "/rsh/errors/#p_407",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can remove the unnecessary value {!rsh} 43 from the {!rsh} Tuple since you are only tracking one loop variable, {!rsh} a."
  },
  {
    "objectID": "/rsh/errors/#p_408",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can update the loop variable {!rsh} Tuple to track more variables:"
  },
  {
    "objectID": "/rsh/errors/#p_409",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to perform an {!rsh} xor operation on an unsupported type."
  },
  {
    "objectID": "/rsh/errors/#p_410",
    "pt": "Error Codes",
    "t": 3,
    "c": "Refer to the {!rsh} xor documentation to see what types are supported."
  },
  {
    "objectID": "/rsh/errors/#p_411",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to perform a {!rsh} mod operation on an unsupported type."
  },
  {
    "objectID": "/rsh/errors/#p_412",
    "pt": "Error Codes",
    "t": 3,
    "c": "Refer to the {!rsh} mod documentation to see what types are supported."
  },
  {
    "objectID": "/rsh/errors/#p_413",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to overload a method with multiple functions that have the same domain."
  },
  {
    "objectID": "/rsh/errors/#p_414",
    "pt": "Error Codes",
    "t": 3,
    "c": "This code overloads c by setting a, b, and d all to c."
  },
  {
    "objectID": "/rsh/errors/#p_415",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this issue by either removing one of the overloads or changing one of the domains. You can change the domain of a function by altering the type of its parameters or adding/removing parameters."
  },
  {
    "objectID": "/rsh/errors/#p_416",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates you had extra fields in {!rsh} REMOTE_FUN.ALGO that are not supported."
  },
  {
    "objectID": "/rsh/errors/#p_417",
    "pt": "Error Codes",
    "t": 3,
    "c": "In this code, foo is an illegal field:"
  },
  {
    "objectID": "/rsh/errors/#p_418",
    "pt": "Error Codes",
    "t": 3,
    "c": "Remove foo to fix the error code:"
  },
  {
    "objectID": "/rsh/errors/#p_419",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a thunk, or function with no parameters, was expected but something else was provided."
  },
  {
    "objectID": "/rsh/errors/#p_420",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously provides a function with one parameter to the {!rsh} .check function:"
  },
  {
    "objectID": "/rsh/errors/#p_421",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by removing the unnecessary function parameter."
  },
  {
    "objectID": "/rsh/errors/#p_422",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you returned the wrong values in {!rsh} CHECKED_CONSENSUS_EXPR of an {!rsh} .api_ branch."
  },
  {
    "objectID": "/rsh/errors/#p_423",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously returns the new accumulator for {!rsh} parallelReduce:"
  },
  {
    "objectID": "/rsh/errors/#p_424",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by returning a function that accepts the API return function as a parameter."
  },
  {
    "objectID": "/rsh/errors/#p_425",
    "pt": "Error Codes",
    "t": 3,
    "c": "Alternatively, if you want the api B.setX to pay into the contract, you can specify the pay amount as the first element in the return value:"
  },
  {
    "objectID": "/rsh/errors/#p_426",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you attempted to create a {!rsh} Data instance with no variants. This is not allowed."
  },
  {
    "objectID": "/rsh/errors/#p_427",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are using a function, like {!rsh} ContractCode, that requires representing values as JSON, but giving it a value that cannot be represented as JSON."
  },
  {
    "objectID": "/rsh/errors/#p_428",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there was an error while parsing or compiling contract code for {!rsh} ContractCode."
  },
  {
    "objectID": "/rsh/errors/#p_429",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there was an error while parsing a number in exponential notation."
  },
  {
    "objectID": "/rsh/errors/#p_430",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by ensuring you use the correct exponential notation syntax as specified in the numeric literals documentation."
  },
  {
    "objectID": "/rsh/errors/#p_431",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you called {!rsh} Bytes.fromHex with an invalid hex string. A hex string may only contain characters 0-9 and a-f."
  },
  {
    "objectID": "/rsh/errors/#p_432",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by providing a string in the correct format."
  },
  {
    "objectID": "/rsh/errors/#p_433",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are trying to access a value from outside of a {!rsh} Reach.App whose value is not known at compile time."
  },
  {
    "objectID": "/rsh/errors/#p_434",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously tries to access {!rsh} c from within the nested {!rsh} Reach.App:"
  },
  {
    "objectID": "/rsh/errors/#p_435",
    "pt": "Error Codes",
    "t": 3,
    "c": "!{rsh} c relies on the value of {!rsh} a, which is only known at runtime. Since nested applications can only reference values that are known at compile time, this code is invalid."
  },
  {
    "objectID": "/rsh/errors/#p_436",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by removing the erroneous reference to a dynamic value."
  },
  {
    "objectID": "/rsh/errors/#p_437",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a View or API uses more arguments than are supported on the ETH connector."
  },
  {
    "objectID": "/rsh/errors/#p_438",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the body of a {!rsh} while loop does not make a publication before the {!rsh} continue statement."
  },
  {
    "objectID": "/rsh/errors/#p_439",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below does not make any publications before continuing the loop:"
  },
  {
    "objectID": "/rsh/errors/#p_440",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by making a publication within the {!rsh} loop:"
  },
  {
    "objectID": "/rsh/errors/#p_441",
    "pt": "Error Codes",
    "t": 3,
    "c": "Note that the body of a {!rsh} while starts in a consensus step so you must first {!rsh} commit before making a publication."
  },
  {
    "objectID": "/rsh/errors/#p_442",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the result of setting a {!rsh} View will never be observable. Either the set does not dominate any {!rsh} commits, or the program {!rsh} exits in the next step."
  },
  {
    "objectID": "/rsh/errors/#p_443",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below attempts to set a loop variable as the value of a {!rsh} View:"
  },
  {
    "objectID": "/rsh/errors/#p_444",
    "pt": "Error Codes",
    "t": 3,
    "c": "The effect of {!rsh} I.i.set(i) is only observable after the next {!rsh} commit in its scope. Since, there are no {!rsh} commits between {!rsh} I.i.set(i) and {!rsh} continue, which is the end of the lexical scope, there is no way to observe the effect of setting {!rsh} I.i."
  },
  {
    "objectID": "/rsh/errors/#p_445",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can generally fix this error by inserting a {!rsh} commit in the area where you'd like the effect of setting a {!rsh} View to be observable. In the case of a {!rsh} while loop, like the program above, it can be fixed the following way:"
  },
  {
    "objectID": "/rsh/errors/#p_446",
    "pt": "Error Codes",
    "t": 3,
    "c": "This change will ensure the {!rsh} View {!rsh} I.i is set to {!rsh} i on every iteration of the loop. Additionally, the continuation of the loop will have {!rsh} I.i set to the last value of the loop variable {!rsh} i."
  },
  {
    "objectID": "/rsh/errors/#p_447",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you called an API multiple times within the same consensus step."
  },
  {
    "objectID": "/rsh/errors/#p_448",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the erroneous code below calls the API, {!rsh} U.f, many times in the same {!rsh} parallelReduce."
  },
  {
    "objectID": "/rsh/errors/#p_449",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by removing the duplicate {!rsh} .api case. Alternatively, you can create a new API method and replace one of the offending cases."
  },
  {
    "objectID": "/rsh/errors/#p_450",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that git clone has failed when trying to download the dependencies of your project. This error will tell you the issue that was encountered."
  },
  {
    "objectID": "/rsh/errors/#p_451",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that git checkout has failed when trying to checkout the specific revision of your dependency. This error will tell you the issue that was encountered."
  },
  {
    "objectID": "/rsh/errors/#p_452",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the dependency required by your project does not contain either the branch specified, or a master/main branch."
  },
  {
    "objectID": "/rsh/errors/#p_453",
    "pt": "Error Codes",
    "t": 3,
    "c": "Please ensure you have specified the correct import."
  },
  {
    "objectID": "/rsh/errors/#p_454",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that your project dependencies need to be retrieved but you did not specify {!rsh} --install-pkgs with your reach command."
  },
  {
    "objectID": "/rsh/errors/#p_455",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by specifying the needed flag with your command."
  },
  {
    "objectID": "/rsh/errors/#p_456",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the syntax you used to specify your import is incorrect."
  },
  {
    "objectID": "/rsh/errors/#p_457",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by using the correct syntax. Please view the documentation for package imports."
  },
  {
    "objectID": "/rsh/errors/#p_458",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the given code must not be reachable because it would result in an error if reached. This error may be caused for different reasons, which will be explained if encountered."
  },
  {
    "objectID": "/rsh/errors/#p_459",
    "pt": "Error Codes",
    "t": 3,
    "c": "One reason this code could be encountered is if there is a branch within a {!rsh} while loop, which does not contain a {!rsh} continue statement when it is expected."
  },
  {
    "objectID": "/rsh/errors/#p_460",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by explicitly adding the {!rsh} continue statement to the erroneous block of code."
  },
  {
    "objectID": "/rsh/errors/#p_461",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is a circular dependency in the {!rsh} imports of your application."
  },
  {
    "objectID": "/rsh/errors/#p_462",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by refactoring your code to remove the cyclic imports."
  },
  {
    "objectID": "/rsh/errors/#p_463",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_464",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you have specified a function without an argument list."
  },
  {
    "objectID": "/rsh/errors/#p_465",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by adding an argument list."
  },
  {
    "objectID": "/rsh/errors/#p_466",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_467",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that an identifier was expected during parsing, but an expression was received."
  },
  {
    "objectID": "/rsh/errors/#p_468",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a key or a key/value pair was expected in a destructuring assignment, but an object method was received."
  },
  {
    "objectID": "/rsh/errors/#p_469",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below creates a method within a destructuring assignment:"
  },
  {
    "objectID": "/rsh/errors/#p_470",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this code by simply specifying {!rsh} x in the assignment:"
  },
  {
    "objectID": "/rsh/errors/#p_471",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that an unsupported binary operator was encountered. Reach is a subset of JavaScript and does not support all of the binary operators JavaScript supports."
  },
  {
    "objectID": "/rsh/errors/#p_472",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by utilizing different operators or functions depending on the logic of your program."
  },
  {
    "objectID": "/rsh/errors/#p_473",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_474",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that an unsupported literal was encountered. Reach is a subset of JavaScript and does not support all of the literals that JavaScript supports."
  },
  {
    "objectID": "/rsh/errors/#p_475",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that an unsupported unary operator was encountered. Reach is a subset of JavaScript and does not support all of the unary operators JavaScript supports."
  },
  {
    "objectID": "/rsh/errors/#p_476",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by utilizing different operators or functions depending on the logic of your program."
  },
  {
    "objectID": "/rsh/errors/#p_477",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are attempting to {!rsh} import a file using an absolute path which is not supported."
  },
  {
    "objectID": "/rsh/errors/#p_478",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by using a relative path for your {!rsh} import."
  },
  {
    "objectID": "/rsh/errors/#p_479",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are trying to {!rsh} import a path that is accessing its parent directory via {!rsh} ... This type of import is not allowed. Please view the documentation for package imports."
  },
  {
    "objectID": "/rsh/errors/#p_480",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously {!rsh} imports a file from its parent directory:"
  },
  {
    "objectID": "/rsh/errors/#p_481",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by moving your file, {!rsh} \"../a.rsh\", to the same directory your program is in. Then, reference it using a relative import:"
  },
  {
    "objectID": "/rsh/errors/#p_482",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_483",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that the Reach file could not be parsed as a module."
  },
  {
    "objectID": "/rsh/errors/#p_484",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that a call-like expression was expected, but another value was provided."
  },
  {
    "objectID": "/rsh/errors/#p_485",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously passes {!rsh} _x, a secret value of {!rsh} Bob, to {!rsh} unknowable:"
  },
  {
    "objectID": "/rsh/errors/#p_486",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this by providing a call-like expression to the function:"
  },
  {
    "objectID": "/rsh/errors/#p_487",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1."
  },
  {
    "objectID": "/rsh/errors/#p_488",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that Reach expected to parse an identifier, but none was given."
  },
  {
    "objectID": "/rsh/errors/#p_489",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by adding an identifier name to the erroneous location."
  },
  {
    "objectID": "/rsh/errors/#p_490",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that there is a syntax error in your program. This error will provide the specific token that is erroneous."
  },
  {
    "objectID": "/rsh/errors/#p_491",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below erroneously provides an extra comma after the last argument of a function call:"
  },
  {
    "objectID": "/rsh/errors/#p_492",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this error by removing the unnecessary trailing comma:"
  },
  {
    "objectID": "/rsh/errors/#p_493",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates that you are trying to inspect or use the value produced from {!rsh} forall outside of an {!rsh} assert."
  },
  {
    "objectID": "/rsh/errors/#p_494",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, the code below attempts to verify that all {!rsh} UInts are greater than or equal to zero via a {!rsh} require:"
  },
  {
    "objectID": "/rsh/errors/#p_495",
    "pt": "Error Codes",
    "t": 3,
    "c": "This is invalid because the result of {!rsh} forall is an abstract value, which cannot exist at runtime. You can fix this code by verifying the claim via an {!rsh} assert:"
  },
  {
    "objectID": "/rsh/errors/#p_496",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error means that you defined an API but did not actually use it in your prorgam."
  },
  {
    "objectID": "/rsh/errors/#p_497",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error means that you returned the result to an API without calling it. This is generally not possible unless you directly use the internal representation of APIs."
  },
  {
    "objectID": "/rsh/errors/#p_498",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error will not happen after version v0.1.10."
  },
  {
    "objectID": "/rsh/errors/#p_499",
    "pt": "Error Codes",
    "t": 3,
    "c": "The error means that you use an API in two places in your program, which is not allowed."
  },
  {
    "objectID": "/rsh/errors/#p_500",
    "pt": "Error Codes",
    "t": 3,
    "c": "This might look like the following in the {!rsh} API_CONSENSUS_EXPR:"
  },
  {
    "objectID": "/rsh/errors/#p_501",
    "pt": "Error Codes",
    "t": 3,
    "c": "You cannot return from an API call twice."
  },
  {
    "objectID": "/rsh/errors/#p_502",
    "pt": "Error Codes",
    "t": 3,
    "c": "Sometimes the second instance is a by-product of an effect duplicating a continuation, such as:"
  },
  {
    "objectID": "/rsh/errors/#p_503",
    "pt": "Error Codes",
    "t": 3,
    "c": "This is because this is equivalent to:"
  },
  {
    "objectID": "/rsh/errors/#p_504",
    "pt": "Error Codes",
    "t": 3,
    "c": "Instead, the effect should happen after the return:"
  },
  {
    "objectID": "/rsh/errors/#p_505",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error means that you did not return a result from an API call."
  },
  {
    "objectID": "/rsh/errors/#p_506",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error means that an API caller relies on non-consensus state to operate. Typically, this is because the {!rsh} assume uses a value not needed by the consensus. This is likely a sign of a bigger error, because a {!rsh} assume that does not have a \"matching\" {!rsh} require in the consensus is not useful."
  },
  {
    "objectID": "/rsh/errors/#p_507",
    "pt": "Error Codes",
    "t": 3,
    "c": "This warning means the syntax or function you are trying to use is deprecated. It is still supported by the Reach compiler, but future versions of Reach may stop supporting it."
  },
  {
    "objectID": "/rsh/errors/#p_508",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this warning by using the new syntax or function the message suggests."
  },
  {
    "objectID": "/rsh/errors/#p_509",
    "pt": "Error Codes",
    "t": 3,
    "c": "This warning indicates there is an issue with the Solidity compiler. The message provided can be reported to Solidity."
  },
  {
    "objectID": "/rsh/errors/#p_510",
    "pt": "Error Codes",
    "t": 3,
    "c": "This warning indicates that your program either uses a feature that is not yet supported on Algorand or surpasses Algorand's limit on resources."
  },
  {
    "objectID": "/rsh/errors/#p_511",
    "pt": "Error Codes",
    "t": 3,
    "c": "This warning indicates your program will not run on Algorand for the listed reasons. These reasons include a limit on the total computation cost."
  },
  {
    "objectID": "/rsh/errors/#p_512",
    "pt": "Error Codes",
    "t": 3,
    "c": "This warning indicates that your program does not contain any publications."
  },
  {
    "objectID": "/rsh/errors/#p_513",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can fix this issue by making sure at least one {!rsh} Participant performs a {!rsh} publish."
  },
  {
    "objectID": "/rsh/errors/#p_514",
    "pt": "Error Codes",
    "t": 3,
    "c": "This warning indicates that a {!rsh} View or {!rsh} API produces or consumes an {!rsh} Object, which is a type internal to Reach. It has an opaque and unspecified representation that can only be automatically consumed by other Reach programs, so it is probably a bad choice for general purpose interfaces."
  },
  {
    "objectID": "/rsh/errors/#p_515",
    "pt": "Error Codes",
    "t": 3,
    "c": "You can remove this warning by using a {!rsh} Struct instead of the {!rsh} Object."
  },
  {
    "objectID": "/rsh/errors/#p_516",
    "pt": "Error Codes",
    "t": 3,
    "c": "This warning indicates that you referenced network seconds in your program."
  },
  {
    "objectID": "/rsh/errors/#p_517",
    "pt": "Error Codes",
    "t": 3,
    "c": "On most consensus networks, network seconds are completely unrelated to reality. The only invariant about these timestamps are that they never go down and they never increase by more than a fixed amont of seconds at each increment. (For example, on Ethereum, the fixed amount is 15, and on Algorand the amount is 25. Typically these are configurable parameters of the consensus, but have never actually been changed.)"
  },
  {
    "objectID": "/rsh/errors/#p_518",
    "pt": "Error Codes",
    "t": 3,
    "c": "For example, time 20 could actually occur on Monday at 17:45:00, but be assigned the timestamp of Sunday at 05:08:32, because that's when time 19 was and there was network downtime. Furthermore, if time 21 was \"on time\" and actually occurred on Monday at 17:45:05, it would be assigned to Sunday at 05:08:57 (25 seconds after time 20's assignment)."
  },
  {
    "objectID": "/rsh/errors/#p_519",
    "pt": "Error Codes",
    "t": 3,
    "c": "This process would slowly \"resychronize\"; on Algorand, it would gain 20 seconds on the \"actual time\" every 5 second round. This means it would take roughly 5 hours to resychronize after a day of downtime. However, this is not guaranteed to occur at any particular time, because block proposers (on Algorand, at least) are free to leave the timestamp unchanged from the last block (i.e. there is no minimum increment), so it is possible that time would never be synchronized with reality at all."
  },
  {
    "objectID": "/rsh/errors/#p_520",
    "pt": "Error Codes",
    "t": 3,
    "c": "Thus, it is unsafe to rely on network seconds for most purposes (such as interest on loans, time limits on auctions, and so forth), because network downtime (even intermittent) and adversarial block proposers (acting alone) can delay and influence the block time."
  },
  {
    "objectID": "/rsh/errors/#p_521",
    "pt": "Error Codes",
    "t": 3,
    "c": "This code uses {!rsh} relativeTime instead of {!rsh} relativeSecs to use real time instead of network time."
  },
  {
    "objectID": "/rsh/errors/#p_522",
    "pt": "Error Codes",
    "t": 3,
    "c": "This error indicates your program has failed verification. This error code is nonspecific, and is invoked for any verification error."
  },
  {
    "objectID": "/rsh/local/#rsh_interact",
    "pt": "Local Steps",
    "t": 0,
    "s": "rsh",
    "c": "interact"
  },
  {
    "objectID": "/rsh/local/#rsh_assume",
    "pt": "Local Steps",
    "t": 0,
    "s": "rsh",
    "c": "assume"
  },
  {
    "objectID": "/rsh/local/#rsh_fail",
    "pt": "Local Steps",
    "t": 0,
    "s": "rsh",
    "c": "fail"
  },
  {
    "objectID": "/rsh/local/#rsh_declassify",
    "pt": "Local Steps",
    "t": 0,
    "s": "rsh",
    "c": "declassify"
  },
  {
    "objectID": "/rsh/local/#rsh_makeCommitment",
    "pt": "Local Steps",
    "t": 0,
    "s": "rsh",
    "c": "makeCommitment"
  },
  {
    "objectID": "/rsh/local/#rsh_didPublish",
    "pt": "Local Steps",
    "t": 0,
    "s": "rsh",
    "c": "didPublish"
  },
  {
    "objectID": "/rsh/local/#term_interaction%20expression",
    "pt": "Local Steps",
    "t": 1,
    "c": "interaction expression"
  },
  {
    "objectID": "/rsh/local/#term_declassify",
    "pt": "Local Steps",
    "t": 1,
    "c": "declassify"
  },
  {
    "objectID": "/rsh/local/#ref-programs-local",
    "pt": "Local Steps",
    "t": 2,
    "c": "Local Steps"
  },
  {
    "objectID": "/rsh/local/#ref-programs-local-stmts",
    "pt": "Local Steps",
    "t": 2,
    "c": "Statements"
  },
  {
    "objectID": "/rsh/local/#ref-programs-local-exprs",
    "pt": "Local Steps",
    "t": 2,
    "c": "Expressions"
  },
  {
    "objectID": "/rsh/local/#ref-programs-local-this",
    "pt": "Local Steps",
    "t": 2,
    "c": "this"
  },
  {
    "objectID": "/rsh/local/#interact",
    "pt": "Local Steps",
    "t": 2,
    "c": "interact"
  },
  {
    "objectID": "/rsh/local/#assume",
    "pt": "Local Steps",
    "t": 2,
    "c": "assume"
  },
  {
    "objectID": "/rsh/local/#fail",
    "pt": "Local Steps",
    "t": 2,
    "c": "fail"
  },
  {
    "objectID": "/rsh/local/#declassify",
    "pt": "Local Steps",
    "t": 2,
    "c": "declassify"
  },
  {
    "objectID": "/rsh/local/#makecommitment",
    "pt": "Local Steps",
    "t": 2,
    "c": "makeCommitment"
  },
  {
    "objectID": "/rsh/local/#didpublish",
    "pt": "Local Steps",
    "t": 2,
    "c": "didPublish"
  },
  {
    "objectID": "/rsh/local/#p_0",
    "pt": "Local Steps",
    "t": 3,
    "c": "A Reach local step occurs in the body of {!rsh} only or {!rsh} each statements. It represents the actions taken by a single participant in an application."
  },
  {
    "objectID": "/rsh/local/#p_1",
    "pt": "Local Steps",
    "t": 3,
    "c": "Any statements valid for a computation are valid for a local step."
  },
  {
    "objectID": "/rsh/local/#p_2",
    "pt": "Local Steps",
    "t": 3,
    "c": "Any expressions valid for a computation are valid for a local step. However, some additional expressions are allowed."
  },
  {
    "objectID": "/rsh/local/#p_3",
    "pt": "Local Steps",
    "t": 3,
    "c": "Inside of a local step, {!rsh} this refers to the participant performing the step. This is useful when the local step was initiated by an {!rsh} each expression."
  },
  {
    "objectID": "/rsh/local/#p_4",
    "pt": "Local Steps",
    "t": 3,
    "c": "An interaction expression, written {!rsh} interact.METHOD(EXPR_0, ..., EXPR_n), where {!rsh} METHOD is an identifier bound in the participant interact interface to a function type, and {!rsh} EXPR_0 through {!rsh} EXPR_n are expressions that evaluate to the result of an interaction with a frontend that receives the evaluation of the {!rsh} n expressions and sends a value."
  },
  {
    "objectID": "/rsh/local/#p_5",
    "pt": "Local Steps",
    "t": 3,
    "c": "An interaction expression may also be written {!rsh} interact.KEY, where {!rsh} KEY is bound in the participant interact interface to a non-function type."
  },
  {
    "objectID": "/rsh/local/#p_6",
    "pt": "Local Steps",
    "t": 3,
    "c": "An interaction expression may only occur in a local step."
  },
  {
    "objectID": "/rsh/local/#p_7",
    "pt": "Local Steps",
    "t": 3,
    "c": "In this example from the Rock, Paper Scissors tutorial, the program is in the local step of Alice. It has Alice {!rsh} declassify the {!rsh} interact object for both the wager and the deadline for Bob, so that Bob can accept them."
  },
  {
    "objectID": "/rsh/local/#p_8",
    "pt": "Local Steps",
    "t": 3,
    "c": "An assumption where {!rsh} claim evaluates to {!rsh} true with honest frontends. This may only appear in a local step. It accepts an optional bytes argument, which is included in any reported violation."
  },
  {
    "objectID": "/rsh/local/#p_9",
    "pt": "Local Steps",
    "t": 3,
    "c": "If the claim dynamically evaluates to false, the frontend will raise an exception."
  },
  {
    "objectID": "/rsh/local/#p_10",
    "pt": "Local Steps",
    "t": 3,
    "c": "In this example, the claim is that the two tokens, tokenA and tokenB, are not the same, and there is no message that displays."
  },
  {
    "objectID": "/rsh/local/#p_11",
    "pt": "Local Steps",
    "t": 3,
    "c": "is a convenience method equivalent to {!rsh} assume(false). This may only appear in a local step."
  },
  {
    "objectID": "/rsh/local/#p_12",
    "pt": "Local Steps",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/local/#p_13",
    "pt": "Local Steps",
    "t": 3,
    "c": "This code calls {!rsh} fail inside of A's {!rsh} only block on line 16. It evaluates to {!rsh} assume(false)."
  },
  {
    "objectID": "/rsh/local/#p_14",
    "pt": "Local Steps",
    "t": 3,
    "c": "The declassify primitive performs a declassification of the given argument."
  },
  {
    "objectID": "/rsh/local/#p_15",
    "pt": "Local Steps",
    "t": 3,
    "c": "In this statement, Alice declassifies the wager and then publishes it so that Bob can know the wager."
  },
  {
    "objectID": "/rsh/local/#p_16",
    "pt": "Local Steps",
    "t": 3,
    "c": "Returns two values, {!rsh} [ commitment, salt ], where {!rsh} salt is the result of calling {!rsh} interact.random(), and {!rsh} commitment is the digest of {!rsh} salt and {!rsh} x. This is used in a local step before {!rsh} checkCommitment is used in a consensus step."
  },
  {
    "objectID": "/rsh/local/#p_17",
    "pt": "Local Steps",
    "t": 3,
    "c": "This is demonstrated in the example below. {!rsh} makeCommitment is used on line 18 before {!rsh} checkCommitment on line 21:"
  },
  {
    "objectID": "/rsh/local/#p_18",
    "pt": "Local Steps",
    "t": 3,
    "c": "Returns a boolean that indicates whether the last publication was made by this principal. A {!rsh} didPublish call must be inside an {!rsh} only block of code and be after a {!rsh} publish call."
  },
  {
    "objectID": "/rsh/local/#p_19",
    "pt": "Local Steps",
    "t": 3,
    "c": "For example, in the code below, a {!rsh} didPublish call is made on line 62 in an {!rsh} only block of code after a {!rsh} publish call was made on line 35:"
  },
  {
    "objectID": "/rsh/module/#rsh_export",
    "pt": "Modules",
    "t": 0,
    "s": "rsh",
    "c": "export"
  },
  {
    "objectID": "/rsh/module/#rsh_import",
    "pt": "Modules",
    "t": 0,
    "s": "rsh",
    "c": "import"
  },
  {
    "objectID": "/rsh/module/#rsh_from",
    "pt": "Modules",
    "t": 0,
    "s": "rsh",
    "c": "from"
  },
  {
    "objectID": "/rsh/module/#rsh_Reach",
    "pt": "Modules",
    "t": 0,
    "s": "rsh",
    "c": "Reach"
  },
  {
    "objectID": "/rsh/module/#rsh_App",
    "pt": "Modules",
    "t": 0,
    "s": "rsh",
    "c": "App"
  },
  {
    "objectID": "/rsh/module/#rsh_Reach.App",
    "pt": "Modules",
    "t": 0,
    "s": "rsh",
    "c": "Reach.App"
  },
  {
    "objectID": "/rsh/module/#term_source%20file",
    "pt": "Modules",
    "t": 1,
    "c": "source file"
  },
  {
    "objectID": "/rsh/module/#term_module",
    "pt": "Modules",
    "t": 1,
    "c": "module"
  },
  {
    "objectID": "/rsh/module/#term_export",
    "pt": "Modules",
    "t": 1,
    "c": "export"
  },
  {
    "objectID": "/rsh/module/#term_imports",
    "pt": "Modules",
    "t": 1,
    "c": "imports"
  },
  {
    "objectID": "/rsh/module/#term_local%20import",
    "pt": "Modules",
    "t": 1,
    "c": "local import"
  },
  {
    "objectID": "/rsh/module/#term_Package%20imports",
    "pt": "Modules",
    "t": 1,
    "c": "Package imports"
  },
  {
    "objectID": "/rsh/module/#term_Reach.App",
    "pt": "Modules",
    "t": 1,
    "c": "Reach.App"
  },
  {
    "objectID": "/rsh/module/#ref-programs-module",
    "pt": "Modules",
    "t": 2,
    "c": "Modules"
  },
  {
    "objectID": "/rsh/module/#ref-programs-module-stmts",
    "pt": "Modules",
    "t": 2,
    "c": "Statements"
  },
  {
    "objectID": "/rsh/module/#ref-programs-export",
    "pt": "Modules",
    "t": 2,
    "c": "export"
  },
  {
    "objectID": "/rsh/module/#ref-programs-import",
    "pt": "Modules",
    "t": 2,
    "c": "import"
  },
  {
    "objectID": "/rsh/module/#ref-programs-import-local",
    "pt": "Modules",
    "t": 2,
    "c": "Local imports"
  },
  {
    "objectID": "/rsh/module/#ref-programs-import-package",
    "pt": "Modules",
    "t": 2,
    "c": "Package imports"
  },
  {
    "objectID": "/rsh/module/#ref-programs-module-exprs",
    "pt": "Modules",
    "t": 2,
    "c": "Expressions"
  },
  {
    "objectID": "/rsh/module/#ref-programs-reachapp",
    "pt": "Modules",
    "t": 2,
    "c": "Reach.App"
  },
  {
    "objectID": "/rsh/module/#deprecated-long-form",
    "pt": "Modules",
    "t": 2,
    "c": "Deprecated long-form"
  },
  {
    "objectID": "/rsh/module/#p_0",
    "pt": "Modules",
    "t": 3,
    "c": "A Reach source file is a textual file which specifies a Reach module. It is traditionally given the file extension rsh, e.g. dao.rsh."
  },
  {
    "objectID": "/rsh/module/#p_1",
    "pt": "Modules",
    "t": 3,
    "c": "A module starts with {!rsh} 'reach 0.1'; followed by a sequence of imports and identifier definitions."
  },
  {
    "objectID": "/rsh/module/#p_2",
    "pt": "Modules",
    "t": 3,
    "c": "See the guide section on versions to understand how Reach uses version numbers like this."
  },
  {
    "objectID": "/rsh/module/#p_3",
    "pt": "Modules",
    "t": 3,
    "c": "Any statements valid for a computation are valid for a module. However, some additional statements are allowed."
  },
  {
    "objectID": "/rsh/module/#p_4",
    "pt": "Modules",
    "t": 3,
    "c": "Module-level identifier definitions may be exported by writing {!rsh} export in front of them. For example,"
  },
  {
    "objectID": "/rsh/module/#p_5",
    "pt": "Modules",
    "t": 3,
    "c": "are valid exports."
  },
  {
    "objectID": "/rsh/module/#p_6",
    "pt": "Modules",
    "t": 3,
    "c": "Module-level identifiers may also be exported after the fact, and may be renamed during export. For example:"
  },
  {
    "objectID": "/rsh/module/#p_7",
    "pt": "Modules",
    "t": 3,
    "c": "Identifiers from other modules may be re-exported (and renamed), even if they are not imported in the current module. For example:"
  },
  {
    "objectID": "/rsh/module/#p_8",
    "pt": "Modules",
    "t": 3,
    "c": "In this case, there is a module with a name of other-module.rsh which contains u and x. Identifier u is exported as u, and x is exported and renamed to be other_x. An exported identifier in a given module may be imported by other modules. Both u and other_x can be imported from the current module instead of importing them from other-module.rsh."
  },
  {
    "objectID": "/rsh/module/#p_9",
    "pt": "Modules",
    "t": 3,
    "c": "Exports are also exposed to the frontend via {!js} getExports. For more information on {!js} getExports and exposing exports to the frontend, refer to JavaScript."
  },
  {
    "objectID": "/rsh/module/#p_10",
    "pt": "Modules",
    "t": 3,
    "c": "Functions are only exposed if they are typed, that is, if they are constructed with {!rsh} is. Refer to Types for more information."
  },
  {
    "objectID": "/rsh/module/#p_11",
    "pt": "Modules",
    "t": 3,
    "c": "Reach supports two types of module imports: local imports, which refer to modules that exist within your project, and package imports, which refer to remote libraries that may be fetched from external sources such as GitHub."
  },
  {
    "objectID": "/rsh/module/#p_12",
    "pt": "Modules",
    "t": 3,
    "c": "Read the guide section on packages for more details."
  },
  {
    "objectID": "/rsh/module/#p_13",
    "pt": "Modules",
    "t": 3,
    "c": "Package imports are easily distinguished from local imports by a mandatory @ character at the beginning of the path string."
  },
  {
    "objectID": "/rsh/module/#p_14",
    "pt": "Modules",
    "t": 3,
    "c": "When a module, X, contains a local import, written {!rsh} import \"LIB.rsh\";, then the path LIB.rsh must resolve to another Reach source file. The exports from the module defined by LIB.rsh are included in the set of bound identifiers in X."
  },
  {
    "objectID": "/rsh/module/#p_15",
    "pt": "Modules",
    "t": 3,
    "c": "Import statements may limit or rename the imported identifiers."
  },
  {
    "objectID": "/rsh/module/#p_16",
    "pt": "Modules",
    "t": 3,
    "c": "Imports may instead bind the entire module to a single identifier, which is an object with fields corresponding to that module's exports."
  },
  {
    "objectID": "/rsh/module/#p_17",
    "pt": "Modules",
    "t": 3,
    "c": "Import cycles are invalid."
  },
  {
    "objectID": "/rsh/module/#p_18",
    "pt": "Modules",
    "t": 3,
    "c": "The path given to an import may not include .. to specify files outside the current directory nor may it be an absolute path."
  },
  {
    "objectID": "/rsh/module/#p_19",
    "pt": "Modules",
    "t": 3,
    "c": "It must be a relative path, which is resolved relative to the parent directory of the source file in which they appear."
  },
  {
    "objectID": "/rsh/module/#p_20",
    "pt": "Modules",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/module/#p_21",
    "pt": "Modules",
    "t": 3,
    "c": "This code imports all the contents of lib.rsh and renames it to lib on line 3 while line 4 imports only a few of lib.rsh's contents."
  },
  {
    "objectID": "/rsh/module/#p_22",
    "pt": "Modules",
    "t": 3,
    "c": "Package imports obey the same rules as local imports but support an extended path syntax which allows Reach programmers to seamlessly plug into third-party libraries hosted on the internet."
  },
  {
    "objectID": "/rsh/module/#p_23",
    "pt": "Modules",
    "t": 3,
    "c": "All package imports begin with the @ character."
  },
  {
    "objectID": "/rsh/module/#p_24",
    "pt": "Modules",
    "t": 3,
    "c": "Package import paths are comprised of the following components:"
  },
  {
    "objectID": "/rsh/module/#p_25",
    "pt": "Modules",
    "t": 3,
    "c": "This component must be followed by a : character."
  },
  {
    "objectID": "/rsh/module/#p_26",
    "pt": "Modules",
    "t": 3,
    "c": "This component defaults to GitHub (i.e. github.com) if no site is specified."
  },
  {
    "objectID": "/rsh/module/#p_27",
    "pt": "Modules",
    "t": 3,
    "c": "Examples: github.com:, bitbucket.org:."
  },
  {
    "objectID": "/rsh/module/#p_28",
    "pt": "Modules",
    "t": 3,
    "c": "This component must be followed by a / character."
  },
  {
    "objectID": "/rsh/module/#p_29",
    "pt": "Modules",
    "t": 3,
    "c": "Examples: reach-sh/, jeapostrophe/."
  },
  {
    "objectID": "/rsh/module/#p_30",
    "pt": "Modules",
    "t": 3,
    "c": "Examples: reach-example-package, nfts."
  },
  {
    "objectID": "/rsh/module/#p_31",
    "pt": "Modules",
    "t": 3,
    "c": "If no ref is specified, Reach first tries to find the requested module on the repository's master branch, and if that fails then on the main branch once more."
  },
  {
    "objectID": "/rsh/module/#p_32",
    "pt": "Modules",
    "t": 3,
    "c": "git refs are discussed in further detail here."
  },
  {
    "objectID": "/rsh/module/#p_33",
    "pt": "Modules",
    "t": 3,
    "c": "Read this guide to learn more about how git tags work."
  },
  {
    "objectID": "/rsh/module/#p_34",
    "pt": "Modules",
    "t": 3,
    "c": "This component must be preceded by a # character."
  },
  {
    "objectID": "/rsh/module/#p_35",
    "pt": "Modules",
    "t": 3,
    "c": "Example: #v3.0.6."
  },
  {
    "objectID": "/rsh/module/#p_36",
    "pt": "Modules",
    "t": 3,
    "c": "This component must be preceded by a : character and must end with a /."
  },
  {
    "objectID": "/rsh/module/#p_37",
    "pt": "Modules",
    "t": 3,
    "c": "Example: :src/lib/."
  },
  {
    "objectID": "/rsh/module/#p_38",
    "pt": "Modules",
    "t": 3,
    "c": "Defaults to index.rsh."
  },
  {
    "objectID": "/rsh/module/#p_39",
    "pt": "Modules",
    "t": 3,
    "c": "If the module exists within a subdirectory it must be preceded by a / character."
  },
  {
    "objectID": "/rsh/module/#p_40",
    "pt": "Modules",
    "t": 3,
    "c": "Example: @reach-sh/example#v1.01:parent/child/pkg.rsh."
  },
  {
    "objectID": "/rsh/module/#p_41",
    "pt": "Modules",
    "t": 3,
    "c": "However, if the module is stored in the root of the repository, it must instead be preceded by a : character."
  },
  {
    "objectID": "/rsh/module/#p_42",
    "pt": "Modules",
    "t": 3,
    "c": "Example: @reach-sh/example#v1.02:pkg.rsh."
  },
  {
    "objectID": "/rsh/module/#p_43",
    "pt": "Modules",
    "t": 3,
    "c": "The following forms are all syntactically valid package import expressions:"
  },
  {
    "objectID": "/rsh/module/#p_44",
    "pt": "Modules",
    "t": 3,
    "c": "Example:"
  },
  {
    "objectID": "/rsh/module/#p_45",
    "pt": "Modules",
    "t": 3,
    "c": "This code imports bestNumber from @reach-sh/reach-example-package:index.rsh package and renames it to bn on line 6. Line 11 {!rsh} asserts that bn is equivalent to 1742."
  },
  {
    "objectID": "/rsh/module/#p_46",
    "pt": "Modules",
    "t": 3,
    "c": "Since git repositories evolve and change over time, Reach takes extra steps in order to pin a given module import's version to the specific SHA hash of the specified revision at the time the package is first installed. These pins are stored in a lockfile, which should be included in your source control system."
  },
  {
    "objectID": "/rsh/module/#p_47",
    "pt": "Modules",
    "t": 3,
    "c": "Any expressions valid for a computation are valid for a module. However, some additional expressions are allowed."
  },
  {
    "objectID": "/rsh/module/#p_48",
    "pt": "Modules",
    "t": 3,
    "c": "Reach.App accepts a no-argument function that specifies a DApp. This function is applied during compilation as an application initialization. It specifies the entire DApp in its body."
  },
  {
    "objectID": "/rsh/module/#p_49",
    "pt": "Modules",
    "t": 3,
    "c": "If the result of {!rsh} Reach.App is eventually bound to an identifier that is exported, then that identifier may be a target given to the compiler, as discussed in the section on usage."
  },
  {
    "objectID": "/rsh/module/#p_50",
    "pt": "Modules",
    "t": 3,
    "c": "Previous versions of Reach only allowed a form of Reach.App which accepted three arguments: an {!rsh} options object, an {!rsh} applicationArgs tuple, and a {!rsh} program arrow of the form {!rsh} (applicationIds) => body."
  },
  {
    "objectID": "/rsh/module/#p_51",
    "pt": "Modules",
    "t": 3,
    "c": "This form was equivalent to"
  },
  {
    "objectID": "/rsh/module/#p_52",
    "pt": "Modules",
    "t": 3,
    "c": "The current version of Reach will automatically transform these \"ternary\" {!rsh} Reach.App instances into the above form."
  },
  {
    "objectID": "/rsh/module/#p_53",
    "pt": "Modules",
    "t": 3,
    "c": "Future versions of Reach will deprecate this transform and such programs will be invalid."
  },
  {
    "objectID": "/rsh/step/#rsh_only",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "only"
  },
  {
    "objectID": "/rsh/step/#rsh_each",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "each"
  },
  {
    "objectID": "/rsh/step/#rsh_publish",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "publish"
  },
  {
    "objectID": "/rsh/step/#rsh_pay",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "pay"
  },
  {
    "objectID": "/rsh/step/#rsh_when",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "when"
  },
  {
    "objectID": "/rsh/step/#rsh_timeout",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "timeout"
  },
  {
    "objectID": "/rsh/step/#rsh_throwTimeout",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "throwTimeout"
  },
  {
    "objectID": "/rsh/step/#rsh_fork",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "fork"
  },
  {
    "objectID": "/rsh/step/#rsh_fork.case",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "fork.case"
  },
  {
    "objectID": "/rsh/step/#rsh_paySpec",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "paySpec"
  },
  {
    "objectID": "/rsh/step/#rsh_fork.paySpec",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "fork.paySpec"
  },
  {
    "objectID": "/rsh/step/#rsh_fork.api",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "fork.api"
  },
  {
    "objectID": "/rsh/step/#rsh_fork.api_",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "fork.api_"
  },
  {
    "objectID": "/rsh/step/#rsh_fork.timeout",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "fork.timeout"
  },
  {
    "objectID": "/rsh/step/#rsh_fork.throwTimeout",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "fork.throwTimeout"
  },
  {
    "objectID": "/rsh/step/#rsh_wait",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "wait"
  },
  {
    "objectID": "/rsh/step/#rsh_exit",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "exit"
  },
  {
    "objectID": "/rsh/step/#rsh_race",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "race"
  },
  {
    "objectID": "/rsh/step/#rsh_unknowable",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "unknowable"
  },
  {
    "objectID": "/rsh/step/#rsh_closeTo",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "closeTo"
  },
  {
    "objectID": "/rsh/step/#rsh_call",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "call"
  },
  {
    "objectID": "/rsh/step/#rsh_call.pay",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "call.pay"
  },
  {
    "objectID": "/rsh/step/#rsh_call.assume",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "call.assume"
  },
  {
    "objectID": "/rsh/step/#rsh_call.check",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "call.check"
  },
  {
    "objectID": "/rsh/step/#rsh_call.throwTimeout",
    "pt": "Steps",
    "t": 0,
    "s": "rsh",
    "c": "call.throwTimeout"
  },
  {
    "objectID": "/rsh/step/#term_interact%20shorthand",
    "pt": "Steps",
    "t": 1,
    "c": "interact shorthand"
  },
  {
    "objectID": "/rsh/step/#term_each",
    "pt": "Steps",
    "t": 1,
    "c": "each"
  },
  {
    "objectID": "/rsh/step/#term_pay%20amount",
    "pt": "Steps",
    "t": 1,
    "c": "pay amount"
  },
  {
    "objectID": "/rsh/step/#term_token%20amount",
    "pt": "Steps",
    "t": 1,
    "c": "token amount"
  },
  {
    "objectID": "/rsh/step/#term_pure",
    "pt": "Steps",
    "t": 1,
    "c": "pure"
  },
  {
    "objectID": "/rsh/step/#term_fork%20statement",
    "pt": "Steps",
    "t": 1,
    "c": "fork statement"
  },
  {
    "objectID": "/rsh/step/#term_wait%20statement",
    "pt": "Steps",
    "t": 1,
    "c": "wait statement"
  },
  {
    "objectID": "/rsh/step/#term_exit%20statement",
    "pt": "Steps",
    "t": 1,
    "c": "exit statement"
  },
  {
    "objectID": "/rsh/step/#term_race%20expression",
    "pt": "Steps",
    "t": 1,
    "c": "race expression"
  },
  {
    "objectID": "/rsh/step/#term_call",
    "pt": "Steps",
    "t": 1,
    "c": "call"
  },
  {
    "objectID": "/rsh/step/#ref-programs-step",
    "pt": "Steps",
    "t": 2,
    "c": "Steps"
  },
  {
    "objectID": "/rsh/step/#ref-programs-step-stmts",
    "pt": "Steps",
    "t": 2,
    "c": "Statements"
  },
  {
    "objectID": "/rsh/step/#ref-programs-only-step",
    "pt": "Steps",
    "t": 2,
    "c": "only and each"
  },
  {
    "objectID": "/rsh/step/#payAmt",
    "pt": "Steps",
    "t": 2,
    "c": "Pay Amounts"
  },
  {
    "objectID": "/rsh/step/#publish---pay---when---check--and--timeout",
    "pt": "Steps",
    "t": 2,
    "c": "publish, pay, when, check and timeout"
  },
  {
    "objectID": "/rsh/step/#fork",
    "pt": "Steps",
    "t": 2,
    "c": "fork"
  },
  {
    "objectID": "/rsh/step/#fork--intuition",
    "pt": "Steps",
    "t": 2,
    "c": "fork intuition"
  },
  {
    "objectID": "/rsh/step/#wait",
    "pt": "Steps",
    "t": 2,
    "c": "wait"
  },
  {
    "objectID": "/rsh/step/#exit",
    "pt": "Steps",
    "t": 2,
    "c": "exit"
  },
  {
    "objectID": "/rsh/step/#ref-programs-step-exprs",
    "pt": "Steps",
    "t": 2,
    "c": "Expressions"
  },
  {
    "objectID": "/rsh/step/#race",
    "pt": "Steps",
    "t": 2,
    "c": "race"
  },
  {
    "objectID": "/rsh/step/#unknowable",
    "pt": "Steps",
    "t": 2,
    "c": "unknowable"
  },
  {
    "objectID": "/rsh/step/#closeto",
    "pt": "Steps",
    "t": 2,
    "c": "closeTo"
  },
  {
    "objectID": "/rsh/step/#call",
    "pt": "Steps",
    "t": 2,
    "c": "call"
  },
  {
    "objectID": "/rsh/step/#p_0",
    "pt": "Steps",
    "t": 3,
    "c": "A Reach step occurs in the continuation of an init statement or commit statement. It represents the actions taken by each of the participants in an application."
  },
  {
    "objectID": "/rsh/step/#p_1",
    "pt": "Steps",
    "t": 3,
    "c": "Any statements valid for a computation are valid for a step. However, some additional statements are allowed."
  },
  {
    "objectID": "/rsh/step/#p_2",
    "pt": "Steps",
    "t": 3,
    "c": "A local step statement is written {!rsh} PART.only(() => BLOCK), where {!rsh} PART is a participant identifier and {!rsh} BLOCK is a block. Within {!rsh} BLOCK, {!rsh} PART is bound to the address of the participant. Any bindings defined within the block of a local step are available in the statement's tail as new local state. For example,"
  },
  {
    "objectID": "/rsh/step/#p_3",
    "pt": "Steps",
    "t": 3,
    "c": "is a valid program where {!rsh} Alice's local state includes the private values {!rsh} x (bound to {!rsh} 3) and {!rsh} y (bound to {!rsh} 4). However, such bindings are not consensus state, so they are purely local state. For example,"
  },
  {
    "objectID": "/rsh/step/#p_4",
    "pt": "Steps",
    "t": 3,
    "c": "is an invalid program, because {!rsh} Bob does not know {!rsh} x."
  },
  {
    "objectID": "/rsh/step/#p_5",
    "pt": "Steps",
    "t": 3,
    "c": "The interact shorthand, written {!rsh} PART.interact.METHOD(EXPR_0, ..., EXPR_n), is available for calling an {!rsh} interact function from outside of an {!rsh} only block. Such functions must return {!rsh} Null; therefore, they are only useful if they produce side-effects, such as logging on the frontend. For example, the function {!rsh} log in the participant interact interface of {!rsh} Alice may be called via:"
  },
  {
    "objectID": "/rsh/step/#p_6",
    "pt": "Steps",
    "t": 3,
    "c": "An each local step statement can be written as {!rsh} each(PART_TUPLE () => BLOCK), where {!rsh} PART_TUPLE is a tuple of participants and {!rsh} BLOCK is a block. It is an abbreviation of many local step statements that could have been written with {!rsh} only."
  },
  {
    "objectID": "/rsh/step/#p_7",
    "pt": "Steps",
    "t": 3,
    "c": "A pay amount is either:"
  },
  {
    "objectID": "/rsh/step/#p_8",
    "pt": "Steps",
    "t": 3,
    "c": "An integer, denoting an amount of network tokens; or,"
  },
  {
    "objectID": "/rsh/step/#p_9",
    "pt": "Steps",
    "t": 3,
    "c": "A tuple of token amounts."
  },
  {
    "objectID": "/rsh/step/#p_10",
    "pt": "Steps",
    "t": 3,
    "c": "A token amount is either:"
  },
  {
    "objectID": "/rsh/step/#p_11",
    "pt": "Steps",
    "t": 3,
    "c": "An integer, denoting an amount of network tokens; or,"
  },
  {
    "objectID": "/rsh/step/#p_12",
    "pt": "Steps",
    "t": 3,
    "c": "A tuple with two elements, where the first is an integer, denoting an amount of non-network tokens, and the second is {!rsh} Token, specifying a particular non-network token."
  },
  {
    "objectID": "/rsh/step/#p_13",
    "pt": "Steps",
    "t": 3,
    "c": "For example, these are all pay amounts:"
  },
  {
    "objectID": "/rsh/step/#p_14",
    "pt": "Steps",
    "t": 3,
    "c": "It is invalid for a pay amount to specify an amount of tokens multiple times. For example, these are invalid pay amounts:"
  },
  {
    "objectID": "/rsh/step/#p_15",
    "pt": "Steps",
    "t": 3,
    "c": "The ordering of a pay amount is only significant when used within a fork statement or parallel reduce statement that specifies a {!rsh} paySpec. In this case, payments are expected to be a tuple where the first element is an integer pay amount, and the rest of the elements are token amount tuples. The ordering of the token amount elements should match the ordering in {!rsh} paySpec. For example,"
  },
  {
    "objectID": "/rsh/step/#p_16",
    "pt": "Steps",
    "t": 3,
    "c": "will indicate that {!rsh} fork payments should be of the format:"
  },
  {
    "objectID": "/rsh/step/#p_17",
    "pt": "Steps",
    "t": 3,
    "c": "Reach assumes that network tokens and non-network tokens behave identically, but often they do not; this article discusses the causes and consequences of this."
  },
  {
    "objectID": "/rsh/step/#p_18",
    "pt": "Steps",
    "t": 3,
    "c": "If you're unsure of what kind of consensus transfer to use, you may want to read the explanation of the differences in the Guide."
  },
  {
    "objectID": "/rsh/step/#p_19",
    "pt": "Steps",
    "t": 3,
    "c": "A consensus transfer is written"
  },
  {
    "objectID": "/rsh/step/#p_20",
    "pt": "Steps",
    "t": 3,
    "c": "where {!rsh} PART_EXPR is an expression that evaluates to a participant or race expression, {!rsh} ID_0 through {!rsh} ID_n are identifiers for {!rsh} PART's public local state, {!rsh} PAY_EXPR is a public expression that evaluates to a pay amount. {!rsh} PAY_REQUIRE_EXPR is an optional nullary function that can be used to make {!rsh} require claims about the PAY_EXPR. {!rsh} WHEN_EXPR is a public expression evaluating to a boolean and determines if the consensus transfer takes place, {!rsh} CHECK_BLOCK is a block that may contain {!rsh} checks about the published values. These checks are applied as assumptions and requirements. {!rsh} DELAY_EXPR is a public expression that depends on only consensus state and evaluates to a time argument, {!rsh} TIMEOUT_BLOCK is a timeout block, which will be executed after the {!rsh} DELAY_EXPR time argument passes without {!rsh} PART executing this consensus transfer."
  },
  {
    "objectID": "/rsh/step/#p_21",
    "pt": "Steps",
    "t": 3,
    "c": "All of the expressions within a consensus transfer are evaluated in a pure context, which may not alter the state of the application. The {!rsh} PAY_EXPR, {!rsh} WHEN_EXPR, and {!rsh} DELAY_EXPR expressions must refer only to the consensus state, including the new data published via the {!rsh} .publish component."
  },
  {
    "objectID": "/rsh/step/#p_22",
    "pt": "Steps",
    "t": 3,
    "c": "The continuation of a consensus transfer statement is a consensus step, which is finalized with a commit statement. The continuation of a timeout block is the same as the continuation of the function the timeout occurs within."
  },
  {
    "objectID": "/rsh/step/#p_23",
    "pt": "Steps",
    "t": 3,
    "c": "See the guide section on non-participation to understand when to use timeouts and how to use them most effectively."
  },
  {
    "objectID": "/rsh/step/#p_24",
    "pt": "Steps",
    "t": 3,
    "c": "The {!rsh} publish component exclusive-or the {!rsh} pay component may be omitted, if either there is no publication or no transfer of network tokens to accompany this consensus transfer. The {!rsh} when component may always be omitted, in which case it is assumed to be {!rsh} true. {!rsh} publish or {!rsh} pay must occur first, after which components may occur in any order. For example, the following are all valid:"
  },
  {
    "objectID": "/rsh/step/#p_25",
    "pt": "Steps",
    "t": 3,
    "c": "The {!rsh} timeout component must be included if {!rsh} when is not statically {!rsh} true. This ensures that your clients will eventually complete the program. If a consensus transfer is a guaranteed race between non-class participants and a participant class that may attempt to transfer (i.e. {!rsh} when is not statically {!rsh} false), then a {!rsh} timeout may be explicitly omitted by writing {!rsh} .timeout(false)."
  },
  {
    "objectID": "/rsh/step/#p_26",
    "pt": "Steps",
    "t": 3,
    "c": "{!rsh} .throwTimeout may be used in place of {!rsh} .timeout. It accepts a {!rsh} DELAY_EXPR and an {!rsh} EXPR, which will be thrown if a timeout should occur. If an {!rsh} EXPR is not provided, then {!rsh} null will be thrown. If a consensus transfer uses {!rsh} .throwTimeout, it must be within a try statement."
  },
  {
    "objectID": "/rsh/step/#p_27",
    "pt": "Steps",
    "t": 3,
    "c": "If a consensus transfer specifies a single participant, which has not yet been fixed in the application and is not a participant class, then this statement does so; therefore, after it the {!rsh} PART may be used as an address."
  },
  {
    "objectID": "/rsh/step/#p_28",
    "pt": "Steps",
    "t": 3,
    "c": "If a consensus transfer specificies a single participant class, then all members of that class will attempt to perform the transfer, but only one will succeed."
  },
  {
    "objectID": "/rsh/step/#p_29",
    "pt": "Steps",
    "t": 3,
    "c": "A consensus transfer binds the identifiers {!rsh} ID_0 through {!rsh} ID_n for all participants to the values included in the consensus transfer, overwriting any bindings that already exist for those identifiers. If an existing participant, not included in {!rsh} PART_EXPR, has previously bound one of these identifiers, then the program is not valid. In other words, the following program is not valid:"
  },
  {
    "objectID": "/rsh/step/#p_30",
    "pt": "Steps",
    "t": 3,
    "c": "because {!rsh} Claire is not included in the {!rsh} race. However, if we were to rename {!rsh} Claire's {!rsh} x into {!rsh} y, then it would be valid, because although {!rsh} Alice and {!rsh} Bob both bind {!rsh} x, they participate in the {!rsh} race, so it is allowed. In the tail of this program, {!rsh} x is bound to either {!rsh} 1 or {!rsh} 2, i.e., either {!rsh} Alice or {!rsh} Bob's value is overwritten. This overwriting applies even if {!rsh} Alice wins and {!rsh} Alice is a participant class, i.e., the value of {!rsh} x in the tail is guaranteed to be the single value that was agreed upon in the consensus."
  },
  {
    "objectID": "/rsh/step/#p_31",
    "pt": "Steps",
    "t": 3,
    "c": "If you're unsure of what kind of consensus transfer to use, you may want to read the explanation of the differences in the Guide."
  },
  {
    "objectID": "/rsh/step/#p_32",
    "pt": "Steps",
    "t": 3,
    "c": "A fork statement is written:"
  },
  {
    "objectID": "/rsh/step/#p_33",
    "pt": "Steps",
    "t": 3,
    "c": "where:"
  },
  {
    "objectID": "/rsh/step/#p_34",
    "pt": "Steps",
    "t": 3,
    "c": "{!rsh} TOKENS_EXPR is a syntactic tuple of {!rsh} Token identifiers, or a static ternary expression that evaluates to one;"
  },
  {
    "objectID": "/rsh/step/#p_35",
    "pt": "Steps",
    "t": 3,
    "c": "{!rsh} PART_EXPR is an expression that evaluates to a participant;"
  },
  {
    "objectID": "/rsh/step/#p_36",
    "pt": "Steps",
    "t": 3,
    "c": "(optional) {!rsh} CHECK_EXPR is a syntactic arrow expression that is evaluated in both the local step and consensus step. This block can be used to specify {!rsh} checks and declare variable bindings. If it is present, then {!rsh} PAY_EXPR must be included;"
  },
  {
    "objectID": "/rsh/step/#p_37",
    "pt": "Steps",
    "t": 3,
    "c": "{!rsh} PUBLISH_EXPR is a syntactic arrow expression that is evaluated in a local step for the specified participant and must evaluate to an object that may contain a msg field, which may be of any type, a when field, which must be a boolean, and a _local field, which may be of any type;"
  },
  {
    "objectID": "/rsh/step/#p_38",
    "pt": "Steps",
    "t": 3,
    "c": "(optional) {!rsh} PAY_EXPR is an expression that evaluates to a function parameterized over the msg value and returns a pay amount; if this component is left-out, it is synthesized to zero;"
  },
  {
    "objectID": "/rsh/step/#p_39",
    "pt": "Steps",
    "t": 3,
    "c": "(optional) {!rsh} PAY_REQUIRE_EXPR is a function parameterized over the msg value which is evaluated for effect in a consensus step; thus it may be used to add {!rsh} require constraints on the value used for payment. If this is absent, then it is synthesized to an empty function."
  },
  {
    "objectID": "/rsh/step/#p_40",
    "pt": "Steps",
    "t": 3,
    "c": "{!rsh} CONSENSUS_EXPR is a syntactic arrow expression parameterized over the msg and _local values which is evaluated in a consensus step;"
  },
  {
    "objectID": "/rsh/step/#p_41",
    "pt": "Steps",
    "t": 3,
    "c": "{!rsh} API_EXPR is an expression that evaluates to an API member function;"
  },
  {
    "objectID": "/rsh/step/#p_42",
    "pt": "Steps",
    "t": 3,
    "c": "(optional) {!rsh} API_ASSUME_EXPR is a function parameterized over the input to the API member function which is evaluated for effect in a local step; thus it may be used to add {!rsh} assume constraints on the values given by the API; if this is absent, then it is synthesized to an empty function; if it is present, then {!rsh} API_PAY_EXPR must be included;"
  },
  {
    "objectID": "/rsh/step/#p_43",
    "pt": "Steps",
    "t": 3,
    "c": "(optional) {!rsh} API_PAY_EXPR is a function parameterized over the input to the API member function which is evaluated to determine the pay amount, like {!rsh} PAY_EXPR;"
  },
  {
    "objectID": "/rsh/step/#p_44",
    "pt": "Steps",
    "t": 3,
    "c": "{!rsh} API_CONSENSUS_EXPR is a function parameterized over the input to the API member function and a function that returns a value to the API call; this function must be called;"
  },
  {
    "objectID": "/rsh/step/#p_45",
    "pt": "Steps",
    "t": 3,
    "c": "{!rsh} API_CHECKED_CONSENSUS_EXPR is a function parameterized over the input to the API member function. It must return either a pair of {!rsh} [ PAY_EXPR, CONSENSUS_RET_EXPR ] or {!rsh} [ CONSENSUS_RET_EXPR ], where {!rsh} CONSENSUS_RET_EXPR is a function parameterized over the function that returns a value to the API call. The parameter of {!rsh} CONSENSUS_RET_EXPR must be called. Any {!rsh} checks performed before the {!rsh} return statement will be applied in the local step, during payment, and the consensus step of the API call."
  },
  {
    "objectID": "/rsh/step/#p_46",
    "pt": "Steps",
    "t": 3,
    "c": "the {!rsh} timeout and {!rsh} throwTimeout parameter are as in an consensus transfer."
  },
  {
    "objectID": "/rsh/step/#p_47",
    "pt": "Steps",
    "t": 3,
    "c": "In the discussion of {!rsh} .api component, the phrase \"parameterized over the input\" means that if an API function has two arguments, such as {!rsh} Fun([UInt, UInt], Null), then the corresponding expression must receive two arguments. For example, the {!rsh} API_PAY_EXPR component would be a function that accepts two arguments, while the {!rsh} API_CONSENSUS_EXPR would be a function that acccepts three arguments---the two for the API and the function used to return a value. All API functions must rely only on consensus state and the function domain."
  },
  {
    "objectID": "/rsh/step/#p_48",
    "pt": "Steps",
    "t": 3,
    "c": "If the msg field is absent from the object returned from {!rsh} PUBLISH_EXPR, then it is treated as if it were {!rsh} null."
  },
  {
    "objectID": "/rsh/step/#p_49",
    "pt": "Steps",
    "t": 3,
    "c": "If the when field is absent from the object returned from {!rsh} PUBLISH_EXPR, then it is treated as if it were {!rsh} true."
  },
  {
    "objectID": "/rsh/step/#p_50",
    "pt": "Steps",
    "t": 3,
    "c": "If the _local field is absent from the object returned from {!rsh} PUBLISH_EXPR, then it is treated as if it were {!rsh} null."
  },
  {
    "objectID": "/rsh/step/#p_51",
    "pt": "Steps",
    "t": 3,
    "c": "If the {!rsh} PAY_EXPR is absent, then it is treated as if it were {!rsh} (_) => 0."
  },
  {
    "objectID": "/rsh/step/#p_52",
    "pt": "Steps",
    "t": 3,
    "c": "The {!rsh} TOKENS_EXPR and {!rsh} PAY_EXPR have the same restrictions as the {!rsh} .pay component of a consensus transfer: i.e., they must be pure and can only refer to consensus state."
  },
  {
    "objectID": "/rsh/step/#p_53",
    "pt": "Steps",
    "t": 3,
    "c": "The {!rsh} .case and {!rsh} .api components may be repeated many times."
  },
  {
    "objectID": "/rsh/step/#p_54",
    "pt": "Steps",
    "t": 3,
    "c": "The same participant may specify multiple cases. In this situation, the order of the cases is significant. That is, a subsequent case will only be evaluated if the prior case's when field is {!rsh} false."
  },
  {
    "objectID": "/rsh/step/#p_55",
    "pt": "Steps",
    "t": 3,
    "c": "If the participant specified by {!rsh} PART_EXPR is not already fixed (in the sense of {!rsh} Participant.set), then if it wins the {!rsh} race, it is fixed, provided it is not a participant class."
  },
  {
    "objectID": "/rsh/step/#p_56",
    "pt": "Steps",
    "t": 3,
    "c": "A fork statement is an abbreviation of a common {!rsh} race and {!rsh} switch pattern you could write yourself."
  },
  {
    "objectID": "/rsh/step/#p_57",
    "pt": "Steps",
    "t": 3,
    "c": "The idea is that each of the participants in the {!rsh} case components do an independent local step evaluation of a value they would like to {!rsh} publish and then all {!rsh} race to {!rsh} publish their value. The one that \"wins\" the {!rsh} race then determines not only the value (& {!rsh} pay expression), but also what consensus step code runs to consume the value."
  },
  {
    "objectID": "/rsh/step/#p_58",
    "pt": "Steps",
    "t": 3,
    "c": "The sample {!rsh} fork statement linked to the {!rsh} fork keyword is roughly equivalent to:"
  },
  {
    "objectID": "/rsh/step/#p_59",
    "pt": "Steps",
    "t": 3,
    "c": "This pattern is tedious to write and error-prone, so the {!rsh} fork statement abbreviates it for Reach programmers. When a participant specifies multiple cases, the msg field of the participant will be wrapped with an additional variant signifying what case was chosen."
  },
  {
    "objectID": "/rsh/step/#p_60",
    "pt": "Steps",
    "t": 3,
    "c": "A wait statement, written {!rsh} wait(TIME);, delays the computation until the {!rsh} TIME time argument passes. {!rsh} TIME must be pure and may only reference values known by the consensus state."
  },
  {
    "objectID": "/rsh/step/#p_61",
    "pt": "Steps",
    "t": 3,
    "c": "In this example, {!rsh} wait is used so Bob doesn't have an advantage over Alice by making two separate {!rsh} publish statements at the same time. {!rsh} wait ensures that Alice has enough time to verify that Bob accepted the {!rsh} wager before beginning a {!rsh} race."
  },
  {
    "objectID": "/rsh/step/#p_62",
    "pt": "Steps",
    "t": 3,
    "c": "Learn more about the {!rsh} race expression in the guide, Racing non-determinism in decentralized applications."
  },
  {
    "objectID": "/rsh/step/#p_63",
    "pt": "Steps",
    "t": 3,
    "c": "{!rsh} wait does not execute on chain, instead, it constrains the next action that may occur on chain. Thus, {!rsh} wait may only occur in a step."
  },
  {
    "objectID": "/rsh/step/#p_64",
    "pt": "Steps",
    "t": 3,
    "c": "An exit statement, written {!rsh} exit();, halts the computation. It is a terminator statement, so it must have an empty tail. It may only occur in a step."
  },
  {
    "objectID": "/rsh/step/#p_65",
    "pt": "Steps",
    "t": 3,
    "c": "Any expressions valid for a computation are valid for a step. However, some additional expressions are allowed."
  },
  {
    "objectID": "/rsh/step/#p_66",
    "pt": "Steps",
    "t": 3,
    "c": "If you're unsure of what kind of consensus transfer to use, you may want to read the explanation of the differences in the Guide."
  },
  {
    "objectID": "/rsh/step/#p_67",
    "pt": "Steps",
    "t": 3,
    "c": "A race expression, written {!rsh} race(PARTICIPANT_0, ..., PARTICIPANT_n);, constructs a participant that may be used in a consensus transfer statement, such as {!rsh} publish or {!rsh} pay, where the various participants race to be the first one to perform the consensus transfer."
  },
  {
    "objectID": "/rsh/step/#p_68",
    "pt": "Steps",
    "t": 3,
    "c": "Reach provides a shorthand, {!rsh} Anybody, which serves as a {!rsh} race between all the participants."
  },
  {
    "objectID": "/rsh/step/#p_69",
    "pt": "Steps",
    "t": 3,
    "c": "See the guide section on races to understand the benefits and dangers of using {!rsh} race."
  },
  {
    "objectID": "/rsh/step/#p_70",
    "pt": "Steps",
    "t": 3,
    "c": "In this example, Bob and Alice are doing a race and whoever publishes first is the winner. Once the first publish is completed, the outcome is decided by checking if ALICE_WINS is true or false. If ALICE_WINS evaluates to true, Alice is declared the winner and the balance of the wager is then transferred to her."
  },
  {
    "objectID": "/rsh/step/#p_71",
    "pt": "Steps",
    "t": 3,
    "c": "A knowledge assertion that the participant {!rsh} Notter does not know the results of the variables {!rsh} var_0 through {!rsh} var_N, but that the participant {!rsh} Knower does know those values. It accepts an optional bytes argument, which is included in any reported violation."
  },
  {
    "objectID": "/rsh/step/#p_72",
    "pt": "Steps",
    "t": 3,
    "c": "This example from the Rock, Paper, Scissors! tutorial checks that both Alice's hand and salt are unknowable to ensure Bob cannot cheat."
  },
  {
    "objectID": "/rsh/step/#p_73",
    "pt": "Steps",
    "t": 3,
    "c": "Has participant {!rsh} Anybody make a publication, then transfer the {!rsh} balance() and the non-network pay amount to {!rsh} Who and end the DApp after executing the function {!rsh} after in a step."
  },
  {
    "objectID": "/rsh/step/#p_74",
    "pt": "Steps",
    "t": 3,
    "c": "As an example, codifying the prose above would look like:"
  },
  {
    "objectID": "/rsh/step/#p_75",
    "pt": "Steps",
    "t": 3,
    "c": "By comparing this example to {!rsh} closeTo, you can see that using this Reach standard library function helps save thinking, as well as additional lines of code, reducing the chances of introducing new errors."
  },
  {
    "objectID": "/rsh/step/#p_76",
    "pt": "Steps",
    "t": 3,
    "c": "The {!rsh} nonNetPayAmt parameter should be a pay amount. For example, when closing a program that uses a {!rsh} Token {!rsh} token, the argument would be {!rsh} [ [balance(tok), tok] ]."
  },
  {
    "objectID": "/rsh/step/#p_77",
    "pt": "Steps",
    "t": 3,
    "c": "The {!rsh} after and {!rsh} nonNetPayAmt arguments are optional."
  },
  {
    "objectID": "/rsh/step/#p_78",
    "pt": "Steps",
    "t": 3,
    "c": "A call is written:"
  },
  {
    "objectID": "/rsh/step/#p_79",
    "pt": "Steps",
    "t": 3,
    "c": "where:"
  },
  {
    "objectID": "/rsh/step/#p_80",
    "pt": "Steps",
    "t": 3,
    "c": "DOMAIN is the domain of the API member function."
  },
  {
    "objectID": "/rsh/step/#p_81",
    "pt": "Steps",
    "t": 3,
    "c": "RET_FUN is a function that returns a value to the API call. This function must be called."
  },
  {
    "objectID": "/rsh/step/#p_82",
    "pt": "Steps",
    "t": 3,
    "c": "API_EXPR is an expression that evaluates to an API member function."
  },
  {
    "objectID": "/rsh/step/#p_83",
    "pt": "Steps",
    "t": 3,
    "c": "API_CHECK_EXPR is a function parameterized over the domain of the API function. This function can be used to add {!rsh} checks involving the domain. These checks will be applied as assumptions and requirements."
  },
  {
    "objectID": "/rsh/step/#p_84",
    "pt": "Steps",
    "t": 3,
    "c": "API_PAY_EXPR and API_ASSUME_EXPR are like the corresponding parts in a {!rsh} fork statement, and {!rsh} call.throwTimeout is like in {!rsh} fork.throwTimeout. They are optional."
  },
  {
    "objectID": "/rsh/step/#p_85",
    "pt": "Steps",
    "t": 3,
    "c": "{!rsh} call will call the given API member function, returning a pair, {!rsh} [DOMAIN, RET_FUN]. {!rsh} call will publish the domain of the API member function, transferring the program from a step to consensus step."
  },
  {
    "objectID": "/tut/erc20/#erc20",
    "pt": "ERC20",
    "t": 2,
    "c": "ERC20"
  },
  {
    "objectID": "/tut/erc20/#the-erc20-standard",
    "pt": "ERC20",
    "t": 2,
    "c": "The ERC20 Standard"
  },
  {
    "objectID": "/tut/erc20/#the-erc20-standard-in-reach",
    "pt": "ERC20",
    "t": 2,
    "c": "The ERC20 Standard in Reach"
  },
  {
    "objectID": "/tut/erc20/#the-core-of-an-erc20-in-reach",
    "pt": "ERC20",
    "t": 2,
    "c": "The Core of an ERC20 in Reach"
  },
  {
    "objectID": "/tut/erc20/#an-erc20-testing-frontend",
    "pt": "ERC20",
    "t": 2,
    "c": "An ERC20 Testing Frontend"
  },
  {
    "objectID": "/tut/erc20/#the-erc20-apis-in-reach",
    "pt": "ERC20",
    "t": 2,
    "c": "The ERC20 APIs in Reach"
  },
  {
    "objectID": "/tut/erc20/#the-rest-of-the-erc20-test-suite",
    "pt": "ERC20",
    "t": 2,
    "c": "The Rest of the ERC20 Test Suite"
  },
  {
    "objectID": "/tut/erc20/#running-the-erc20-test-suite",
    "pt": "ERC20",
    "t": 2,
    "c": "Running the ERC20 Test Suite"
  },
  {
    "objectID": "/tut/erc20/#p_0",
    "pt": "ERC20",
    "t": 3,
    "c": "This tutorial will demonstrate the ERC20 spec in Reach."
  },
  {
    "objectID": "/tut/erc20/#p_1",
    "pt": "ERC20",
    "t": 3,
    "c": "It assumes prior knowledge of Reach: we recommend completing the Rock, Paper, Scissors tutorial and the RSVP tutorial first."
  },
  {
    "objectID": "/tut/erc20/#p_2",
    "pt": "ERC20",
    "t": 3,
    "c": "We assume you are working in a project folder called erc20:"
  },
  {
    "objectID": "/tut/erc20/#p_3",
    "pt": "ERC20",
    "t": 3,
    "c": "Start by creating your files:"
  },
  {
    "objectID": "/tut/erc20/#p_4",
    "pt": "ERC20",
    "t": 3,
    "c": "Our application is going to implement the ERC20 token spec and allow these functions to be called indefinitely. We'll implement the standard ERC20 functions, views and events."
  },
  {
    "objectID": "/tut/erc20/#p_5",
    "pt": "ERC20",
    "t": 3,
    "c": "The functions are:"
  },
  {
    "objectID": "/tut/erc20/#p_6",
    "pt": "ERC20",
    "t": 3,
    "c": "And the events are:"
  },
  {
    "objectID": "/tut/erc20/#p_7",
    "pt": "ERC20",
    "t": 3,
    "c": "Transfer(from: address, to: address, value: uint256) which MUST trigger when tokens are transferred, including zero value transfers."
  },
  {
    "objectID": "/tut/erc20/#p_8",
    "pt": "ERC20",
    "t": 3,
    "c": "Approval(owner: address, spender: address, value: uint256) which MUST trigger on any successful call to approve(spender, amount)."
  },
  {
    "objectID": "/tut/erc20/#p_9",
    "pt": "ERC20",
    "t": 3,
    "c": "We can encode all of this in Reach in the following way:"
  },
  {
    "objectID": "/tut/erc20/#p_10",
    "pt": "ERC20",
    "t": 3,
    "c": "The program will first accept the token metadata and parameters and then allow our {!rsh} API member functions to be called indefinitely. This means we'll use the mighty {!rsh} parallelReduce with special considerations."
  },
  {
    "objectID": "/tut/erc20/#p_11",
    "pt": "ERC20",
    "t": 3,
    "c": "Let's define our users."
  },
  {
    "objectID": "/tut/erc20/#p_12",
    "pt": "ERC20",
    "t": 3,
    "c": "The application starts with the Deployer providing the token metadata and deploying the contract with the first {!rsh} publish. So, we add some token data definitions to our {!rsh} Participant."
  },
  {
    "objectID": "/tut/erc20/#p_13",
    "pt": "ERC20",
    "t": 3,
    "c": "This structure will allow a single address to bind to D and allow A functions to be called by other contracts or off-chain by frontends representing any number of different users."
  },
  {
    "objectID": "/tut/erc20/#p_14",
    "pt": "ERC20",
    "t": 3,
    "c": "Line 6 declares the token metadata as an {!rsh} Object with specified fields. (Click on {!rsh} StringDyn if you've never seen it before!)"
  },
  {
    "objectID": "/tut/erc20/#p_15",
    "pt": "ERC20",
    "t": 3,
    "c": "Line 13 defines a launched function to notify the frontend of contract deployment. This is a good practice when building this style of Reach DApp. When done correctly, it prevents frontend interaction that relies on a deployed contract before it is complete."
  },
  {
    "objectID": "/tut/erc20/#p_16",
    "pt": "ERC20",
    "t": 3,
    "c": "Line 15 declares an {!rsh} API."
  },
  {
    "objectID": "/tut/erc20/#p_17",
    "pt": "ERC20",
    "t": 3,
    "c": "Lines 16-18 declare the functions our {!rsh} API members are allowed to call. These are the functions defined by the ERC20 spec."
  },
  {
    "objectID": "/tut/erc20/#p_18",
    "pt": "ERC20",
    "t": 3,
    "c": "Line 20 declares a {!rsh} View that makes the information more easily accessible to the frontend."
  },
  {
    "objectID": "/tut/erc20/#p_19",
    "pt": "ERC20",
    "t": 3,
    "c": "Lines 21-26 sets the information we make available to our {!rsh} View."
  },
  {
    "objectID": "/tut/erc20/#p_20",
    "pt": "ERC20",
    "t": 3,
    "c": "Line 28 declares an {!rsh} Event that will allow monitoring of our Reach program."
  },
  {
    "objectID": "/tut/erc20/#p_21",
    "pt": "ERC20",
    "t": 3,
    "c": "Line 29-30 declares the two events that we will emit and their values."
  },
  {
    "objectID": "/tut/erc20/#p_22",
    "pt": "ERC20",
    "t": 3,
    "c": "The transferFrom method allows contracts to transfer tokens on your behalf and/or to charge fees in sub-currencies. Source"
  },
  {
    "objectID": "/tut/erc20/#p_23",
    "pt": "ERC20",
    "t": 3,
    "c": "That is all for our data definitions, so we start defining the states of our program."
  },
  {
    "objectID": "/tut/erc20/#p_24",
    "pt": "ERC20",
    "t": 3,
    "c": "As noted earlier, the first step is to have the Deployer provide the token metadata and actually deploy the contract with the first publish."
  },
  {
    "objectID": "/tut/erc20/#p_25",
    "pt": "ERC20",
    "t": 3,
    "c": "Then, the Deployer notifies the frontend that the contract is deployed. {!rsh} getContract() will return the contract value, it cannot be called until after the first {!rsh} publish."
  },
  {
    "objectID": "/tut/erc20/#p_26",
    "pt": "ERC20",
    "t": 3,
    "c": "Now, we can set the {!rsh} Views related to our token metadata."
  },
  {
    "objectID": "/tut/erc20/#p_27",
    "pt": "ERC20",
    "t": 3,
    "c": "This information is already available, because we published it to the blockchain, but it is accessible with some difficulty."
  },
  {
    "objectID": "/tut/erc20/#p_28",
    "pt": "ERC20",
    "t": 3,
    "c": "{!rsh} Views make this as simple as defining a function to provide the information to the frontend."
  },
  {
    "objectID": "/tut/erc20/#p_29",
    "pt": "ERC20",
    "t": 3,
    "c": "Next, we'll create the {!rsh} Maps that hold balances and allowances for transfer."
  },
  {
    "objectID": "/tut/erc20/#p_30",
    "pt": "ERC20",
    "t": 3,
    "c": "The balances map will be our database of ownership, so we set the balance map for the deployer to the totalSupply."
  },
  {
    "objectID": "/tut/erc20/#p_31",
    "pt": "ERC20",
    "t": 3,
    "c": "The allowances map will hold the allowed amount of tokens to be transferred by an address."
  },
  {
    "objectID": "/tut/erc20/#p_32",
    "pt": "ERC20",
    "t": 3,
    "c": "Next, we'll emit the event for Transfer from the zero address."
  },
  {
    "objectID": "/tut/erc20/#p_33",
    "pt": "ERC20",
    "t": 3,
    "c": "Events emit at significant actions of the program, they allow monitoring of Reach program actions."
  },
  {
    "objectID": "/tut/erc20/#p_34",
    "pt": "ERC20",
    "t": 3,
    "c": "This event shows the token has been minted and given initial state."
  },
  {
    "objectID": "/tut/erc20/#p_35",
    "pt": "ERC20",
    "t": 3,
    "c": "Before we go any further in our Reach (rsh) file, let's jump into the frontend (mjs) file."
  },
  {
    "objectID": "/tut/erc20/#p_36",
    "pt": "ERC20",
    "t": 3,
    "c": "We'll start with necessary imports and ensure that we're running on an Ethereum-based network:"
  },
  {
    "objectID": "/tut/erc20/#p_37",
    "pt": "ERC20",
    "t": 3,
    "c": "Our frontend is primarily going to be a test suite, so we'll define some testing functions:"
  },
  {
    "objectID": "/tut/erc20/#p_38",
    "pt": "ERC20",
    "t": 3,
    "c": "Next, let's write some test functions. We, of course want, to test that they pass when we assume they will, but we also want to check our assumptions about when we expect them to fail."
  },
  {
    "objectID": "/tut/erc20/#p_39",
    "pt": "ERC20",
    "t": 3,
    "c": "Next we define a helper function to check that values are identical. We have a special case for numbers, because the {!js} === operation does not work on {!js} BigNumbers."
  },
  {
    "objectID": "/tut/erc20/#p_40",
    "pt": "ERC20",
    "t": 3,
    "c": "Now, we create the startMeUp function to handle deploying our contract and any errors we may encounter."
  },
  {
    "objectID": "/tut/erc20/#p_41",
    "pt": "ERC20",
    "t": 3,
    "c": "Then, we define the {!js} zeroAddress and create our test accounts:"
  },
  {
    "objectID": "/tut/erc20/#p_42",
    "pt": "ERC20",
    "t": 3,
    "c": "Now, we can setup our token metadata in an object to eventually be passed to the backend:"
  },
  {
    "objectID": "/tut/erc20/#p_43",
    "pt": "ERC20",
    "t": 3,
    "c": "Now, that we have our Deployer account and token data, we can deploy the contract and send this info to the backend. We'll use acc0 as the Deployer:"
  },
  {
    "objectID": "/tut/erc20/#p_44",
    "pt": "ERC20",
    "t": 3,
    "c": "We have all of our users created now and the contract is deployed. Now, we can go back to our .rsh file."
  },
  {
    "objectID": "/tut/erc20/#p_45",
    "pt": "ERC20",
    "t": 3,
    "c": "The next thing we want to do is create the functionality for our {!rsh} APIs. Given that we have many users who need to do something, we will use a {!rsh} parallelReduce. {!rsh} parallelReduce is a powerful control structure, it will allow users to repeatedly call {!rsh} APIs in a looping construct. We could use a {!rsh} while loop with a {!rsh} fork, but {!rsh} parallelReduce is a more convenient way to write it."
  },
  {
    "objectID": "/tut/erc20/#p_46",
    "pt": "ERC20",
    "t": 3,
    "c": "The only values that need to be tracked in the program are the balances and allowances, so the {!rsh} parallelReduce does not track any values."
  },
  {
    "objectID": "/tut/erc20/#p_47",
    "pt": "ERC20",
    "t": 3,
    "c": "The {!rsh} define block of our {!rsh} parallelReduce will be used to define some helper functions."
  },
  {
    "objectID": "/tut/erc20/#p_48",
    "pt": "ERC20",
    "t": 3,
    "c": "First, a function to check the balance and set the related View."
  },
  {
    "objectID": "/tut/erc20/#p_49",
    "pt": "ERC20",
    "t": 3,
    "c": "Why do we use {!rsh} fromSome() here?"
  },
  {
    "objectID": "/tut/erc20/#p_50",
    "pt": "ERC20",
    "t": 3,
    "c": "The keys of a {!rsh} Map (i.e. balances and allowances) may not exist, so Reach returns an option type: {!rsh} Maybe which has two possibilities: {!rsh} Some (present) and {!rsh} None (not present). Reach provides the {!rsh} fromSome() function to easily consume these {!rsh} Maybe values, returning a default value in the {!rsh} None case."
  },
  {
    "objectID": "/tut/erc20/#p_51",
    "pt": "ERC20",
    "t": 3,
    "c": "Next, we also set the allowances of each account:"
  },
  {
    "objectID": "/tut/erc20/#p_52",
    "pt": "ERC20",
    "t": 3,
    "c": "Finally, we define a helper function for doing transfers, which emits the Transfer event, as required by the ERC20 spec."
  },
  {
    "objectID": "/tut/erc20/#p_53",
    "pt": "ERC20",
    "t": 3,
    "c": "After the {!rsh} .define block of the {!rsh} parallelReduce, we set up the invariant (the balance never changes from zero) and the termination condition (never):"
  },
  {
    "objectID": "/tut/erc20/#p_54",
    "pt": "ERC20",
    "t": 3,
    "c": "We can now define our {!rsh} API member functions."
  },
  {
    "objectID": "/tut/erc20/#p_55",
    "pt": "ERC20",
    "t": 3,
    "c": "The transfer is basic wrapper around the transfer_ function with a few checks:"
  },
  {
    "objectID": "/tut/erc20/#p_56",
    "pt": "ERC20",
    "t": 3,
    "c": "Next is the transferFrom function, which is like transfer but uses the allowances concept from the ERC20 standard:"
  },
  {
    "objectID": "/tut/erc20/#p_57",
    "pt": "ERC20",
    "t": 3,
    "c": "In this case, we emit the Approval event, because the allowances changed."
  },
  {
    "objectID": "/tut/erc20/#p_58",
    "pt": "ERC20",
    "t": 3,
    "c": "Finally, we have the approve function, which sets the allowances:"
  },
  {
    "objectID": "/tut/erc20/#p_59",
    "pt": "ERC20",
    "t": 3,
    "c": "This too emits an Approval event."
  },
  {
    "objectID": "/tut/erc20/#p_60",
    "pt": "ERC20",
    "t": 3,
    "c": "(The final few lines are outside of the {!rsh} parallelReduce and simply {!rsh} exit, which will never happen because the {!rsh} while condition is {!rsh} true."
  },
  {
    "objectID": "/tut/erc20/#p_61",
    "pt": "ERC20",
    "t": 3,
    "c": "We can jump back to our frontend and implement some tests for our new functions."
  },
  {
    "objectID": "/tut/erc20/#p_62",
    "pt": "ERC20",
    "t": 3,
    "c": "First, we define a function to verify assertions about the balances of our accounts:"
  },
  {
    "objectID": "/tut/erc20/#p_63",
    "pt": "ERC20",
    "t": 3,
    "c": "Next, we define a function to ensure that an event actually occurred:"
  },
  {
    "objectID": "/tut/erc20/#p_64",
    "pt": "ERC20",
    "t": 3,
    "c": "Finally, we define wrappers around each of the {!rsh} API calls, but wrap them in a few test assertions related to the events that we expect to be generated:"
  },
  {
    "objectID": "/tut/erc20/#p_65",
    "pt": "ERC20",
    "t": 3,
    "c": "Finally, we can add some tests our program! Each test is annotated with some explanation of what its purpose is:"
  },
  {
    "objectID": "/tut/erc20/#p_66",
    "pt": "ERC20",
    "t": 3,
    "c": "Now, we can run our application. Remember, this is only designed to work on the Ethereum network, so we'll run with:"
  },
  {
    "objectID": "/tut/erc20/#p_67",
    "pt": "ERC20",
    "t": 3,
    "c": "The output looks something like:"
  },
  {
    "objectID": "/tut/erc20/#p_68",
    "pt": "ERC20",
    "t": 3,
    "c": "Th-th-th-that's all, folks!"
  },
  {
    "objectID": "/tut/erc20/#p_69",
    "pt": "ERC20",
    "t": 3,
    "c": "Our test suite was 175 lines and our Reach application was 106 lines. Great job!"
  },
  {
    "objectID": "/tut/overview/#overview",
    "pt": "Overview",
    "t": 2,
    "c": "Overview"
  },
  {
    "objectID": "/tut/overview/#over-model",
    "pt": "Overview",
    "t": 2,
    "c": "Decentralized applications"
  },
  {
    "objectID": "/tut/overview/#over-minimal",
    "pt": "Overview",
    "t": 2,
    "c": "A minimal Reach program"
  },
  {
    "objectID": "/tut/overview/#over-compile",
    "pt": "Overview",
    "t": 2,
    "c": "Compile"
  },
  {
    "objectID": "/tut/overview/#over-verify",
    "pt": "Overview",
    "t": 2,
    "c": "Verify"
  },
  {
    "objectID": "/tut/overview/#over-interface",
    "pt": "Overview",
    "t": 2,
    "c": "Interface"
  },
  {
    "objectID": "/tut/overview/#over-execute",
    "pt": "Overview",
    "t": 2,
    "c": "Execute"
  },
  {
    "objectID": "/tut/overview/#over-react",
    "pt": "Overview",
    "t": 2,
    "c": "Web app"
  },
  {
    "objectID": "/tut/overview/#over-next",
    "pt": "Overview",
    "t": 2,
    "c": "Next steps"
  },
  {
    "objectID": "/tut/overview/#p_0",
    "pt": "Overview",
    "t": 3,
    "c": "This is an informal overview of Reach and the structure of a Reach program. The goal of this document is to give enough technical specifics to help you understand what Reach does, but it isn't intended as either a tutorial or a reference. When you're ready to really begin a project, you can start with one of those, or the workshop."
  },
  {
    "objectID": "/tut/overview/#p_1",
    "pt": "Overview",
    "t": 3,
    "c": "If you have experience with blockchain development using existing tools, we recommend reading this article and a comparison with other development platforms."
  },
  {
    "objectID": "/tut/overview/#p_2",
    "pt": "Overview",
    "t": 3,
    "c": "A recording of a live workshop that goes over this material is available on YouTube."
  },
  {
    "objectID": "/tut/overview/#p_3",
    "pt": "Overview",
    "t": 3,
    "c": "DApps are made of multiple agents interacting with each other through some backend consensus network, like Ethereum or Algorand. These agents act on behalf of principals that provide direction and authority through information. These principals might be humans or other autonomous agents or even committees and organizations with their own structure. The consensus network allows these agents to transfer and receive value in the form of network-specific tokens, like ETH or ALGO. The network also allows the creation of \"contracts\" that ensure that all agents follow the same rules as they take turns computing and publishing values and information. The details of these \"contracts\" are specific to each consensus network, but they are implicitly trusted by all agents and principals because their operation can be independently verified to match the previously agreed-upon rules."
  },
  {
    "objectID": "/tut/overview/#p_4",
    "pt": "Overview",
    "t": 3,
    "c": "A single Reach program incorporates all aspects of a DApp:"
  },
  {
    "objectID": "/tut/overview/#p_5",
    "pt": "Overview",
    "t": 3,
    "c": "Participant backends are the agents acting on behalf of the principals."
  },
  {
    "objectID": "/tut/overview/#p_6",
    "pt": "Overview",
    "t": 3,
    "c": "Frontends are the technical representation of the interface between the participants and the principals."
  },
  {
    "objectID": "/tut/overview/#p_7",
    "pt": "Overview",
    "t": 3,
    "c": "A contract enforces the rules of the program, including the order of operation."
  },
  {
    "objectID": "/tut/overview/#p_8",
    "pt": "Overview",
    "t": 3,
    "c": "In Reach, a programmer only needs to specify the actions of participants---what they do individually and what they do in unison. The Reach compiler automatically derives a contract for the consensus network via a connector that enforces these rules."
  },
  {
    "objectID": "/tut/overview/#p_9",
    "pt": "Overview",
    "t": 3,
    "c": "Let's look at a simple Reach program where two principals, Alice and Bob, interact. In this DApp, Alice has some information that Bob might want and she has an amount of network tokens in mind that she'd like to trade for it."
  },
  {
    "objectID": "/tut/overview/#p_10",
    "pt": "Overview",
    "t": 3,
    "c": "You can look at the entire example program by visiting overview/index.rsh."
  },
  {
    "objectID": "/tut/overview/#p_11",
    "pt": "Overview",
    "t": 3,
    "c": "Get language support for Reach in your editor by visiting the guide on editor support."
  },
  {
    "objectID": "/tut/overview/#p_12",
    "pt": "Overview",
    "t": 3,
    "c": "The main part of the program looks like this:"
  },
  {
    "objectID": "/tut/overview/#p_13",
    "pt": "Overview",
    "t": 3,
    "c": "Line 1 specifies that this is a Reach program."
  },
  {
    "objectID": "/tut/overview/#p_14",
    "pt": "Overview",
    "t": 3,
    "c": "Line 2 specifies that this program will be compiled with strict mode, which enables unused variable checks."
  },
  {
    "objectID": "/tut/overview/#p_15",
    "pt": "Overview",
    "t": 3,
    "c": "Line 4 defines the main export from this program. main is the default used by Reach."
  },
  {
    "objectID": "/tut/overview/#p_16",
    "pt": "Overview",
    "t": 3,
    "c": "Line 4 also specifies that it is an application."
  },
  {
    "objectID": "/tut/overview/#p_17",
    "pt": "Overview",
    "t": 3,
    "c": "Line 5 specifies that the program identifier {!rsh} A will represent the Alice participant."
  },
  {
    "objectID": "/tut/overview/#p_18",
    "pt": "Overview",
    "t": 3,
    "c": "Lines 6 and 7 specify the interface between Alice's participant and frontend. In this case, Alice's frontend must provide a number called request and a string called info."
  },
  {
    "objectID": "/tut/overview/#p_19",
    "pt": "Overview",
    "t": 3,
    "c": "Line 9 specifies that the program identifier {!rsh} B will represent the Bob participant."
  },
  {
    "objectID": "/tut/overview/#p_20",
    "pt": "Overview",
    "t": 3,
    "c": "Lines 10 and 11 specify the interface for Bob, which includes a function named want, that takes a number and returns {!rsh} null, as well as a function named got, that receives the information."
  },
  {
    "objectID": "/tut/overview/#p_21",
    "pt": "Overview",
    "t": 3,
    "c": "Finally, line 13, deploys the DApp."
  },
  {
    "objectID": "/tut/overview/#p_22",
    "pt": "Overview",
    "t": 3,
    "c": "The elided lines, 14 through 34, contain the body of the application, which we can divide into four parts."
  },
  {
    "objectID": "/tut/overview/#p_23",
    "pt": "Overview",
    "t": 3,
    "c": "Lines 15 and 16 specify that Alice takes a local step where she declassifies the amount of tokens requested. In Reach, all values from the frontend are secret until explicitly made public with declassify."
  },
  {
    "objectID": "/tut/overview/#p_24",
    "pt": "Overview",
    "t": 3,
    "c": "Line 17 has Alice join the application by publishing that value, and the logic of the program transitions to specifying what the contract does."
  },
  {
    "objectID": "/tut/overview/#p_25",
    "pt": "Overview",
    "t": 3,
    "c": "Line 18 has the contract commit to these values and continue the rest of the program."
  },
  {
    "objectID": "/tut/overview/#p_26",
    "pt": "Overview",
    "t": 3,
    "c": "At this point, Bob's backend has learned the value of {!rsh} request and can deliver it to Bob's frontend for his approval. This happens next."
  },
  {
    "objectID": "/tut/overview/#p_27",
    "pt": "Overview",
    "t": 3,
    "c": "Lines 20 and 21 have Bob perform that delivery. {!rsh} interact.want doesn't explicitly return a boolean because the frontend cannot return if Bob doesn't want to continue. A better version of this program might return {!rsh} false and have that communicated to Alice."
  },
  {
    "objectID": "/tut/overview/#p_28",
    "pt": "Overview",
    "t": 3,
    "c": "Lines 22 and 23 have Bob join the application and submit a payment matching the appropriate amount, and then the contract commits."
  },
  {
    "objectID": "/tut/overview/#p_29",
    "pt": "Overview",
    "t": 3,
    "c": "It's now Alice's turn again:"
  },
  {
    "objectID": "/tut/overview/#p_30",
    "pt": "Overview",
    "t": 3,
    "c": "Lines 25 and 26 specify that Alice declassifies the information."
  },
  {
    "objectID": "/tut/overview/#p_31",
    "pt": "Overview",
    "t": 3,
    "c": "Line 27 has her publish it."
  },
  {
    "objectID": "/tut/overview/#p_32",
    "pt": "Overview",
    "t": 3,
    "c": "Line 28 has the contract transfer the requested amount to her."
  },
  {
    "objectID": "/tut/overview/#p_33",
    "pt": "Overview",
    "t": 3,
    "c": "Line 29 commits the transactions on the consensus network."
  },
  {
    "objectID": "/tut/overview/#p_34",
    "pt": "Overview",
    "t": 3,
    "c": "The only thing left is for Bob's backend to deliver the information to his frontend."
  },
  {
    "objectID": "/tut/overview/#p_35",
    "pt": "Overview",
    "t": 3,
    "c": "Line 31 and 32 use an interaction expression to transfer the information to the frontend."
  },
  {
    "objectID": "/tut/overview/#p_36",
    "pt": "Overview",
    "t": 3,
    "c": "Line 33 exits the program."
  },
  {
    "objectID": "/tut/overview/#p_37",
    "pt": "Overview",
    "t": 3,
    "c": "Reach programmers don't need to think about details like contract storage, protocol diagrams, state validation, or network details; instead, they can focus exclusively on the business logic of their application."
  },
  {
    "objectID": "/tut/overview/#p_38",
    "pt": "Overview",
    "t": 3,
    "c": "After a Reach programmer writes this application in a file like overview/index.rsh, they could run"
  },
  {
    "objectID": "/tut/overview/#p_39",
    "pt": "Overview",
    "t": 3,
    "c": "and the build directory will contain a new file named index.main.mjs, which contains a JavaScript implementation of a backend for each participant, as well as the Ethereum bytecode for the contract."
  },
  {
    "objectID": "/tut/overview/#p_40",
    "pt": "Overview",
    "t": 3,
    "c": "If you are curious, you can take a look at this file by going to overview/build/index.main.mjs. The Ethereum bytecode is not readable, but if you understand Solidity, you may want to look at overview/build/index.main.sol to see the original Solidity source that it is compiled from. Reach can leave files like these in place when run with --intermediate-files."
  },
  {
    "objectID": "/tut/overview/#p_41",
    "pt": "Overview",
    "t": 3,
    "c": "The command line snippets in this overview make no assumption about where Reach is installed on your machine. If Reach is installed in the directory you're working in, point to it with ./reach; if it is in a parent directory use ../reach; if you installed it into your {!cmd} PATH, just type reach. Learn more about installing Reach in the Tools documentation or in our Tutorial."
  },
  {
    "objectID": "/tut/overview/#p_42",
    "pt": "Overview",
    "t": 3,
    "c": "For this thirty line application, the Reach compiler generated hundreds of lines of JavaScript code in two functions, one for Alice and one for Bob. Separately, it generated hundreds more lines of Solidity code to implement the contract. If a programmer wasn't using Reach, they would have to write all this code in these three modules individually and keep them synchronized at every step of the development process."
  },
  {
    "objectID": "/tut/overview/#p_43",
    "pt": "Overview",
    "t": 3,
    "c": "Moreover, Reach doesn't only work for Ethereum: it is blockchain agnostic and can be easily configured to use a different connector to target a different consensus network, like Algorand. Nor is Reach tied to JavaScript: it can be configured to target other backend languages, like Go, Python, and C#."
  },
  {
    "objectID": "/tut/overview/#p_44",
    "pt": "Overview",
    "t": 3,
    "c": "Reach doesn't just compile your program: it also verifies it and ensures that entire categories of errors don't occur. For example, it always guarantees that the balance in the contract at the end of the program is zero. This is important because if it were not true, then tokens would be locked away by the contract and inaccessible."
  },
  {
    "objectID": "/tut/overview/#p_45",
    "pt": "Overview",
    "t": 3,
    "c": "For this example program, it is obvious that when a single transfer of {!rsh} request goes in at line 22 and a single transfer of {!rsh} request goes out at line 28, then the balance is zero at the end of the program. We could make a small tweak, however, to demonstrate things going wrong."
  },
  {
    "objectID": "/tut/overview/#p_46",
    "pt": "Overview",
    "t": 3,
    "c": "Let's change the third step to leave a single unit in the balance:"
  },
  {
    "objectID": "/tut/overview/#p_47",
    "pt": "Overview",
    "t": 3,
    "c": "And then run the compiler:"
  },
  {
    "objectID": "/tut/overview/#p_48",
    "pt": "Overview",
    "t": 3,
    "c": "It will print out a detailed error message showing the violation."
  },
  {
    "objectID": "/tut/overview/#p_49",
    "pt": "Overview",
    "t": 3,
    "c": "Verification failures include a lot of information, such as a concrete counter-example showing values that could have been provided by frontends that would lead to the property failing to hold. In this case, it reports that if Alice were to pass an {!rsh} interact.request over {!rsh} 1 at the start of the program on line 5, then the balance of the contract would not be provably {!rsh} 0 at the end of the program."
  },
  {
    "objectID": "/tut/overview/#p_50",
    "pt": "Overview",
    "t": 3,
    "c": "Reach programmers don't need to worry about entire categories of errors because the compiler automatically checks their code and ensures that those errors aren't present. Of course, there's a lot more to say about the details of automatic verification; indeed, it is one of the most powerful features of Reach, but we'll leave it at that for now."
  },
  {
    "objectID": "/tut/overview/#p_51",
    "pt": "Overview",
    "t": 3,
    "c": "The backend produced by the Reach compiler isn't an application on its own. In particular, each participant needs a frontend to interact with. In a real deployment, this interfacing code would be tied to a GUI, like a Web or smartphone app. Let's look at a simple command-line version that demonstrates how it would work for testing on a private devnet."
  },
  {
    "objectID": "/tut/overview/#p_52",
    "pt": "Overview",
    "t": 3,
    "c": "You can look at the entire example interface program by visiting overview/index.mjs."
  },
  {
    "objectID": "/tut/overview/#p_53",
    "pt": "Overview",
    "t": 3,
    "c": "The program is just a few dozen lines long and the shell of it is quite simple:"
  },
  {
    "objectID": "/tut/overview/#p_54",
    "pt": "Overview",
    "t": 3,
    "c": "Lines 1 and 2 import the Reach standard library loader and the compiled app backend."
  },
  {
    "objectID": "/tut/overview/#p_55",
    "pt": "Overview",
    "t": 3,
    "c": "Line 4 dynamically loads the appropriate network-specific Reach standard library, based on the REACH_CONNECTOR_MODE environment variable. All of Reach's network-specific standard libraries adhere to a common interface allowing you to write programs that are network-agnostic."
  },
  {
    "objectID": "/tut/overview/#p_56",
    "pt": "Overview",
    "t": 3,
    "c": "Lines 6 and 7 initialize new test accounts for Alice and Bob."
  },
  {
    "objectID": "/tut/overview/#p_57",
    "pt": "Overview",
    "t": 3,
    "c": "Line 9 has Alice deploy the contract on the consensus network."
  },
  {
    "objectID": "/tut/overview/#p_58",
    "pt": "Overview",
    "t": 3,
    "c": "Line 10 has Bob attach to the contract. The value {!js} ctcAlice contains no secret information and could easily be printed out and shared with Bob outside of the consensus network."
  },
  {
    "objectID": "/tut/overview/#p_59",
    "pt": "Overview",
    "t": 3,
    "c": "Lines 12 through 21 launch the backends and wait for their completion. We'll look at the details in a moment."
  },
  {
    "objectID": "/tut/overview/#p_60",
    "pt": "Overview",
    "t": 3,
    "c": "This code, similar for all test programs, demonstrates how straightforward it is to scaffold a Reach application for testing."
  },
  {
    "objectID": "/tut/overview/#p_61",
    "pt": "Overview",
    "t": 3,
    "c": "Let's look at initializing and interfacing each participant, starting with Alice."
  },
  {
    "objectID": "/tut/overview/#p_62",
    "pt": "Overview",
    "t": 3,
    "c": "Line 13 uses the contract handle associated with Alice's account to run the Alice participant backend, passing an object which holds the interact functions."
  },
  {
    "objectID": "/tut/overview/#p_63",
    "pt": "Overview",
    "t": 3,
    "c": "Line 14 provides the {!rsh} request value."
  },
  {
    "objectID": "/tut/overview/#p_64",
    "pt": "Overview",
    "t": 3,
    "c": "Line 15 provides the {!rsh} info value."
  },
  {
    "objectID": "/tut/overview/#p_65",
    "pt": "Overview",
    "t": 3,
    "c": "Let's look at Bob next."
  },
  {
    "objectID": "/tut/overview/#p_66",
    "pt": "Overview",
    "t": 3,
    "c": "Line 17 initializes Bob just like Alice, although we use the {!js} p short-hand."
  },
  {
    "objectID": "/tut/overview/#p_67",
    "pt": "Overview",
    "t": 3,
    "c": "Line 18 provides his {!rsh} want function, which produces a log message and always accepts."
  },
  {
    "objectID": "/tut/overview/#p_68",
    "pt": "Overview",
    "t": 3,
    "c": "Line 19 provides his {!rsh} got function, which displays the secret on the console as well."
  },
  {
    "objectID": "/tut/overview/#p_69",
    "pt": "Overview",
    "t": 3,
    "c": "Reach completely abstracts all the details of the chosen consensus network from the programmer, except for those directly impinging on business decisions, like the amounts of currency transacted. Reach allows programmers to focus on the business logic of their application at every stage, from the core application to the interfacing elements."
  },
  {
    "objectID": "/tut/overview/#p_70",
    "pt": "Overview",
    "t": 3,
    "c": "It's now time to execute this test program and ensure that everything is working correctly. In this case, we've set up our application simply: there's one Reach file for the application and one JavaScript file for the interface. This is a common practice, so Reach comes with a simple wrapper script to build and execute such applications."
  },
  {
    "objectID": "/tut/overview/#p_71",
    "pt": "Overview",
    "t": 3,
    "c": "First, we connect Reach to a consensus network. We can connect to Ethereum's test environment by running:"
  },
  {
    "objectID": "/tut/overview/#p_72",
    "pt": "Overview",
    "t": 3,
    "c": "Then, we just run:"
  },
  {
    "objectID": "/tut/overview/#p_73",
    "pt": "Overview",
    "t": 3,
    "c": "And then Reach"
  },
  {
    "objectID": "/tut/overview/#p_74",
    "pt": "Overview",
    "t": 3,
    "c": "compiles overview/index.rsh;"
  },
  {
    "objectID": "/tut/overview/#p_75",
    "pt": "Overview",
    "t": 3,
    "c": "creates a temporary Node.js package;"
  },
  {
    "objectID": "/tut/overview/#p_76",
    "pt": "Overview",
    "t": 3,
    "c": "builds a Docker image based on Reach's standard image for the package; and,"
  },
  {
    "objectID": "/tut/overview/#p_77",
    "pt": "Overview",
    "t": 3,
    "c": "runs the application connected to the specified consensus network's devnet image."
  },
  {
    "objectID": "/tut/overview/#p_78",
    "pt": "Overview",
    "t": 3,
    "c": "On typical developer laptops, this entire process takes seconds and can be completely integrated into existing development IDEs, like VSCode, so Reach developers can compile, verify, build, launch, and test their Reach app with a single command."
  },
  {
    "objectID": "/tut/overview/#p_79",
    "pt": "Overview",
    "t": 3,
    "c": "Reach completely abstracts all the details of building and maintaining consensus network test environments and build scripts from the programmer, so they can focus exclusively on the business logic of their application. In fact, Reach works for multiple networks, so if we instead run"
  },
  {
    "objectID": "/tut/overview/#p_80",
    "pt": "Overview",
    "t": 3,
    "c": "then Reach will start up a private Algorand devnet and use the Algorand connector. The developer does not need to change anything about their program because Reach is entirely agnostic to the consensus network choice during deployment."
  },
  {
    "objectID": "/tut/overview/#p_81",
    "pt": "Overview",
    "t": 3,
    "c": "The previous section uses Node.js to perform a test run at the command line. However, most Reach developers deploy their DApps via a Web application, as we describe below."
  },
  {
    "objectID": "/tut/overview/#p_82",
    "pt": "Overview",
    "t": 3,
    "c": "A Web deployment uses the exact same index.rsh file connected, this time, to a React-based index.js file. (It also uses some simple React views and css to go with it.) Let's take a look at some snippets from the React index.js and compare with the Node.js index.mjs from before:"
  },
  {
    "objectID": "/tut/overview/#p_83",
    "pt": "Overview",
    "t": 3,
    "c": "At the top of the file, we import the Reach-generated backend as {!js} backend and we load the standard library as {!js} reach."
  },
  {
    "objectID": "/tut/overview/#p_84",
    "pt": "Overview",
    "t": 3,
    "c": "We hook into the App component's lifecycle event {!js} componentDidMount in order to fetch the user's account. {!js} getDefaultAccount automatically interacts with browser extensions, like MetaMask, to get the user's currently-selected account. Reach is able to deploy contracts and send transactions to the consensus network by prompting the user directly through the extension's API, without additional assistance from the React frontend. This is just like how in the Node.js deployment, the Reach programmer does not need to decode the details of the underlying consensus network's interaction API."
  },
  {
    "objectID": "/tut/overview/#p_85",
    "pt": "Overview",
    "t": 3,
    "c": "Our React component has a method called {!js} deploy that actually deploys the contract on the network, using the same calls as in the test deployment: on line 72 we call the {!js} acc.deploy function, and on line 74, we call the {!js} ctc.getInfo function; exactly as we did for the Node.js program."
  },
  {
    "objectID": "/tut/overview/#p_86",
    "pt": "Overview",
    "t": 3,
    "c": "Similarly, we implement a {!js} runBackend method that executes the Reach program as Alice using information gathered from the React UI."
  },
  {
    "objectID": "/tut/overview/#p_87",
    "pt": "Overview",
    "t": 3,
    "c": "We implement a similar method in the {!js} Bob component that runs the backend as Bob."
  },
  {
    "objectID": "/tut/overview/#p_88",
    "pt": "Overview",
    "t": 3,
    "c": "We specify Alice's and Bob's respective participant interact interfaces just as we would in Node.js. In the React program, we have the ability to leverage Bob's {!rsh} interact functions as callbacks that can update the React state in order to display to, or harvest information from, the React user interface."
  },
  {
    "objectID": "/tut/overview/#p_89",
    "pt": "Overview",
    "t": 3,
    "c": "You can install the @reachsh/stdlib JavaScript library into your React project, or for convenience, instead of setting up a React project, you can simply use the command"
  },
  {
    "objectID": "/tut/overview/#p_90",
    "pt": "Overview",
    "t": 3,
    "c": "This command runs your DApp with the React development server in a Docker container which has Reach and React JavaScript dependencies pre-installed, so it starts up much faster than building them yourself."
  },
  {
    "objectID": "/tut/overview/#p_91",
    "pt": "Overview",
    "t": 3,
    "c": "As before, you can use REACH_CONNECTOR_MODE to choose your desired connector."
  },
  {
    "objectID": "/tut/overview/#p_92",
    "pt": "Overview",
    "t": 3,
    "c": "In this overview, we've briefly described the structure and fundamental concepts of a Reach application. We've shown how to construct a simple program, compile it, connect an interface, test at the command-line, and deploy it using a React Web application. Since this is only a brief overview of what Reach can do, we left a lot out. But even so, it should be clear why Reach is the easiest and safest programming language for decentralized application development."
  },
  {
    "objectID": "/tut/overview/#p_93",
    "pt": "Overview",
    "t": 3,
    "c": "Furthermore, this example program has many flaws and should not be used in practice. For example, it provides no protection to Bob in the event that Alice fails to deliver the information, and makes no attempt to ensure that the information is what he wants. Reach allows you to abstract away the low-level details of your decentralized program and focus on these sorts of bigger picture issues. In the rest of the guide, we discuss design issues like this. For example,"
  },
  {
    "objectID": "/tut/overview/#p_94",
    "pt": "Overview",
    "t": 3,
    "c": "Effectively using automatic verification to check your application;"
  },
  {
    "objectID": "/tut/overview/#p_95",
    "pt": "Overview",
    "t": 3,
    "c": "Fortifying your application against non-participation;"
  },
  {
    "objectID": "/tut/overview/#p_96",
    "pt": "Overview",
    "t": 3,
    "c": "Building interaction abstractions for related applications."
  },
  {
    "objectID": "/tut/overview/#p_97",
    "pt": "Overview",
    "t": 3,
    "c": "However, unless you're ready to dive deep now, the next steps for you are to:"
  },
  {
    "objectID": "/tut/overview/#p_98",
    "pt": "Overview",
    "t": 3,
    "c": "Install Reach;"
  },
  {
    "objectID": "/tut/overview/#p_99",
    "pt": "Overview",
    "t": 3,
    "c": "Work through the tutorial;"
  },
  {
    "objectID": "/tut/overview/#p_100",
    "pt": "Overview",
    "t": 3,
    "c": "Join the Discord community."
  },
  {
    "objectID": "/tut/overview/#p_101",
    "pt": "Overview",
    "t": 3,
    "c": "Thanks for being part of Reach!"
  },
  {
    "objectID": "/tut/rps/#tut",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Rock, Paper, Scissors!"
  },
  {
    "objectID": "/tut/rps/#tut-1",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Install and Initialize"
  },
  {
    "objectID": "/tut/rps/#tut-2",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Scaffolding and Setup"
  },
  {
    "objectID": "/tut/rps/#tut-3",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Rock, Paper, and Scissors"
  },
  {
    "objectID": "/tut/rps/#tut-4",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Bets and Wagers"
  },
  {
    "objectID": "/tut/rps/#tut-5",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Trust and Commitments"
  },
  {
    "objectID": "/tut/rps/#tut-6",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Timeouts and Participation"
  },
  {
    "objectID": "/tut/rps/#tut-7",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Play and Play Again"
  },
  {
    "objectID": "/tut/rps/#tut-8",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Interaction and Independence"
  },
  {
    "objectID": "/tut/rps/#tut-9",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Web Interaction"
  },
  {
    "objectID": "/tut/rps/#tut-9-App",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Application component"
  },
  {
    "objectID": "/tut/rps/#tut-9-ConnectAccount",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Connect Account dialog"
  },
  {
    "objectID": "/tut/rps/#tut-9-FundAccount",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Fund Account dialog"
  },
  {
    "objectID": "/tut/rps/#tut-9-DeployerOrAttacher",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Choose Role"
  },
  {
    "objectID": "/tut/rps/#tut-9-Player",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Player component"
  },
  {
    "objectID": "/tut/rps/#tut-9-GetHand",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Get Hand dialog"
  },
  {
    "objectID": "/tut/rps/#tut-9-WaitingForResults",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Waiting for results display"
  },
  {
    "objectID": "/tut/rps/#tut-9-Done",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Done display"
  },
  {
    "objectID": "/tut/rps/#tut-9-Timeout",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Timeout display"
  },
  {
    "objectID": "/tut/rps/#tut-9-Deployer",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Deployer component"
  },
  {
    "objectID": "/tut/rps/#tut-9-SetWager",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Set Wager dialog"
  },
  {
    "objectID": "/tut/rps/#tut-9-Deploy",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Deploy dialog"
  },
  {
    "objectID": "/tut/rps/#tut-9-Deploying",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Deploying display"
  },
  {
    "objectID": "/tut/rps/#tut-9-WaitingForAttacher",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Waiting for Attacher display"
  },
  {
    "objectID": "/tut/rps/#tut-9-Attacher",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Attacher component"
  },
  {
    "objectID": "/tut/rps/#tut-9-Attach",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Attach dialog"
  },
  {
    "objectID": "/tut/rps/#tut-9-Attaching",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Attaching display"
  },
  {
    "objectID": "/tut/rps/#tut-9-AcceptTerms",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Accept Terms dialog"
  },
  {
    "objectID": "/tut/rps/#tut-9-WaitingForTurn",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Waiting for Turn display"
  },
  {
    "objectID": "/tut/rps/#tut-9-Final",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Putting it all together"
  },
  {
    "objectID": "/tut/rps/#tut-10",
    "pt": "Rock, Paper, Scissors!",
    "t": 2,
    "c": "Onward and Further"
  },
  {
    "objectID": "/tut/rps/#p_0",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "This tutorial walks through the creation of a simple decentralized application. It contains everything you need to know to build and test this application and assumes no prior experience with DApp/blockchain development of any kind. If you want a broad overview before diving in it, we recommend reading the overview first. On the other hand, if this is too simple, then you may want to start the workshop for larger and less constrained projects or the reference manual for the minute details of Reach."
  },
  {
    "objectID": "/tut/rps/#p_1",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If you're ready, click through to the first step!"
  },
  {
    "objectID": "/tut/rps/#p_2",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Reach is designed to work on POSIX systems with make, Docker, and Docker Compose installed. The best way to install Docker on Mac and Windows is with Docker Desktop."
  },
  {
    "objectID": "/tut/rps/#p_3",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "You probably already have make installed. For example, OS X and many other POSIX systems come with make, but some versions of Linux do not include it by default and will require you to install it. If you're on Ubuntu, you can run sudo apt install make to get it."
  },
  {
    "objectID": "/tut/rps/#p_4",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "You'll know that you have everything installed if you can run the following three commands without errors"
  },
  {
    "objectID": "/tut/rps/#p_5",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If you're using Windows, consult the guide to using Reach on Windows."
  },
  {
    "objectID": "/tut/rps/#p_6",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Once you've confirmed that they are installed, choose a directory for this project. We recommend"
  },
  {
    "objectID": "/tut/rps/#p_7",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next, download Reach by running"
  },
  {
    "objectID": "/tut/rps/#p_8",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "You'll know that the download worked if you can run"
  },
  {
    "objectID": "/tut/rps/#p_9",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The recommended next step, although optional, is to set up your environment with"
  },
  {
    "objectID": "/tut/rps/#p_10",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "This will make subsequent uses of the reach script more convenient by tuning its runtime behavior to your specific needs and only downloading the dependencies you'll actually use."
  },
  {
    "objectID": "/tut/rps/#p_11",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "{!cmd} reach config sets overridable defaults for all Reach projects on your development machine and not just the current one, so feel free to skip this step if you'd prefer not to make your choices global."
  },
  {
    "objectID": "/tut/rps/#p_12",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Since Reach is Dockerized, when you first use it, you'll need to download the images it uses. Fetch them by running"
  },
  {
    "objectID": "/tut/rps/#p_13",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "You'll know that everything is in order if you can run"
  },
  {
    "objectID": "/tut/rps/#p_14",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Get language support for Reach in your editor by visiting IDE/Text Editor Support."
  },
  {
    "objectID": "/tut/rps/#p_15",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Now that your Reach installation is in order, you should open a text editor and get ready to write your first Reach application!"
  },
  {
    "objectID": "/tut/rps/#p_16",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In this tutorial, we'll be building a version of Rock, Paper, Scissors! where two players, Alice and Bob, can wager on the result of the game. We'll start simple and slowly make the application more fully-featured."
  },
  {
    "objectID": "/tut/rps/#p_17",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "You should follow along by copying each part of the program and seeing how things go. If you're like us, you may find it beneficial to type each line out, rather than copying & pasting so you can start building your muscle memory and begin to get a sense for each part of a Reach program."
  },
  {
    "objectID": "/tut/rps/#p_18",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Let's start by creating a file named index.rsh. It doesn't matter where you put this file, but we recommend putting it in the current directory, which would be ~/reach/tut if you're following along exactly. In all the subsequent code samples, we'll label the files based on the chapter of the tutorial you're reading. For example, start off by typing the following into index.rsh:"
  },
  {
    "objectID": "/tut/rps/#p_19",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Did you notice that rps-1-setup/index.rsh was a link in the box above the code sample? You can always click on these links to see the entire file in our GitHub repository."
  },
  {
    "objectID": "/tut/rps/#p_20",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Did you notice the attractive copy icon on the top the right of that box? You can click on it and the content of the code box will be copied onto your clipboard."
  },
  {
    "objectID": "/tut/rps/#p_21",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Did your text editor recognize index.rsh as a Reach program and give you proper syntax highlighting? If not, check if there's a plugin available for your editor by visiting IDE/Text Editor Support or manually configure it to treat Reach (.rsh) files as JavaScript and things will be mostly correct."
  },
  {
    "objectID": "/tut/rps/#p_22",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "This is just a shell of a program that doesn't do much, but it has a few important components."
  },
  {
    "objectID": "/tut/rps/#p_23",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 1 indicates that this is a Reach program. You'll always have this at the top of every program."
  },
  {
    "objectID": "/tut/rps/#p_24",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 3 defines the main export from the program. When you compile, this is what the compiler will look at."
  },
  {
    "objectID": "/tut/rps/#p_25",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 4 through 9 specify the two participants to this application, Alice and Bob."
  },
  {
    "objectID": "/tut/rps/#p_26",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 10 marks the deployment of the Reach program, which allows the program to start doing things."
  },
  {
    "objectID": "/tut/rps/#p_27",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Before we go too much further, let's create a similar shell for our JavaScript frontend code. Open a new file named index.mjs and fill it with this:"
  },
  {
    "objectID": "/tut/rps/#p_28",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "This JavaScript code is similarly schematic and will be consistent across all of your test programs."
  },
  {
    "objectID": "/tut/rps/#p_29",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 1 imports the Reach standard library loader."
  },
  {
    "objectID": "/tut/rps/#p_30",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 2 imports your backend, which ./reach compile will produce."
  },
  {
    "objectID": "/tut/rps/#p_31",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 3 loads the standard library dynamically based on the REACH_CONNECTOR_MODE environment variable."
  },
  {
    "objectID": "/tut/rps/#p_32",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 5 defines a quantity of network tokens as the starting balance for each test account."
  },
  {
    "objectID": "/tut/rps/#p_33",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 6 and 7 create test accounts with initial endowments for Alice and Bob. This will only work on the Reach-provided developer testing network."
  },
  {
    "objectID": "/tut/rps/#p_34",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 9 has Alice deploy the application."
  },
  {
    "objectID": "/tut/rps/#p_35",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The program defined in rps-1-setup/index.rsh will only begin to run after it has been deployed via rps-1-setup/index.mjs."
  },
  {
    "objectID": "/tut/rps/#p_36",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 10 has Bob attach to it."
  },
  {
    "objectID": "/tut/rps/#p_37",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 13 through 15 initialize a backend for Alice."
  },
  {
    "objectID": "/tut/rps/#p_38",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 16 through 18 initialize a backend for Bob."
  },
  {
    "objectID": "/tut/rps/#p_39",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 12 waits for the backends to complete."
  },
  {
    "objectID": "/tut/rps/#p_40",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "This is now enough for Reach to compile and run our program. Let's try by running"
  },
  {
    "objectID": "/tut/rps/#p_41",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Reach should now build and launch a Docker container for this application. Since the application doesn't do anything, you'll just see a lot of diagnostic messages though, so that's not very exciting."
  },
  {
    "objectID": "/tut/rps/#p_42",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The entire process that we just went through can be automated by running"
  },
  {
    "objectID": "/tut/rps/#p_43",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "when you start your next project!"
  },
  {
    "objectID": "/tut/rps/#p_44",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In the next step, we'll implement the logic of Rock, Paper, Scissors! and our application will start doing something!"
  },
  {
    "objectID": "/tut/rps/#p_45",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "When you write a DApp using Reach, do you"
  },
  {
    "objectID": "/tut/rps/#p_46",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "write a smart contract in Solidity, a backend in JavaScript using the Ethereum SDK, and a frontend in JavaScript, then use Reach to test and deploy it;"
  },
  {
    "objectID": "/tut/rps/#p_47",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "write a program in Reach that generates a smart contract & a backend and a front-end in JavaScript, then use Reach to test and deploy it?"
  },
  {
    "objectID": "/tut/rps/#p_48",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "2; Reach abstracts away the details of the underlying consensus network"
  },
  {
    "objectID": "/tut/rps/#p_49",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In this section, we'll have Alice and Bob actually execute the game of Rock, Paper, Scissors!."
  },
  {
    "objectID": "/tut/rps/#p_50",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We have to decide how to represent the hands of the game. A simple way is to represent them as the numbers {!rsh} 0, {!rsh} 1, and {!rsh} 2, standing for Rock, Paper, and Scissors. However, Reach does not support unsigned integers of exactly two bits, so it is better to represent them as the equivalence class of integers modulo three, so we won't distinguish between {!rsh} 0 and {!rsh} 3 as Rock."
  },
  {
    "objectID": "/tut/rps/#p_51",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We'll use a similar strategy for representing the three outcomes of the game: B wins, Draw, and A wins."
  },
  {
    "objectID": "/tut/rps/#p_52",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The first step is to change the Reach program to specify that Alice and Bob's frontends can be interacted with to get the move that they will play, and later informed of the outcome of the game."
  },
  {
    "objectID": "/tut/rps/#p_53",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 3 through 6 define a participant interact interface that will be shared between the two players. In this case, it provides two methods: {!rsh} getHand, which returns a number; and {!rsh} seeOutcome, which receives a number."
  },
  {
    "objectID": "/tut/rps/#p_54",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 9 through 14 use this interface for both participants. Because of this line, {!rsh} interact in the rest of the program will be bound to an object with methods corresponding to these actions, which will connect to the frontend of the corresponding participant."
  },
  {
    "objectID": "/tut/rps/#p_55",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Before continuing with the Reach application, let's move over to the JavaScript interface and implement these methods in our frontend."
  },
  {
    "objectID": "/tut/rps/#p_56",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 12 and 13 define arrays to hold the meaning of the hands and outcomes."
  },
  {
    "objectID": "/tut/rps/#p_57",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 14 defines a constructor for the {!js} Player implementation."
  },
  {
    "objectID": "/tut/rps/#p_58",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 15 through 19 implement the {!js} getHand method."
  },
  {
    "objectID": "/tut/rps/#p_59",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 20 through 22 implement the {!js} seeOutcome method."
  },
  {
    "objectID": "/tut/rps/#p_60",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Finally, lines 27 and 30 instantiate the implementation once for Alice and once for Bob. These are the actual objects that will be bound to {!rsh} interact in the Reach program."
  },
  {
    "objectID": "/tut/rps/#p_61",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "There should be nothing interesting or controversial about these implementations; that's the point of Reach: we get to just write normal business logic without worrying about the details of the consensus network and decentralized application."
  },
  {
    "objectID": "/tut/rps/#p_62",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Let's return to the Reach program and look inside of the body of the program for what actions Alice and Bob take."
  },
  {
    "objectID": "/tut/rps/#p_63",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In a real-life game of Rock, Paper, Scissors!, Alice and Bob simultaneously decide what hand they will play and reveal it at the same time. \"Simultaneity\" is a complex concept that is hard to realize in practice. For example, if you've ever played against a little kid, you may notice them trying to see what you're going to choose and delaying until the last minute to show their hand so they will win. In a decentralized application, it is not possible to have simultaneity. Instead, we have to select a particular participant who will \"go first\". In this case, we'll choose Alice."
  },
  {
    "objectID": "/tut/rps/#p_64",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Does Alice go first, or do we call the player that goes first \"Alice\"? This might seem like an unnecessary distinction to make, but it is a very subtle point about the way that Reach works. In our frontend, we explicitly ran {!rsh} backend.Alice and {!rsh} backend.Bob. When we did that, we were committing that particular JavaScript thread to be either Alice or Bob. In our game, whoever chose to run the Alice backend is the one that will go first. In other words, Alice goes first. This will be more obvious at the end of the tutorial when we'll make the choice interactively about which role to play."
  },
  {
    "objectID": "/tut/rps/#p_65",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The game proceeds in three steps."
  },
  {
    "objectID": "/tut/rps/#p_66",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "First, the backend for Alice interacts with its frontend, gets Alice's hand, and publishes it."
  },
  {
    "objectID": "/tut/rps/#p_67",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 17 states that this block of code is something that only {!rsh} Alice performs."
  },
  {
    "objectID": "/tut/rps/#p_68",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "That means that the variable, {!rsh} handAlice, bound on line 18 is known only to Alice."
  },
  {
    "objectID": "/tut/rps/#p_69",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 18 binds that value to the result of interacting with Alice through the {!rsh} getHand method, which we wrote in JavaScript."
  },
  {
    "objectID": "/tut/rps/#p_70",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 18 also declassifies the value, because in Reach, all information from frontends is secret until it is explicitly made public."
  },
  {
    "objectID": "/tut/rps/#p_71",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 20 has Alice join the application by publishing the value to the consensus network, so it can be used to evaluate the outcome of the game. Once this happens, the code is in a \"consensus step\" where all participants act together."
  },
  {
    "objectID": "/tut/rps/#p_72",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 21 commits the state of the consensus network and returns to \"local step\" where individual participants can act alone."
  },
  {
    "objectID": "/tut/rps/#p_73",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The next step is similar, in that Bob publishes his hand; however, we don't immediately commit the state, instead we compute the outcome of the game."
  },
  {
    "objectID": "/tut/rps/#p_74",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 23 through 26 match Alice's similar local step and joining of the application through a consensus transfer publication."
  },
  {
    "objectID": "/tut/rps/#p_75",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "But, line 28 computes the outcome of the game before committing. ({!rsh} (handAlice + (4 - handBob)) % 3 is a clever equation to compute the winner of a game of Rock, Paper, Scissors! using modular arithmetic. Consider when {!rsh} handAlice is {!rsh} 0 (i.e., Rock) and {!rsh} handBob is {!rsh} 2 (i.e., Scissors), then this equation is {!rsh} ((handAlice + (4 - handBob)) % 3) = ((0 + (4 - 2)) % 3) = ((0 + 2) % 3) = (2 % 3) = 2, which is the last outcome, that is Alice wins, as we expect it to be.)"
  },
  {
    "objectID": "/tut/rps/#p_76",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Finally, we use the each form to have each of the participants send the final outcome to their frontends."
  },
  {
    "objectID": "/tut/rps/#p_77",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 31 states that this is a local step that each of the participants performs."
  },
  {
    "objectID": "/tut/rps/#p_78",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "At this point, we can run the program and see its output by running"
  },
  {
    "objectID": "/tut/rps/#p_79",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Since the players act randomly, the results will be different every time. When I ran the program three times, this is the output I got:"
  },
  {
    "objectID": "/tut/rps/#p_80",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Alice is pretty good at Rock, Paper, Scissors!!"
  },
  {
    "objectID": "/tut/rps/#p_81",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Consensus networks in general, and Reach specifically, guarantee that all participants agree on the outcome of their decentralized computation. Indeed, this is where the name consensus network comes from, as they enable these distributed, and untrusted, parties to come to a consensus, or agreement, about the intermediate states of a computation; and if they agree on the intermediate states, they will also agree on the output. That's why every time you run ./reach run, both Alice and Bob will see the same outcome!"
  },
  {
    "objectID": "/tut/rps/#p_82",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If your version isn't working, look at the complete versions of rps-2-rps/index.rsh and rps-2-rps/index.mjs to make sure you copied everything down correctly!"
  },
  {
    "objectID": "/tut/rps/#p_83",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In the next step, we'll add some stakes to the game, because Alice needs to take her skills to the bank!"
  },
  {
    "objectID": "/tut/rps/#p_84",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Reach programs allow interaction with a user interface through which of the following methods?"
  },
  {
    "objectID": "/tut/rps/#p_85",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "by forcing you to write a custom backend for the user interface that connects to the generated smart contract,"
  },
  {
    "objectID": "/tut/rps/#p_86",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "by allowing the frontends to provide values directly to the Reach application,"
  },
  {
    "objectID": "/tut/rps/#p_87",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "by allowing the Reach program to callback to the frontend via the interact object."
  },
  {
    "objectID": "/tut/rps/#p_88",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "2 and 3; Reach programs specify a two-way interface between the frontend and the backend via the participant interact interface."
  },
  {
    "objectID": "/tut/rps/#p_89",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "How do participants in a Reach application share information with each other and find out what others have shared?"
  },
  {
    "objectID": "/tut/rps/#p_90",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Reach generates a smart contract, but you need to implement a process to scan the blockchain for events that correspond to sharing;"
  },
  {
    "objectID": "/tut/rps/#p_91",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The Reach primitive {!rsh} publish allows a participant to share information with all other participants, which happens automatically without the other parties needing to do anything special;"
  },
  {
    "objectID": "/tut/rps/#p_92",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The Reach primitive {!rsh} publish allows a participant to share information with all other participants, but they need to explicitly run the receive primitive to receive published information."
  },
  {
    "objectID": "/tut/rps/#p_93",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "2; the {!rsh} publish primitive does everything for you."
  },
  {
    "objectID": "/tut/rps/#p_94",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Although it's fun to play Rock, Paper, Scissors! with friends for a laugh, it's even better to play it with enemies and your entire life-savings on the line! Let's change our program so that Alice can offer a wager to Bob and whoever wins will take the pot."
  },
  {
    "objectID": "/tut/rps/#p_95",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "This time, let's start with changes to the JavaScript frontend and then we'll go back into the Reach code and connect the new methods up."
  },
  {
    "objectID": "/tut/rps/#p_96",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Since we're going to be having funds get transferred, we'll record the balances of each participant before the game starts, so we can more clearly show what they won at the end. We'll add this code in between account creation and contract deployment."
  },
  {
    "objectID": "/tut/rps/#p_97",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 9 shows a helpful function for displaying currency amounts with up to 4 decimal places."
  },
  {
    "objectID": "/tut/rps/#p_98",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 10 shows a helpful function for getting the balance of a participant and displaying it with up to 4 decimal places."
  },
  {
    "objectID": "/tut/rps/#p_99",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 11 and 12 get the balance before the game starts for both Alice and Bob."
  },
  {
    "objectID": "/tut/rps/#p_100",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next, we'll update Alice's interface object to include her wager."
  },
  {
    "objectID": "/tut/rps/#p_101",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 32 splices the common {!js} Player interface into Alice's interface."
  },
  {
    "objectID": "/tut/rps/#p_102",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 33 defines her wager as 5 units of the network token. This is an example of using a concrete value, rather than a function, in a participant interact interface."
  },
  {
    "objectID": "/tut/rps/#p_103",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "For Bob, we'll modify his interface to show the wager and immediately accept it by returning."
  },
  {
    "objectID": "/tut/rps/#p_104",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 37 through 39 define the {!js} acceptWager function."
  },
  {
    "objectID": "/tut/rps/#p_105",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Finally, after the computation is over, we'll get the balance again and show a message summarizing the effect."
  },
  {
    "objectID": "/tut/rps/#p_106",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 44 and 45 get the balances afterwards."
  },
  {
    "objectID": "/tut/rps/#p_107",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 47 and 48 print out the effect."
  },
  {
    "objectID": "/tut/rps/#p_108",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "These changes to the frontend only deal with issues of presentation and interfacing. The actual business logic of making the wager and transferring the funds will happen in the Reach code."
  },
  {
    "objectID": "/tut/rps/#p_109",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Let's look at that now."
  },
  {
    "objectID": "/tut/rps/#p_110",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "First, we need to update the participant interact interface."
  },
  {
    "objectID": "/tut/rps/#p_111",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 9 through 12 define Alice's interface as the {!rsh} Player interface, plus an integer value called {!rsh} wager."
  },
  {
    "objectID": "/tut/rps/#p_112",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 13 through 16 do the same for Bob, where he has a method called {!rsh} acceptWager that can look at the wager value."
  },
  {
    "objectID": "/tut/rps/#p_113",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Each of the three parts of the application have to be updated to deal with the wager. Let's look at Alice's first step first."
  },
  {
    "objectID": "/tut/rps/#p_114",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 20 has Alice declassify the wager for transmission."
  },
  {
    "objectID": "/tut/rps/#p_115",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 23 is updated so that Alice shares the wager amount with Bob."
  },
  {
    "objectID": "/tut/rps/#p_116",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 24 has her transfer the amount as part of her publication. The Reach compiler would throw an exception if {!rsh} wager did not appear on line 23, but did appear on line 24. Change the program and try it. This is because the consensus network needs to be able to verify that the amount of network tokens included in Alice's publication match some computation available to consensus network."
  },
  {
    "objectID": "/tut/rps/#p_117",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next, Bob needs to be shown the wager and given the opportunity to accept it and transfer his funds."
  },
  {
    "objectID": "/tut/rps/#p_118",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 28 has Bob accept the wager. If he doesn't like the terms, his frontend can just not respond to this method and the DApp will stall."
  },
  {
    "objectID": "/tut/rps/#p_119",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 32 has Bob pay the wager as well."
  },
  {
    "objectID": "/tut/rps/#p_120",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The DApp is now running in a consensus step and the contract itself now holds twice the wager amount. Before, it would compute the outcome and then commit the state; but now, it needs to look at the outcome and use it to balance the account."
  },
  {
    "objectID": "/tut/rps/#p_121",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 35 through 38 compute the amounts given to each participant depending on the outcome by determining how many {!rsh} wager amounts each party gets. If the outcome is {!rsh} 2, Alice wins, then she gets two portions; while if it is {!rsh} 0, Bob wins, then he gets two portions; otherwise they each get one portion."
  },
  {
    "objectID": "/tut/rps/#p_122",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 39 and 40 transfer the corresponding amounts. This transfer takes place from the contract to the participants, not from the participants to each other, because all of the funds reside inside of the contract."
  },
  {
    "objectID": "/tut/rps/#p_123",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 41 commits the state of the application and allows the participants to see the outcome and complete."
  },
  {
    "objectID": "/tut/rps/#p_124",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "At this point, we can run the program and see its output by running"
  },
  {
    "objectID": "/tut/rps/#p_125",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Since the players act randomly, the results will be different every time. When I ran the program three times, this is the output I got:"
  },
  {
    "objectID": "/tut/rps/#p_126",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "How come Alice and Bob's balances go back to 100 every time? It's because each time we run ./reach run, it creates fresh accounts for both players."
  },
  {
    "objectID": "/tut/rps/#p_127",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "How come the balances aren't exactly 100, 105, and 95? It's because consensus network charge fees to run transactions."
  },
  {
    "objectID": "/tut/rps/#p_128",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If we had shown all the decimals, they'd look like this:"
  },
  {
    "objectID": "/tut/rps/#p_129",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Why does Alice win slightly less than Bob when she wins? She has to pay to deploy the contract, because she publishes the first message in her frontend."
  },
  {
    "objectID": "/tut/rps/#p_130",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Alice is doing okay - if she keeps this up, she'll make a fortune on Rock, Paper, Scissors!!"
  },
  {
    "objectID": "/tut/rps/#p_131",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If your version isn't working, look at the complete versions of rps-3-bets/index.rsh and rps-3-bets/index.mjs to make sure you copied everything down correctly!"
  },
  {
    "objectID": "/tut/rps/#p_132",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Now that there is a reason to play this game, it turns out that there's a major security vulnerability. We'll fix this in the next step; make sure you don't launch with this version, or Alice is going to go broke!"
  },
  {
    "objectID": "/tut/rps/#p_133",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "How do Reach programs manage token funds?"
  },
  {
    "objectID": "/tut/rps/#p_134",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "They don’t; you need to manage them explicitly in parallel to the Reach program;"
  },
  {
    "objectID": "/tut/rps/#p_135",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The {!rsh} pay primitive can be added to a {!rsh} publish primitive to send funds to the Reach program, which can then use the {!rsh} transfer primitive to send funds back to participants, and other addresses."
  },
  {
    "objectID": "/tut/rps/#p_136",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "2; the {!rsh} pay and {!rsh} transfer primitives do everything for you."
  },
  {
    "objectID": "/tut/rps/#p_137",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In the last section, we made it so that Alice and Bob can actually exchange currency when they play Rock, Paper, Scissors!. However, the version of the application we wrote has a fundamental flaw: Bob can win every game!"
  },
  {
    "objectID": "/tut/rps/#p_138",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "How is that possible? We showed executions of the game where Alice won, like the following"
  },
  {
    "objectID": "/tut/rps/#p_139",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The problem is that this version of the game only executed an honest version of Bob, that is, one that followed the Reach program exactly, including in his private local steps. It is possible for a deviant and dishonest version of a Bob backend to execute different code and always win by computing the appropriate guess based on what value Alice provided for {!rsh} handAlice."
  },
  {
    "objectID": "/tut/rps/#p_140",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If we change Bob's code to the following:"
  },
  {
    "objectID": "/tut/rps/#p_141",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "then he will ignore the frontend and just compute the correct value."
  },
  {
    "objectID": "/tut/rps/#p_142",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If we run this version of the program, we will see output like this:"
  },
  {
    "objectID": "/tut/rps/#p_143",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In this version, unlike the honest version, Bob never consults the frontend and so it never prints out the message of what hand Bob played. No matter what Alice chooses, Bob will always win."
  },
  {
    "objectID": "/tut/rps/#p_144",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Is it just a fluke of the random number generator that we observed Bob always winning? How would we know? Reach comes with an automatic verification engine that we can use to mathematically prove that this version will always result in the {!rsh} outcome variable equalling {!rsh} 0, which means Bob wins. We can instruct Reach to prove this theorem by adding these lines after computing the {!rsh} outcome:"
  },
  {
    "objectID": "/tut/rps/#p_145",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 35 requires that the dishonest version of Bob be used for the proof."
  },
  {
    "objectID": "/tut/rps/#p_146",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 36 conducts the proof by including an assert statement in the program."
  },
  {
    "objectID": "/tut/rps/#p_147",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Before we had this line in the file, when we ran ./reach compile, it would print out the message:"
  },
  {
    "objectID": "/tut/rps/#p_148",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "But now, it prints out"
  },
  {
    "objectID": "/tut/rps/#p_149",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 7 is different and shows that more theorems have been proven about our program. It prints out five more, rather than one more, because the theorem is proved differently in the different verification modes."
  },
  {
    "objectID": "/tut/rps/#p_150",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Many programming languages include assertions like this, but Reach is one of a small category where the compiler doesn't just insert a runtime check for the property, but actually conducts a mathematical proof at compile-time that the expression always evaluates to {!rsh} true."
  },
  {
    "objectID": "/tut/rps/#p_151",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In this case, we used Reach's automatic verification engine to prove that an attack did what we expected it would. But, it is better to use verification to show that no flaw exists and no attack is possible."
  },
  {
    "objectID": "/tut/rps/#p_152",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Reach includes some such assertions automatically in every program. That's why every version of Rock, Paper, Scissors! has said that a number of theorems were checked. We can see what these theorems do by deliberately inserting an error into the program."
  },
  {
    "objectID": "/tut/rps/#p_153",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Let's start by undoing the changes we made earlier by changing"
  },
  {
    "objectID": "/tut/rps/#p_154",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "back to"
  },
  {
    "objectID": "/tut/rps/#p_155",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "and removing"
  },
  {
    "objectID": "/tut/rps/#p_156",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Let's change the computation of the payout and make it so that if Alice wins, then she only gets her wager back, not Bob's."
  },
  {
    "objectID": "/tut/rps/#p_157",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We should now have something that looks like"
  },
  {
    "objectID": "/tut/rps/#p_158",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 36 has {!rsh} [1, 0], but should have {!rsh} [2, 0]."
  },
  {
    "objectID": "/tut/rps/#p_159",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "When we run ./reach compile rps-4-attack/index-bad.rsh, it gives details about the error:"
  },
  {
    "objectID": "/tut/rps/#p_160",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "There's a lot of information in the compiler output that can help an experienced programmer track down the problem. But the most important parts are"
  },
  {
    "objectID": "/tut/rps/#p_161",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 7 says that this is an attempt to prove the theorem that the balance at the end of the program is zero, which means that no network tokens are sealed in the contract forever."
  },
  {
    "objectID": "/tut/rps/#p_162",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 10-20 describe the values that could cause the theorem to fail."
  },
  {
    "objectID": "/tut/rps/#p_163",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 23-31 outline the theorem that failed."
  },
  {
    "objectID": "/tut/rps/#p_164",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Refer to How to read verification failures if you'd like to learn more about the details of this output."
  },
  {
    "objectID": "/tut/rps/#p_165",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "These kinds of automatic verifications are helpful for Reach programmers, because they don't need to remember to put them in their program, and they will still be protected from entire categories of errors."
  },
  {
    "objectID": "/tut/rps/#p_166",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "However, now let's add an assertion to the program that will ensure that every version of the program that allows Bob to know Alice's hand before he chooses his own will be rejected."
  },
  {
    "objectID": "/tut/rps/#p_167",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We'll go back to the version of rps-3-bets/index.rsh from the last section, which has an honest version of Bob. (Click on the preceding link if you need to see what it contained.)"
  },
  {
    "objectID": "/tut/rps/#p_168",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We'll add a single line to the program after Alice publishes, but before Bob takes a local step:"
  },
  {
    "objectID": "/tut/rps/#p_169",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 27 contains a knowledge assertion that Bob cannot know Alice's value {!rsh} handAlice at this point in the program. In this case, it is obvious that this is not true, because Alice shares {!rsh} handAlice at line 23. In many cases, this is not obvious and Reach's automatic verification engine has to reason about how values that Bob does know are connected to values that might be related to Alice's secret values."
  },
  {
    "objectID": "/tut/rps/#p_170",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "When we run ./reach run, it reports that this assertion is false:"
  },
  {
    "objectID": "/tut/rps/#p_171",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "It is not enough to correct failures and attacks when you discover them. You must always add an assertion to your program that would fail to hold if the attack or failure were present. This ensures that all similar attacks are not present and that they will not accidentally be reintroduced."
  },
  {
    "objectID": "/tut/rps/#p_172",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Let's use these insights into automatic verification and rewrite our Rock, Paper, Scissors! so that it is more trustworthy and secure."
  },
  {
    "objectID": "/tut/rps/#p_173",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Since we've been making lots of changes to the code, let's start fresh with a new version and we'll look at every single line again, to make sure that you aren't missing anything."
  },
  {
    "objectID": "/tut/rps/#p_174",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "First, we'll define the rules of Rock, Paper, Scissors! a little bit more abstractly, so we can separate the logic of the game from the details of the application:"
  },
  {
    "objectID": "/tut/rps/#p_175",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 1 is the usual Reach version header."
  },
  {
    "objectID": "/tut/rps/#p_176",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 3 and 4 define enumerations for the hands that may be played, as well as the outcomes of the game."
  },
  {
    "objectID": "/tut/rps/#p_177",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 6 and 7 define the function that computes the winner of the game."
  },
  {
    "objectID": "/tut/rps/#p_178",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "When we first wrote Rock, Paper, Scissors!, we asked you to trust that this formula for computing the winner is correct, but it is good to actually check. One way to check would be to implement a JavaScript frontend that didn't interact with a real user, nor would it randomly generate values, but instead, it would return specific testing scenario values and check that the output is as expected. That's a typical way to debug and is possible with Reach. However, Reach allows us to write such test cases directly into the Reach program as verification assertions."
  },
  {
    "objectID": "/tut/rps/#p_179",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 9 makes an assertion that when Alice plays Rock and Bob plays Paper, then Bob wins as expected."
  },
  {
    "objectID": "/tut/rps/#p_180",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "But, Reach's automatic verification allows us to express even more powerful statements about our program's behavior. For example, we can state that no matter what values are provided for {!rsh} handAlice and {!rsh} handBob, {!rsh} winner will always provide a valid outcome:"
  },
  {
    "objectID": "/tut/rps/#p_181",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "And we can specify that whenever the same value is provided for both hands, no matter what it is, {!rsh} winner always returns {!rsh} DRAW:"
  },
  {
    "objectID": "/tut/rps/#p_182",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "These examples both use {!rsh} forall, which allows Reach programmers to quantify over all possible values that might be provided to a part of their program. You might think that these theorems will take a very long time to prove, because they have to loop over all the billions and billions of possibilities (e.g., Ethereum uses 256-bits for its unsigned integers) for the bits of {!rsh} handAlice (twice!) and {!rsh} handBob. In fact, on rudimentary laptops, it takes less than half a second. That's because Reach uses an advanced symbolic execution engine to reason about this theorem abstractly without considering individual values."
  },
  {
    "objectID": "/tut/rps/#p_183",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Let's continue the program by specifying the participant interact interfaces for Alice and Bob. These will be mostly the same as before, except that we will also expect that each frontend can provide access to random numbers. We'll use these later on to protect Alice's hand."
  },
  {
    "objectID": "/tut/rps/#p_184",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The only line that is different is line 21, which includes {!rsh} hasRandom, from the Reach standard library, in the interface. We'll use this to generate a random number to protect Alice's hand."
  },
  {
    "objectID": "/tut/rps/#p_185",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Similarly, we only need to modify one line of our JavaScript frontend. Line 20 allows each participant's Reach code to generate random numbers as necessary."
  },
  {
    "objectID": "/tut/rps/#p_186",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "These two changes might look identical, but they mean very different things. The first, line 21 in the Reach program, adds {!rsh} hasRandom to the interface that the backend expects the frontend to provide. The second, line 20 in the JavaScript, adds {!rsh} hasRandom to the implementation that the frontend provides to the backend."
  },
  {
    "objectID": "/tut/rps/#p_187",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next, we'll create the Reach app and the participant interact interface for Alice and Bob. Nothing here is new."
  },
  {
    "objectID": "/tut/rps/#p_188",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We're now at the crucial juncture where we will implement the actual application and ensure that Alice's hand is protected until after Bob reveals his hand. The simplest thing would be to have Alice just publish the wager, but this, of course, would just leave Bob vulnerable. We need Alice to be able to publish her hand, but also keep it secret. This is a job for a cryptographic commitment scheme. Reach's standard library comes with {!rsh} makeCommitment to make this easier for you."
  },
  {
    "objectID": "/tut/rps/#p_189",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 39 has Alice compute her hand, but not declassify it."
  },
  {
    "objectID": "/tut/rps/#p_190",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 40 has her compute a commitment to the hand. It comes with a secret \"salt\" value that must be revealed later. This \"salt\" was generated by the {!rsh} random function inside of {!rsh} hasRandom and it's why we pass {!rsh} interact to this function."
  },
  {
    "objectID": "/tut/rps/#p_191",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 41 has Alice declassify the commitment."
  },
  {
    "objectID": "/tut/rps/#p_192",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 43 has her publish them, and line 44 has her include the wager funds in the publication."
  },
  {
    "objectID": "/tut/rps/#p_193",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "At this point, we can state the knowledge assertion that Bob can't know either the hand or the \"salt\" and continue with his part of the program."
  },
  {
    "objectID": "/tut/rps/#p_194",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "It is important to include the salt in the commitment, so that multiple commitments to the same value are not identical. Similarly, it is important not to share the salt until later, because if an attacker knows the set of possible values, they can enumerate them and compare with the result of the commitment and learn the value. That's why we use a randomly generated salt."
  },
  {
    "objectID": "/tut/rps/#p_195",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 47 states the knowledge assertion."
  },
  {
    "objectID": "/tut/rps/#p_196",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 48 through 53 are unchanged from the original version."
  },
  {
    "objectID": "/tut/rps/#p_197",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 54 has the transaction commit, without computing the payout, because we can't yet, because Alice's hand is not yet public."
  },
  {
    "objectID": "/tut/rps/#p_198",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We now return to Alice who can reveal her secrets."
  },
  {
    "objectID": "/tut/rps/#p_199",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 57 and 58 have Alice declassify the secret information."
  },
  {
    "objectID": "/tut/rps/#p_200",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 60 has her publish it."
  },
  {
    "objectID": "/tut/rps/#p_201",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 61 checks that the published values match the original values. This will always be the case with honest participants, but dishonest participants may violate this assumption."
  },
  {
    "objectID": "/tut/rps/#p_202",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The rest of the program is unchanged from the original version, except that it uses the new names for the outcomes:"
  },
  {
    "objectID": "/tut/rps/#p_203",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Since we didn't have to change the frontend in any meaningful way, the output of running ./reach run is still the same as it ever was:"
  },
  {
    "objectID": "/tut/rps/#p_204",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Except now, behind the scenes, and without any changes to the frontend, Alice takes two steps in our program and Bob only takes one, and she is protected against Bob finding her hand and using it to ensure he wins!"
  },
  {
    "objectID": "/tut/rps/#p_205",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "When we compile this version of the application, Reach's automatic formal verification engine proves many theorems and protects us against a plethora of mistakes one might make when writing even a simple application like this. Non-Reach programmers that try to write decentralized applications are on their own trying to ensure that these problems don't exist."
  },
  {
    "objectID": "/tut/rps/#p_206",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If your version isn't working, look at the complete versions of rps-5-trust/index.rsh and rps-5-trust/index.mjs to make sure you copied everything down correctly!"
  },
  {
    "objectID": "/tut/rps/#p_207",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Now our implementation of Rock, Paper, Scissors! is secure and doesn't contain any exploits for either Alice or Bob to guarantee a win. However, it still has a final category of mistake that is common in decentralized applications: non-participation. We'll fix this in the next step; make sure you don't launch with this version, or Alice may decide to back out of the game when she knows she's going to lose!"
  },
  {
    "objectID": "/tut/rps/#p_208",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Since blockchain programs run on a single, global, publicly-checked and certified consensus network, you don’t need to test them as much as normal software, which run on a wide variety of different platforms and operating systems."
  },
  {
    "objectID": "/tut/rps/#p_209",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "False"
  },
  {
    "objectID": "/tut/rps/#p_210",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "It is easy to write correct programs that handle financial information, and even if you make a mistake, blockchains support an \"Undo\" operation that allows you to rollback to earlier versions of the ledger to correct mistakes and recover lost funds."
  },
  {
    "objectID": "/tut/rps/#p_211",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "False"
  },
  {
    "objectID": "/tut/rps/#p_212",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Reach provides automatic verifications to ensure that your program does not lose, lock away, or overspend funds and guarantees that your applications are free from entire categories of errors."
  },
  {
    "objectID": "/tut/rps/#p_213",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "True"
  },
  {
    "objectID": "/tut/rps/#p_214",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Reach provides tools for you to add custom verifications to your program, like ensuring that information is known only to one party, or that your implementation of a sensitive algorithm is correct."
  },
  {
    "objectID": "/tut/rps/#p_215",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "True"
  },
  {
    "objectID": "/tut/rps/#p_216",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In the last section, we removed a security vulnerability from Rock, Paper, Scissors! that was a clear attack on the viability of the application. In this section, we'll focus on a more subtle issue that is important and unique to decentralized applications: non-participation."
  },
  {
    "objectID": "/tut/rps/#p_217",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Non-participation refers to the act of one party ceasing to continue playing their role in an application."
  },
  {
    "objectID": "/tut/rps/#p_218",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In traditional client-server programs, like a Web server, this would be the case of a client not sending any more requests to the server, or the server stopping sending responses to the client. In these sorts of traditional programs, non-participation is an exceptional circumstance that normally leads to an error message for clients and, at most, a log entry for servers. Sometimes traditional programs will need to recycle resources, like network ports, on non-participation, but they would have also needed to do that if the transaction ended by normal means. In other words, for traditional client-server programs, it is not necessary for designers to meticulously consider the consequences of non-participation."
  },
  {
    "objectID": "/tut/rps/#p_219",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In contrast, decentralized applications must be carefully designed with an eye towards their behavior in the face of non-participation. For example, consider what happens in our Rock, Paper, Scissors! game if after Alice has paid her wager, Bob never accepts and the application doesn't continue. In this case, Alice's network tokens would be locked inside of the contract and lost to her. Similarly, if after Bob accepted and paid his wager, Alice stopped participating and never submitted her hand, then both their funds would be locked away forever. In each of these cases, both parties would be greatly hurt and their fear of that outcome would introduce an additional cost to transacting, which would lower the value they got from participating in the application. Of course, in a situation like Rock, Paper, Scissors! this is unlikely to be an important matter, but recall that Rock, Paper, Scissors! is a microcosm of decentralized application design."
  },
  {
    "objectID": "/tut/rps/#p_220",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Technically, in the first case, when Bob fails to start the application, Alice is not locked away from her funds: since Bob's identity is not fixed until after his first message, she could start another instance of the game as the Bob role and then she'd win all of the funds, less any transaction costs of the consensus network. In the second case, however, there would be no recourse for either party."
  },
  {
    "objectID": "/tut/rps/#p_221",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In the rest of this section, we'll discuss how Reach helps address non-participation. For a longer discussion, refer to the guide chapter on non-participation."
  },
  {
    "objectID": "/tut/rps/#p_222",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In Reach, non-participation is handled through a \"timeout\" mechanism whereby each consensus transfer can be paired with a step that occurs for all participants if the originator of the consensus transfer fails to make the required publication before a particular network time. We'll integrate this mechanism into our version of Rock, Paper, Scissors! and deliberately insert non-participation into our JavaScript testing program to watch the consequences play out."
  },
  {
    "objectID": "/tut/rps/#p_223",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "First, we'll modify the participant interact interface to allow the frontend to be informed that a timeout occurred."
  },
  {
    "objectID": "/tut/rps/#p_224",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 24 introduces a new method, {!rsh} informTimeout, that receives no arguments and returns no information. We'll call this function when a timeout occurs."
  },
  {
    "objectID": "/tut/rps/#p_225",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We'll make a slight tweak to our JavaScript frontend to be able to receive this message and display it on the console."
  },
  {
    "objectID": "/tut/rps/#p_226",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Back in the Reach program, we'll declare a value to use as a standard deadline throughout the program. Similar to how she provides the wager, we will have Alice also provide the deadline."
  },
  {
    "objectID": "/tut/rps/#p_227",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 31 adds the {!js} deadline field to Alice's participant interact interface. It is defined as some number of time delta units, which are an abstraction of the underlying notion of network time in the consensus network. In many networks, like Ethereum, this number is a number of blocks."
  },
  {
    "objectID": "/tut/rps/#p_228",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next, at the start of the Reach application, we'll define a helper function to inform each of the participants of the timeout by calling this new method."
  },
  {
    "objectID": "/tut/rps/#p_229",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 39 defines the function as an arrow expression."
  },
  {
    "objectID": "/tut/rps/#p_230",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 40 has each of the participants perform a local step."
  },
  {
    "objectID": "/tut/rps/#p_231",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 41 has them call the new {!rsh} informTimeout method."
  },
  {
    "objectID": "/tut/rps/#p_232",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We will have Alice declassify and publish the {!rsh} deadline for later timeout clauses."
  },
  {
    "objectID": "/tut/rps/#p_233",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We won't add a timeout clause to Alice's first message, because there is no consequence to her non-participation: if she doesn't start the game, then no one is any worse off."
  },
  {
    "objectID": "/tut/rps/#p_234",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 50 has Alice declassify the {!rsh} deadline time delta."
  },
  {
    "objectID": "/tut/rps/#p_235",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 52 now has Alice publish the {!rsh} deadline."
  },
  {
    "objectID": "/tut/rps/#p_236",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "However, we will adjust Bob's first message, because if he fails to participate, then Alice's initial wager will be lost to her."
  },
  {
    "objectID": "/tut/rps/#p_237",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 63 adds a timeout handler to Bob's publication."
  },
  {
    "objectID": "/tut/rps/#p_238",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The timeout handler specifies that if Bob does not complete this action within a time delta of {!rsh} deadline, then the application transitions to the step given by the arrow expression. In this case, the timeout code is a call to {!rsh} closeTo, which is a Reach standard library function that allows anyone to send a message and transfer all of the funds in the contract to Alice, then call the given function afterwards. This means that if Bob fails to publish his hand, then Alice will take her network tokens back."
  },
  {
    "objectID": "/tut/rps/#p_239",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We will add a similar timeout handler to Alice's second message."
  },
  {
    "objectID": "/tut/rps/#p_240",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "But in this case, Bob will be able to claim all of the funds if Alice doesn't participate. You might think that it would be \"fair\" for Alice's funds to be returned to Alice and Bob's to Bob. However, if we implemented it that way, then Alice would be wise to always timeout if she were going to lose, which she knows will happen, because she knows her hand and Bob's hand."
  },
  {
    "objectID": "/tut/rps/#p_241",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "These are the only changes we need to make to the Reach program to make it robust against non-participation: eleven lines!"
  },
  {
    "objectID": "/tut/rps/#p_242",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Let's modify the JavaScript frontend to deliberately cause a timeout sometimes when Bob is supposed to accept the wager."
  },
  {
    "objectID": "/tut/rps/#p_243",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 38 has Alice specify a {!js} deadline of ten blocks."
  },
  {
    "objectID": "/tut/rps/#p_244",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 42 through 51 redefine Bob's {!js} acceptWager method as an asynchronous function, where half of the time it will take at least ten blocks on the Ethereum network by waiting for ten units of time to pass. We know that ten is the value of {!js} deadline, so this will cause a timeout."
  },
  {
    "objectID": "/tut/rps/#p_245",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Let's run the program and see what happens:"
  },
  {
    "objectID": "/tut/rps/#p_246",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Of course, when you run, you may not get two of the three times ending in a timeout."
  },
  {
    "objectID": "/tut/rps/#p_247",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If your version isn't working, look at the complete versions of rps-6-timeouts/index.rsh and rps-6-timeouts/index.mjs to make sure you copied everything down correctly!"
  },
  {
    "objectID": "/tut/rps/#p_248",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Now our implementation of Rock, Paper, Scissors! is robust against either participant dropping from the game. In the next step, we'll extend the application to disallow draws and have Alice and Bob play again until there is a winner."
  },
  {
    "objectID": "/tut/rps/#p_249",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "What happens in a decentralized application when one participant refuses to take the next step of the program? For example, if Alice refuses to share her hand with Bob in a game of ‘Rock, Paper, Scissors’."
  },
  {
    "objectID": "/tut/rps/#p_250",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "This is not possible, because the blockchain guarantees that each party performs a particular set of actions;"
  },
  {
    "objectID": "/tut/rps/#p_251",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The program hangs forever waiting for Alice to provide the value;"
  },
  {
    "objectID": "/tut/rps/#p_252",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Alice is punished and the program proceeds as-if Bob were the winner;"
  },
  {
    "objectID": "/tut/rps/#p_253",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "It depends on how the program was written; if the developer used Reach, the default is (2), but the developer could include a {!rsh} timeout block to implement the (3) behavior."
  },
  {
    "objectID": "/tut/rps/#p_254",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "4; Reach empowers programmers to design the application with the business logic they want."
  },
  {
    "objectID": "/tut/rps/#p_255",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In this section, we extend our application so that Alice and Bob will continue to play against each other until there is a clear winner, so if it is a draw they will continue playing."
  },
  {
    "objectID": "/tut/rps/#p_256",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "This will only require a change to the Reach program, not the JavaScript frontend, but we will take the opportunity to modify the frontend so that timeouts can happen to both parties when they are asked to submit their hands. Let's do that to get it out of the way and not distract from the main task of removing draws."
  },
  {
    "objectID": "/tut/rps/#p_257",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We'll modify the {!js} Player interact object so that it will have a different {!js} getHand method."
  },
  {
    "objectID": "/tut/rps/#p_258",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 24 through 29 moves the forced timeout code that we wrote for Bob's {!js} acceptWager function into this method. We also change the threshold so that timeouts only happen 1% of the time. This isn't a very interesting behavior, so we'll make it much less frequent."
  },
  {
    "objectID": "/tut/rps/#p_259",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We also adjust Bob's {!js} acceptWager function to remove the timeout code, since we're testing that differently now. It's just a matter of reverting to the simpler version from before."
  },
  {
    "objectID": "/tut/rps/#p_260",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 48 through 50 have the simpler {!js} acceptWager method for Bob."
  },
  {
    "objectID": "/tut/rps/#p_261",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Now, let's look at the Reach application. All of the details about the playing of the game and the interface to the players will remain the same. The only thing that's going to be different is the order the actions take place."
  },
  {
    "objectID": "/tut/rps/#p_262",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "It used to be that the steps were:"
  },
  {
    "objectID": "/tut/rps/#p_263",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Alice sends her wager and commitment."
  },
  {
    "objectID": "/tut/rps/#p_264",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Bob accepts the wager and sends his hand."
  },
  {
    "objectID": "/tut/rps/#p_265",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Alice reveals her hand."
  },
  {
    "objectID": "/tut/rps/#p_266",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The game ends."
  },
  {
    "objectID": "/tut/rps/#p_267",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "But, now because the players may submit many hands, but should only have a single wager, we'll break these steps up differently, as follows:"
  },
  {
    "objectID": "/tut/rps/#p_268",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Alice sends her wager."
  },
  {
    "objectID": "/tut/rps/#p_269",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Bob accepts the wager."
  },
  {
    "objectID": "/tut/rps/#p_270",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Alice sends her commitment."
  },
  {
    "objectID": "/tut/rps/#p_271",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Bob sends his hand."
  },
  {
    "objectID": "/tut/rps/#p_272",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Alice reveals her hand."
  },
  {
    "objectID": "/tut/rps/#p_273",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If it's draw, return to step 3; otherwise, the game ends."
  },
  {
    "objectID": "/tut/rps/#p_274",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Let's make these changes now."
  },
  {
    "objectID": "/tut/rps/#p_275",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 49 has Alice publish the wager and deadline."
  },
  {
    "objectID": "/tut/rps/#p_276",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 50 has Alice pay the wager."
  },
  {
    "objectID": "/tut/rps/#p_277",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 56 has Bob pay the wager."
  },
  {
    "objectID": "/tut/rps/#p_278",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 58 does not have this consensus step commit."
  },
  {
    "objectID": "/tut/rps/#p_279",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "It's now time to begin the repeatable section of the application, where each party will repeatedly submit hands until the the outcome is not a draw. In normal programming languages, such a circumstance would be implemented with a {!js} while loop, which is exactly what we'll do in Reach. However, {!rsh} while loops in Reach require extra care, as discussed in the guide on loops in Reach, so we'll take it slow."
  },
  {
    "objectID": "/tut/rps/#p_280",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In the rest of a Reach program, all identifier bindings are static and unchangeable, but if this were the case throughout all of Reach, then {!rsh} while loops would either never start or never terminate, because the loop condition would never change. So, a {!rsh} while loop in Reach can introduce a variable binding."
  },
  {
    "objectID": "/tut/rps/#p_281",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next, because of Reach's automatic verification engine, we must be able to make a statement about what properties of the program are invariant before and after a {!rsh} while loop body's execution, a so-called \"loop invariant\"."
  },
  {
    "objectID": "/tut/rps/#p_282",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Finally, such loops may only occur inside of consensus steps. That's why Bob's transaction was not committed, because we need to remain inside of the consensus to start the {!rsh} while loop. This is because all of the participants must agree on the direction of control flow in the application."
  },
  {
    "objectID": "/tut/rps/#p_283",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Here's what the structure looks like:"
  },
  {
    "objectID": "/tut/rps/#p_284",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 59 defines the loop variable, {!rsh} outcome."
  },
  {
    "objectID": "/tut/rps/#p_285",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 60 states the invariant that the body of the loop does not change the balance in the contract account and that {!rsh} outcome is a valid outcome."
  },
  {
    "objectID": "/tut/rps/#p_286",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 61 begins the loop with the condition that it continues as long as the outcome is a draw."
  },
  {
    "objectID": "/tut/rps/#p_287",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Now, let's look at the body of the loop for the remaining steps, starting with Alice's commitment to her hand."
  },
  {
    "objectID": "/tut/rps/#p_288",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 62 commits the last transaction, which at the start of the loop is Bob's acceptance of the wager, and at subsequent runs of the loop is Alice's publication of her hand."
  },
  {
    "objectID": "/tut/rps/#p_289",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 64 through 71 are almost identical to the older version, except the wager is already known and paid."
  },
  {
    "objectID": "/tut/rps/#p_290",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Similarly, Bob's code is almost identical to the prior version, except that he's already accepted and paid the wager."
  },
  {
    "objectID": "/tut/rps/#p_291",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Alice's next step is actually identical, because she is still revealing her hand in exactly the same way."
  },
  {
    "objectID": "/tut/rps/#p_292",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next is the end of the loop."
  },
  {
    "objectID": "/tut/rps/#p_293",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 89 updates the {!rsh} outcome loop variable with the new value."
  },
  {
    "objectID": "/tut/rps/#p_294",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 90 continues the loop. Unlike most programming languages, Reach requires that {!rsh} continue be explicitly written in the loop body."
  },
  {
    "objectID": "/tut/rps/#p_295",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The rest of the program could be exactly the same as it was before, except now it occurs outside of the loop, but we will simplify it, because we know that the outcome can never be a draw."
  },
  {
    "objectID": "/tut/rps/#p_296",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 93 asserts that the outcome is never draw, which is trivially true because otherwise the {!rsh} while loop would not have exited."
  },
  {
    "objectID": "/tut/rps/#p_297",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 94 transfers the funds to the winner."
  },
  {
    "objectID": "/tut/rps/#p_298",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Let's run the program and see what happens:"
  },
  {
    "objectID": "/tut/rps/#p_299",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "As usual, your results may differ, but you should be able to see single round victories like this, as well as multi-round fights and timeouts from either party."
  },
  {
    "objectID": "/tut/rps/#p_300",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If your version isn't working, look at the complete versions of rps-7-loops/index.rsh and rps-7-loops/index.mjs to make sure you copied everything down correctly!"
  },
  {
    "objectID": "/tut/rps/#p_301",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Now our implementation of Rock, Paper, Scissors! will always result in a pay-out, which is much more fun for everyone. In the next step, we'll show how to exit \"testing\" mode with Reach and turn our JavaScript into an interactive Rock, Paper, Scissors! game with real users."
  },
  {
    "objectID": "/tut/rps/#p_302",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "How do you write an application in Reach that runs arbitrarily long, like a game of Rock, Paper, Scissors that is guaranteed to not end in a draw?"
  },
  {
    "objectID": "/tut/rps/#p_303",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "This is not possible, because all Reach programs are finitely long;"
  },
  {
    "objectID": "/tut/rps/#p_304",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "You can use a {!rsh} while loop that runs until the outcome of the game is decided."
  },
  {
    "objectID": "/tut/rps/#p_305",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "2; Reach supports {!rsh} while loops."
  },
  {
    "objectID": "/tut/rps/#p_306",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "When you check if a program with a {!rsh} while loop is correct, you need to have a property called a loop invariant. Which of the following statements have to be true about the loop invariant?"
  },
  {
    "objectID": "/tut/rps/#p_307",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The part of the program before the {!rsh} while loop must establish the invariant."
  },
  {
    "objectID": "/tut/rps/#p_308",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The condition and the body of the loop must establish the invariant."
  },
  {
    "objectID": "/tut/rps/#p_309",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The negation of the condition and the invariant must establish any properties of the rest of the program."
  },
  {
    "objectID": "/tut/rps/#p_310",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "All of the above."
  },
  {
    "objectID": "/tut/rps/#p_311",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In the last section, we made our Rock, Paper, Scissors! run until there was a definitive winner. In this section, we won't be making any changes to the Reach program itself. Instead, we'll introduce customizations to the JavaScript frontend which facilitate interactivity and provide the option to connect to a real consensus network."
  },
  {
    "objectID": "/tut/rps/#p_312",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We'll start from scratch and show every line of the program again. You'll see a lot of similarity between this and the last version, but for completeness, we'll show every line."
  },
  {
    "objectID": "/tut/rps/#p_313",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 1 has been updated to import the ask object of @reach-sh/stdlib, the Reach standard library. We'll see how ask is used below."
  },
  {
    "objectID": "/tut/rps/#p_314",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 2, and 3 are the same as before: importing the standard library and the backend."
  },
  {
    "objectID": "/tut/rps/#p_315",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 5 through 8 ask the question whether they are playing as Alice and expect a \"Yes\" or \"No\" answer. {!js} ask.ask presents a prompt and collects a line of input until its argument does not error. {!js} ask.yesno errors if it is not given \"y\" or \"n\"."
  },
  {
    "objectID": "/tut/rps/#p_316",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 14 through 17 present the user with the choice of creating a test account if they can or inputting a secret to load an existing account."
  },
  {
    "objectID": "/tut/rps/#p_317",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 19 creates the test account as before."
  },
  {
    "objectID": "/tut/rps/#p_318",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 25 loads the existing account."
  },
  {
    "objectID": "/tut/rps/#p_319",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Line 29 branches based on whether the player is running as Alice, who must deploy the contract, or Bob, who must attach to it."
  },
  {
    "objectID": "/tut/rps/#p_320",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 30 through 32 deploy it and print out public information ({!js} ctc.getInfo) that can be given to the other player when it becomes available."
  },
  {
    "objectID": "/tut/rps/#p_321",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lines 34 through 39 request, parse, and process this information."
  },
  {
    "objectID": "/tut/rps/#p_322",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next we define a few helper functions and start the participant interaction interface."
  },
  {
    "objectID": "/tut/rps/#p_323",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Then we define a timeout handler."
  },
  {
    "objectID": "/tut/rps/#p_324",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next, we request the wager amount or define the {!js} acceptWager method, depending on if we are Alice or not."
  },
  {
    "objectID": "/tut/rps/#p_325",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next, we define the shared {!js} getHand method."
  },
  {
    "objectID": "/tut/rps/#p_326",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Finally, the {!js} seeOutcome method."
  },
  {
    "objectID": "/tut/rps/#p_327",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Lastly, we choose the appropriate backend function and await its completion."
  },
  {
    "objectID": "/tut/rps/#p_328",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We can now run"
  },
  {
    "objectID": "/tut/rps/#p_329",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "in one terminal in this directory to play as Alice and"
  },
  {
    "objectID": "/tut/rps/#p_330",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "in another terminal in this directory to play as Bob."
  },
  {
    "objectID": "/tut/rps/#p_331",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Here's an example run:"
  },
  {
    "objectID": "/tut/rps/#p_332",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "and"
  },
  {
    "objectID": "/tut/rps/#p_333",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Of course, when you run the exact amounts and addresses may be different."
  },
  {
    "objectID": "/tut/rps/#p_334",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If your version isn't working, compare with rps-8-interact/index.rsh and rps-8-interact/index.mjs to ensure you've copied everything down correctly!"
  },
  {
    "objectID": "/tut/rps/#p_335",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If we were to instead run"
  },
  {
    "objectID": "/tut/rps/#p_336",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "in two terminals we'd see equivalent output from running our application on a private Algorand devnet."
  },
  {
    "objectID": "/tut/rps/#p_337",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Connecting to live consensus networks is similarly easy:"
  },
  {
    "objectID": "/tut/rps/#p_338",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Now our implementation of Rock, Paper, Scissors! is finished! We are protected against attacks, timeouts, and draws, and we can run interactively on non-test networks."
  },
  {
    "objectID": "/tut/rps/#p_339",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In this step, we made a command-line interface for our Reach program. In the next step, we'll replace this with a Web interface for the same Reach program."
  },
  {
    "objectID": "/tut/rps/#p_340",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Reach helps you build automated tests for your decentralized application, but it doesn’t support building interactive user-interfaces."
  },
  {
    "objectID": "/tut/rps/#p_341",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "False; Reach does not impose any constraints on what kind of frontend is attached to your Reach application."
  },
  {
    "objectID": "/tut/rps/#p_342",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In the last section, we made Rock, Paper, Scissors! run as a command-line application, without any changes to the Reach program. In this section, we again won't be making any changes to the Reach program. Instead, we'll replace the command-line interface with a Web interface."
  },
  {
    "objectID": "/tut/rps/#p_343",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We will use React.js for this tutorial, but the same principles apply to any Web framework."
  },
  {
    "objectID": "/tut/rps/#p_344",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If you've never used React before, here are some basics about how it works:"
  },
  {
    "objectID": "/tut/rps/#p_345",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "React programs are JavaScript programs that use a special library that allows you to mix HTML inside of the body of your JavaScript."
  },
  {
    "objectID": "/tut/rps/#p_346",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "React has a special compiler that combines a bundle of JavaScript programs, and all their dependencies, into one large file that can be deployed on a static Web server. This is called \"packing\"."
  },
  {
    "objectID": "/tut/rps/#p_347",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "When you're developing and testing with React, you run a special development Web server that watches and updates this packed file every time you modify a source file, so you don't have to constantly run the compiler."
  },
  {
    "objectID": "/tut/rps/#p_348",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Reach automates the process of starting this development server for you when you run ./reach react and gives you access to it at http://localhost:3000/."
  },
  {
    "objectID": "/tut/rps/#p_349",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Similarly, in this tutorial, we assume that we will be deploying (and testing) with Ethereum. Reach Web applications rely on the Web browser to provide access to a consensus network account and its associated wallet. On Ethereum, the standard wallet is MetaMask. If you want to test this code, you'll need to install it and set it up. Furthermore, MetaMask does not support multiple active accounts, so if you want to test Rock, Paper, Scissors! locally, you'll need to have two separate browser instances: one to act as Alice and another to act as Bob."
  },
  {
    "objectID": "/tut/rps/#p_350",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "To complete this section we'll use the index.rsh you've already written and create an index.js file from scratch which replaces index.mjs."
  },
  {
    "objectID": "/tut/rps/#p_351",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If you do not replace index.mjs, then you will get an error when you run reach react. You can avoid this error by renaming the file to index.mjs.bak, or by creating a totally new directory with a copy of the old index.rsh. We do the second option."
  },
  {
    "objectID": "/tut/rps/#p_352",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "This code is also supplemented with index.css and some views. These details are not specific to Reach, and are fairly trivial, so we will not explain the specifics of those files. If you run this locally, you'll want to download those files. Your directory should look like:"
  },
  {
    "objectID": "/tut/rps/#p_353",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We will focus on rps-9-web/index.js, because rps-9-web/index.rsh is the same as previous sections."
  },
  {
    "objectID": "/tut/rps/#p_354",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On lines 1 thru 6, we import our view code and CSS. On line 7, we import the compiled {!rsh} backend. On lines 8 and 9, we load the {!rsh} stdlib as {!rsh} reach."
  },
  {
    "objectID": "/tut/rps/#p_355",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "React compiles the Reach standard library in such a way that it does not have direct access to the environment variables which are used to select the desired standard library. This is why you need to pass {!js} process.env as an argument to achieve the desired effect."
  },
  {
    "objectID": "/tut/rps/#p_356",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On these lines we define a few helpful constants and defaults for later, some corresponding to the enumerations we defined in Reach."
  },
  {
    "objectID": "/tut/rps/#p_357",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We start defining the main application view, {!js} App, as a React component, and tell it what to do once it mounts, which is the React term for starting."
  },
  {
    "objectID": "/tut/rps/#p_358",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 19, we initialize the component state to display Connect Account dialog."
  },
  {
    "objectID": "/tut/rps/#p_359",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On lines 21 thru 31, we hook into React's {!js} componentDidMount lifecycle event, which is called when the component starts."
  },
  {
    "objectID": "/tut/rps/#p_360",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 22, we use {!js} getDefaultAccount, which accesses the default browser account. For example, when used with Ethereum, it can discover the currently-selected MetaMask account."
  },
  {
    "objectID": "/tut/rps/#p_361",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 26, we use {!js} canFundFromFaucet to see if we can access the Reach developer testing network faucet."
  },
  {
    "objectID": "/tut/rps/#p_362",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 27, if {!js} canFundFromFaucet was {!js} true, we set the component state to display Fund Account dialog."
  },
  {
    "objectID": "/tut/rps/#p_363",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 29, if {!js} canFundFromFaucet was {!js} false, we set the component state to skip to Choose Role."
  },
  {
    "objectID": "/tut/rps/#p_364",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 39, we render the appropriate view from rps-9-web/views/AppViews.js."
  },
  {
    "objectID": "/tut/rps/#p_365",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "When we combine the application component with the view (rps-9-web/views/AppViews.js) it will look like: "
  },
  {
    "objectID": "/tut/rps/#p_366",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next, we define callbacks on {!js} App for what to do when the user clicks certain buttons."
  },
  {
    "objectID": "/tut/rps/#p_367",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On lines 32 thru 35, we define what happens when the user clicks the Fund Account button."
  },
  {
    "objectID": "/tut/rps/#p_368",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 33, we transfer funds from the faucet to the user's account."
  },
  {
    "objectID": "/tut/rps/#p_369",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 34, we set the component state to display Choose Role."
  },
  {
    "objectID": "/tut/rps/#p_370",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 36, we define what to do when the user clicks the Skip button, which is to set the component state to display Choose Role."
  },
  {
    "objectID": "/tut/rps/#p_371",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "When we combine this with the view (rps-9-web/views/AppViews.js) it will look like: "
  },
  {
    "objectID": "/tut/rps/#p_372",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On lines 37 and 38, we set a sub-component based on whether the user clicks Deployer or Attacher."
  },
  {
    "objectID": "/tut/rps/#p_373",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "When we combine this with the view (rps-9-web/views/AppViews.js) it will look like: "
  },
  {
    "objectID": "/tut/rps/#p_374",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next, we will define {!js} Player as a React component, that will hold all of the behavior of the players and which will be extended by the specialized components for Alice and Bob."
  },
  {
    "objectID": "/tut/rps/#p_375",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Our Web frontend needs to implement the participant interact interface for players, which we defined as:"
  },
  {
    "objectID": "/tut/rps/#p_376",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We will provide these callbacks via the React component directly."
  },
  {
    "objectID": "/tut/rps/#p_377",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 43, we provide the {!js} random callback"
  },
  {
    "objectID": "/tut/rps/#p_378",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On lines 44 thru 50, we provide the {!js} getHand callback."
  },
  {
    "objectID": "/tut/rps/#p_379",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On lines 45 thru 47, we set the component state to display Get Hand dialog, and wait for a {!js} Promise which can be resolved via user interaction."
  },
  {
    "objectID": "/tut/rps/#p_380",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 48, which occurs after the {!js} Promise is resolved, we set the component state to display Waiting for results display."
  },
  {
    "objectID": "/tut/rps/#p_381",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On lines 51 and 52, we provide the {!js} seeOutcome and {!js} informTimeout callbacks, which set the component state to display Done display and Timeout display, respectively."
  },
  {
    "objectID": "/tut/rps/#p_382",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 53, we define what happens when the user clicks Rock, Paper, or Scissors: The {!js} Promise from line 45 is resolved."
  },
  {
    "objectID": "/tut/rps/#p_383",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The dialog used to get a hand from the player (rps-9-web/views/PlayerViews.js) looks like: "
  },
  {
    "objectID": "/tut/rps/#p_384",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The dialog used to get a hand from the player (rps-9-web/views/PlayerViews.js) looks like: "
  },
  {
    "objectID": "/tut/rps/#p_385",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The display when the player sees the end of the game (rps-9-web/views/PlayerViews.js) looks like: "
  },
  {
    "objectID": "/tut/rps/#p_386",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The display when the player sees a timeout (rps-9-web/views/PlayerViews.js) looks like: "
  },
  {
    "objectID": "/tut/rps/#p_387",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next, we will define {!js} Deployer as a React component for Alice, which extends {!js} Player."
  },
  {
    "objectID": "/tut/rps/#p_388",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Our Web frontend needs to implement the participant interact interface for Alice, which we defined as:"
  },
  {
    "objectID": "/tut/rps/#p_389",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We will provide the {!js} wager and {!js} deadline values, and define some button handlers in order to trigger the deployment of the contract."
  },
  {
    "objectID": "/tut/rps/#p_390",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 59, we set the component state to display Set Wager dialog."
  },
  {
    "objectID": "/tut/rps/#p_391",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 61, we define what to do when the user clicks the Set Wager button, which is to set the component state to display Deploy dialog."
  },
  {
    "objectID": "/tut/rps/#p_392",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On lines 62 thru 69, we define what to do when the user clicks the Deploy button."
  },
  {
    "objectID": "/tut/rps/#p_393",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 63, we call {!js} acc.deploy, which triggers a deploy of the contract."
  },
  {
    "objectID": "/tut/rps/#p_394",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 64, we set the component state to display Deploying display."
  },
  {
    "objectID": "/tut/rps/#p_395",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 65, we set the {!js} wager property."
  },
  {
    "objectID": "/tut/rps/#p_396",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 66, we set the {!js} deadline property based on which connector is being used."
  },
  {
    "objectID": "/tut/rps/#p_397",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 67, we start running the Reach program as Alice, using the {!js} this React component as the participant interact interface object."
  },
  {
    "objectID": "/tut/rps/#p_398",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On lines 68 and 69, we set the component state to display Waiting for Attacher display, which displays the deployed contract info as JSON."
  },
  {
    "objectID": "/tut/rps/#p_399",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 71, we render the appropriate view from rps-9-web/views/DeployerViews.js."
  },
  {
    "objectID": "/tut/rps/#p_400",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The dialog used to set the wager (rps-9-web/views/DeployerViews.js) looks like: "
  },
  {
    "objectID": "/tut/rps/#p_401",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The dialog used to deploy (rps-9-web/views/DeployerViews.js) looks like: "
  },
  {
    "objectID": "/tut/rps/#p_402",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The display shown while deploying (rps-9-web/views/DeployerViews.js) looks like: "
  },
  {
    "objectID": "/tut/rps/#p_403",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The display shown while waiting for the attacher (rps-9-web/views/DeployerViews.js) looks like: "
  },
  {
    "objectID": "/tut/rps/#p_404",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Our Web frontend needs to implement the participant interact interface for Bob, which we defined as:"
  },
  {
    "objectID": "/tut/rps/#p_405",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We will provide the {!js} acceptWager callback, and define some button handlers in order to attach to the deployed contract."
  },
  {
    "objectID": "/tut/rps/#p_406",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 76, we initialize the component state to display Attach dialog."
  },
  {
    "objectID": "/tut/rps/#p_407",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On lines 78 thru 82, we define what happens when the user clicks the Attach button."
  },
  {
    "objectID": "/tut/rps/#p_408",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 79, we call {!js} acc.attach"
  },
  {
    "objectID": "/tut/rps/#p_409",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 80, we set the component state to display Attaching display."
  },
  {
    "objectID": "/tut/rps/#p_410",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 81, we start running the Reach program as Bob, using the {!js} this React component as the participant interact interface object."
  },
  {
    "objectID": "/tut/rps/#p_411",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On lines 83 thru 88, we define the {!js} acceptWager callback."
  },
  {
    "objectID": "/tut/rps/#p_412",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On lines 85 thru 87, we set the component state to display Accept Terms dialog, and wait for a {!js} Promise which can be resolved via user interaction."
  },
  {
    "objectID": "/tut/rps/#p_413",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On lines 89 thru 92, we define what happens when the user clicks the Accept Terms and Pay Wager button: the {!js} Promise from line 90 is resolved, and we set the component state to display Waiting for Turn display."
  },
  {
    "objectID": "/tut/rps/#p_414",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "On line 93, we render the appropriate view from rps-9-web/views/AttacherViews.js"
  },
  {
    "objectID": "/tut/rps/#p_415",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The dialog used to attach (rps-9-web/views/AttacherViews.js) looks like: "
  },
  {
    "objectID": "/tut/rps/#p_416",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The display when attaching (rps-9-web/views/AttacherViews.js) looks like: "
  },
  {
    "objectID": "/tut/rps/#p_417",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The dialog used to accept the terms of the wager (rps-9-web/views/AttacherViews.js) looks like: "
  },
  {
    "objectID": "/tut/rps/#p_418",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The display when waiting for a turn (rps-9-web/views/AttacherViews.js) looks like: "
  },
  {
    "objectID": "/tut/rps/#p_419",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Finally, we call a small helper function from rps-9-web/views/render.js to render our App component."
  },
  {
    "objectID": "/tut/rps/#p_420",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "As a convenience for running the React development server, you can call:"
  },
  {
    "objectID": "/tut/rps/#p_421",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If you get an error or it does not seem to be working correctly, make sure that the folder does not have an index.mjs file. If you do, you can rename it to index.mjs.bak or move it to a new directory with a copy of the old index.rsh."
  },
  {
    "objectID": "/tut/rps/#p_422",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "To run the React development server with Algorand, you can call:"
  },
  {
    "objectID": "/tut/rps/#p_423",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If you expect that your Algorand users do not have access to an ARC-0011 browser wallet, you want to provide a fallback."
  },
  {
    "objectID": "/tut/rps/#p_424",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If you add the following to your program, then you can provide a simple wallet where the user copies and pastes their mnemonic for each interaction."
  },
  {
    "objectID": "/tut/rps/#p_425",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Instead, if you would like to allow your users to use MyAlgo, then you can add the following:"
  },
  {
    "objectID": "/tut/rps/#p_426",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Or, you could have your users use PeraWallet, by adding the following:"
  },
  {
    "objectID": "/tut/rps/#p_427",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "(Of course, you may want to replace 'TestNet' in either of these samples with a different network name, like 'MainNet'.)"
  },
  {
    "objectID": "/tut/rps/#p_428",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Because these are fallbacks, you need to decide for your users which wallet they'll use, or make a user interface element to let them select which wallet fallback to use."
  },
  {
    "objectID": "/tut/rps/#p_429",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If you'd like to instead use Reach in your own JavaScript project, you can call:"
  },
  {
    "objectID": "/tut/rps/#p_430",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "The Reach standard library is undergoing continual improvement and is updated often. If you are experiencing issues with the Node.js package, try updating!"
  },
  {
    "objectID": "/tut/rps/#p_431",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "As usual, you can compile your Reach program index.rsh to the {!js} backend build artifact build/index.main.mjs with:"
  },
  {
    "objectID": "/tut/rps/#p_432",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Now our implementation of Rock, Paper, Scissors! is live in the browser! We can leverage callbacks in the participant interact interface to display to and gather information from the user, through any Web UI framework of our choice."
  },
  {
    "objectID": "/tut/rps/#p_433",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "If we wanted to deploy this application to the world, then we would take the static files that React produces and host them on a Web server. These files embed your compiled Reach program, so there's nothing more to do than provide them to the world."
  },
  {
    "objectID": "/tut/rps/#p_434",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In the next section, we'll summarize where we've gone and direct you to the next step of your journey to decentralized application mastery."
  },
  {
    "objectID": "/tut/rps/#p_435",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Reach integrates with all Web interface libraries, like React, Vue, and so on, because Reach frontends are just normal JavaScript programs."
  },
  {
    "objectID": "/tut/rps/#p_436",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "True"
  },
  {
    "objectID": "/tut/rps/#p_437",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Reach accelerates your development with React by baking-in a React development server and the deployment process to test React programs locally."
  },
  {
    "objectID": "/tut/rps/#p_438",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "True"
  },
  {
    "objectID": "/tut/rps/#p_439",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Let's review what we've done through this tutorial:"
  },
  {
    "objectID": "/tut/rps/#p_440",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In part one, we saw how Reach can be installed with one command on almost any system without any dependencies beyond what most developers have anyways."
  },
  {
    "objectID": "/tut/rps/#p_441",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In part two, we saw how Reach programs have a succinct setup that easily abstracts the details of your chosen consensus network into a couple lines and three key API calls."
  },
  {
    "objectID": "/tut/rps/#p_442",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In part three, we saw how Reach allows developers to focus on the business logic of their decentralized application and look past the nitty-gritty details of blockchain interaction and protocol design."
  },
  {
    "objectID": "/tut/rps/#p_443",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In part four, we saw that it is just as easy for Reach to deal with tokens and network transactions as it is to deal with data sharing."
  },
  {
    "objectID": "/tut/rps/#p_444",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In part five, we introduced you to the Reach automatic formal verification engine and its ability to ensure our program doesn't have entire categories of flaws and security vulnerabilities."
  },
  {
    "objectID": "/tut/rps/#p_445",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In part six, we saw how Reach allows you to specify how to deal with non-participation and protect against funds being locked in contracts."
  },
  {
    "objectID": "/tut/rps/#p_446",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In part seven, we saw how Reach can express arbitrary length interactions and how flexible the Reach frontends are to variations in the backend."
  },
  {
    "objectID": "/tut/rps/#p_447",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In part eight, we saw how to decouple your Reach program from the Reach standard testing environment and launch an interactive version on a real network."
  },
  {
    "objectID": "/tut/rps/#p_448",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "In part nine, we saw how to deploy your Reach program as a fully decentralized Web application."
  },
  {
    "objectID": "/tut/rps/#p_449",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Despite having done so much, this is really just a brief introduction to what is possible with Reach."
  },
  {
    "objectID": "/tut/rps/#p_450",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "How difficult was all this? Let's look at the final versions of our programs."
  },
  {
    "objectID": "/tut/rps/#p_451",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "First, let's look at the Reach program:"
  },
  {
    "objectID": "/tut/rps/#p_452",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Next, the JavaScript command-line frontend:"
  },
  {
    "objectID": "/tut/rps/#p_453",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "And finally, the Web frontend:"
  },
  {
    "objectID": "/tut/rps/#p_454",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "We wrote about a hundred lines of Reach and two different frontends. Our command-line version is about a hundred lines of JavaScript, while our Web version is about the same length, but has a lot of presentation code as well."
  },
  {
    "objectID": "/tut/rps/#p_455",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Behind the scenes, Reach generated hundreds of lines of Solidity (which you can look at here: rps-8-interact/build/index.main.sol), almost two thousand lines of TEAL (which you can look at here: rps-8-interact/build/index.main.appApproval.teal), as well as over a thousand lines of JavaScript (which you can look at here: rps-8-interact/build/index.main.mjs). If we weren't using Reach, then we'd have to write all this code ourselves and ensure that they are consistent and updated at every change to the application."
  },
  {
    "objectID": "/tut/rps/#p_456",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Now that you've seen an entire Reach application from beginning to end, it's time for you to start working on your own applications!"
  },
  {
    "objectID": "/tut/rps/#p_457",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "You may want to start the workshop, which is a self-study course on practicing and learning Reach through different specific projects."
  },
  {
    "objectID": "/tut/rps/#p_458",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Or, maybe you'd like to spend some time in the guide learning about the background of some of the concepts used in Reach programs."
  },
  {
    "objectID": "/tut/rps/#p_459",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Or, maybe it's time for you to dive into the reference and look into the minutiae of Reach's features."
  },
  {
    "objectID": "/tut/rps/#p_460",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Finally, you may like to repeat a portion of this tutorial, but using a language other than JavaScript, like Python or Go!"
  },
  {
    "objectID": "/tut/rps/#p_461",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "No matter what you decide to read or work on next, we hope you'll join us on the Discord community. Once you join, message @team, I just completed the tutorial! and we'll give you the tutorial veteran role, so you can more easily help others work through it!"
  },
  {
    "objectID": "/tut/rps/#p_462",
    "pt": "Rock, Paper, Scissors!",
    "t": 3,
    "c": "Thanks for spending your afternoon with us!"
  },
  {
    "objectID": "/tut/rsvp/#tut-rsvp",
    "pt": "Répondez S'il Vous Plaît",
    "t": 2,
    "c": "Répondez S'il Vous Plaît"
  },
  {
    "objectID": "/tut/rsvp/#tut-rsvp1",
    "pt": "Répondez S'il Vous Plaît",
    "t": 2,
    "c": "Respond, If You Please"
  },
  {
    "objectID": "/tut/rsvp/#tut-rsvp2",
    "pt": "Répondez S'il Vous Plaît",
    "t": 2,
    "c": "Participate, Please"
  },
  {
    "objectID": "/tut/rsvp/#tut-rsvp3",
    "pt": "Répondez S'il Vous Plaît",
    "t": 2,
    "c": "Yo Dawg..."
  },
  {
    "objectID": "/tut/rsvp/#tut-rsvp4-tests",
    "pt": "Répondez S'il Vous Plaît",
    "t": 2,
    "c": "Test First, but Verify"
  },
  {
    "objectID": "/tut/rsvp/#tut-rsvp4-rsh",
    "pt": "Répondez S'il Vous Plaît",
    "t": 2,
    "c": "A Decentralized DApp"
  },
  {
    "objectID": "/tut/rsvp/#tut-rsvp4-mjs",
    "pt": "Répondez S'il Vous Plaît",
    "t": 2,
    "c": "My Kingdom for a Framework!"
  },
  {
    "objectID": "/tut/rsvp/#tut-rsvp5-api",
    "pt": "Répondez S'il Vous Plaît",
    "t": 2,
    "c": "The API and The Map"
  },
  {
    "objectID": "/tut/rsvp/#tut-rsvp5-rsh",
    "pt": "Répondez S'il Vous Plaît",
    "t": 2,
    "c": "Programming with APIs and Maps"
  },
  {
    "objectID": "/tut/rsvp/#tut-rsvp5-mjs",
    "pt": "Répondez S'il Vous Plaît",
    "t": 2,
    "c": "Testing our APIs and Maps"
  },
  {
    "objectID": "/tut/rsvp/#tut-rsvp6-rsh",
    "pt": "Répondez S'il Vous Plaît",
    "t": 2,
    "c": "A View To An Event"
  },
  {
    "objectID": "/tut/rsvp/#tut-rsvp6-mjs",
    "pt": "Répondez S'il Vous Plaît",
    "t": 2,
    "c": "The Panopticon"
  },
  {
    "objectID": "/tut/rsvp/#tut-rsvp7",
    "pt": "Répondez S'il Vous Plaît",
    "t": 2,
    "c": "Where Do We Go From Here?"
  },
  {
    "objectID": "/tut/rsvp/#p_0",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "This tutorial walks through the creation of a simple, but real, decentralized application. It assumes a basic familiarity with Reach, as though you've completed the Rock, Paper, Scissors! tutorial, but does not dwell on intimate details of it. Similarly, it assumes that you have Reach installed and are comfortable using it."
  },
  {
    "objectID": "/tut/rsvp/#p_1",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "In this tutorial, we'll be building a basic DApp for running events, which we'll refer to as \"RSVP\". In this DApp, a Host will run an event, like a dinner party, which Guests will attend. The Host wants the Guests to tell her if they are coming, so she accepts them to visit the DApp beforehand. The Host does not want to charge the Guests for the privilege of their company, but she is nervous that she'll order too many macaroons. Therefore, she requires that the Guests pay something when they agree to come. We call this the \"reservation\". But, when the Guests actually arrive and check-in, they will get their reservation back."
  },
  {
    "objectID": "/tut/rsvp/#p_2",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "For example, this is a plausible run of the application:"
  },
  {
    "objectID": "/tut/rsvp/#p_3",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "If everyone has $10 before the event, and the reservation is $1, then afterwards:"
  },
  {
    "objectID": "/tut/rsvp/#p_4",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "When you take this tutorial and launch your own product based on it, you should let Giles send his regrets if it is early enough! Similarly, it would be cool if you made it so that the extra $2 was split between the Guests and the Host. But, we won't implement these features today."
  },
  {
    "objectID": "/tut/rsvp/#p_5",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "When you build DApps, it is essential that you think through these kinds of scenarios first, before you start writing code, because they will help you know where to start and know when you are done."
  },
  {
    "objectID": "/tut/rsvp/#p_6",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "If you have done a prior Reach tutorial, like Rock, Paper, Scissors!, then you are probably wondering what the participants in this program are."
  },
  {
    "objectID": "/tut/rsvp/#p_7",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Should we have a Host participant and a Guest participant?"
  },
  {
    "objectID": "/tut/rsvp/#p_8",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Should we have a Host participant, as well as the participants Guest1, Guest2, up through Guest5?"
  },
  {
    "objectID": "/tut/rsvp/#p_9",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "If we do the first, then how will we have five guests, like in Buffy's example? If we do the second, then what if Jenny decides to come? Would we need a totally different program?"
  },
  {
    "objectID": "/tut/rsvp/#p_10",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "The second idea is really bad and we should absolutely not do anything like unto it. The first idea is not always dumb, but it turns out we're going to do something else for this application. However, since it is sometimes a good idea, let's elaborate on what it means and why it can be valuable."
  },
  {
    "objectID": "/tut/rsvp/#p_11",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "If we had a Reach application with just two participants, one for the Host and one for the Guest, then if we had many Guests, we would need to have many different instances of the application. This is similar to the Rock, Paper, Scissors! application, where each instance plays exactly one game, but you can run the application as many times as you want."
  },
  {
    "objectID": "/tut/rsvp/#p_12",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "For our event reservation application, each instance of the application would handle the registration of one Guest and we would build a user interface that supports launching many instances and (for the Host) managing each instance. This is a \"decentralized\" decentralized application (a \"De-DApp\"), because there are many instances of the same application with a common user interface. Sometimes people refer to \"De-DApp\"s as \"protocols\", because they are trying to emphasize the idea that there are many instances which all speak a common language."
  },
  {
    "objectID": "/tut/rsvp/#p_13",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "In contrast, there are \"centralized\" decentralized applications (\"Ce-DApps\") where there is one single instance that manages all interactions within the application."
  },
  {
    "objectID": "/tut/rsvp/#p_14",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Some features are easier to build into De-DApps and others are more difficult, but are easier with Ce-DApps. For example, we speculate that it is easier to add the feature that Guests who show up can split the abandoned reservations in a Ce-DApp than a De-DApp."
  },
  {
    "objectID": "/tut/rsvp/#p_15",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "This concept of Ce-DApps and De-DApps is artistic and humanistic: there is no definitive technical definition. In particular, there is a spectrum of centralization. For example, just as we can imagine one application for a single Event but for all Guests, we can imagine one application for all Events and all Guests of that Event. In that sense, we've just spoken about \"De-De-DApps\" (decentralized-decentralized-decentralized applications) and \"De-Ce-DApps\" as opposed to \"Ce-Ce-DApps\"."
  },
  {
    "objectID": "/tut/rsvp/#p_16",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "We are going to demonstrate the \"decentralized\" style, because it introduces fewer new Reach concepts, but we believe that the \"centralized\" design is more appropriate for this application."
  },
  {
    "objectID": "/tut/rsvp/#p_17",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "But, rather than jumping into the Reach program, we're going to put our money where our mouth is and write a test scenario corresponding to Buffy's Birthday Bash. We'll demonstrate how to use Reach's testing tools to write a convenient testing framework customized for your application. We'll show the tests, then the framework, then the Reach code, and show how the Reach code connects to the framework. This structure is overly complex for this simple application, but it is under complex for what it takes to build a \"real\" DApp."
  },
  {
    "objectID": "/tut/rsvp/#p_18",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "We're going to use this exact same testing for each of the different versions of the application we build today, but each version will have a slightly different \"framework\" that connects totally different Reach code."
  },
  {
    "objectID": "/tut/rsvp/#p_19",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Let's get started:"
  },
  {
    "objectID": "/tut/rsvp/#p_20",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "In this sample, we use {!js} test.one to define a single test scenario. We use the function {!js} makeRSVP, which we will define later, to create a JavaScript object for the Event abstraction. When it is created, it has the details of the event in it."
  },
  {
    "objectID": "/tut/rsvp/#p_21",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Next, we define objects for each of the people involved in the scenario. This code uses {!js} Event.makeGuests, a function which we will define later, to turn a list of labels into Guest abstractions."
  },
  {
    "objectID": "/tut/rsvp/#p_22",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Next, we have each one of the Scoobies declare that they will go to the event, and therefore pay the reservation."
  },
  {
    "objectID": "/tut/rsvp/#p_23",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Next, we wait for the deadline and have people start showing up, or not. In the case of Angel, when he says he'll go, there's an error, because he's late. {!js} err is a constant we'll define later that is the text of the error message from the consensus network indicating that there was a problem submitting the transaction. Similarly, in the case of Jonathan, when he tries to show up, there's an error."
  },
  {
    "objectID": "/tut/rsvp/#p_24",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Finally, we print out the balances of everyone and see that they match our expectations. The function {!js} test.run instructs Reach to run all of the tests and not print out extra debugging information."
  },
  {
    "objectID": "/tut/rsvp/#p_25",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Here's what an example run looks like on Algorand:"
  },
  {
    "objectID": "/tut/rsvp/#p_26",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "This sample contains extra printouts we didn't show, because they are embedded in the \"framework\" (i.e. {!js} makeRSVP) that we'll show later."
  },
  {
    "objectID": "/tut/rsvp/#p_27",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Ideally, we would make real tests that assert that these numbers are correct, but in practice it is very difficult to do so, because of protocol fees and (on networks like Algorand) rewards. One work around for this is to use deliberately huge numbers (like a reservation of 50) and have tests that do \"epsilon comparison\" (i.e. rather than writing {!js} x == y, you write {!js} (x - y) <= epsilon, where epsilon is a small number). We won't bother with that today, however."
  },
  {
    "objectID": "/tut/rsvp/#p_28",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Now that we've shown the test case that we'll use for every version, let's look at the \"decentralized\" version of this DApp."
  },
  {
    "objectID": "/tut/rsvp/#p_29",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Recall, that in the \"decentralized\" version, there will be one instance of the application for every Guest that goes to the Event. Since the Host can't know how many Guests there are going to be, she cannot create all of the instances. So, in our design, the Guest will create the instance themselves. When the Guest checks in, they have to tell the Host about the instance so the Host can interact with it and return the reservation. The Host will have to check to make sure the instance is for the correct Event. On the other hand, if the Guest doesn't check in, then the Host has to find out about the instance somehow and claim the reservation. (This \"somehow\" is why this may not be the best design for this application.)"
  },
  {
    "objectID": "/tut/rsvp/#p_30",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "First, we define a type that represents the details of the event. It contains the name of the event (\"Buffy's Birthday Bash...\"), as well as the reservation price, the deadline, and the host's address."
  },
  {
    "objectID": "/tut/rsvp/#p_31",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Second, we define the application and the two participants, the Host, and the Guest."
  },
  {
    "objectID": "/tut/rsvp/#p_32",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "As mentioned above, the first thing that happens in the program is that the Guest launches the instance by doing the first publication. They publish the details of the event, which they had to get from the Host somehow. (Another \"somehow\"!) And they have to pay the reservation fee."
  },
  {
    "objectID": "/tut/rsvp/#p_33",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "We enforce that the current time on the network is before the deadline. This is not strictly necessary, but it will be convenient and helpful for end users."
  },
  {
    "objectID": "/tut/rsvp/#p_34",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "What is {!rsh} enforce?"
  },
  {
    "objectID": "/tut/rsvp/#p_35",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "It is similar to {!rsh} require, except that Reach does not guarantee that there is an {!rsh} assume that dominates it. This means that honest actors may submit publications that will not be satisfied, because they violate the property. You should use this sparingly and only for properties that cannot be checked locally, like things related to time (as in this case) or things related to external {!rsh} remote objects."
  },
  {
    "objectID": "/tut/rsvp/#p_36",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Finally, the Guest is informed, via their registered {!rsh} interact function, about the contract's identity, so they can share it with the Host."
  },
  {
    "objectID": "/tut/rsvp/#p_37",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Did you notice that the {!rsh} interact function was called outside of an {!rsh} only block and within a consensus step?"
  },
  {
    "objectID": "/tut/rsvp/#p_38",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "When an {!rsh} interact function returns {!rsh} Null, it can be called via the short-hand {!rsh} Participant.interact.f(....). This a short-hand for writing {!rsh} Participant.only(() => interact.f(....))."
  },
  {
    "objectID": "/tut/rsvp/#p_39",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "When a local step (such as the {!rsh} interact short-hand) appears in a consensus step, it will run after the consensus step is confirmed, whenever the participant learns about that confirmation."
  },
  {
    "objectID": "/tut/rsvp/#p_40",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "It is now time for the Host to show up and declare what should happen to the reservation. First, the Host checks to see if the details are correct. If they are, then the Host publishes a boolean for whether the Guest really showed up or not. When they publish, it is checked locally and consensually whether the sender is the specified Host. We ensure that the time is after the deadline, and then send the reservation to the appropriate place."
  },
  {
    "objectID": "/tut/rsvp/#p_41",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "What is {!rsh} check?"
  },
  {
    "objectID": "/tut/rsvp/#p_42",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "It is like {!rsh} assume and {!rsh} require, except that it morphs into whichever is appropriate given the context of its use. This is convenient for writing functions that validate input data that can be used locally (like {!rsh} assume) and in consensus (like {!rsh} require)."
  },
  {
    "objectID": "/tut/rsvp/#p_43",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "How does the Guest know that the Host is going to be honest and report that they attended accurately?"
  },
  {
    "objectID": "/tut/rsvp/#p_44",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "There is no way for the Guest to enforce this. They must trust the Host to do this correctly, just like they need to trust that the Host is not going to throw a lame party. This is an example of the so-called \"oracle problem\" in consensus networks: when you want to represent on-chain information that is only available off-chain, you must have some trusted party that can bridge the information from the \"real\" world into the consensus network. In this case, the Host is the Oracle."
  },
  {
    "objectID": "/tut/rsvp/#p_45",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "This application works well and we'll be able to run our test scenario. It is extremely simple, as a Reach program, but its main downside is that it requires complexity outside of the consensus network."
  },
  {
    "objectID": "/tut/rsvp/#p_46",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "For example, how does the Host inform Guests what the proper event details are? We assume that the Host is going to have a Web page that shows these events in a machine-readable format, like a QR code, which the RSVP application will consume and automatically use as the {!rsh} details variable. One precise way this could work is that the Host goes to the RSVP application site, enters the information, and gets a custom link where this information is embedded in the URL, like https://rsvp.app/event?d=SXQncyBhIHNlY3JldCB0byBldmVyeW9uZQo=, and when they share the link, the application will be in \"Guest mode\". The link could also contain things that are useful outside of the core consensus program, like a link to a banner image and other important details. This would be a completely stateless way to implement the application."
  },
  {
    "objectID": "/tut/rsvp/#p_47",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Similarly, how do the Guests inform the Host about their instance of the program? One strategy for this is that the RSVP application generates a QR code which is an encoded form of their {!rsh} getContract value. When the Guest arrives at the event, they show the QR code, which the Host scans with the RSVP application in \"Host mode\" and then it runs the next step of the program."
  },
  {
    "objectID": "/tut/rsvp/#p_48",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "But, how does the Host find out about Guests that reserved, but never came? In one way, it doesn't matter: the Host doesn't want the money, she just wants the Guest to have an incentive to come. That answer is very unsatisfying though."
  },
  {
    "objectID": "/tut/rsvp/#p_49",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "There are roughly two alternatives:"
  },
  {
    "objectID": "/tut/rsvp/#p_50",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "First, the Guest could tell the Host up-front that they are coming, but they would have to do that off-chain, such as by the RSVP application tracking it in a centralized database or encouraging the Guest to send an automated email or SMS message."
  },
  {
    "objectID": "/tut/rsvp/#p_51",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Second, the Host could search the consensus network for all instances of the RSVP application with matching details and then deliberately interact with and claim the funds."
  },
  {
    "objectID": "/tut/rsvp/#p_52",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "The first option is \"centralized\", while the second option is \"decentralized\". (It appears, we now have a \"decentralized, decentralized, decentralized, decentralized application\" design, if we go with the second option.)"
  },
  {
    "objectID": "/tut/rsvp/#p_53",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Both of these options are tedious and annoying, so we will eventually use a different technique to engineer the RSVP application. But before we do that, let's look at the JavaScript framework that makes our test scenario work. It makes explicit these issues about who (Guest or Host) does what, when, and how."
  },
  {
    "objectID": "/tut/rsvp/#p_54",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "In Test First, but Verify, we showed a set of tests which we will use for each instance of the RSVP application code. In A Decentralized DApp, we showed the Reach program that implements an extremely decentralized version of this program. In this section, we show the testing framework that connects these two things."
  },
  {
    "objectID": "/tut/rsvp/#p_55",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "This framework needs to provide:"
  },
  {
    "objectID": "/tut/rsvp/#p_56",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "{!js} makeRSVP // :: Details -> Event --- A function which accepts the details of an event and returns an Event abstraction."
  },
  {
    "objectID": "/tut/rsvp/#p_57",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "{!js} Event.Host // :: Person --- An abstraction of the Host."
  },
  {
    "objectID": "/tut/rsvp/#p_58",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "{!js} Event.makeGuests // :: [string] -> Promise<[Guest]> --- A function that produces an array of Guest abstractions, which are subclasses of People abstractions."
  },
  {
    "objectID": "/tut/rsvp/#p_59",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "{!js} Guest.willGo // :: -> Promise<void> --- A function for one guest to make a reservation."
  },
  {
    "objectID": "/tut/rsvp/#p_60",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "{!js} Event.waitUntilDeadline // :: -> Promise<void> --- A function that waits until the deadline has passed."
  },
  {
    "objectID": "/tut/rsvp/#p_61",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "{!js} Guest.showUp // :: -> Promise<void> --- A function for one guest to be checked in."
  },
  {
    "objectID": "/tut/rsvp/#p_62",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "{!js} Guest.noShow // :: -> Promise<void> --- A function for one guest to be indicated as failing to check in."
  },
  {
    "objectID": "/tut/rsvp/#p_63",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "{!js} Person.getBalance // :: -> Promise<UInt> --- A function to read one person's balance."
  },
  {
    "objectID": "/tut/rsvp/#p_64",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "We'll talk about each of these in turn."
  },
  {
    "objectID": "/tut/rsvp/#p_65",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "First, we have the basic header that imports and initializes the Reach standard library. The only interesting thing here is the definition of the various error messages for each network connector."
  },
  {
    "objectID": "/tut/rsvp/#p_66",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "We define the {!js} makeRSVP function and create an initial test account for the host and set its label for debugging."
  },
  {
    "objectID": "/tut/rsvp/#p_67",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Next, we define the function stdPerson which takes an obj with an acc field and adds a {!js} Person.getBalance function that returns the account's current balance as a nice formatted string. We use this function to define the {!js} Event.Host value."
  },
  {
    "objectID": "/tut/rsvp/#p_68",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Next, we define the deadline, based on the current time, and the {!js} Event.waitUntilDeadline function for waiting until that time has passed."
  },
  {
    "objectID": "/tut/rsvp/#p_69",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Now, we can define the details object that will be consumed by Reach. This value will be in scope for each of the Guests, which represents the Event details being shared with all the Guests. We use accHost for the host field, because Reach can convert account abstractions into {!rsh} Address values."
  },
  {
    "objectID": "/tut/rsvp/#p_70",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "We define the {!js} Event.makeGuest function, which starts by creating a new test account and setting its label."
  },
  {
    "objectID": "/tut/rsvp/#p_71",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "We define the {!js} Guest.willGo function, which spawns a new contract that runs as the Guest participant. It uses {!js} stdlib.withDisconnect and {!js} stdlib.disconnect to stop running after the registered {!rsh} interact function has been called with the contract information. This information is returned from {!js} stdlib.withDisconnect, so ctcInfo is set to the actual contract that was deployed. In a real deployment, this contract information would be presented the user as something like a QR code for them to save and show to the Host later."
  },
  {
    "objectID": "/tut/rsvp/#p_72",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "We define the two functions {!js} Guest.showUp and {!js} Guest.noShow by defining a common function doHost that accepts a boolean. This function throws an error if there was never a reservation, which we know because the ctcInfo variable is undefined. Although the function is inside of the Guest object, it uses the Host's account abstraction to attach to an instance of the program. It has access to details object, so it can ensure that they match."
  },
  {
    "objectID": "/tut/rsvp/#p_73",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "We close the definition of the Guest abstraction by calling stdPerson to add the {!js} Person.getBalance function. Then, we define {!js} Event.makeGuests, which produces a single promise out of the array of promises of Guest abstractions. These values are all wrapped together into a final object, which is the result of {!js} makeRSVP."
  },
  {
    "objectID": "/tut/rsvp/#p_74",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "At this point, we have a completely working DApp and testing framework. But, turning this into a viable product and usable experience is more difficult."
  },
  {
    "objectID": "/tut/rsvp/#p_75",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Rather than do that, we're going to switch gears and show a different way to write this application that is a centralized DApp."
  },
  {
    "objectID": "/tut/rsvp/#p_76",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Recall that our previous version uses one instance for every Guest that goes to an Event and that this is tedious for the Host to communicate to the Guests what the Event details are and difficult for the Guests to communicate to the Host that they are intending to come and for the Host to note whether the Guests actually came."
  },
  {
    "objectID": "/tut/rsvp/#p_77",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "The key source of this tediousness is its over decentralization: the information is spread throughout the system and duplicated many times. In some ways, this kind of decentralization is very valuable, because it means that there is not a single-point-of-failure, like how your body has many many different immune cells rather than a single giant immune cell. However, that benefit is unnecessary when we are already running on a consensus network, where decentralization at the base layer provides trustlessness at the application layer. Indeed, the difficulty of the over decentralized model leads some designer to build an off-chain centralized database, like a database of the active events, because it is so difficult to query the consensus network for matching application instances. Those centralized databases become a trusted point-of-failure that are worthy targets of attack and exploitation."
  },
  {
    "objectID": "/tut/rsvp/#p_78",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Instead, we're going to write a version of RSVP using a single instance."
  },
  {
    "objectID": "/tut/rsvp/#p_79",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "If you're only familiar with Reach from the Rock, Paper, Scissors! tutorial, then you should be wondering, \"But how are you going to let any number of Guests join? And where will you store their information?\" We're going to use two new concepts to implement this:"
  },
  {
    "objectID": "/tut/rsvp/#p_80",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "APIs --- which are a source of publications that do not originate in a participant are a source of asynchronous input events to the consensus network."
  },
  {
    "objectID": "/tut/rsvp/#p_81",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Mappings --- which are a database of values that grow linearly over the lifetime of the program."
  },
  {
    "objectID": "/tut/rsvp/#p_82",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "We will define an API that Guests can call to register for an Event and we'll define another API that the Host can call whenever they want to report whether a Guest showed up."
  },
  {
    "objectID": "/tut/rsvp/#p_83",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "We will define a Mapping that records whether a Guest has registered and we will clear that record when the Host reports their attendance."
  },
  {
    "objectID": "/tut/rsvp/#p_84",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Since API publications do not come from participants, but could come from any number of actors in the consensus network, including other contracts, AND because Mappings can grow linearly in the number of actors that interact with the program, there is no limit to the number of Guests!"
  },
  {
    "objectID": "/tut/rsvp/#p_85",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "The overall structure of our application will be:"
  },
  {
    "objectID": "/tut/rsvp/#p_86",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "The Host creates an application instance."
  },
  {
    "objectID": "/tut/rsvp/#p_87",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Guests repeatedly make reservations, before the deadline."
  },
  {
    "objectID": "/tut/rsvp/#p_88",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "The Host repeatedly reports whether Guests come."
  },
  {
    "objectID": "/tut/rsvp/#p_89",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "The program ends when all reserved Guests are accounted for."
  },
  {
    "objectID": "/tut/rsvp/#p_90",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Let's dig into the code!"
  },
  {
    "objectID": "/tut/rsvp/#p_91",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "We define an object for the details of the Event, which is the same as before."
  },
  {
    "objectID": "/tut/rsvp/#p_92",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "We define the participant and then the two APIs."
  },
  {
    "objectID": "/tut/rsvp/#p_93",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "The participant, Admin, is the one that actually creates the instance. In most cases, this will be the Host, but we don't restrict it so it has to be the same person."
  },
  {
    "objectID": "/tut/rsvp/#p_94",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "The first API, Guest, is for Guests to call and it has just a single function. On-chain, this function will be callable as Guest_register, according to whatever the ABI standard is for the chain. Off-chain, Reach provides an interface in its standard library to call it as {!js} ctc.apis.Guest.register()."
  },
  {
    "objectID": "/tut/rsvp/#p_95",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "The second API, Host is for the Host to call as they check-in (or note the failure to show) of Guests. It takes two arguments: the first for who the Guest is and the second for whether they showed up, or not. It can be called on-chain as Host_checkin and off-chain with {!js} ctc.apis.Host.checkin(guest, showed)."
  },
  {
    "objectID": "/tut/rsvp/#p_96",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "We publish the details, unpack them, and signal to the creator that the contract has been launched. However, we do not {!rsh} commit(), because we are going to do something else in the consensus."
  },
  {
    "objectID": "/tut/rsvp/#p_97",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "This is a very dense code sample with lots of new ideas if you're only familiar with basic Reach. It is worth studying closely, because these ideas are used over and over in complex Reach programs."
  },
  {
    "objectID": "/tut/rsvp/#p_98",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "First, we define a new {!rsh} Map that stores a boolean value for each address used as a key. We're going to use this to store the set of Guest accounts. (There is a {!rsh} Set container available too that abstracts this pattern, but we're going to show the \"raw\" version to explain mappings in detail.)"
  },
  {
    "objectID": "/tut/rsvp/#p_99",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "We can set entries in the mapping by writing {!rsh} Guests[addr] = bool (or {!rsh} delete Guests[addr] to remove them). We will be able to access entries of the mapping by writing {!rsh} Guests[addr], which will evaluate to a {!rsh} Maybe(Bool) value. It will be {!rsh} None() if the value is not set. It will be {!rsh} Some(bool) if the value is set."
  },
  {
    "objectID": "/tut/rsvp/#p_100",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Some people find {!rsh} Maybes to be tedious, but they are an important protection against NULL pointer dereferences that you see in other systems."
  },
  {
    "objectID": "/tut/rsvp/#p_101",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "You may enjoy reading Sir Tony Hoare's explanation about how and why he created NULL pointers and why he has regretted it ever since. We think his cost estimate of the damage of NULL pointers at one billion dollars is too low by an order of magnitude."
  },
  {
    "objectID": "/tut/rsvp/#p_102",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Second, we start a \"parallel reduce\" block. In computer science, a reduction is when a set of data is turned into a single value; i.e. it is reduced to one value. For example, if you have a set of numbers, and you add them together, to get the sum, that's a reduction. In this case, we are reducing a set of input events (API calls) that occur in parallel to each other (meaning that they are independently chosen by their initiators) into two values, done and howMany. done is going to be a boolean that tells us if the Event is over and we can clear it from memory; it starts as {!rsh} false. howMany is a running counter of how many Guests have registered, but have not checked in; it starts as {!rsh} 0. Shortly, we'll review the code that actually reduces incoming events into updated versions of these values."
  },
  {
    "objectID": "/tut/rsvp/#p_103",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Every {!rsh} parallelReduce can be written as a {!rsh} while loop, but it is often more convenient to think about it as a separate kind of construct. Because it is a {!rsh} while loop, it must have a condition for when it terminates (a {!rsh} .while component) and loop invariants (a sequence of {!rsh} .invariant components). In our case, we have two invariants and one condition."
  },
  {
    "objectID": "/tut/rsvp/#p_104",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "The first invariant is that the variable howMany is the same as the size of the Guests mapping."
  },
  {
    "objectID": "/tut/rsvp/#p_105",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "The second invariant is that the contract's balance is the same as howMany times the number of reservations; in other words, that we can perfectly predict how much funds are in the contract's account."
  },
  {
    "objectID": "/tut/rsvp/#p_106",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "The condition is that we will continue accepting (and reducing!) input events until we are done and howMany is zero; because only then is it safe to turn off the ability to check in Guests."
  },
  {
    "objectID": "/tut/rsvp/#p_107",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "We can now show the reduction blocks for each different kind of input event."
  },
  {
    "objectID": "/tut/rsvp/#p_108",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "This uses a new form you've never seen before: the {!rsh} .api_ component. It has two arguments:"
  },
  {
    "objectID": "/tut/rsvp/#p_109",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "First, there's the API call that is actually being handled; in this case, the {!rsh} Guest.register call."
  },
  {
    "objectID": "/tut/rsvp/#p_110",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Second, there's a function that accepts the arguments to call (in this case there are none) and specifies the action."
  },
  {
    "objectID": "/tut/rsvp/#p_111",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "The action specification function is made of two parts:"
  },
  {
    "objectID": "/tut/rsvp/#p_112",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "First, there's a sequence of {!rsh} checks that validate whether the API can be validly called. In this case, we check to ensure that the Event hasn't started and that the Guest has not registered (by using the function {!rsh} isNone to test the contents of the mapping). Although we don't in this example, you can define values here that are used later in the reduction handler."
  },
  {
    "objectID": "/tut/rsvp/#p_113",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Second, there's a {!rsh} return that specifies (a) what should be paid when this call is made, and (b) what happens in the consensus when it is called, specified as a function. In this case, we have to pay the reservation price."
  },
  {
    "objectID": "/tut/rsvp/#p_114",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "The consensus reduction specification function accepts an argument (traditionally labeled ret (for \"return\") or k (for \"continuation\")) that must be called with the API call result. The function can then perform any additional checks or effects, before yielding the result (by invoking ret) and then returning updated values for the reduction."
  },
  {
    "objectID": "/tut/rsvp/#p_115",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "In this case, the function"
  },
  {
    "objectID": "/tut/rsvp/#p_116",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "ensures that it is not too late;"
  },
  {
    "objectID": "/tut/rsvp/#p_117",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "stores that the Guest is coming in the mapping;"
  },
  {
    "objectID": "/tut/rsvp/#p_118",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "yield {!rsh} null to the API caller; and,"
  },
  {
    "objectID": "/tut/rsvp/#p_119",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "increments the count of the number of Guests, howMany."
  },
  {
    "objectID": "/tut/rsvp/#p_120",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "The Host checkin function is similar. It accepts the Guest's address and whether the Host is reporting that they showed up or not. It ensures that the initiator of the API call is the Host. It ensures that the named Guest actually made a reservation. It does not make the Host pay anything. It ensures that the Host is doing this after the deadline. It removes the Guest's entry from the mapping. It transfers the reservation fee to either the Guest or the Host, depending on the value of showed. And, finally, it decrements the Guest counter and indicates that Event has started."
  },
  {
    "objectID": "/tut/rsvp/#p_121",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Finally we close the applications. We don't need to do any final {!rsh} transfers or anything like that to satisfy the token linearity property (which enforces that the contract's account is empty when it ends), because we know that we only reach the end of the {!rsh} parallelReduce when howMany is zero, and we know that the contract balance is howMany * reservation, so it must be zero in that case too."
  },
  {
    "objectID": "/tut/rsvp/#p_122",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Although we did not dwell on the verification of this program, nearly every line in the program is essential in some way and many of them are essential for passing the verification engine."
  },
  {
    "objectID": "/tut/rsvp/#p_123",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "For example, suppose that we neglected to delete the Guest's reservation entry. This means that we will decrement howMany without changing the size of the mapping, so one of the loop invariants will be incorrect. Reach will detect this error and show the following error during verification:"
  },
  {
    "objectID": "/tut/rsvp/#p_124",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "This program is interesting, because the invariants and assertions are set up in such a way that almost no other program could possibly satisfy them. In general, this is a good property to seek when you're writing trust-worthy software: you want any change to be detected by your verification engine and test suite."
  },
  {
    "objectID": "/tut/rsvp/#p_125",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "We've just walked through the Reach implementation of the RSVP application using APIs and Maps. But, now we need to show the updates to our testing framework that work with the new implementation."
  },
  {
    "objectID": "/tut/rsvp/#p_126",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "The program starts exactly the same as before:"
  },
  {
    "objectID": "/tut/rsvp/#p_127",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "But after we define the details, there's a difference:"
  },
  {
    "objectID": "/tut/rsvp/#p_128",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "We define the Host's contract handle and have them run the Admin participant, which creates and launches the single contract instance for everyone. As mentioned above, we could have a separate account do this, but we choose not to for simplicity."
  },
  {
    "objectID": "/tut/rsvp/#p_129",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "The code for guests is much simpler, because in each case we just have either the Guest call the register function or the Host call the checkin function."
  },
  {
    "objectID": "/tut/rsvp/#p_130",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Everything else about the program is the same."
  },
  {
    "objectID": "/tut/rsvp/#p_131",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "When we run the program, we will see output like:"
  },
  {
    "objectID": "/tut/rsvp/#p_132",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "This is output is effectively identical to the previous version of the program."
  },
  {
    "objectID": "/tut/rsvp/#p_133",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "This program is excellent and we wouldn't need to make any fundamentally different decisions about its design if we were to really launch the rsvp.app service. However, there are a few things that are difficult to do with the program as it is."
  },
  {
    "objectID": "/tut/rsvp/#p_134",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "For example, ideally when you go to rsvp.app/event?id=bbbb, you should be able to see some information about the Event, like who the Host is, what's the reservation price, and so on. This information is embedded in the consensus network's records and in the state of the contract instance, but it requires low-level knowledge to extract. We're going to add a {!rsh} View to the program to make it easy to access."
  },
  {
    "objectID": "/tut/rsvp/#p_135",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Similarly, we'd like to display information about how many people have already made reservations and, maybe, even who they are and when it happened. For the first of those things, we'll add another {!rsh} View; and for the second, we'll add an {!rsh} Events that will make it easy to access the record of everything that happened."
  },
  {
    "objectID": "/tut/rsvp/#p_136",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Although we're going to make changes to the Reach program, we're not actually exposing any information that wasn't already available in the consensus network's records."
  },
  {
    "objectID": "/tut/rsvp/#p_137",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "For example, the {!rsh} View is going to make it easy to read the details and howMany variables. These variables are actually stored in the consensus network's memory. It is possible, for example, to know that \"howMany is stored at memory offset 0x8008\" and that is encoded as 64 bytes in little-endian order. However, those details are extremely low-level and subject to change as the consensus network's implementation improves and Reach discovers more efficient ways to compile your program."
  },
  {
    "objectID": "/tut/rsvp/#p_138",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "By adding a {!rsh} View, we'll produce a usable API that abstracts these kinds of details for the benefit of our colleagues that create the User Interface, our future selves that need to understand the program, and our users that want to have easy access to data about themselves."
  },
  {
    "objectID": "/tut/rsvp/#p_139",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "First, we'll review the changes to the Reach application code."
  },
  {
    "objectID": "/tut/rsvp/#p_140",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "We add definitions for the {!rsh} View and {!rsh} Event objects."
  },
  {
    "objectID": "/tut/rsvp/#p_141",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Let's look at the {!rsh} View first. The first argument is a label for it, like how we give labels to APIs and participants. Next, we provide an object where the keys are the names of the view components and the fields are their types. This object is just like an {!rsh} interact object, except that the values are provided from Reach, rather than to Reach. In this case, like APIs, these values can be accessed on- and off-chain. On-chain, they can be accessed using the normal ABI of the consensus network, just like APIs. For example, the details are provided via a function named Info_details that takes no arguments and returns a Details structure, and there's a function named Info_reserved that accepts an address and returns a boolean indicating if they've made a reservation. Off-chain, they can be accessed via a frontend function like {!js} ctc.views.Info.details(). The off-chain function returns the value or an indication that it was not available."
  },
  {
    "objectID": "/tut/rsvp/#p_142",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Next, let's look at the {!rsh} Events definition. It can also be provided with a label, but we've chosen not to include one. We don't have to provide labels for {!rsh} APIs or {!rsh} Views either, but we think it is a good idea in those cases. The object provided to {!rsh} Events is not an interface, where the keys are types, but instead has tuples of types as the values. These are the values that will be emitted together. For example, the register event will contain one address, while the checkin event will contain an address and a boolean. Like APIs and Views, they are available on- and off-chain. On-chain, they are available using the standard ABI for the platform. (Although, note, that some chains, like Ethereum, don't provide any on-chain mechanism for consuming events.) Off-chain, they are available via a frontend function like {!js} ctc.events.register. The off-chain function has sub-methods for reading the next instance of the event or monitoring every event, as well as other options."
  },
  {
    "objectID": "/tut/rsvp/#p_143",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "In both cases, we have not actually defined the values or meaning of these Views and Events. We've merely indicated that our application contains them. This is similar to how we define a Participant and then later indicate what actions it performs. Let's look at the view definitions next."
  },
  {
    "objectID": "/tut/rsvp/#p_144",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "A View can have a different value at each point in the program, including not having any value at all. You define the value by calling {!rsh} View.field.set and providing a value that satisfies the type. For example, here (on line 40) we indicate that the details field is always the same as the details variable. This definition applies to all dominated occurrences of the {!rsh} commit() keyword. Views are not mutable references: instead, they are ways of naming, for external consumption, portions of the consensus state."
  },
  {
    "objectID": "/tut/rsvp/#p_145",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "We similarly expose the contents of the Guests mapping, as well as the howMany variable. We use the {!rsh} .define feature of {!rsh} parllelReduce to introduce a statement that dominates the {!rsh} commit()s implicit in the {!rsh} parallelReduce. This context is the only context that has access to the howMany variable, which is why we must place it there."
  },
  {
    "objectID": "/tut/rsvp/#p_146",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Next, let's look at the code that emits instances of the {!rsh} Events we defined."
  },
  {
    "objectID": "/tut/rsvp/#p_147",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "We can emit an event by calling {!rsh} Events.kind(args) in a consensus step. We do so inside of the {!rsh} .api_ for the Guest.register API call on line 58."
  },
  {
    "objectID": "/tut/rsvp/#p_148",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "We do the same for the Host.checkin event on line 70. It is typical to emit events just before or after yield a result to the API caller."
  },
  {
    "objectID": "/tut/rsvp/#p_149",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "We've now exposed information about the state and history of the RSVP application to callers. If we were going to build a real version of this application, we'd include calls to the {!rsh} View functions in the user interface and provide an event logger that monitors the {!rsh} Events. However, we'll delay that for another time. Instead, we'll just make a few simple changes to the test framework to demonstrate how to use these functions."
  },
  {
    "objectID": "/tut/rsvp/#p_150",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "First, we'll have the Host monitor all registrations for this event. {!js} ctcHost.events.register.monitor(f) is a function that calls f once for every event. f is called with an object that has a when field and a what field. when is the time when the event was emitted from the consensus network. what is an array of the values that were included with the event. In this code, we extract those fields and print out a message on every registration. This is representative of a user interface that shows the Host each registration as it happens."
  },
  {
    "objectID": "/tut/rsvp/#p_151",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "We've added a gas limit using {!js} stdlib.setGasLimit for testing on Ethereum. Normally the gas limit is computed by looking at the contract code, but it is not always accurate. There is always a gas limit, even if we don't specify anything. We've set the \"limit\" to the largest possible amount of gas that could ever be spent. Thus, we're removing the limit by setting it to be \"infinity\"."
  },
  {
    "objectID": "/tut/rsvp/#p_152",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Next, we modify the willGo function so that the Guest, before they register, inspects the event details and looks at the reservation price. This is representative of a user interface that informs the Guest of how much they'll be expected to pay to make a reservation. In this code, we call {!js} ctcGuest.unsafeViews, because when the view is not defined, it throws an error, rather than returning a special wrapper object. We know that it will always be defined, so it is more convenient to use this, than to worry about decoding the wrapper object."
  },
  {
    "objectID": "/tut/rsvp/#p_153",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "When we run this version of the program, it behaves exactly the same as before in all important ways, but has a slightly different output:"
  },
  {
    "objectID": "/tut/rsvp/#p_154",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "We've implemented a full DApp for managing events RSVPs in less than 80 lines of Reach code. In less than a hundred lines of JavaScript, we have a testing system where we can implement test scenarios to ensure it is correct. This is a lot to do in an afternoon, but it is better than writing the 3,000 lines of Solidity, TEAL, and JavaScript support code that Reach generated for us!"
  },
  {
    "objectID": "/tut/rsvp/#p_155",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "You should now be asking, Where Do We Go From Here? You now understand..."
  },
  {
    "objectID": "/tut/rsvp/#p_156",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "How to design decentralized and centralized DApps;"
  },
  {
    "objectID": "/tut/rsvp/#p_157",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "How to use {!rsh} APIs in Reach programs;"
  },
  {
    "objectID": "/tut/rsvp/#p_158",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "How to use {!rsh} Maps in Reach programs;"
  },
  {
    "objectID": "/tut/rsvp/#p_159",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "How to define {!rsh} Views, for observing Reach programs internal state;"
  },
  {
    "objectID": "/tut/rsvp/#p_160",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "How to define {!rsh} Events, for monitoring Reach program actions; and,"
  },
  {
    "objectID": "/tut/rsvp/#p_161",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "How to do it all with a testing-first framework."
  },
  {
    "objectID": "/tut/rsvp/#p_162",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "We find that many many users want to write DApps that are more like Répondez S'il Vous Plaît than Rock, Paper, Scissors!, so hopefully this tutorial will help you on your way!"
  },
  {
    "objectID": "/tut/rsvp/#p_163",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "If you want to extend this program and make it even better and more interesting, you should create a Web interface to it. The interface will work by..."
  },
  {
    "objectID": "/tut/rsvp/#p_164",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Initially showing an \"Admin\" interface, where an administrator can launch an Event contract instance."
  },
  {
    "objectID": "/tut/rsvp/#p_165",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "Upon launch, it should turn the contract information into a special URL, or QR code, that can be shared with potential Guests and the Host."
  },
  {
    "objectID": "/tut/rsvp/#p_166",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "The Guest view should allow Guests to see the Event details and the current number of reservations. It should do this without requiring the user to attach a wallet, but if they want to make a reservation, they would have to. It should check to make sure they haven't already registered first (by using the Info.reserved view)."
  },
  {
    "objectID": "/tut/rsvp/#p_167",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "The Host view should allow the Host to see who has registered and provide an interface for checking them in, either by clicking a button associated with each Notify.register event, or by scanning their address on their mobile wallet."
  },
  {
    "objectID": "/tut/rsvp/#p_168",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "There is nothing new you'd need to learn about Reach to write that Web interface, but you'd have to be good at designing and building Web applications. If you were using Algorand and wanted to provide a wallet to users who don't have an ARC11 wallet, then you'd use {!js} stdlib.walletFallback, but other than that, your code would look almost identical to our test suite, except you'd have lots of Web interface manipulation code."
  },
  {
    "objectID": "/tut/rsvp/#p_169",
    "pt": "Répondez S'il Vous Plaît",
    "t": 3,
    "c": "So, remember, there's only one thing on this earth more powerful than evil, and that's us!"
  },
  {
    "objectID": "/tut/ticket-sales/#ticket-sales",
    "pt": "Ticket Sales",
    "t": 2,
    "c": "Ticket Sales"
  },
  {
    "objectID": "/tut/ticket-sales/#p_0",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "This tutorial will demonstrate a token distribution mechanism in Reach."
  },
  {
    "objectID": "/tut/ticket-sales/#p_1",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "This token distribution DApp could be used for many different applications, but we thought it would be best used to demonstrate a decentralized DApp replacement for Ticketmaster."
  },
  {
    "objectID": "/tut/ticket-sales/#p_2",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "It assumes prior knowledge of Reach: we recommend completing the Rock, Paper, Scissors tutorial first."
  },
  {
    "objectID": "/tut/ticket-sales/#p_3",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "And maybe RSVP."
  },
  {
    "objectID": "/tut/ticket-sales/#p_4",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "And maybe Wisdom For Sale."
  },
  {
    "objectID": "/tut/ticket-sales/#p_5",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "And maybe ERC20."
  },
  {
    "objectID": "/tut/ticket-sales/#p_6",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Just do them all, you will be really good after."
  },
  {
    "objectID": "/tut/ticket-sales/#p_7",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "We assume you are working in a project folder called ticket-sales:"
  },
  {
    "objectID": "/tut/ticket-sales/#p_8",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Start by creating your files:"
  },
  {
    "objectID": "/tut/ticket-sales/#p_9",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Our application is going to allow the Administrator to provide details about the token sale and then allow users to come in and buy tokens until the contract balance is zero."
  },
  {
    "objectID": "/tut/ticket-sales/#p_10",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "At that time it will close the sale functions and transfer the total network tokens collected back to the Administrator."
  },
  {
    "objectID": "/tut/ticket-sales/#p_11",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "As with any Reach DApp, it is best to first think about who the users are in our application."
  },
  {
    "objectID": "/tut/ticket-sales/#p_12",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "There will be one Deployer (the Admin) providing the parameters of the sale, including the non-network tokens (or tickets)."
  },
  {
    "objectID": "/tut/ticket-sales/#p_13",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 4 declares a single {!rsh} Participant to bind as the Admin."
  },
  {
    "objectID": "/tut/ticket-sales/#p_14",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Lines 5-8 declares the parameters to be passed to the contract initially."
  },
  {
    "objectID": "/tut/ticket-sales/#p_15",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 10 declares a launched function, common in this style of application. Why?"
  },
  {
    "objectID": "/tut/ticket-sales/#p_16",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "We then need a dynamic amount of users whose functionality will be repeated."
  },
  {
    "objectID": "/tut/ticket-sales/#p_17",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 12 defines a dynamic amount of users, all with shared abilities."
  },
  {
    "objectID": "/tut/ticket-sales/#p_18",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 13 declares a buyTicket function that our Buyer(s) will be able to call."
  },
  {
    "objectID": "/tut/ticket-sales/#p_19",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Now we've defined our users and the functions they will be allowed, we call {!rsh} init() to start stepping through the states of our program."
  },
  {
    "objectID": "/tut/ticket-sales/#p_20",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Now the Admin can actually provide the values for the parameters we've declared. This happens in an Local Step."
  },
  {
    "objectID": "/tut/ticket-sales/#p_21",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Read more about Modes of a Reach App."
  },
  {
    "objectID": "/tut/ticket-sales/#p_22",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 17 starts the Local Step."
  },
  {
    "objectID": "/tut/ticket-sales/#p_23",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 18 declassifies the parameters and unpacks them into respective constants."
  },
  {
    "objectID": "/tut/ticket-sales/#p_24",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 20 publishes those values to the blockchain."
  },
  {
    "objectID": "/tut/ticket-sales/#p_25",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 21 {!rsh} commits to move us out of consensus step."
  },
  {
    "objectID": "/tut/ticket-sales/#p_26",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Now, the next step is to have the Admin actually pay the non-network tokens into the contract. This needs to happen in a consensus step."
  },
  {
    "objectID": "/tut/ticket-sales/#p_27",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Why then did we move out of consensus on Line 21?"
  },
  {
    "objectID": "/tut/ticket-sales/#p_28",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "The answer is that we need to {!rsh} publish the non-network token tok before we can {!rsh} pay it into the contract."
  },
  {
    "objectID": "/tut/ticket-sales/#p_29",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Reach supports network tokens by default, but a non-network token, like the one in our program, needs to be taught to Reach before you can pay it in."
  },
  {
    "objectID": "/tut/ticket-sales/#p_30",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "The general flow for paying non-network tokens:"
  },
  {
    "objectID": "/tut/ticket-sales/#p_31",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Get token info in Local Step."
  },
  {
    "objectID": "/tut/ticket-sales/#p_32",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "{!rsh} publish token info in Consensus Step."
  },
  {
    "objectID": "/tut/ticket-sales/#p_33",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "{!rsh} commit()."
  },
  {
    "objectID": "/tut/ticket-sales/#p_34",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "{!rsh} pay tokens in Consensus Step."
  },
  {
    "objectID": "/tut/ticket-sales/#p_35",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "That means our next step is to {!rsh} pay the tokens into the contract."
  },
  {
    "objectID": "/tut/ticket-sales/#p_36",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 22 pays the supply of tok from A into the contract account. This must be a syntactic tuple where the general structure is {!rsh} A.pay([networkTokenAmount, [amount, non-networkTokens]]);."
  },
  {
    "objectID": "/tut/ticket-sales/#p_37",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 23 notifies the frontend that our contract is ready to start accepting API calls, this can only be called after the first {!rsh} publish."
  },
  {
    "objectID": "/tut/ticket-sales/#p_38",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "This is a good place to pause in our Reach rsh file and get into the frontend mjs testing file."
  },
  {
    "objectID": "/tut/ticket-sales/#p_39",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Let's start with some basics."
  },
  {
    "objectID": "/tut/ticket-sales/#p_40",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 1-2 are necessary imports."
  },
  {
    "objectID": "/tut/ticket-sales/#p_41",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 3 sets a constant for the standard library and hides warning messages."
  },
  {
    "objectID": "/tut/ticket-sales/#p_42",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 4 sets a constant for the MAX number of tickets. Changing this number does so across the entire program."
  },
  {
    "objectID": "/tut/ticket-sales/#p_43",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 7 launches a new token with a MAX supply. Alternatively, you could replace tickets.id with a known testnet token id string."
  },
  {
    "objectID": "/tut/ticket-sales/#p_44",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 9 welcomes you to the ticket sales revolution. Just make sure you print enough pamphlets."
  },
  {
    "objectID": "/tut/ticket-sales/#p_45",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "It is very important for you as a programmer to understand the warning messages Reach is giving you before you silence them. Many times, these warnings are indicative of critical DApp design flaws."
  },
  {
    "objectID": "/tut/ticket-sales/#p_46",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "If you remove this from this particular program, Reach will warn you that you are using stdlib.newTestAccount and this cannot be used outside of devnet environments. When you move to TestNet, you'll need to get the users account via stdlib.getDefaultAccount()."
  },
  {
    "objectID": "/tut/ticket-sales/#p_47",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Now we'll fast forward to the end of our test suite and add the functionality for our Admin."
  },
  {
    "objectID": "/tut/ticket-sales/#p_48",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 24 creates a promise with the Admin contract handle."
  },
  {
    "objectID": "/tut/ticket-sales/#p_49",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Lines 25-28 specify the parameters of our sale."
  },
  {
    "objectID": "/tut/ticket-sales/#p_50",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 30 defines our launched function, which starts the chain of API calls to our contract with startBuyers()."
  },
  {
    "objectID": "/tut/ticket-sales/#p_51",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 35 is useful to note our test suite reached its exit normally."
  },
  {
    "objectID": "/tut/ticket-sales/#p_52",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Our frontend test suite mjs is now caught up to our Reach rsh file."
  },
  {
    "objectID": "/tut/ticket-sales/#p_53",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Let's move back to the Reach file and actually create our API function."
  },
  {
    "objectID": "/tut/ticket-sales/#p_54",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "This program ends up being short and compact because of the {!rsh} parallelReduce control structure that we'll implement to allow access to our API functions in a looping construct."
  },
  {
    "objectID": "/tut/ticket-sales/#p_55",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Read all about it in our parallelReduce Guide."
  },
  {
    "objectID": "/tut/ticket-sales/#p_56",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "In this case, we want the loop to allow the function to be callable until the contract is out of tokens. This is an important piece of information for our design."
  },
  {
    "objectID": "/tut/ticket-sales/#p_57",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 25 declares a new {!rsh} parallelReduce and sets it up to track a single value ticketsSold, which is initialized to zero."
  },
  {
    "objectID": "/tut/ticket-sales/#p_58",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 26 states an {!rsh} invariant about our loop that the network token balance will always equal cost * ticketsSold."
  },
  {
    "objectID": "/tut/ticket-sales/#p_59",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 27 states an {!rsh} invariant about our loop that the non-network token balance will always equal the initial supply - ticketsSold."
  },
  {
    "objectID": "/tut/ticket-sales/#p_60",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 28 sets our {!rsh} while loop to run until ticketsSold == supply at which point it will exit the {!rsh} parallelReduce."
  },
  {
    "objectID": "/tut/ticket-sales/#p_61",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "It is important to note the relationship between the values above."
  },
  {
    "objectID": "/tut/ticket-sales/#p_62",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "The Reach compiler will check your DApp for all of the possibilities related to your program values in an unbounded way, bound only by the limits of the data type you are working with."
  },
  {
    "objectID": "/tut/ticket-sales/#p_63",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Reach will put bounds on those checks as determined by your verification checks and {!rsh} invariants."
  },
  {
    "objectID": "/tut/ticket-sales/#p_64",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "By tightly tracking all of the {!rsh} invariant values in our {!rsh} parallelReduce LHS and {!rsh} while loop -- and relating them to the contract balance of network tokens and non-network tokens, we can satisfy the Reach Verification Engine to produce no errors."
  },
  {
    "objectID": "/tut/ticket-sales/#p_65",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Read more about How and what to verify."
  },
  {
    "objectID": "/tut/ticket-sales/#p_66",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Understanding this relationship is key to building Reach DApps."
  },
  {
    "objectID": "/tut/ticket-sales/#p_67",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Now we can actually define our API function."
  },
  {
    "objectID": "/tut/ticket-sales/#p_68",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 29 defines an API macro {!rsh} .api_ from the B API with the name buyTicket. It takes no parameters."
  },
  {
    "objectID": "/tut/ticket-sales/#p_69",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 30 starts the outer {!rsh} return. Here we sepecify a PAY_EXPR of cost and declare our {!rsh} return function ret."
  },
  {
    "objectID": "/tut/ticket-sales/#p_70",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 31 sends one non-network token (ticket) to the API caller."
  },
  {
    "objectID": "/tut/ticket-sales/#p_71",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 32 returns {!rsh} null to the caller."
  },
  {
    "objectID": "/tut/ticket-sales/#p_72",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 33 is our inner {!rsh} return, where we increment {!rsh} parallelReduce LHS value ticketsSold."
  },
  {
    "objectID": "/tut/ticket-sales/#p_73",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "On incrementing, Reach does not support incrementing with i++, because this is a mutation of i and Reach insists that we always return new, updated values."
  },
  {
    "objectID": "/tut/ticket-sales/#p_74",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Use i + 1 instead."
  },
  {
    "objectID": "/tut/ticket-sales/#p_75",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "That is all for our API member function buyTicket."
  },
  {
    "objectID": "/tut/ticket-sales/#p_76",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "After this loop terminates, the next step is to transfer the network token balance to the ticket seller."
  },
  {
    "objectID": "/tut/ticket-sales/#p_77",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 36 transfers the exact known balance back to the seller. It is bad practice to use {!rsh} transfer(balance()).to(A) here. Instead, use a formula that evaluates to the known balance."
  },
  {
    "objectID": "/tut/ticket-sales/#p_78",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 37-38 has us {!rsh} commit and {!rsh} exit the DApp."
  },
  {
    "objectID": "/tut/ticket-sales/#p_79",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "We are almost done. The final step is to test our API function by making some calls in the frontend mjs file."
  },
  {
    "objectID": "/tut/ticket-sales/#p_80",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "To test our users, we need functions to create accounts and contract information."
  },
  {
    "objectID": "/tut/ticket-sales/#p_81",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 11 is the outer function that will be called from launched to start making API calls."
  },
  {
    "objectID": "/tut/ticket-sales/#p_82",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 12 will allow for repeating actions for individual users."
  },
  {
    "objectID": "/tut/ticket-sales/#p_83",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 13-14 creates an account, funds it, and connects it to the Admins contract instance."
  },
  {
    "objectID": "/tut/ticket-sales/#p_84",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 15 has the account opt-in to our ticket token."
  },
  {
    "objectID": "/tut/ticket-sales/#p_85",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 16 is our API call. It uses the contract handle to access the Buyer.buyTicket function."
  },
  {
    "objectID": "/tut/ticket-sales/#p_86",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Line 19-20 is a looping construct for easily repeating users up to MAX."
  },
  {
    "objectID": "/tut/ticket-sales/#p_87",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "That is everything you need for a decentralized ticket-sales contract in Reach."
  },
  {
    "objectID": "/tut/ticket-sales/#p_88",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Let's run it.."
  },
  {
    "objectID": "/tut/ticket-sales/#p_89",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "If you have not specified a network via reach config, you will need to specify one with REACH_CONNECTOR_MODE."
  },
  {
    "objectID": "/tut/ticket-sales/#p_90",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "The output looks something like:"
  },
  {
    "objectID": "/tut/ticket-sales/#p_91",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Again, the number of tickets sold here can be changed by editing the MAX constant."
  },
  {
    "objectID": "/tut/ticket-sales/#p_92",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Next, we'll start working on a frontend to demonstrate integrating this Reach DApp with React."
  },
  {
    "objectID": "/tut/ticket-sales/#p_93",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "This code is open source. Nudge, nudge, wink, wink."
  },
  {
    "objectID": "/tut/ticket-sales/#p_94",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "Someone use it to unseat Ticketmaster, please."
  },
  {
    "objectID": "/tut/ticket-sales/#p_95",
    "pt": "Ticket Sales",
    "t": 3,
    "c": "We are tired of paying $3k USD for Taylor Swift tickets."
  },
  {
    "objectID": "/tut/wfs/#wfs",
    "pt": "Wisdom For Sale",
    "t": 2,
    "c": "Wisdom For Sale"
  },
  {
    "objectID": "/tut/wfs/#wfs-1",
    "pt": "Wisdom For Sale",
    "t": 2,
    "c": "Learning Objectives"
  },
  {
    "objectID": "/tut/wfs/#wfs-2",
    "pt": "Wisdom For Sale",
    "t": 2,
    "c": "Reach Modes"
  },
  {
    "objectID": "/tut/wfs/#wfs-3",
    "pt": "Wisdom For Sale",
    "t": 2,
    "c": "Reach Mode Definitions"
  },
  {
    "objectID": "/tut/wfs/#wfs-4",
    "pt": "Wisdom For Sale",
    "t": 2,
    "c": "Init Mode"
  },
  {
    "objectID": "/tut/wfs/#wfs-5",
    "pt": "Wisdom For Sale",
    "t": 2,
    "c": "Step Mode"
  },
  {
    "objectID": "/tut/wfs/#wfs-6",
    "pt": "Wisdom For Sale",
    "t": 2,
    "c": "Local Step Mode"
  },
  {
    "objectID": "/tut/wfs/#wfs-7",
    "pt": "Wisdom For Sale",
    "t": 2,
    "c": "Consensus Step Mode"
  },
  {
    "objectID": "/tut/wfs/#wfs-8",
    "pt": "Wisdom For Sale",
    "t": 2,
    "c": "Pre-coding preparation"
  },
  {
    "objectID": "/tut/wfs/#wfs-9",
    "pt": "Wisdom For Sale",
    "t": 2,
    "c": "Examine the transaction"
  },
  {
    "objectID": "/tut/wfs/#wfs-10",
    "pt": "Wisdom For Sale",
    "t": 2,
    "c": "Create the files"
  },
  {
    "objectID": "/tut/wfs/#wfs-11",
    "pt": "Wisdom For Sale",
    "t": 2,
    "c": "Create the Frontend"
  },
  {
    "objectID": "/tut/wfs/#wfs-12",
    "pt": "Wisdom For Sale",
    "t": 2,
    "c": "Create the Backened"
  },
  {
    "objectID": "/tut/wfs/#wfs-13",
    "pt": "Wisdom For Sale",
    "t": 2,
    "c": "Run the DApp"
  },
  {
    "objectID": "/tut/wfs/#wfs-14",
    "pt": "Wisdom For Sale",
    "t": 2,
    "c": "Pass an argument"
  },
  {
    "objectID": "/tut/wfs/#wfs-15",
    "pt": "Wisdom For Sale",
    "t": 2,
    "c": "Explore units and balances"
  },
  {
    "objectID": "/tut/wfs/#wfs-16",
    "pt": "Wisdom For Sale",
    "t": 2,
    "c": "Deploy the contract (seller)"
  },
  {
    "objectID": "/tut/wfs/#wfs-17",
    "pt": "Wisdom For Sale",
    "t": 2,
    "c": "Attach to the contract (buyer)"
  },
  {
    "objectID": "/tut/wfs/#wfs-18",
    "pt": "Wisdom For Sale",
    "t": 2,
    "c": "Cancel a transaction"
  },
  {
    "objectID": "/tut/wfs/#wfs-19",
    "pt": "Wisdom For Sale",
    "t": 2,
    "c": "Complete a transaction"
  },
  {
    "objectID": "/tut/wfs/#wfs-20",
    "pt": "Wisdom For Sale",
    "t": 2,
    "c": "View the contract"
  },
  {
    "objectID": "/tut/wfs/#wfs-21",
    "pt": "Wisdom For Sale",
    "t": 2,
    "c": "Review and further learning"
  },
  {
    "objectID": "/tut/wfs/#wfs-22",
    "pt": "Wisdom For Sale",
    "t": 2,
    "c": "Self Assessment"
  },
  {
    "objectID": "/tut/wfs/#p_0",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Wisdom for Sale is a command-line and Web-based application that enables two participants (a seller and a buyer) to trade wise expressions for tokens via a Reach Decentralized Application (DApp). Reach programs are built using a Docker container on your computer. If you need help installing Reach and its prerequisites then get started at our Quick Installation Guide."
  },
  {
    "objectID": "/tut/wfs/#p_1",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Wisdom For Sale creates and funds two accounts (one for each participant), enables the seller and buyer to make a transaction, and then exits."
  },
  {
    "objectID": "/tut/wfs/#p_2",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "At the end of this tutorial you will be able to:"
  },
  {
    "objectID": "/tut/wfs/#p_3",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Define essential Reach terms."
  },
  {
    "objectID": "/tut/wfs/#p_4",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Build a Reach command-line DApp."
  },
  {
    "objectID": "/tut/wfs/#p_5",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Convert the command-line DApp into a vanilla Web-app."
  },
  {
    "objectID": "/tut/wfs/#p_6",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Reach programs (the index.rsh portion of your Reach DApp) are organized into four modes: Init Mode, Step Mode, Local Step Mode, and Consensus Step Mode. Consider this diagram:"
  },
  {
    "objectID": "/tut/wfs/#p_7",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "The dark blue boxes in the diagram represent modes. The light blue boxes represent actions (functions) permitted within the mode. The red text represents functions that cause transitions between modes."
  },
  {
    "objectID": "/tut/wfs/#p_8",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Application Initialization defines participants and views."
  },
  {
    "objectID": "/tut/wfs/#p_9",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "If you want to see the entire program from the start, skip to the section View the contract later in this tutorial."
  },
  {
    "objectID": "/tut/wfs/#p_10",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Lines 2 and 3 below occur in the App Init section of the program:"
  },
  {
    "objectID": "/tut/wfs/#p_11",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "The {!rsh} init function transitions the program from App Init to Step."
  },
  {
    "objectID": "/tut/wfs/#p_12",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "A Step specifies actions taken by each and every participant. exit(), for example, is a function that must occur within a step, and it means that each and every participant exits the contract after which that instance of the contract becomes forever unavailable."
  },
  {
    "objectID": "/tut/wfs/#p_13",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "A Local Step specifies actions taken by a single participant. Local steps must occur within the body of {!rsh} only or {!rsh} each statements. Here is an example:"
  },
  {
    "objectID": "/tut/wfs/#p_14",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "{!rsh} only() and {!rsh} each() transition to a local step and then back to the originating mode (either Step or Consensus Step)."
  },
  {
    "objectID": "/tut/wfs/#p_15",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "A Consensus Step specifies actions taken by the contract itself. Later in this tutorial, the contract calls {!rsh} transfer to transfer funds from the contract to the seller."
  },
  {
    "objectID": "/tut/wfs/#p_16",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Before you start to code, it is a good idea to think about the application that you want to create and write down a plan for the actions. This makes it easier to code the app, add in all of the functionality, and be less likely to make a mistake."
  },
  {
    "objectID": "/tut/wfs/#p_17",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Wisdom for Sale requirements:"
  },
  {
    "objectID": "/tut/wfs/#p_18",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Wisdom for Sale requires two participants, a Buyer and a Seller."
  },
  {
    "objectID": "/tut/wfs/#p_19",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "The buyer will need a pay function and a function that displays the wisdom."
  },
  {
    "objectID": "/tut/wfs/#p_20",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "The seller will need a function to input the wisdom, and to put it up for sale."
  },
  {
    "objectID": "/tut/wfs/#p_21",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Both participants will be publishing information: the seller will publish the wisdom and the price, the buyer will publish their decision to purchase."
  },
  {
    "objectID": "/tut/wfs/#p_22",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "The buyer needs to be able to decide to NOT purchase the wisdom, so we need to create a function for cancelling the sale."
  },
  {
    "objectID": "/tut/wfs/#p_23",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "If the buyer does decide to buy the wisdom, then there needs to be a function that reports the payment to both the seller and the buyer."
  },
  {
    "objectID": "/tut/wfs/#p_24",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "The following diagram represents the Wisdom for Sale application flow:"
  },
  {
    "objectID": "/tut/wfs/#p_25",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "This particular transaction took place on an Algorand devnet. The Algorand cryptocurrency standard token unit is the ALGO. As indicated by the final balances in the diagram, the seller received 0.006 ALGO less than the agreed upon price, and the buyer paid 0.003 ALGO more. These expenses represent fees, the cost of doing business on a consensus network. The seller paid a little more fees than the buyer because the seller paid a small fee to deploy the contract."
  },
  {
    "objectID": "/tut/wfs/#p_26",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Create a project folder and {!cmd} cd into it via the command line."
  },
  {
    "objectID": "/tut/wfs/#p_27",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Create index.mjs and index.rsh in your project folder and open both new files in your preferred editor."
  },
  {
    "objectID": "/tut/wfs/#p_28",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Type the following code into the file named index.mjs."
  },
  {
    "objectID": "/tut/wfs/#p_29",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 1: Import the Reach JS Standard Library loader."
  },
  {
    "objectID": "/tut/wfs/#p_30",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 2: Import the JS backend compiled from index.rsh."
  },
  {
    "objectID": "/tut/wfs/#p_31",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 4: Hard-code the role. You will change this later."
  },
  {
    "objectID": "/tut/wfs/#p_32",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 5: Display the role."
  },
  {
    "objectID": "/tut/wfs/#p_33",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 7: Load the Reach JS Stdlib for the consensus network specified by {!cmd} REACH_CONNECTOR_MODE env var."
  },
  {
    "objectID": "/tut/wfs/#p_34",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 8: Display the consensus network type."
  },
  {
    "objectID": "/tut/wfs/#p_35",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 10: Define an empty (for now) common interaction object."
  },
  {
    "objectID": "/tut/wfs/#p_36",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 13: Code for when you run this app as the seller."
  },
  {
    "objectID": "/tut/wfs/#p_37",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 14: Define an empty (for now) Seller interaction object."
  },
  {
    "objectID": "/tut/wfs/#p_38",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 18: Create an account for the seller. {!js} parseCurrency transforms units from standard to atomic."
  },
  {
    "objectID": "/tut/wfs/#p_39",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 19: Get a reference to the contract."
  },
  {
    "objectID": "/tut/wfs/#p_40",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 20: Initiate interaction with contract for seller."
  },
  {
    "objectID": "/tut/wfs/#p_41",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 23: Code for when you run this app as the buyer."
  },
  {
    "objectID": "/tut/wfs/#p_42",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 24 and 25: Define empty (for now) Buyer interaction object."
  },
  {
    "objectID": "/tut/wfs/#p_43",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Type the following into index.rsh:"
  },
  {
    "objectID": "/tut/wfs/#p_44",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 1: Instruction to the compiler."
  },
  {
    "objectID": "/tut/wfs/#p_45",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Lines 3-9: Define empty (for now) participant interaction interface objects."
  },
  {
    "objectID": "/tut/wfs/#p_46",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 11: Reach standard application initialization."
  },
  {
    "objectID": "/tut/wfs/#p_47",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 12: Define a constant to represent the seller."
  },
  {
    "objectID": "/tut/wfs/#p_48",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 13: Define a constant to represent the buyer."
  },
  {
    "objectID": "/tut/wfs/#p_49",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 14: Finalize participant and other options, and proceed to a Reach step."
  },
  {
    "objectID": "/tut/wfs/#p_50",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 16: Terminate computation."
  },
  {
    "objectID": "/tut/wfs/#p_51",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Reach can currently compile the DApp to run on any of the following consensus network types:"
  },
  {
    "objectID": "/tut/wfs/#p_52",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "ALGO -- Algorand"
  },
  {
    "objectID": "/tut/wfs/#p_53",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "ETH -- Ethereum (and other EVM-based networks)"
  },
  {
    "objectID": "/tut/wfs/#p_54",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Instruct the Reach compiler to connect to a network by setting the {!cmd} REACH_CONNECTOR_MODE environment variable. Open a command prompt, and run the following command:"
  },
  {
    "objectID": "/tut/wfs/#p_55",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Run the program with the following command:"
  },
  {
    "objectID": "/tut/wfs/#p_56",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "You can repeat the first step to switch the consensus network to ETH."
  },
  {
    "objectID": "/tut/wfs/#p_57",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "For consistency, output in this tutorial reflects {!cmd} REACH_CONNECTOR_MODE=ALGO."
  },
  {
    "objectID": "/tut/wfs/#p_58",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Where does the DApp run? In a local \"devnet\" environment, the Reach compiler, the consensus network devnets, your application, and the smart contract run on your computer in Docker containers instantiated from Reach Docker images. A devnet refers to Reach's Dockerized developer network that allows developers to rapidly test their DApp."
  },
  {
    "objectID": "/tut/wfs/#p_59",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "The bottom of the output should have the following lines:"
  },
  {
    "objectID": "/tut/wfs/#p_60",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "This section shows you how to tell your DApp whether to run as the seller or the buyer. You do this by passing role as a command-line argument (e.g. {!cmd} reach run index seller). You cannot do this by passing role as a custom environment variable (e.g. {!cmd} ROLE=seller reach run) because in order to protect you, the {!cmd} reach tool exports only a pre-determined list of environment variables (including {!cmd} REACH_CONNECTOR_MODE) within the Docker container where it runs your DApp. Follow these directions to pass role as a command-line argument:"
  },
  {
    "objectID": "/tut/wfs/#p_61",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.mjs, find the following line:"
  },
  {
    "objectID": "/tut/wfs/#p_62",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Replace it with the following to be able to set the role in the command line arguments, and save the file:"
  },
  {
    "objectID": "/tut/wfs/#p_63",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Open two terminals (i.e. shells):"
  },
  {
    "objectID": "/tut/wfs/#p_64",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Change the directory in both terminals by typing the following command:"
  },
  {
    "objectID": "/tut/wfs/#p_65",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In the Seller Terminal, run your DApp as the seller:"
  },
  {
    "objectID": "/tut/wfs/#p_66",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "When you pass arguments to {!cmd} ./reach run, the first one must be the name of the rsh file without the extension (i.e. index) as seen above."
  },
  {
    "objectID": "/tut/wfs/#p_67",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Application output should resemble the following:"
  },
  {
    "objectID": "/tut/wfs/#p_68",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In the Buyer Terminal, run your DApp as the buyer:"
  },
  {
    "objectID": "/tut/wfs/#p_69",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "The output should resemble the following:"
  },
  {
    "objectID": "/tut/wfs/#p_70",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "This section helps you explore standard and atomic units using the JavaScript Standard Library. Regarding tokens, each consensus network has a (divisible) standard unit and an (indivisible) atomic unit. Users usually want to see standard units. A smart contract, on the other hand, always deals with atomic units."
  },
  {
    "objectID": "/tut/wfs/#p_71",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "So, your DApp needs to convert between the two frequently. We use the commands {!js} parseCurrency and {!js} formatCurrency to do the conversions. {!js} parseCurrency converts from standard to atomic. {!js} formatCurrency converts from atomic to standard."
  },
  {
    "objectID": "/tut/wfs/#p_72",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "As mentioned, {!js} parseCurrency is often used for human interactions: setting a contract price, paying the contract, wagers, staking, and other items where a user will either set the amount, or use the amount. {!js} formatCurrency is more frequently used with computer interactions or with small costs: such as paying fees, making sure the contract balance is zero, or showing wallet balances after contracts exit."
  },
  {
    "objectID": "/tut/wfs/#p_73",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.mjs, find the {!js} console.log statement below:"
  },
  {
    "objectID": "/tut/wfs/#p_74",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Add the following two {!js} console.log statements that utilize the {!js} stdlib.standardUnit and {!js} stdlib.atomicUnit below it, and run your DApp as the seller to view the standard and atomic units for your network:"
  },
  {
    "objectID": "/tut/wfs/#p_75",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "The output should resemble the following:"
  },
  {
    "objectID": "/tut/wfs/#p_76",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Remove the two {!js} console.log additions and then create suStr and auStr. Set suStr to {!js} standardUnit, and auStr to {!js} atomicUnit. Replace the {!js} stdlib statements with the corresponding {!js} const statements:"
  },
  {
    "objectID": "/tut/wfs/#p_77",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "The output should be the same."
  },
  {
    "objectID": "/tut/wfs/#p_78",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Now, let's create a way to go back and forth between the two unit types. We will then utilize {!js} parseCurrency and {!js} formatCurrency to change unit types. We will also create a suBal to add 1000 standard units of funds, then utilize the toAU method to change the unit type of suBal to atomic units. Let's write a couple of statements to the console to make sure it works as we expect, and then run again:"
  },
  {
    "objectID": "/tut/wfs/#p_79",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "The output should resemble the following:"
  },
  {
    "objectID": "/tut/wfs/#p_80",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Now, since that worked, we should refine the code. We want to keep toAU and toSU because they are useful, but we do not need all of the console statements. Instead, we can create a single {!js} const named iBalance and set it to atomic units using toAU, then wrap the account with toSU when we want to display standard units. We want to display the account balance to the console, as well as test wrapping the account with toSU, so let's write one more statement to the console. Your new code should look like the following:"
  },
  {
    "objectID": "/tut/wfs/#p_81",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "You use iBalance and showBalance in the next steps."
  },
  {
    "objectID": "/tut/wfs/#p_82",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.mjs, find the line below and replace stdlib.parseCurrency(1000) with iBalance:"
  },
  {
    "objectID": "/tut/wfs/#p_83",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.mjs, insert showBalance in the two places shown below to show the account balance before and after contract deployment:"
  },
  {
    "objectID": "/tut/wfs/#p_84",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Run your DApp again. Output should resemble the following:"
  },
  {
    "objectID": "/tut/wfs/#p_85",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "The second balance is now poised to reflect the results of the transactions you will implement below."
  },
  {
    "objectID": "/tut/wfs/#p_86",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "This section shows you how to have the seller (1) deploy the contract and (2) return the contract information to be used later by the buyer to attach to the contract. The format of contract information varies depending on the consensus network but can always be serialized to and from JSON without losing information. The following are examples of contract information written in JSON:"
  },
  {
    "objectID": "/tut/wfs/#p_87",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In this tutorial, the seller outputs the contract information to the Seller Terminal, and the buyer copies & pastes the contract information from the Seller Terminal to the Buyer Terminal (including the quotation marks if present). In an actual deployment, the seller would need to search for a contract name and its associated contract information in some repository, or receive it in the form of something like a QR code."
  },
  {
    "objectID": "/tut/wfs/#p_88",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Follow these directions to have the seller deploy the contract and return the contract information:"
  },
  {
    "objectID": "/tut/wfs/#p_89",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.mjs, find the sellerInteract code:"
  },
  {
    "objectID": "/tut/wfs/#p_90",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Add price and reportReady methods to it:"
  },
  {
    "objectID": "/tut/wfs/#p_91",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "You will add a wisdom property to the sellerInteract later in the tutorial."
  },
  {
    "objectID": "/tut/wfs/#p_92",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.rsh, find the sellerInteract code:"
  },
  {
    "objectID": "/tut/wfs/#p_93",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Add price and reportReady that was added in the index.mjs file to the index.rsh code:"
  },
  {
    "objectID": "/tut/wfs/#p_94",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 4: sellerInteract is a user-defined Reach object."
  },
  {
    "objectID": "/tut/wfs/#p_95",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 5: The spread syntax ... adds all commonInteract properties (none yet) to the object."
  },
  {
    "objectID": "/tut/wfs/#p_96",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 6: price is a {!rsh} UInt, a Reach-defined unsigned integer."
  },
  {
    "objectID": "/tut/wfs/#p_97",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 7: reportReady is a function that takes a {!rsh} UInt as an argument and returns nothing."
  },
  {
    "objectID": "/tut/wfs/#p_98",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.rsh, add the following code between {!rsh} init and {!rsh} exit:"
  },
  {
    "objectID": "/tut/wfs/#p_99",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 16: {!rsh} init initializes the DApp, and transitions to a step."
  },
  {
    "objectID": "/tut/wfs/#p_100",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 18: {!rsh} S.only() transitions to a local step in which seller gets price."
  },
  {
    "objectID": "/tut/wfs/#p_101",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 19: {!rsh} S.publish() transitions to a consensus step."
  },
  {
    "objectID": "/tut/wfs/#p_102",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 20: {!rsh} S.interact transitions to a local step in which seller passes price to frontend."
  },
  {
    "objectID": "/tut/wfs/#p_103",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 21: {!rsh} commit() transitions to a step."
  },
  {
    "objectID": "/tut/wfs/#p_104",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 23: {!rsh} exit() halts the contract forever."
  },
  {
    "objectID": "/tut/wfs/#p_105",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "The next section explains these functions in more detail. For now, know that Reach programs (the index.rsh portion of your Reach DApp) are organized into four modes, and that {!rsh} init, {!rsh} only, {!rsh} publish, {!rsh} commit, and {!rsh} exit cause mode transitions."
  },
  {
    "objectID": "/tut/wfs/#p_106",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Run your DApp as the seller. The output should resemble the following:"
  },
  {
    "objectID": "/tut/wfs/#p_107",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "The seller creates the contract, retrieves the contract information, and makes it available to the buyer who will use the information to attach to the contract. Deploying the contract costs the seller a fee. Here, you can see that the balance after creating the contract is displayed using atomic units, because acc references iBalance which takes the input of 1000 standard units and turns it into the atomic units using {!js} parseCurrency."
  },
  {
    "objectID": "/tut/wfs/#p_108",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "The interact objects introduced in this section facilitate communication between the frontend (e.g. index.mjs) and backend (e.g. index.main.mjs) of Reach applications, (remembering that index.rsh is the pre-compiled version of index.main.mjs)."
  },
  {
    "objectID": "/tut/wfs/#p_109",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "This section demonstrates how the buyer attaches to the contact. It also introduces @reach-sh/stdlib/ask.mjs, a minimal Reach Node.js package for command-line input."
  },
  {
    "objectID": "/tut/wfs/#p_110",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Interaction is often necessary between the DApp and the participants. {!js} ask is a convenient way to allow interaction in a variety of different ways, each with a specific use. {!js} ask.yesno is used to ask a question where the answer is either yes or no, and accepts a single letter response (y for yes and n for no). {!js} ask.ask is valuable for queries where the expected response is a string, such as \"What is your name?\". {!js} ask.done is used when there are no more questions."
  },
  {
    "objectID": "/tut/wfs/#p_111",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.mjs, add ask to the imports from the Reach standard library:"
  },
  {
    "objectID": "/tut/wfs/#p_112",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.mjs, find the buyerInteract code:"
  },
  {
    "objectID": "/tut/wfs/#p_113",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Replace it with the following:"
  },
  {
    "objectID": "/tut/wfs/#p_114",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 44: {!js} ask.ask and {!js} ask.yesno are functions in @reach-sh/stdlib. {!js} ask.yesno accepts only y or n."
  },
  {
    "objectID": "/tut/wfs/#p_115",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 48: You must parse contract information (so, it must be parsable)."
  },
  {
    "objectID": "/tut/wfs/#p_116",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 51: You can substitute participants for p."
  },
  {
    "objectID": "/tut/wfs/#p_117",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "And, add {!js} ask.done(); at the bottom of the file."
  },
  {
    "objectID": "/tut/wfs/#p_118",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "{!js} ask.done(); needs to be after }; so that it is accessible by both the Seller and the Buyer"
  },
  {
    "objectID": "/tut/wfs/#p_119",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.rsh, find the buyerInteract code:"
  },
  {
    "objectID": "/tut/wfs/#p_120",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Add a confirmPurchase method as shown below:"
  },
  {
    "objectID": "/tut/wfs/#p_121",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "After the ...commonInteract, there needs to be a comma. When you add a property, all properties above the final property require a comma at the end of the line."
  },
  {
    "objectID": "/tut/wfs/#p_122",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 9: buyerInteract is a user-defined Reach object."
  },
  {
    "objectID": "/tut/wfs/#p_123",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 10: The spread syntax ... adds all commonInteract properties (none yet) to the object."
  },
  {
    "objectID": "/tut/wfs/#p_124",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 11: confirmPurchase is a function that takes a UInt and returns a Bool."
  },
  {
    "objectID": "/tut/wfs/#p_125",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.rsh, add the following before {!rsh} exit() to utilize confirmPurchase:"
  },
  {
    "objectID": "/tut/wfs/#p_126",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 24: confirmPurchase passes price and returns true or false from frontend."
  },
  {
    "objectID": "/tut/wfs/#p_127",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 25: B.publish() transitions to a consensus step."
  },
  {
    "objectID": "/tut/wfs/#p_128",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 27: {!rsh} commit() transitions to a step."
  },
  {
    "objectID": "/tut/wfs/#p_129",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Run your DApp as both the seller and the buyer. When prompted, copy & paste the contract info from the Seller Terminal to the Buyer Terminal. Output should resemble the following:"
  },
  {
    "objectID": "/tut/wfs/#p_130",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "This section shows you how to display that a transaction is cancelled."
  },
  {
    "objectID": "/tut/wfs/#p_131",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.mjs, find the following line:"
  },
  {
    "objectID": "/tut/wfs/#p_132",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Replace it with the following:"
  },
  {
    "objectID": "/tut/wfs/#p_133",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.rsh, find the following line:"
  },
  {
    "objectID": "/tut/wfs/#p_134",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Replace it with the following:"
  },
  {
    "objectID": "/tut/wfs/#p_135",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.rsh, add Lines 3 and 4 to existing code:"
  },
  {
    "objectID": "/tut/wfs/#p_136",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Run your DApp as both the seller and the buyer. Answer n when asked to buy wisdom. Output should include the following:"
  },
  {
    "objectID": "/tut/wfs/#p_137",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In the Buyer Terminal, it might be more consistent to output You cancelled the order instead of The buyer cancelled the order. The following steps implement this slight change."
  },
  {
    "objectID": "/tut/wfs/#p_138",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.mjs, modify commonInteract:"
  },
  {
    "objectID": "/tut/wfs/#p_139",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.mjs, modify both sellerInteract and buyerInteract to pass role to commonInteract:"
  },
  {
    "objectID": "/tut/wfs/#p_140",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Rerun your DApp as the seller and buyer. Answer n again. Now, buyer output should include You cancelled the order:"
  },
  {
    "objectID": "/tut/wfs/#p_141",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "This section shows you how to get wisdom from the seller on the frontend, and swap it for tokens on the backend."
  },
  {
    "objectID": "/tut/wfs/#p_142",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.mjs, add a wisdom property to sellerInteract right after the price property:"
  },
  {
    "objectID": "/tut/wfs/#p_143",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.rsh, add a wisdom property to sellerInteract right after the price property:"
  },
  {
    "objectID": "/tut/wfs/#p_144",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.mjs, add a reportPayment property to commonInteract:"
  },
  {
    "objectID": "/tut/wfs/#p_145",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.rsh, add a reportPayment property to commonInteract right after the reportCancellation property:"
  },
  {
    "objectID": "/tut/wfs/#p_146",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.mjs, add reportWisdom to buyerInteract after confirmPurchase:"
  },
  {
    "objectID": "/tut/wfs/#p_147",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.rsh, add reportWisdom to buyerInteract:"
  },
  {
    "objectID": "/tut/wfs/#p_148",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.rsh, add the following before {!rsh} exit():"
  },
  {
    "objectID": "/tut/wfs/#p_149",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 39: The buyer always pays the contract."
  },
  {
    "objectID": "/tut/wfs/#p_150",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 42: After the buyer commits to purchase, the seller declassifies the wisdom."
  },
  {
    "objectID": "/tut/wfs/#p_151",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 43: The seller makes the wisdom available to the buyer."
  },
  {
    "objectID": "/tut/wfs/#p_152",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 44: The contract transfers funds to the seller."
  },
  {
    "objectID": "/tut/wfs/#p_153",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 47: The buyer sends the new wisdom to the frontend for the user."
  },
  {
    "objectID": "/tut/wfs/#p_154",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "It might be nice to inform the seller and the buyer when the {!rsh} pay and {!rsh} transfer actions take place. The next steps add these improvements."
  },
  {
    "objectID": "/tut/wfs/#p_155",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.mjs, add reportTransfer to commonInteract:"
  },
  {
    "objectID": "/tut/wfs/#p_156",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.rsh, add reportTransfer to commonInteract:"
  },
  {
    "objectID": "/tut/wfs/#p_157",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.rsh, add Lines 41 and 49 to existing code:"
  },
  {
    "objectID": "/tut/wfs/#p_158",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 41: {!rsh} each calls {!rsh} interact.reportPayment for each participant in the array."
  },
  {
    "objectID": "/tut/wfs/#p_159",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Line 49: {!rsh} each calls {!rsh} interact.reportTransfer for each participant in the array."
  },
  {
    "objectID": "/tut/wfs/#p_160",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Run your DApp as the seller and the buyer. Answer y when asked to buy wisdom. Output should resemble the following:"
  },
  {
    "objectID": "/tut/wfs/#p_161",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Congratulations on completing the contract! So far, you have learned how to create a contract, attach to the contract, cancel the contract, and complete the contract. These are some of the most common interactions participants will experience after deploying or attaching to a Reach DApp."
  },
  {
    "objectID": "/tut/wfs/#p_162",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Let's take a look at the final Reach code:"
  },
  {
    "objectID": "/tut/wfs/#p_163",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "And the final frontend code:"
  },
  {
    "objectID": "/tut/wfs/#p_164",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "You have learned about command-line DApps, but customers prefer to use a GUI DApp. GUI stands for \"graphical user interface\" and uses buttons, pop-ups, or other graphical elements to make the interface more user-friendly. This section gives a taste of using a GUI to have the buyer peek into the deployed contract before attaching to view the price. Allowing a buyer to view the contract before attaching is a better user experience, and better user experiences generally lead to more users."
  },
  {
    "objectID": "/tut/wfs/#p_165",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Review the index.mjs version of confirmPurchase from the buyerInteract object:"
  },
  {
    "objectID": "/tut/wfs/#p_166",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Currently, the backend calls the function passing the price of the contract, and the frontend displays price to the buyer, asks for a decision, waits for the answer, and returns true or false to the backend. This approach doesn't work well for a Web-app which might use a modal (an informative pop-up) in place of {!js} ask.yesno:"
  },
  {
    "objectID": "/tut/wfs/#p_167",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Here is how to display a modal using Bootstrap:"
  },
  {
    "objectID": "/tut/wfs/#p_168",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "A Web-app can do the following prior to attaching to the contract:"
  },
  {
    "objectID": "/tut/wfs/#p_169",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Get and display the price to the buyer."
  },
  {
    "objectID": "/tut/wfs/#p_170",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Get confirmation from the buyer."
  },
  {
    "objectID": "/tut/wfs/#p_171",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Once confirmed, the Web-app can attach to the contract and complete the transaction. The following directions show you how to obtain price from the contract before attaching:"
  },
  {
    "objectID": "/tut/wfs/#p_172",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.rsh, add Lines 23 and 29:"
  },
  {
    "objectID": "/tut/wfs/#p_173",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In index.mjs, add Lines 59 and 60 (in the buyer section):"
  },
  {
    "objectID": "/tut/wfs/#p_174",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Run your DApp as the seller and the buyer. Buyer output should include the following:"
  },
  {
    "objectID": "/tut/wfs/#p_175",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "The buyer is able to obtain price before attaching to the contract by using a view. Now, if the buyer decides not to buy, he did not pay the cost of connecting to the contract, as he did in Attach to the contract. This saves the buyer money and frustration from paying a fee while getting nothing in return, and greatly improves the user experience. If you want to learn more about GUI Dapps, see our next tutorial."
  },
  {
    "objectID": "/tut/wfs/#p_176",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Let's review the subjects learned in this tutorial:"
  },
  {
    "objectID": "/tut/wfs/#p_177",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In Reach Modes, we learned the different modes of a Reach program: Init, Step, Local Step, and Consensus Step."
  },
  {
    "objectID": "/tut/wfs/#p_178",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Pre-coding preparation helped us learn how to pre-code, increasing coding accuracy and speed."
  },
  {
    "objectID": "/tut/wfs/#p_179",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In Create the files, we created the initial Reach files so we could start coding our DApp."
  },
  {
    "objectID": "/tut/wfs/#p_180",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Run the DApp showed us how to run a Reach program."
  },
  {
    "objectID": "/tut/wfs/#p_181",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "We explored {!rsh} formatCurrency and {!rsh} parseCurrency, their uses, and how to convert between them in Explore units and balances."
  },
  {
    "objectID": "/tut/wfs/#p_182",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In Deploy the contract, we learned how to deploy a contract to the devnet."
  },
  {
    "objectID": "/tut/wfs/#p_183",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "We learned about attaching to a contract in Attach to the contract."
  },
  {
    "objectID": "/tut/wfs/#p_184",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "We figured out how to tell participants that the contract was cancelled in Cancel a transaction."
  },
  {
    "objectID": "/tut/wfs/#p_185",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In Complete a transaction, we completed the transaction and saw the results of the contract."
  },
  {
    "objectID": "/tut/wfs/#p_186",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "And finally, in View the contract, we utilized Bootstrap to allow buyers to see the contract prior to attaching."
  },
  {
    "objectID": "/tut/wfs/#p_187",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Congratulations! A great next step is to check out the next tutorial to continue your learning, or visit one of our guide topics or workshops for self-guided exploration of Reach."
  },
  {
    "objectID": "/tut/wfs/#p_188",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Join us on Discord the Discord community and message @team, I just completed the Wisdom For Sale tutorial!. We will give you the tutorial veteran role, so you can more easily help others work through it!"
  },
  {
    "objectID": "/tut/wfs/#p_189",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Click on the question to view the answer."
  },
  {
    "objectID": "/tut/wfs/#p_190",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Do smart contracts use standard or atomic units?"
  },
  {
    "objectID": "/tut/wfs/#p_191",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Smart contracts use atomic (indivisible) units. User interfaces, on the other hand, often use standard units to present cryptocurrency amounts to users. Therefore, Reach frontends frequently need to convert between the two. The Reach JS Stdlib function {!rsh} parseCurrency converts from standard to atomic, and the function {!rsh} formatCurrency converts from atomic to standard. :::"
  },
  {
    "objectID": "/tut/wfs/#p_192",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Reach DApps create smart contracts that enable ____ to interact on consensus networks."
  },
  {
    "objectID": "/tut/wfs/#p_193",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Participants. A Reach program describes participant interactions from which the Reach compiler derives a smart contract. :::"
  },
  {
    "objectID": "/tut/wfs/#p_194",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Name the objects that comprise the interface between Reach frontend and backend participants."
  },
  {
    "objectID": "/tut/wfs/#p_195",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Interact objects enable Reach frontend and backend participants to communicate. :::"
  },
  {
    "objectID": "/tut/wfs/#p_196",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Name the Reach default frontend and backend files."
  },
  {
    "objectID": "/tut/wfs/#p_197",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "index.mjs and index.rsh are the default frontend and backend filenames respectively. The Reach compiler compiles index.rsh into index.main.mjs. :::"
  },
  {
    "objectID": "/tut/wfs/#p_198",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "In addition to participant backends, what does index.main.mjs contain?"
  },
  {
    "objectID": "/tut/wfs/#p_199",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "It also contains the smart contract bytecode for each supported consensus network. :::"
  },
  {
    "objectID": "/tut/wfs/#p_200",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "When does the Reach Verification Engine run?"
  },
  {
    "objectID": "/tut/wfs/#p_201",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Compile time. :::"
  },
  {
    "objectID": "/tut/wfs/#p_202",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Can Reach DApps run on local Dockerized devnets?"
  },
  {
    "objectID": "/tut/wfs/#p_203",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Yes. Running Reach DApps on local Dockerized devnets is a convenient way to develop and test. :::"
  },
  {
    "objectID": "/tut/wfs/#p_204",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Name the environment variable used by Reach to determine the target consensus network."
  },
  {
    "objectID": "/tut/wfs/#p_205",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "{!cmd} REACH_CONNECTOR_MODE :::"
  },
  {
    "objectID": "/tut/wfs/#p_206",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Name the {!cmd} reach command that stops and removes all Reach Docker containers."
  },
  {
    "objectID": "/tut/wfs/#p_207",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "./reach down :::"
  },
  {
    "objectID": "/tut/wfs/#p_208",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "Name the Reach object that allows frontends to peak into a contract without attaching."
  },
  {
    "objectID": "/tut/wfs/#p_209",
    "pt": "Wisdom For Sale",
    "t": 3,
    "c": "{!rsh} View :::"
  },
  {
    "objectID": "/guide/abstract/#guide-abstract",
    "pt": "Building decentralized abstractions",
    "t": 2,
    "c": "Building decentralized abstractions"
  },
  {
    "objectID": "/guide/abstract/#p_0",
    "pt": "Building decentralized abstractions",
    "t": 3,
    "c": "Many decentralized applications have the same structure, similar to how there are many games that can be categorized as combinatorial games or simultaneous games."
  },
  {
    "objectID": "/guide/abstract/#p_1",
    "pt": "Building decentralized abstractions",
    "t": 3,
    "c": "These applications can either be programmed individually, or you can build an abstraction that captures the common structure of a game. Reach supports typical programming language abstractions, like first-class functions (via arrow expressions) and objects, that can be used to build these abstractions."
  },
  {
    "objectID": "/guide/abstract/#p_2",
    "pt": "Building decentralized abstractions",
    "t": 3,
    "c": "When building such abstractions, the most difficult part is correctly capturing loop invariants of the user of the abstraction on the inside of the abstraction. Often, this means the abstraction must set up a protocol to communicate with its user, such as by receiving an invariant captured by an arrow expression."
  },
  {
    "objectID": "/guide/abstract/#p_3",
    "pt": "Building decentralized abstractions",
    "t": 3,
    "c": "See the abstraction workshop for a walkthrough of building such an abstraction."
  },
  {
    "objectID": "/guide/assert/#guide-assert",
    "pt": "How and what to verify",
    "t": 2,
    "c": "How and what to verify"
  },
  {
    "objectID": "/guide/assert/#p_0",
    "pt": "How and what to verify",
    "t": 3,
    "c": "Reach's verification engine ensures that invariants about the state of a program assumed by programmers are held by all possible executions of the program."
  },
  {
    "objectID": "/guide/assert/#p_1",
    "pt": "How and what to verify",
    "t": 3,
    "c": "At a high-level, the goal of a programmer getting started with verification is to write down every single assumption they have into the program in the form of {!rsh} assert statements. For example, if a value, {!rsh} x is assumed to be smaller than 20, then the programmer should always include {!rsh} assert(x < 20); in the program. This is not to help the verification engine prove later properties, but is to give the verification engine assumptions that it can attempt to falsify so the programmer can learn if their assumptions are correct."
  },
  {
    "objectID": "/guide/assert/#p_2",
    "pt": "How and what to verify",
    "t": 3,
    "c": "At a low-level, the programmer should see the verification engine as a tool to prevent test regressions by encoding tests directly into the program in the form of assertions. For example, suppose that during development and testing, a programmer observes an erroneous state where the variable {!rsh} y is assigned to the value {!rsh} 41, then the programmer should insert {!rsh} assert(y != 41); into the program. The programmer should insert this check before they fix the problem in the code. This will ensure that all future versions of the program will also be protected from these problems."
  },
  {
    "objectID": "/guide/assert/#p_3",
    "pt": "How and what to verify",
    "t": 3,
    "c": "These high- and low-level perspectives on assertions apply to individual code fragments, like the body of an {!rsh} only statement, as well as entire functions. For example, if a programmer expects a unary function over integers, {!rsh} f, to always return a number between {!rsh} 0 and {!rsh} 50, then they should write {!rsh} assert(f(forall(UInt)) <= 50); in their program. Similarly, the unit tests for a function that a developer would normally write in a test suite, should instead be written as a series of assertions in the module that defines a function."
  },
  {
    "objectID": "/guide/assert/#p_4",
    "pt": "How and what to verify",
    "t": 3,
    "c": "If you'd like to continue learning about verification, we recommend reading about \"property-based testing\". Although most resources on the topic will refer to dynamic, random tools, like QuickCheck, the strategies used transfer automatically to a formally verified context, like Reach."
  },
  {
    "objectID": "/guide/assert/#p_5",
    "pt": "How and what to verify",
    "t": 3,
    "c": "If you'd like to continue reading about verification in Reach specifically, read the guide section on loop invariants."
  },
  {
    "objectID": "/guide/ctransfers/#guide-ctransfers",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 2,
    "c": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?"
  },
  {
    "objectID": "/guide/ctransfers/#is-a-single-participant-responsible-for-the-transfer",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 2,
    "c": "Is a single participant responsible for the transfer?"
  },
  {
    "objectID": "/guide/ctransfers/#are-multiple-participants-able-to-cause-the-transfer-but-each-will-provide-different-data",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 2,
    "c": "Are multiple participants able to cause the transfer, but each will provide different data?"
  },
  {
    "objectID": "/guide/ctransfers/#are-there-multiple-participants-that-each-want-to-do-different-things",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 2,
    "c": "Are there multiple participants that each want to do different things?"
  },
  {
    "objectID": "/guide/ctransfers/#will-these-different-things-happen-over-and-over-until-some-condition-is-met",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 2,
    "c": "Will these different things happen over and over until some condition is met?"
  },
  {
    "objectID": "/guide/ctransfers/#summary",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 2,
    "c": "Summary"
  },
  {
    "objectID": "/guide/ctransfers/#p_0",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "A fundamental concept in Reach is that the application starts in a detached birds-eye perspective called a step where each of the participants are acting completely independently. These independent steps are punctuated by consensus transfers which cause all of the participants to come together and agree on the computation, which is called a consensus step."
  },
  {
    "objectID": "/guide/ctransfers/#p_1",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "These consensus steps are what happen \"on-chain\" and are executed by a so-called \"smart contract\"."
  },
  {
    "objectID": "/guide/ctransfers/#p_2",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "There are many ways to perform a consensus transfer in Reach and each is used for different reasons. The variety can feel a bit bewildering for new users, but here is an intuitive guide to help you decide which you need for any given situation."
  },
  {
    "objectID": "/guide/ctransfers/#p_3",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "If the entire DApp is waiting for a single participant to act, such as when at a play the entire theatre waits in anticipation for the stage hands to draw the curtains, then you either need a {!rsh} pay or {!rsh} publish. If the single participant is sharing information, then you need a {!rsh} publish; but if they are only paying a previously known amount, then you need a {!rsh} pay. This kind of transfer always explicitly names the party acting, as in:"
  },
  {
    "objectID": "/guide/ctransfers/#p_4",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "{!rsh} pay and {!rsh} publish without a {!rsh} race are for when one participant wants to do one thing."
  },
  {
    "objectID": "/guide/ctransfers/#p_5",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "If the entire DApp has a clear \"next step\", but multiple participants are able to provide the values used in that step, then you need a {!rsh} race to determine the participant used for a {!rsh} publish or {!rsh} pay. For example, in a radio call-in contest, there is one chance for a listener to call-in first and win the prize. If a participant value is participant class, then all of its actions are {!rsh} races, because the Reach identifier does not represent a specific principal, but a member of a large class."
  },
  {
    "objectID": "/guide/ctransfers/#p_6",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "{!rsh} race, and participant classes are for when many participants want to do one thing."
  },
  {
    "objectID": "/guide/ctransfers/#p_7",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "If the DApp doesn't have a clear next step, but multiple participants each have a different option for what the next step should be, then you need a {!rsh} fork. For example, a sale DApp might have a buy option and a bid option where the first immediately ends the computation, while the second moves it to an auction."
  },
  {
    "objectID": "/guide/ctransfers/#p_8",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "{!rsh} fork is for when many participants want to each do a different thing."
  },
  {
    "objectID": "/guide/ctransfers/#p_9",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "If you are in a situation where a {!rsh} race or {!rsh} fork is needed, and the options are available repeatedly after small diversions, then you need a {!rsh} parallelReduce. For example, in an auction, bidders repeatedly provide new bids as they compete to be the highest bidder before a time limit is reached."
  },
  {
    "objectID": "/guide/ctransfers/#p_10",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "The main questions are:"
  },
  {
    "objectID": "/guide/ctransfers/#p_11",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "How many participants can act? One or many?"
  },
  {
    "objectID": "/guide/ctransfers/#p_12",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "How many things can be done? One or many?"
  },
  {
    "objectID": "/guide/ctransfers/#p_13",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "How many times can this be done? Once or many?"
  },
  {
    "objectID": "/guide/ctransfers/#p_14",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "If it happens many times, you want {!rsh} parallelReduce. If many things could happen, you want {!rsh} fork. If many participants can act, you want {!rsh} race. Otherwise, you want {!rsh} publish or {!rsh} pay."
  },
  {
    "objectID": "/guide/ctransfers/#p_15",
    "pt": "What do the different kinds of consensus transfers mean? publish, pay, race, fork, parallelReduce?",
    "t": 3,
    "c": "The above article uses the word \"need\" when talking about {!rsh} fork and {!rsh} parallelReduce, but actually you never need these, because they are just abbreviations of particular patterns of using the other features. {!rsh} fork works by having each participant {!rsh} race to provide a {!rsh} Data instance, where the single consensus step does a case analysis on the {!rsh} Data to determine which code to run. Similarly, {!rsh} parallelReduce is just an abbreviation of a {!rsh} fork within a {!rsh} while loop."
  },
  {
    "objectID": "/guide/determ/#guide-determ",
    "pt": "Determinism, simultaneity, and choice in decentralized applications",
    "t": 2,
    "c": "Determinism, simultaneity, and choice in decentralized applications"
  },
  {
    "objectID": "/guide/determ/#p_0",
    "pt": "Determinism, simultaneity, and choice in decentralized applications",
    "t": 3,
    "c": "The structure of a Reach computation is deterministic, because at each point in a computation, all participants agree on which publication is the next one in the computation. If this were not the case, then different participants may attempt to pursue different paths through a computation and thereby reach different values at the end. This deterministic structure, however, does not mean that the participant that provides the publication must be fixed, merely that which publication event is next must be fixed; see for example {!rsh} race expressions and the guide section on races for an elaboration of this point. Even in the presence of this non-determinism in actors, Reach programs remain deterministic in their structure."
  },
  {
    "objectID": "/guide/determ/#p_1",
    "pt": "Determinism, simultaneity, and choice in decentralized applications",
    "t": 3,
    "c": "However, many developers think of their application as having a step when two participants act simultaneously. For example, in a game of Rock, Paper, Scissors! in the real world, both players simultaneously choose their hands. Similarly, a rental agreement gives both the landlord and the tenant the ability to cancel the agreement (subject to some penalty) at any time. In both of these cases, it is not clear how to understand this interaction as being sequential and deterministic."
  },
  {
    "objectID": "/guide/determ/#p_2",
    "pt": "Determinism, simultaneity, and choice in decentralized applications",
    "t": 3,
    "c": "At first glance, these situations appear different. In the first, the participants are doing \"the same thing\" simultaneously, because both will submit a hand eventually; while in the second, they are doing \"something different\", because only one of them will actually end the agreement early. However, both of these situations are actually identical, because in the second case they are both simultaneously deciding whether they will end early. In the first case, the participants are submitting one of three values (Rock, Paper, or Scissors), while in the second they are submitting one of two (Leave or Stay)."
  },
  {
    "objectID": "/guide/determ/#p_3",
    "pt": "Determinism, simultaneity, and choice in decentralized applications",
    "t": 3,
    "c": "In such situations, in a decentralized application, the program must agree that one participant acts first. The important thing to realize is that \"simultaneity\" is not the same thing as \"non-determinism\". The pertinent design detail is whether one participant has an advantage for going in any particular order. If there is no advantage for either place, then the developer can arbitrarily decide to go in one order. If there is an advantage, then a commitment strategy similar to the Rock, Paper, Scissors! tutorial should be used."
  },
  {
    "objectID": "/guide/determ/#p_4",
    "pt": "Determinism, simultaneity, and choice in decentralized applications",
    "t": 3,
    "c": "For example, in the rental agreement, if we felt there was no advantage for going second, then we could have either the landlord or the tenant go first. But, is there no advantage? If both the tenant and the landlord want to exit in the same month, but the landlord goes first, then the landlord would suffer a loss of their deposit; but, if they fairly shared their choice at the same time, then they could both be refunded in this case. This is an example of the Pareto improvements that are possible in decentralized applications relative to existing institutions."
  },
  {
    "objectID": "/guide/determ/#p_5",
    "pt": "Determinism, simultaneity, and choice in decentralized applications",
    "t": 3,
    "c": "See rental workshop for a discussion of this example in further detail."
  },
  {
    "objectID": "/guide/editor-support/#guide-editor-support",
    "pt": "IDE/Text Editor Support",
    "t": 2,
    "c": "IDE/Text Editor Support"
  },
  {
    "objectID": "/guide/editor-support/#guide-install-VSCode",
    "pt": "IDE/Text Editor Support",
    "t": 2,
    "c": "Install VSCode"
  },
  {
    "objectID": "/guide/editor-support/#guide-install-Atom",
    "pt": "IDE/Text Editor Support",
    "t": 2,
    "c": "Install Atom"
  },
  {
    "objectID": "/guide/editor-support/#guide-install-Sublime",
    "pt": "IDE/Text Editor Support",
    "t": 2,
    "c": "Install Sublime"
  },
  {
    "objectID": "/guide/editor-support/#p_0",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "There are a number of text editor plugins available to provide a better development experience for Reach. These plugins provide syntax highlighting, build commands, key mappings, snippets, and more. The following plugins are available:"
  },
  {
    "objectID": "/guide/editor-support/#p_1",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Visual Studio Code: Reach IDE"
  },
  {
    "objectID": "/guide/editor-support/#p_2",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Atom: Reach Language Support, Reach IDE"
  },
  {
    "objectID": "/guide/editor-support/#p_3",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Sublime Text: Reach IDE"
  },
  {
    "objectID": "/guide/editor-support/#p_4",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "We highly recommend using Visual Studio Code IDE, it is the most advanced Reach extension."
  },
  {
    "objectID": "/guide/editor-support/#p_5",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Visual Studio Code (VSCode) enables users to both write and compile Reach code. With the Reach IDE VSCode extension installed, VSCode compiles automatically in the background and alerts users of coding errors in seconds when the necessary prerequisites, such as Docker, are installed and running."
  },
  {
    "objectID": "/guide/editor-support/#p_6",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Download the VSCode IDE."
  },
  {
    "objectID": "/guide/editor-support/#p_7",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Double-click the file to install VSCode."
  },
  {
    "objectID": "/guide/editor-support/#p_8",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "In VSCode, click extensions in the left panel."
  },
  {
    "objectID": "/guide/editor-support/#p_9",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Search for Reach, and then install the most recent version of the Reach IDE extension."
  },
  {
    "objectID": "/guide/editor-support/#p_10",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Download and install Atom matching your system."
  },
  {
    "objectID": "/guide/editor-support/#p_11",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "In Atom, click File\\Settings."
  },
  {
    "objectID": "/guide/editor-support/#p_12",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Click Install."
  },
  {
    "objectID": "/guide/editor-support/#p_13",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Type Reach."
  },
  {
    "objectID": "/guide/editor-support/#p_14",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Install Reach IDE."
  },
  {
    "objectID": "/guide/editor-support/#p_15",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Install Reach Language Support."
  },
  {
    "objectID": "/guide/editor-support/#p_16",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Download and install Sublime."
  },
  {
    "objectID": "/guide/editor-support/#p_17",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Download the Reach-IDE."
  },
  {
    "objectID": "/guide/editor-support/#p_18",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Unzip the Reach-IDE into the \\Sublime Text\\Packages folder of your Sublime installation."
  },
  {
    "objectID": "/guide/editor-support/#p_19",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Open your project in Sublime."
  },
  {
    "objectID": "/guide/editor-support/#p_20",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Click Tools\\Command Palette, and then type Reach."
  },
  {
    "objectID": "/guide/editor-support/#p_21",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Click Set Syntax:Reach."
  },
  {
    "objectID": "/guide/editor-support/#p_22",
    "pt": "IDE/Text Editor Support",
    "t": 3,
    "c": "Repeat 5 and then select Reach - Compile to build with Reach."
  },
  {
    "objectID": "/guide/ganache/#guide-ganache",
    "pt": "How to use Ganache with Reach",
    "t": 2,
    "c": "How to use Ganache with Reach"
  },
  {
    "objectID": "/guide/ganache/#p_0",
    "pt": "How to use Ganache with Reach",
    "t": 3,
    "c": "Ganache is a very popular Ethereum personal blockchain for quick application development, deployment, and testing with a replica of the Ethereum mainnet. Ganache provides many customization options, such as control over the gas limit and price."
  },
  {
    "objectID": "/guide/ganache/#p_1",
    "pt": "How to use Ganache with Reach",
    "t": 3,
    "c": "There are two ways to use Ganache with Reach."
  },
  {
    "objectID": "/guide/ganache/#p_2",
    "pt": "How to use Ganache with Reach",
    "t": 3,
    "c": "First, you can run the Ganache desktop application and start a workspace, then connect to it using the Reach ETH-live connector mode. This requires specifying the node URI as well. For example, if you're running your Reach frontend from within Docker, and Ganache on your host machine, you might run:"
  },
  {
    "objectID": "/guide/ganache/#p_3",
    "pt": "How to use Ganache with Reach",
    "t": 3,
    "c": "This sets the Ethereum URI to the host machine's port and instructs Reach that the network is \"isolated\", which means it is for testing."
  },
  {
    "objectID": "/guide/ganache/#p_4",
    "pt": "How to use Ganache with Reach",
    "t": 3,
    "c": "Second, you can programmatically create a Ganache network from inside of your JavaScript frontend and set it as a provider for the Reach standard library. This requires some modification to your frontend."
  },
  {
    "objectID": "/guide/ganache/#p_5",
    "pt": "How to use Ganache with Reach",
    "t": 3,
    "c": "You need to add the ganache-core package as a dependency in your package.json file. If you don't already have one, then you'll want to use reach scaffold to set one up. You'll also need to add the ethers package, because you'll be directly interacting with the underlying network to set things up."
  },
  {
    "objectID": "/guide/ganache/#p_6",
    "pt": "How to use Ganache with Reach",
    "t": 3,
    "c": "After that, you need to import the two packages on the JavaScript side in your index.mjs file:"
  },
  {
    "objectID": "/guide/ganache/#p_7",
    "pt": "How to use Ganache with Reach",
    "t": 3,
    "c": "Next, you need to actually create the Ganache-based provider and connect it to Reach:"
  },
  {
    "objectID": "/guide/ganache/#p_8",
    "pt": "How to use Ganache with Reach",
    "t": 3,
    "c": "This will work, but Reach will not consider the network to be \"isolated\", which means that it won't be able to fund test accounts. You can enable this by setting the Reach faucet:"
  },
  {
    "objectID": "/guide/ganache/#p_9",
    "pt": "How to use Ganache with Reach",
    "t": 3,
    "c": "If you want to use some of the interesting customizations that Ganache provides, then refer to their documentation about what {!js} ganacheOptions may be set to."
  },
  {
    "objectID": "/guide/lifecycle/#guide-lifecycle",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 2,
    "c": "Contract Development Lifecycle and Best Practices for Building Reach DApps"
  },
  {
    "objectID": "/guide/lifecycle/#key-ideas-and-goals",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 2,
    "c": "Key Ideas and Goals"
  },
  {
    "objectID": "/guide/lifecycle/#requirements-and-limitations",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 2,
    "c": "Requirements and Limitations"
  },
  {
    "objectID": "/guide/lifecycle/#determine-ui-requirements",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 2,
    "c": "Determine UI Requirements"
  },
  {
    "objectID": "/guide/lifecycle/#choosing-a-frontend",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 2,
    "c": "Choosing a Frontend"
  },
  {
    "objectID": "/guide/lifecycle/#developing-the-smart-contract",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 2,
    "c": "Developing the Smart Contract"
  },
  {
    "objectID": "/guide/lifecycle/#general-tips",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 2,
    "c": "General Tips"
  },
  {
    "objectID": "/guide/lifecycle/#observing-time",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 2,
    "c": "Observing Time"
  },
  {
    "objectID": "/guide/lifecycle/#committing-artifacts",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 2,
    "c": "Committing Artifacts"
  },
  {
    "objectID": "/guide/lifecycle/#artifacts-for-the-ui--deployer",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 2,
    "c": "Artifacts for the UI & Deployer"
  },
  {
    "objectID": "/guide/lifecycle/#artifacts-for-auditors",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 2,
    "c": "Artifacts for Auditors"
  },
  {
    "objectID": "/guide/lifecycle/#testing",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 2,
    "c": "Testing"
  },
  {
    "objectID": "/guide/lifecycle/#integrate-the-smart-contract",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 2,
    "c": "Integrate the Smart Contract"
  },
  {
    "objectID": "/guide/lifecycle/#automate-testing",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 2,
    "c": "Automate Testing"
  },
  {
    "objectID": "/guide/lifecycle/#user-testing",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 2,
    "c": "User Testing"
  },
  {
    "objectID": "/guide/lifecycle/#audits",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 2,
    "c": "Audits"
  },
  {
    "objectID": "/guide/lifecycle/#launch",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 2,
    "c": "Launch"
  },
  {
    "objectID": "/guide/lifecycle/#p_0",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Smart contracts impose unique restrictions on development that is not experienced in web2. Building web3 DApps with intentionality enables efficient use of a developer's time and reduces exposure to unforeseen vulnerabilities."
  },
  {
    "objectID": "/guide/lifecycle/#p_1",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Before any code is created, take time to answer the following questions to better understand the problem your DApp will solve. Start with the 'Why'."
  },
  {
    "objectID": "/guide/lifecycle/#p_2",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Why do we need a DApp?2 What is the motivation to create this DApp?3 Is decentralization adding real value for users?4 Could it be on a centralized database instead of blockchain?5 Is there a revenue model? Is it fair? Will users agree?"
  },
  {
    "objectID": "/guide/lifecycle/#p_3",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "What is the motivation to create this DApp?"
  },
  {
    "objectID": "/guide/lifecycle/#p_4",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Is decentralization adding real value for users?"
  },
  {
    "objectID": "/guide/lifecycle/#p_5",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Could it be on a centralized database instead of blockchain?"
  },
  {
    "objectID": "/guide/lifecycle/#p_6",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Is there a revenue model? Is it fair? Will users agree?"
  },
  {
    "objectID": "/guide/lifecycle/#p_7",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "How do we plan to achieve the DApp's goal?7 How do we position the DApp to our customers or users?8 How will this DApp solve problems?"
  },
  {
    "objectID": "/guide/lifecycle/#p_8",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "How do we position the DApp to our customers or users?"
  },
  {
    "objectID": "/guide/lifecycle/#p_9",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "How will this DApp solve problems?"
  },
  {
    "objectID": "/guide/lifecycle/#p_10",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "What will the DApp do?10 What specific problem will you solve?11 What does the DApp need to accomplish?12 What is the minimum viable product (MVP)?13 Which products or services are we offering that require a new contract?14 Can it be more decentralized to add even more value for users? Is there adequate incentive (profit, reputation, other) to do it that way?"
  },
  {
    "objectID": "/guide/lifecycle/#p_11",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "What specific problem will you solve?"
  },
  {
    "objectID": "/guide/lifecycle/#p_12",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "What does the DApp need to accomplish?"
  },
  {
    "objectID": "/guide/lifecycle/#p_13",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "What is the minimum viable product (MVP)?"
  },
  {
    "objectID": "/guide/lifecycle/#p_14",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Which products or services are we offering that require a new contract?"
  },
  {
    "objectID": "/guide/lifecycle/#p_15",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Can it be more decentralized to add even more value for users? Is there adequate incentive (profit, reputation, other) to do it that way?"
  },
  {
    "objectID": "/guide/lifecycle/#p_16",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Where will it be deployed?16 Which consensus networks will this DApp live on?17 Will the DApp rely on premium indexer services or free tiers of service?"
  },
  {
    "objectID": "/guide/lifecycle/#p_17",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Which consensus networks will this DApp live on?"
  },
  {
    "objectID": "/guide/lifecycle/#p_18",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Will the DApp rely on premium indexer services or free tiers of service?"
  },
  {
    "objectID": "/guide/lifecycle/#p_19",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Who is our user persona?19 Is the persona documented?20 Who is it trying to impress and why?21 Who will find value in using this DApp? What pain will it solve?22 Will incentives align for people to use the DApp in the intended manner?23 Does this DApp fulfill grant requirements, appeal to certain investors, or potential partner networks?"
  },
  {
    "objectID": "/guide/lifecycle/#p_20",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Is the persona documented?"
  },
  {
    "objectID": "/guide/lifecycle/#p_21",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Who is it trying to impress and why?"
  },
  {
    "objectID": "/guide/lifecycle/#p_22",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Who will find value in using this DApp? What pain will it solve?"
  },
  {
    "objectID": "/guide/lifecycle/#p_23",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Will incentives align for people to use the DApp in the intended manner?"
  },
  {
    "objectID": "/guide/lifecycle/#p_24",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Does this DApp fulfill grant requirements, appeal to certain investors, or potential partner networks?"
  },
  {
    "objectID": "/guide/lifecycle/#p_25",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "When should it be delivered?25 Does this deadline have a high opportunity cost?"
  },
  {
    "objectID": "/guide/lifecycle/#p_26",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Does this deadline have a high opportunity cost?"
  },
  {
    "objectID": "/guide/lifecycle/#p_27",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Take time to create answers that are as specific as possible. DApps with a clear roadmap are more likely to succeed."
  },
  {
    "objectID": "/guide/lifecycle/#p_28",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Determine the requirements and limitations of the smart contract. Requirements should be measurable, specific, and solution-oriented. The initial product should be narrow in scope; fight scope-creep by storing new feature suggestions in a backlog."
  },
  {
    "objectID": "/guide/lifecycle/#p_29",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Once you understand the purpose of the DApp, you can clarify who will interact with the DApp and what restrictions each participant will experience. This can be thought of as the communication model of the application."
  },
  {
    "objectID": "/guide/lifecycle/#p_30",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Describe the participants (human or bot):30 How they will interact with the contract31 What will they cause the contract to do?32 What information will the contract return?"
  },
  {
    "objectID": "/guide/lifecycle/#p_31",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "How they will interact with the contract"
  },
  {
    "objectID": "/guide/lifecycle/#p_32",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "What will they cause the contract to do?"
  },
  {
    "objectID": "/guide/lifecycle/#p_33",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "What information will the contract return?"
  },
  {
    "objectID": "/guide/lifecycle/#p_34",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Identify specific participants that will cause the contract to do things:"
  },
  {
    "objectID": "/guide/lifecycle/#p_35",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "A Deployer"
  },
  {
    "objectID": "/guide/lifecycle/#p_36",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "One or more Admins36 Is the Deployer the only Admin?37 Can Admins change over time?"
  },
  {
    "objectID": "/guide/lifecycle/#p_37",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Is the Deployer the only Admin?"
  },
  {
    "objectID": "/guide/lifecycle/#p_38",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Can Admins change over time?"
  },
  {
    "objectID": "/guide/lifecycle/#p_39",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "{!rsh} APIs who add resources to the contract"
  },
  {
    "objectID": "/guide/lifecycle/#p_40",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "{!rsh} APIs with special access to extract resources from the contract40 What must be true to enable this functionality?"
  },
  {
    "objectID": "/guide/lifecycle/#p_41",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "What must be true to enable this functionality?"
  },
  {
    "objectID": "/guide/lifecycle/#p_42",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "{!rsh} APIs who interact with the contract in a completely unprivileged manner"
  },
  {
    "objectID": "/guide/lifecycle/#p_43",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Identify the circumstances that must be met to allow these interactions."
  },
  {
    "objectID": "/guide/lifecycle/#p_44",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Describe information that the contract should expose about itself:"
  },
  {
    "objectID": "/guide/lifecycle/#p_45",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Views: Information about the DApps' current state45 Expose one large informative view that shares as much about the global state as possible, because this can minimize API calls and limit the size of the contract code."
  },
  {
    "objectID": "/guide/lifecycle/#p_46",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Expose one large informative view that shares as much about the global state as possible, because this can minimize API calls and limit the size of the contract code."
  },
  {
    "objectID": "/guide/lifecycle/#p_47",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "{!rsh} Events: Information about transaction history and triggered behavior47 Generally, {!rsh} Events should be paired with API calls and only emit associated inputs and outputs."
  },
  {
    "objectID": "/guide/lifecycle/#p_48",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Generally, {!rsh} Events should be paired with API calls and only emit associated inputs and outputs."
  },
  {
    "objectID": "/guide/lifecycle/#p_49",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Describe the lifecycle of the contract:"
  },
  {
    "objectID": "/guide/lifecycle/#p_50",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Does it live forever?50 If not, under what circumstances does it end?"
  },
  {
    "objectID": "/guide/lifecycle/#p_51",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "If not, under what circumstances does it end?"
  },
  {
    "objectID": "/guide/lifecycle/#p_52",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "How many parties are involved in setting things up?52 What is their expected user experience?"
  },
  {
    "objectID": "/guide/lifecycle/#p_53",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "What is their expected user experience?"
  },
  {
    "objectID": "/guide/lifecycle/#p_54",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "When is each API valid?"
  },
  {
    "objectID": "/guide/lifecycle/#p_55",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Describe the rules and expectations of the contract:"
  },
  {
    "objectID": "/guide/lifecycle/#p_56",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Provide sample inputs and their expected outputs"
  },
  {
    "objectID": "/guide/lifecycle/#p_57",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "How 'caveat emptor' is the contract?57 Does it allow users to do foolish things as long as they would only harm themselves in doing so?58 e.g. Does deleting their user state cause them to lose access to their funds?"
  },
  {
    "objectID": "/guide/lifecycle/#p_58",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Does it allow users to do foolish things as long as they would only harm themselves in doing so?"
  },
  {
    "objectID": "/guide/lifecycle/#p_59",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "e.g. Does deleting their user state cause them to lose access to their funds?"
  },
  {
    "objectID": "/guide/lifecycle/#p_60",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Based on the requirements above, describe the overall complexity of the contract."
  },
  {
    "objectID": "/guide/lifecycle/#p_61",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "How difficult will the contract be to audit?"
  },
  {
    "objectID": "/guide/lifecycle/#p_62",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "What prior information will auditors need to understand?"
  },
  {
    "objectID": "/guide/lifecycle/#p_63",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Properly prepared requirements should be encapsulated within Reach {!rsh} APIs, {!rsh} Views, {!rsh} Events, and {!rsh} Participants. Accurate descriptions will allow the smart contract and the UI to be developed simultaneously by coding against the same expectations."
  },
  {
    "objectID": "/guide/lifecycle/#p_64",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Describe the user experiences that should be possible via the UI"
  },
  {
    "objectID": "/guide/lifecycle/#p_65",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Describe the kinds of information needed to render each view65 How many contract views need to be accessed to render the full page?66 Does this amount scale up over time?67 How will the UI keep requests under control?68 Pagination69 Paying for premium indexer services"
  },
  {
    "objectID": "/guide/lifecycle/#p_66",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "How many contract views need to be accessed to render the full page?"
  },
  {
    "objectID": "/guide/lifecycle/#p_67",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Does this amount scale up over time?"
  },
  {
    "objectID": "/guide/lifecycle/#p_68",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "How will the UI keep requests under control?68 Pagination69 Paying for premium indexer services"
  },
  {
    "objectID": "/guide/lifecycle/#p_69",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Pagination"
  },
  {
    "objectID": "/guide/lifecycle/#p_70",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Paying for premium indexer services"
  },
  {
    "objectID": "/guide/lifecycle/#p_71",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Describe how the UI should limit a user's interactions with the contract, above and beyond the limitations imposed by the contract itself71 Why is the interaction in the UI instead of in the contract?"
  },
  {
    "objectID": "/guide/lifecycle/#p_72",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Why is the interaction in the UI instead of in the contract?"
  },
  {
    "objectID": "/guide/lifecycle/#p_73",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Describe how the UI should surface errors to the user"
  },
  {
    "objectID": "/guide/lifecycle/#p_74",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "How will the UI prevent the user from taking impossible actions"
  },
  {
    "objectID": "/guide/lifecycle/#p_75",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Describe what happens if:75 The indexer service is down or has an inconsistent connection76 The user doesn't have enough funds77 There may be different error messages based on the issue78 Did the user have enough USDCa for the API call, but not enough ALGO to pay the transaction fee?79 There are DApp-specific reasons that an API call might be rejected by the contract"
  },
  {
    "objectID": "/guide/lifecycle/#p_76",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "The indexer service is down or has an inconsistent connection"
  },
  {
    "objectID": "/guide/lifecycle/#p_77",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "The user doesn't have enough funds77 There may be different error messages based on the issue78 Did the user have enough USDCa for the API call, but not enough ALGO to pay the transaction fee?"
  },
  {
    "objectID": "/guide/lifecycle/#p_78",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "There may be different error messages based on the issue78 Did the user have enough USDCa for the API call, but not enough ALGO to pay the transaction fee?"
  },
  {
    "objectID": "/guide/lifecycle/#p_79",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Did the user have enough USDCa for the API call, but not enough ALGO to pay the transaction fee?"
  },
  {
    "objectID": "/guide/lifecycle/#p_80",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "There are DApp-specific reasons that an API call might be rejected by the contract"
  },
  {
    "objectID": "/guide/lifecycle/#p_81",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "You may choose to use any frontend language or framework to interact with the Reach smart contract. However, Reach provides the ability to quickly create React scaffolding with {!cmd} reach react"
  },
  {
    "objectID": "/guide/lifecycle/#p_82",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "If you do not have a frontend preference then we suggest using React with Reach"
  },
  {
    "objectID": "/guide/lifecycle/#p_83",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Now that the communication model of the application is clearly understood, you are able to codify the {!rsh} APIs, {!rsh} Views, {!rsh} Events, and {!rsh} Participants. Use the {!rsh} interact interface to dictate how users interact with the contract and other {!rsh} Participants. The App Initialization mode should be written to be platform-agnostic. Any platform-specific elements should be implemented via the appropriate {!rsh} interact interface."
  },
  {
    "objectID": "/guide/lifecycle/#p_84",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "The following best practices in contract design create Reach DApps that are efficient and faster to debug:"
  },
  {
    "objectID": "/guide/lifecycle/#p_85",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Prefer to name the Reach file index.rsh"
  },
  {
    "objectID": "/guide/lifecycle/#p_86",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "In most cases, prefer {!rsh} APIs over {!rsh} Participants"
  },
  {
    "objectID": "/guide/lifecycle/#p_87",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Always include {!rsh} invariants about the contract balance(s) for all currencies in a {!rsh} while loop87 Every time a theorem fails within a {!rsh} while loop your first impulse should be to add an {!rsh} invariant, not a {!rsh} check"
  },
  {
    "objectID": "/guide/lifecycle/#p_88",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Every time a theorem fails within a {!rsh} while loop your first impulse should be to add an {!rsh} invariant, not a {!rsh} check"
  },
  {
    "objectID": "/guide/lifecycle/#p_89",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Use {!rsh} parallelReduce for contracts that require loops and respond to {!rsh} APIs on demand"
  },
  {
    "objectID": "/guide/lifecycle/#p_90",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "When waiting for a single {!rsh} API call without looping, use simpler tools such as {!rsh} fork or {!rsh} call, instead of a {!rsh} parallelReduce"
  },
  {
    "objectID": "/guide/lifecycle/#p_91",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "{!rsh} 'use strict' is ok, but not necessary. Use it only if you want."
  },
  {
    "objectID": "/guide/lifecycle/#p_92",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "{!rsh} verifyArithmetic is good, but not necessary. Use it if you can."
  },
  {
    "objectID": "/guide/lifecycle/#p_93",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Refine is a good way to ensure that invariants get checked at boundaries like {!rsh} interact and {!rsh} publish. Use it if applicable."
  },
  {
    "objectID": "/guide/lifecycle/#p_94",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Observing so called, \"real\" time with {!rsh} absoluteSecs and {!rsh} relativeSecs should be avoided. The aforementioned methods measure time passed on the blockchain. In the event of a network failure time will appear to stop when measured with {!rsh} absoluteSecs and {!rsh} relativeSecs. Contracts based on block number is a better option, however, this option can become unreliable if transaction speeds change over time. Consider your business and consumer needs when considering measuring the passage of time."
  },
  {
    "objectID": "/guide/lifecycle/#p_95",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "The output of the compiler can be committed so that UI developers don't need to run the compiler:"
  },
  {
    "objectID": "/guide/lifecycle/#p_96",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Use the designated Reach version to compile: REACH_VERSION=x.x reach compile"
  },
  {
    "objectID": "/guide/lifecycle/#p_97",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Commit build/index.main.mjs and any other files in build/ that are needed"
  },
  {
    "objectID": "/guide/lifecycle/#p_98",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Commit any additional artifacts, such as those useful for auditors"
  },
  {
    "objectID": "/guide/lifecycle/#p_99",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "gitignore everything else in build/"
  },
  {
    "objectID": "/guide/lifecycle/#p_100",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Committing intermediate artifacts can be useful for auditors. When preparing for an audit, compile with the --intermediate-files flag to persist them to your file system."
  },
  {
    "objectID": "/guide/lifecycle/#p_101",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "For example, in an Algorand contract, .dot and .teal files may be helpful:"
  },
  {
    "objectID": "/guide/lifecycle/#p_102",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "You can also generate .png images by using the dot program:"
  },
  {
    "objectID": "/guide/lifecycle/#p_103",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Write tests at the Reach level of abstraction without regard to the intended UI in which the Reach program will be used. The Reach contract should incorporate a robust test suite to ensure its security. Follow these guidelines when writing Reach tests:"
  },
  {
    "objectID": "/guide/lifecycle/#p_104",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Remember that people and bots can send transactions directly to a contract without using a UI"
  },
  {
    "objectID": "/guide/lifecycle/#p_105",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Tests should be runnable with {!cmd} reach run105 Prefer to write the test suite in index.mjs106 Prefer to use {!js} test.one and {!js} test.run from stdlib"
  },
  {
    "objectID": "/guide/lifecycle/#p_106",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Prefer to write the test suite in index.mjs"
  },
  {
    "objectID": "/guide/lifecycle/#p_107",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Prefer to use {!js} test.one and {!js} test.run from stdlib"
  },
  {
    "objectID": "/guide/lifecycle/#p_108",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Tests should pass on all connectors (ETH, ALGO) that will actually be used by the DApp"
  },
  {
    "objectID": "/guide/lifecycle/#p_109",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Tests should be plugged into CI and run on every PR that changes the contract109 Tests should run using a designated version of Reach110 It is useful to run a nightly job on the CI to detect regressions early111 Tests should be included in build processes112 PRs should not be merged until the CI passes correctly"
  },
  {
    "objectID": "/guide/lifecycle/#p_110",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Tests should run using a designated version of Reach"
  },
  {
    "objectID": "/guide/lifecycle/#p_111",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "It is useful to run a nightly job on the CI to detect regressions early"
  },
  {
    "objectID": "/guide/lifecycle/#p_112",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Tests should be included in build processes"
  },
  {
    "objectID": "/guide/lifecycle/#p_113",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "PRs should not be merged until the CI passes correctly"
  },
  {
    "objectID": "/guide/lifecycle/#p_114",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Tests should be self-contained and avoid relying on outside setup"
  },
  {
    "objectID": "/guide/lifecycle/#p_115",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Tests should not rely on a fresh devnet, being the only thing running on devnet, and should avoid checking for exact block numbers115 Sometimes this is unavoidable when the contract has differing behavior based on entering new states or ending based on elapsed block time"
  },
  {
    "objectID": "/guide/lifecycle/#p_116",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Sometimes this is unavoidable when the contract has differing behavior based on entering new states or ending based on elapsed block time"
  },
  {
    "objectID": "/guide/lifecycle/#p_117",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Tests should demonstrate that the happy path leads to the desired outcomes"
  },
  {
    "objectID": "/guide/lifecycle/#p_118",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Tests should demonstrate that unauthorized and invalid API calls are rejected by the contract"
  },
  {
    "objectID": "/guide/lifecycle/#p_119",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "It should be clear when and if tests are complete and no contract should be shipped without complete tests"
  },
  {
    "objectID": "/guide/lifecycle/#p_120",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Integrate the smart contract into the UI after Reach tests pass:"
  },
  {
    "objectID": "/guide/lifecycle/#p_121",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Use the project's specified version of '@reach-sh/stdlib'"
  },
  {
    "objectID": "/guide/lifecycle/#p_122",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Retrieve the aforementioned contract artifacts122 The UI can be created before the contract is finished, but it is critical to predetermine the {!rsh} APIs, {!rsh} Views, and {!rsh} Events"
  },
  {
    "objectID": "/guide/lifecycle/#p_123",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "The UI can be created before the contract is finished, but it is critical to predetermine the {!rsh} APIs, {!rsh} Views, and {!rsh} Events"
  },
  {
    "objectID": "/guide/lifecycle/#p_124",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Never use Number when dealing with amounts of currency, especially fractional amounts. Number uses a floating point representation that is prone to weird rounding issues.124 Use BigInt or BigNumber to represent the amount as an integer in its atomic unit125 Use n.toString() or JSON.stringify(n) if it has to be formatted as JSON126 Render to a user-friendly string at the last moment before displaying to the user127 Parse and store as a BigInt or BigNumber as soon as possible when receiving input from a user"
  },
  {
    "objectID": "/guide/lifecycle/#p_125",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Use BigInt or BigNumber to represent the amount as an integer in its atomic unit"
  },
  {
    "objectID": "/guide/lifecycle/#p_126",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Use n.toString() or JSON.stringify(n) if it has to be formatted as JSON"
  },
  {
    "objectID": "/guide/lifecycle/#p_127",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Render to a user-friendly string at the last moment before displaying to the user"
  },
  {
    "objectID": "/guide/lifecycle/#p_128",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Parse and store as a BigInt or BigNumber as soon as possible when receiving input from a user"
  },
  {
    "objectID": "/guide/lifecycle/#p_129",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Test the DApp's UI as functionality is integrated. UI development is a granular process, in that each element builds upon the other:"
  },
  {
    "objectID": "/guide/lifecycle/#p_130",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Test the UI with a devnet using {!cmd} reach devnet"
  },
  {
    "objectID": "/guide/lifecycle/#p_131",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Run a devnet in the background with {!cmd} reach devnet --await background"
  },
  {
    "objectID": "/guide/lifecycle/#p_132",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Prefer to test with devnet because it is much faster than testnet and can easily fund test accounts"
  },
  {
    "objectID": "/guide/lifecycle/#p_133",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Engineers at Reach recommend using cypress for automated UI testing"
  },
  {
    "objectID": "/guide/lifecycle/#p_134",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Integrate automated UI testing into CI"
  },
  {
    "objectID": "/guide/lifecycle/#p_135",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Thorough user testing of the UI will eliminate embarrassing bugs and glitches in the user experience:"
  },
  {
    "objectID": "/guide/lifecycle/#p_136",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Document a manual \"smoke test\" that is performed by individual developer team members prior to asking others to run user tests136 Automate the smoke test to whatever degree possible and roll that work into the automated UI tests137 Document remaining manual tests to quickly reproduce errors"
  },
  {
    "objectID": "/guide/lifecycle/#p_137",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Automate the smoke test to whatever degree possible and roll that work into the automated UI tests"
  },
  {
    "objectID": "/guide/lifecycle/#p_138",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Document remaining manual tests to quickly reproduce errors"
  },
  {
    "objectID": "/guide/lifecycle/#p_139",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Work with a product manager to plan, announce, and release public test versions of the UI and associated smart contracts. Use the opportunity for PR to create buzz about the product. Proper timing for releases and promotions can be important."
  },
  {
    "objectID": "/guide/lifecycle/#p_140",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Prefer internal user testing before public user testing"
  },
  {
    "objectID": "/guide/lifecycle/#p_141",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Incentivize public user testing to increase participation. A product manager can determine the proper incentives to offer."
  },
  {
    "objectID": "/guide/lifecycle/#p_142",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Apply a password to the UI for internal testnet testing"
  },
  {
    "objectID": "/guide/lifecycle/#p_143",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Prefer testing with testnet rather than mainnet unless there's a compelling counter argument"
  },
  {
    "objectID": "/guide/lifecycle/#p_144",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Perform a release to staging aimed at mainnet and user test before pushing to production"
  },
  {
    "objectID": "/guide/lifecycle/#p_145",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Slow is smooth. Smooth is fast. Taking time to identify the key goals and requirements of the DApp will inform what to test for and create an efficient development experience of the back and frontends. In turn, auditors will be able to more easily understand a highly structured application which will allow you to move to user testing and production in faster time. Join our Discord for access to personalized help and guidance."
  },
  {
    "objectID": "/guide/lifecycle/#p_146",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Commission an audit of the smart contracts to provide peace of mind to your stakeholders. Reach has used FYEO and EKA Silicon for audits. They are prepared to audit Reach contracts and are able to provide such services for a lower fee and at a faster turn around time then other low-level language audits."
  },
  {
    "objectID": "/guide/lifecycle/#p_147",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Ensure the highest confidence in the contract before securing an audit. Ideally, this confidence should be reinforced with successful UI tests before an audit is secured. Reach is happy to offer code reviews and advice as part of our [in]Reach Partner Program."
  },
  {
    "objectID": "/guide/lifecycle/#p_148",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Following the best practices in this guide will result in faster DApp development cycles with fewer surprises. Encouraging test-driven development creates fewer vulnerabilities and provides the opportunity to create greater public confidence in your DApp. Our partners have realized a savings of 7x as compared to traditional blockchain development practices. We're happy to talk to you about your DApp and how you can use Reach to get to market safer and faster."
  },
  {
    "objectID": "/guide/lifecycle/#p_149",
    "pt": "Contract Development Lifecycle and Best Practices for Building Reach DApps",
    "t": 3,
    "c": "Say hello if you'd like to talk to Reach about our [in]Reach Partner Program."
  },
  {
    "objectID": "/guide/limits/#guide-limits",
    "pt": "What are Reach's limitations?",
    "t": 2,
    "c": "What are Reach's limitations?"
  },
  {
    "objectID": "/guide/limits/#p_0",
    "pt": "What are Reach's limitations?",
    "t": 3,
    "c": "Today, Reach is a powerful language for building decentralized applications, as demonstrated in the overview, the tutorial, and the workshop series. However, it has a lot of potential for growth. This section describes a few of these areas and gives brief sketches of our roadmap for directing this growth. We welcome your contributions on GitHub and in the Discord community to help bring these plans to fruition."
  },
  {
    "objectID": "/guide/limits/#p_1",
    "pt": "What are Reach's limitations?",
    "t": 3,
    "c": "Connectors. Foremost, Reach is a consensus network-agnostic language, so one of our highest priorities is supporting a wide variety of platforms, including layer-2 abstractions over other layer-1 networks. Presently, we have a robust Ethereum backend and Algorand backend."
  },
  {
    "objectID": "/guide/limits/#p_2",
    "pt": "What are Reach's limitations?",
    "t": 3,
    "c": "Backends. Presently, Reach has a robust backend for JavaScript that is well-suited for client-facing applications and JavaScript servers. However, we believe that many decentralized application developers would like to make use of languages like Go and Rust for their participants. Presently, this can be accomplished via the RPC server, but we'd like to build a dedicated backend for languages like these."
  },
  {
    "objectID": "/guide/limits/#p_3",
    "pt": "What are Reach's limitations?",
    "t": 3,
    "c": "Computation. Reach's computational language is based on JavaScript and contains many of JavaScript's most desirable features, like arrow expressions, free-form objects, destructuring bindings, robust {!rsh} import and {!rsh} export specificiers, and so on. However, there are some differences that represent limitations, such as the inability to use functions as values at runtime and the need to enforce finite limits on data."
  },
  {
    "objectID": "/guide/limits/#p_4",
    "pt": "What are Reach's limitations?",
    "t": 3,
    "c": "Verification. Reach's verifier is robust in the face of many complex and interesting theorems about decentralized application behavior, but it is inherently conservative and does not presently allow users to manually prove theorems that are conservatively rejected."
  },
  {
    "objectID": "/guide/limits/#p_5",
    "pt": "What are Reach's limitations?",
    "t": 3,
    "c": "Network Integration. Since Reach is consensus network-agnostic, it is not possible for Reach programs to directly integrate with network-specific features, such as observing the blockhash on Ethereum. Reach programs can instead interact with these low-level details of their chosen consensus network via remote object interaction."
  },
  {
    "objectID": "/guide/limits/#p_6",
    "pt": "What are Reach's limitations?",
    "t": 3,
    "c": "Communication. Reach's communication language has some limitations that we have plans to remove, which are discussed in roadmap, but there are some for which we do not have plans to remove. For example, we do not intend to support co-inductive or cyclic state, nor expose an arbitrary consensus heap to programmers."
  },
  {
    "objectID": "/guide/logging/#guide-logging",
    "pt": "How do I add tracing logs to my Reach program?",
    "t": 2,
    "c": "How do I add tracing logs to my Reach program?"
  },
  {
    "objectID": "/guide/logging/#p_0",
    "pt": "How do I add tracing logs to my Reach program?",
    "t": 3,
    "c": "Sometimes it is useful to add \"tracing logs\" to your program so you can see the values of variables and computations as the program is running. For example, if we were writing purely in JavaScript, we might write"
  },
  {
    "objectID": "/guide/logging/#p_1",
    "pt": "How do I add tracing logs to my Reach program?",
    "t": 3,
    "c": "And we'd see the output"
  },
  {
    "objectID": "/guide/logging/#p_2",
    "pt": "How do I add tracing logs to my Reach program?",
    "t": 3,
    "c": "How can we do something like this in Reach?"
  },
  {
    "objectID": "/guide/logging/#p_3",
    "pt": "How do I add tracing logs to my Reach program?",
    "t": 3,
    "c": "The key is to use participant interact interfaces to share arbitrary information with the frontend, which has the ability to log to a console or any other tracing service. For example:"
  },
  {
    "objectID": "/guide/logging/#p_4",
    "pt": "How do I add tracing logs to my Reach program?",
    "t": 3,
    "c": "However, as this example shows, it can be inconvenient to use this pattern, because {!rsh} Fun types constrain their domains to particular input data types, but we may need to log different kinds of data at different points in the program. Similarly, it is inconvenient to use an entire {!rsh} only block for a simple log."
  },
  {
    "objectID": "/guide/logging/#p_5",
    "pt": "How do I add tracing logs to my Reach program?",
    "t": 3,
    "c": "Reach provides two conveniences for this situation that taste great together: unconstrained domain function types and interact shorthand. The first allows a function in a participant interact interface to have a completely unconstrained domain. The second allows a call to a frontend from anywhere without an {!rsh} only, provided the function returns no value. If we re-write the above example using both of these patterns, it looks like:"
  },
  {
    "objectID": "/guide/logging/#p_6",
    "pt": "How do I add tracing logs to my Reach program?",
    "t": 3,
    "c": "Then, a JavaScript frontend can simply use {!js} console.log as the value of the log function."
  },
  {
    "objectID": "/guide/logging/#p_7",
    "pt": "How do I add tracing logs to my Reach program?",
    "t": 3,
    "c": "Reach provides {!rsh} hasConsoleLogger and hasConsoleLogger (Frontend) in the standard library for default implementations of logging to stdout. It can be used in Reach with:"
  },
  {
    "objectID": "/guide/logging/#p_8",
    "pt": "How do I add tracing logs to my Reach program?",
    "t": 3,
    "c": "and in the JavaScript frontend with:"
  },
  {
    "objectID": "/guide/logging/#p_9",
    "pt": "How do I add tracing logs to my Reach program?",
    "t": 3,
    "c": "The Reach development repository contains an example of this pattern: log/index.rsh and log/index.mjs."
  },
  {
    "objectID": "/guide/loop-invs/#guide-loop-invs",
    "pt": "Finding and using loop invariants",
    "t": 2,
    "c": "Finding and using loop invariants"
  },
  {
    "objectID": "/guide/loop-invs/#p_0",
    "pt": "Finding and using loop invariants",
    "t": 3,
    "c": "Reach requires that {!rsh} while loops are annotated with loop invariants. A loop invariant is a property {!rsh} INV which is true before the loop starts and is true after the loop ends."
  },
  {
    "objectID": "/guide/loop-invs/#p_1",
    "pt": "Finding and using loop invariants",
    "t": 3,
    "c": "Consider the following program fragment,"
  },
  {
    "objectID": "/guide/loop-invs/#p_2",
    "pt": "Finding and using loop invariants",
    "t": 3,
    "c": "We can summarize the properties that must be true about this code as follows:"
  },
  {
    "objectID": "/guide/loop-invs/#p_3",
    "pt": "Finding and using loop invariants",
    "t": 3,
    "c": "{!rsh} before and {!rsh} V = INIT implies {!rsh} INV --- The earlier part of the program must establish {!rsh} INV."
  },
  {
    "objectID": "/guide/loop-invs/#p_4",
    "pt": "Finding and using loop invariants",
    "t": 3,
    "c": "If {!rsh} COND and {!rsh} INV, then {!rsh} body and {!rsh} V = NEXT implies {!rsh} INV --- The loop body can make use of the truth of the condition and the invariant to re-establish the invariant after {!rsh} V is mutated to {!rsh} NEXT."
  },
  {
    "objectID": "/guide/loop-invs/#p_5",
    "pt": "Finding and using loop invariants",
    "t": 3,
    "c": "{!rsh} ! COND and {!rsh} INV and {!rsh} after implies {!rsh} P --- The later part of the program can make use of the negation of the condition and the invariant to establish any future assertions."
  },
  {
    "objectID": "/guide/loop-invs/#p_6",
    "pt": "Finding and using loop invariants",
    "t": 3,
    "c": "Loop invariants only need to mention values that can vary because of the execution of the loop. In Reach, all bindings are immutable, except for those bound by {!rsh} while, so they never need to be mentioned. However, Reach has two kinds of mutable bindings: loop variables and the contract balance (which is imperatively modified by {!rsh} pay and {!rsh} transfer). As such, both of these are typically mentioned in loop invariants."
  },
  {
    "objectID": "/guide/loop-invs/#p_7",
    "pt": "Finding and using loop invariants",
    "t": 3,
    "c": "Loop variables are mentioned if they occur in subsequent assertions, or if they are used to perform potentially unsafe actions, like an array dereference. But, since every Reach program terminates with the token linearity property, loop invariants always reference the contract balance."
  },
  {
    "objectID": "/guide/loop-invs/#p_8",
    "pt": "Finding and using loop invariants",
    "t": 3,
    "c": "When designing a loop invariant, first write down an equation for the contract balance before the loop. If the loop contains any transfers to the contract, then you must be able to track the amount and number of these. In the best case, you should be able to express the balance as an equation over the existing loop variables. In the worst case, you will have to add more loop variables to track some quantity, like the number of rounds of a game, that the balance is derived from."
  },
  {
    "objectID": "/guide/loop-invs/#p_9",
    "pt": "Finding and using loop invariants",
    "t": 3,
    "c": "After you've tracked the balance, you will need to add additional clauses that track whatever properties you rely on in the tail of the loop."
  },
  {
    "objectID": "/guide/loop-invs/#p_10",
    "pt": "Finding and using loop invariants",
    "t": 3,
    "c": "The most complex circumstance is when you have nested loops. In this situation, the inner loop's invariant will have to include clauses related to the outer loop's invariant."
  },
  {
    "objectID": "/guide/nntoks/#guide-nntoks",
    "pt": "How do network and non-network tokens differ?",
    "t": 2,
    "c": "How do network and non-network tokens differ?"
  },
  {
    "objectID": "/guide/nntoks/#how-do-network-tokens-behave",
    "pt": "How do network and non-network tokens differ?",
    "t": 2,
    "c": "How do network tokens behave?"
  },
  {
    "objectID": "/guide/nntoks/#how-do-non-network-tokens-violate-this",
    "pt": "How do network and non-network tokens differ?",
    "t": 2,
    "c": "How do non-network tokens violate this?"
  },
  {
    "objectID": "/guide/nntoks/#why-does-this-matter",
    "pt": "How do network and non-network tokens differ?",
    "t": 2,
    "c": "Why does this matter?"
  },
  {
    "objectID": "/guide/nntoks/#what-does-reach-do-about-this",
    "pt": "How do network and non-network tokens differ?",
    "t": 2,
    "c": "What does Reach do about this?"
  },
  {
    "objectID": "/guide/nntoks/#what-can-i-do-about-it",
    "pt": "How do network and non-network tokens differ?",
    "t": 2,
    "c": "What can I do about it?"
  },
  {
    "objectID": "/guide/nntoks/#are-there-any-situations-where-i-cant-do-anything-about-it",
    "pt": "How do network and non-network tokens differ?",
    "t": 2,
    "c": "Are there any situations where I can't do anything about it?"
  },
  {
    "objectID": "/guide/nntoks/#p_0",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "Reach assumes that network tokens and non-network tokens behave identically on consensus networks, but this is not the case in practice."
  },
  {
    "objectID": "/guide/nntoks/#p_1",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "An account on a consensus network can hold network tokens and as long as the network is available, it may send these tokens to other accounts or receive tokens from other accounts without preapproval from recipients and without the interference of third-parties not involved in a particular transfer. Each network may prescribe fees on transfers or other similar constraints on transfers (such as a minimum balance holding to send funds) but may not restrict the reception of funds or arbitrarily hold or reclaim network tokens. All consensus networks that Reach supports obey these properties."
  },
  {
    "objectID": "/guide/nntoks/#p_2",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "In each of the networks supported by Reach, non-network tokens may violate these expectations."
  },
  {
    "objectID": "/guide/nntoks/#p_3",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "On Ethereum, and Ethereum-like networks, where non-network tokens are just particular patterns of smart contracts, the concrete behavior of abstract operations like \"Transfer 10 Zorkmids from John to Paul\" may have arbitrary semantics. For example, a smart contract insisting that Paul pre-approve the reception of Zorkmids; a smart contract could allow all transfers to be universally halted, like an old-fashioned bank closure; a smart contract could simply take John's Zorkmids away because the administrator of the token decides to; and so on. Smart contracts have power to implement arbitrary semantics and there is no guarantee that a smart contract that supplies a function with the name transfer and the signature function transfer(address _to, uint256 _value) public returns (bool success) has any particular behavior. Furthermore, you can send network tokens to a contract as you create it, but you cannot send non-network tokens, because sending non-network tokens (using ERC-20) requires knowing a contract's address, which you cannot know until after you create it (unless you use a particular low-level creation operation)."
  },
  {
    "objectID": "/guide/nntoks/#p_4",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "On Algorand, non-network tokens are built into the network, so they have a stable and predictable semantics, but that semantics is different than network tokens. For example, non-network token reception must be pre-approved so John cannot transfer to Paul unless Paul has predetermined he is willing to accept Zorkmids. Furthermore, non-network token creation supports options which have further differences: it may be possible to \"freeze\" all transfers, so that no one can make any transfers; and, it may be possible to \"clawback\" balances, so that John's Zorkmids can be removed from his account without his intervention."
  },
  {
    "objectID": "/guide/nntoks/#p_5",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "On each network, it is possible to minimize these differences---by disabling these options and obeying a standard semantics---but that behavior is not universal among all tokens."
  },
  {
    "objectID": "/guide/nntoks/#p_6",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "Non-network tokens minted by Reach always disable these options and behave as closely as possible to network tokens."
  },
  {
    "objectID": "/guide/nntoks/#p_7",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "These issues matter because developers and users of their applications need to understand that when they interact with a non-network token, they are interacting with a third party that can potentially control their application's behavior."
  },
  {
    "objectID": "/guide/nntoks/#p_8",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "For example, suppose George and Ringo decide to play poker on a consensus network and bet Zorkmids, rather than network tokens. If the manager of Zorkmids, Zorkmanager, freezes them, then the game must stop. If the game requires that hands be provided in a timely fashion, then George could bribe Zorkmanager to freeze them every time it is Ringo's turn, forcing him to forfeit a round."
  },
  {
    "objectID": "/guide/nntoks/#p_9",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "Suppose at the end of the game, there is a pot of 200 Zorkmids with 5 meant for George and 195 meant for Ringo. If Zorkmanager takes 1 Zorkmid from the pot via \"clawback\", then only one of the parties can be paid in full. What's worse, an application may be programmed to either transfer everything or nothing, so in this scenario if George extracts first, then Ringo will not be able to extract anything. Furthermore, suppose the application is programmed to clear the pot atomically, disbursing to each player in one single step; in this scenario, if recipients are required to pre-authorize holding a token, then George can revoke that permission to spite Ringo and prevent him from getting his allocation."
  },
  {
    "objectID": "/guide/nntoks/#p_10",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "In summary, non-network tokens' semantics are non-intuitive considering the power given to their creators."
  },
  {
    "objectID": "/guide/nntoks/#p_11",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "Reach uses a verification engine to model the semantics of Reach programs to predict and reason about their behavior. In particular, it tries to prove two theorems:"
  },
  {
    "objectID": "/guide/nntoks/#p_12",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "Honesty: Honest participants will not submit transactions that will be rejected."
  },
  {
    "objectID": "/guide/nntoks/#p_13",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "Progress: If honest participants submit transactions, the program will finish."
  },
  {
    "objectID": "/guide/nntoks/#p_14",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "If a program contains an operation such as \"Transfer 10 tokens to John\", then there are certain pre-conditions that must be true for this operation to succeed, such as \"The contract holds at least 10 tokens\". Reach will guarantee that every pre-condition in the program is entailed by the earlier parts of the program. When pre-conditions depend on user input, it will ensure that honest participants check that input before submitting the transaction."
  },
  {
    "objectID": "/guide/nntoks/#p_15",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "Non-network tokens, because they are arbitrary code on some networks and depend on transient state controlled by third-parties on other networks, have no semantics, and therefore, have no predictable pre-conditions. This means that it is impossible to predict whether an operation will succeed or fail simply by knowing it (for example) follows the ERC-20 specification or is an Algorand Standard Asset."
  },
  {
    "objectID": "/guide/nntoks/#p_16",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "In our design of Reach, we had three choices when contemplating how to manage such unpredictability."
  },
  {
    "objectID": "/guide/nntoks/#p_17",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "First, we could represent non-network token operations as free terms with no semantics, and thus unpredictable behavior. We did not do this, because users expect they'll have a particular behavior (most actually do!) and expect that Reach's token linearity verification will apply to non-network tokens as well."
  },
  {
    "objectID": "/guide/nntoks/#p_18",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "Second, we could explicitly represent the details of the power each network gives to non-network token creators and include their state space in the analysis of Reach programs. We did not do this, because it is impossible to write programs that are generic in the non-network tokens they use with this token. In other words, a Reach program that implemented a poker game couldn't be constructed to use some token. Rather, it would have to be a game that used Zorkmids, and you'd have to write (or verify) another program for a game that used Gil, and so on. Given that most tokens actually behave properly, this would be unnecessarily painful for productive programming."
  },
  {
    "objectID": "/guide/nntoks/#p_19",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "Third, we can assume that non-network tokens behave the same as network tokens and document the differences and educate developers and users about the consequences of this. Clearly, this is what we did."
  },
  {
    "objectID": "/guide/nntoks/#p_20",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "First, if you use non-network tokens, you need to understand that you are trusting the token issuer as much as you are trusting the consensus network itself. This means that you need to audit its code, or configuration, and decide if you can place trust in its manager."
  },
  {
    "objectID": "/guide/nntoks/#p_21",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "Second, if your token requires pre-authorization of receipt, and if this pre-authorization can be revoked, you need to remove atomic simultaneous transfers of non-network tokens from your program and replace them with phases where each party can receive their tokens individually, so that one party cannot maliciously opt-out to prevent the other party from receiving their funds."
  },
  {
    "objectID": "/guide/nntoks/#p_22",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "Finally, you can advocate, perhaps with your money and support, that consensus networks pursue giving non-network tokens feature parity with network tokens so that there will be a consensus network that can faithfully implement the token semantics users expect."
  },
  {
    "objectID": "/guide/nntoks/#p_23",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "On Algorand, when a Reach program is ending, it closes out all of its accounts. This returns any funds that were part of the minimum balance back to the deployer, as well as any rewards or other funds that were received outside of the scope of the program's operation."
  },
  {
    "objectID": "/guide/nntoks/#p_24",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "Since you cannot close an account until you have de-authorized receipt of all non-network tokens (because that authorization increases your minimum balance), we close out each one of those non-network token accounts to the deployer too."
  },
  {
    "objectID": "/guide/nntoks/#p_25",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "This means that the deployer has the ability to block the destruction of contracts by de-authorizing themselves as a recipient of the non-network token."
  },
  {
    "objectID": "/guide/nntoks/#p_26",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "For example, this sequence of actions will block a Reach program from destruction on Algorand:"
  },
  {
    "objectID": "/guide/nntoks/#p_27",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "This will fail because the contract will try to close out its Zorkmid account (which contains 1 Zorkmid) to Aang, who has never authorized receipt of Zorkmids. Thus, Zuko can disrupt the otherwise safe activity of Aang, Katara, and Sokka."
  },
  {
    "objectID": "/guide/nntoks/#p_28",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "The remedies for this are:"
  },
  {
    "objectID": "/guide/nntoks/#p_29",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "Reach can switch to a model where contracts have to be \"lazily\" destroyed. In this model, rather than exitting, Reach contracts would transition to a \"zombie\" state where each resource can be individually freed, until all are free, whereupon they are actually deleted."
  },
  {
    "objectID": "/guide/nntoks/#p_30",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "Reach users can change their programs to always end by running {!rsh} getUntrackedFunds(Zorkmids) and transferring the funds to a known receiver agent."
  },
  {
    "objectID": "/guide/nntoks/#p_31",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "Reach users can ensure that the deployer will always accept the same non-network tokens as the contract. (This is a special case of #2.)"
  },
  {
    "objectID": "/guide/nntoks/#p_32",
    "pt": "How do network and non-network tokens differ?",
    "t": 3,
    "c": "We expect to eventually implement an option for #1, but it is very expensive for end-users, so we don't expect users will always want it. (It is expensive, because these \"zombies\" have to be found and destroyed manually.)"
  },
  {
    "objectID": "/guide/packages/#guide-packages",
    "pt": "Sharing and discovering shared Reach packages",
    "t": 2,
    "c": "Sharing and discovering shared Reach packages"
  },
  {
    "objectID": "/guide/packages/#p_0",
    "pt": "Sharing and discovering shared Reach packages",
    "t": 3,
    "c": "Reach makes library packaging very easy: simply push your code to GitHub or BitBucket and tag it to mark a version number."
  },
  {
    "objectID": "/guide/packages/#p_1",
    "pt": "Sharing and discovering shared Reach packages",
    "t": 3,
    "c": "Packages on GitHub may also activate the reach-pkg topic by configuring it in their repo's \"About\" configuration to enjoy greater discoverability."
  },
  {
    "objectID": "/guide/packages/#p_2",
    "pt": "Sharing and discovering shared Reach packages",
    "t": 3,
    "c": "The package imports reference section details Reach's remote module import syntax, and the compile command reference describes the --install-pkgs command-line argument which allows remote packages to be fetched during compilation."
  },
  {
    "objectID": "/guide/parallelReduce/#guide-parallelReduce",
    "pt": "parallelReduce Guide",
    "t": 2,
    "c": "parallelReduce Guide"
  },
  {
    "objectID": "/guide/parallelReduce/#description",
    "pt": "parallelReduce Guide",
    "t": 2,
    "c": "Description"
  },
  {
    "objectID": "/guide/parallelReduce/#api-inputs-and-returns",
    "pt": "parallelReduce Guide",
    "t": 2,
    "c": "API Inputs and Returns"
  },
  {
    "objectID": "/guide/parallelReduce/#api_-vs-api-syntax",
    "pt": "parallelReduce Guide",
    "t": 2,
    "c": ".api_ vs .api Syntax"
  },
  {
    "objectID": "/guide/parallelReduce/#api_",
    "pt": "parallelReduce Guide",
    "t": 2,
    "c": ".api_"
  },
  {
    "objectID": "/guide/parallelReduce/#api",
    "pt": "parallelReduce Guide",
    "t": 2,
    "c": ".api"
  },
  {
    "objectID": "/guide/parallelReduce/#define-your-views",
    "pt": "parallelReduce Guide",
    "t": 2,
    "c": ".define your Views"
  },
  {
    "objectID": "/guide/parallelReduce/#pay-the-pied-parallelreduce",
    "pt": "parallelReduce Guide",
    "t": 2,
    "c": "Pay the Pied ParallelReduce"
  },
  {
    "objectID": "/guide/parallelReduce/#non-network-tokens",
    "pt": "parallelReduce Guide",
    "t": 2,
    "c": "Non-network Tokens"
  },
  {
    "objectID": "/guide/parallelReduce/#p_0",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "The purpose of this guide is to bring together all of the information we have about the parallelReduce and to provide additional clarity on how it works and why we use it."
  },
  {
    "objectID": "/guide/parallelReduce/#p_1",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "There are layers of abstraction to the {!rsh} parallelReduce structure that we should understand first."
  },
  {
    "objectID": "/guide/parallelReduce/#p_2",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Generally speaking it is an abbreviation of a {!rsh} while loop pattern."
  },
  {
    "objectID": "/guide/parallelReduce/#p_3",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "The variables you set are repeatedly updated uniquely by each one of your participants until the loop condition no longer holds. Values are updated via {!rsh} return statements, while {!rsh} continue is implicit."
  },
  {
    "objectID": "/guide/parallelReduce/#p_4",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "If some thing or many things can be done by many different people, you use a {!rsh} parallelReduce to handle the {!rsh} fork and cases."
  },
  {
    "objectID": "/guide/parallelReduce/#p_5",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "A {!rsh} fork is a {!rsh} race between API members where we are unsure who exactly is performing the next consensus operation, this is why they are common with API members – which offer functionality to many different participants."
  },
  {
    "objectID": "/guide/parallelReduce/#p_6",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "{!rsh} fork ends in the execution of a {!rsh} switch structure, executing the appropriate case (if Bob1 wins do this, if Bob2 wins do that). Read more about {!rsh} fork, including the underlying code that makes up the {!rsh} fork keyword."
  },
  {
    "objectID": "/guide/parallelReduce/#p_7",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Learn more about {!rsh} race in the race guide."
  },
  {
    "objectID": "/guide/parallelReduce/#p_8",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Read through the guide about when to use what kind of consensus transfer."
  },
  {
    "objectID": "/guide/parallelReduce/#p_9",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "After you understand that you can examine the structure of {!rsh} parallelReduce components and their definitions."
  },
  {
    "objectID": "/guide/parallelReduce/#p_10",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Let's start by looking at the most simple {!rsh} parallelReduce that we could implement."
  },
  {
    "objectID": "/guide/parallelReduce/#p_11",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Here we declare one API member function countUp for the API on line 9, then define its functionality below."
  },
  {
    "objectID": "/guide/parallelReduce/#p_12",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 18 declares one loop variable count and initializes it to zero, starting the {!rsh} parallelReduce."
  },
  {
    "objectID": "/guide/parallelReduce/#p_13",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 19 sets the {!rsh} invariant, this contract will accept no tokens."
  },
  {
    "objectID": "/guide/parallelReduce/#p_14",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 20 is a standard {!rsh} while loop condition, it runs until the condition breaks."
  },
  {
    "objectID": "/guide/parallelReduce/#p_15",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 21 is the definition of our API member function countUp API.functionName and takes zero arguments."
  },
  {
    "objectID": "/guide/parallelReduce/#p_16",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 22 starts the outer {!rsh} return and zero is in the pay expression. This function takes no payment from the user. You can specify any number to be paid by the user here. You can also omit the zero and Reach will synthesize this to zero. ret is the {!rsh} return function to return the function signature value to the caller. Here we have said that the {!rsh} return value is a {!rsh} UInt on line 8. More information on this below."
  },
  {
    "objectID": "/guide/parallelReduce/#p_17",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 23 invokes that {!rsh} return function and returns the count."
  },
  {
    "objectID": "/guide/parallelReduce/#p_18",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 24 updates the count loop variable to newCount."
  },
  {
    "objectID": "/guide/parallelReduce/#p_19",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "All API member functions must rely only on consensus state and the function inputs."
  },
  {
    "objectID": "/guide/parallelReduce/#p_20",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "The API member function has a consensus reduction specification function that takes an argument. Here that function is called ret."
  },
  {
    "objectID": "/guide/parallelReduce/#p_21",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "You can name this function anything you like, traditionally ret or k is used to denote return or continuation, respectively."
  },
  {
    "objectID": "/guide/parallelReduce/#p_22",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "ret must be called inside the API member function to provide the {!rsh} return value to the API caller. Below on line 17 is the function signature for the API member function register. It takes no arguments and returns {!rsh} null."
  },
  {
    "objectID": "/guide/parallelReduce/#p_23",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "And here again is the implementation of the register function, this time pointing to the inputs and outputs."
  },
  {
    "objectID": "/guide/parallelReduce/#p_24",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Remember, it takes no arguments and returns {!rsh} null."
  },
  {
    "objectID": "/guide/parallelReduce/#p_25",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 52 specifies the API and which function we are referencing Guest.register. The empty parenthesis denotes that it takes no parameters."
  },
  {
    "objectID": "/guide/parallelReduce/#p_26",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 59 invokes our ret function and returns a {!rsh} null value to the caller."
  },
  {
    "objectID": "/guide/parallelReduce/#p_27",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "As an exercise -- bring the index.rsh file to your machine and change the ret(null) on line 59 to ret(true) and see what error comes up."
  },
  {
    "objectID": "/guide/parallelReduce/#p_28",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "You should get a type mismatch error, because the return does not match the function signature. RE"
  },
  {
    "objectID": "/guide/parallelReduce/#p_29",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Now that we understand our loop, how to update values, and how to structure function inputs and outputs -- let's look at the difference in syntax between {!rsh} .api and {!rsh} .api_."
  },
  {
    "objectID": "/guide/parallelReduce/#p_30",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "We will demonstrate our countUp function with both {!rsh} .api and {!rsh} .api_."
  },
  {
    "objectID": "/guide/parallelReduce/#p_31",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "In the following examples these two functions have the same funtionality, to increase the count by one each time a user calls our function."
  },
  {
    "objectID": "/guide/parallelReduce/#p_32",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "First, the {!rsh} .api_ that you have seen already."
  },
  {
    "objectID": "/guide/parallelReduce/#p_33",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 21 denotes the start of our API member function B.countUp. The empty parenthesis means it takes no arguments."
  },
  {
    "objectID": "/guide/parallelReduce/#p_34",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 22 starts the outer {!rsh} return. Zero denotes the amount to be paid and we declare our ret function."
  },
  {
    "objectID": "/guide/parallelReduce/#p_35",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 23 invokes our ret function and returns the value of count to the caller."
  },
  {
    "objectID": "/guide/parallelReduce/#p_36",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 24 updates the loop variable count increasing it by one."
  },
  {
    "objectID": "/guide/parallelReduce/#p_37",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Any checks performed before the {!rsh} return statement will be applied in the local step, during payment and the consensus step of the API call. You should use {!rsh} .api_ when this check is the same for these steps."
  },
  {
    "objectID": "/guide/parallelReduce/#p_38",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Now notice the difference in syntax for {!rsh} .api. Remember, this function does the same thing as the one above."
  },
  {
    "objectID": "/guide/parallelReduce/#p_39",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 21 denotes the start of our API member function B.countUp."
  },
  {
    "objectID": "/guide/parallelReduce/#p_40",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 22 is for the ASSUME_EXPR. The empty parenthesis means it takes no arguments. These will be evaluated in a local step, so you may use it to add things you {!rsh} assume about the values given by the API caller."
  },
  {
    "objectID": "/guide/parallelReduce/#p_41",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 23 is the pay expression, it is set to zero, matching our previous function."
  },
  {
    "objectID": "/guide/parallelReduce/#p_42",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 24 declares our {!rsh} return function ret."
  },
  {
    "objectID": "/guide/parallelReduce/#p_43",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 25 invokes that {!rsh} return, sending count back to the caller."
  },
  {
    "objectID": "/guide/parallelReduce/#p_44",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 26 updates our loop variable count."
  },
  {
    "objectID": "/guide/parallelReduce/#p_45",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "A key difference now is the ability to specify different verification checks for the different Reach modes your function will go through."
  },
  {
    "objectID": "/guide/parallelReduce/#p_46",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "You could have an {!rsh} assume expression that evaluates in the users local step and a different expression to {!rsh} require in a consensus step."
  },
  {
    "objectID": "/guide/parallelReduce/#p_47",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Read through both of these functions again, this time comparing syntax for the same operation in each function."
  },
  {
    "objectID": "/guide/parallelReduce/#p_48",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "You see that {!rsh} .api_ is an abstraction of {!rsh} .api with more compact syntax and {!rsh} .api allows you to specify different verification checks at different steps of the function."
  },
  {
    "objectID": "/guide/parallelReduce/#p_49",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Now that we are comfortable with the syntax -- let's look at accessing some values."
  },
  {
    "objectID": "/guide/parallelReduce/#p_50",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "The {!rsh} parallelReduce operates in a consensus step and the values that we are tracking are already publicly accessible."
  },
  {
    "objectID": "/guide/parallelReduce/#p_51",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "To easily view any of our values, we should declare them as {!rsh} Views and include them in the {!rsh} .define block of our {!rsh} parallelReduce."
  },
  {
    "objectID": "/guide/parallelReduce/#p_52",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "In the following examples from rsvp-6-vevt we are tracking howMany users have called our register function."
  },
  {
    "objectID": "/guide/parallelReduce/#p_53",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 44 declares our loop variables."
  },
  {
    "objectID": "/guide/parallelReduce/#p_54",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 45 initializes values for those variables inside our {!rsh} parallelReduce."
  },
  {
    "objectID": "/guide/parallelReduce/#p_55",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 46 starts the {!rsh} .define block."
  },
  {
    "objectID": "/guide/parallelReduce/#p_56",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 47 is where we set the {!rsh} View related to our value. In this case, howMany users have registered."
  },
  {
    "objectID": "/guide/parallelReduce/#p_57",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Lines 49-50 are for our loop invariants."
  },
  {
    "objectID": "/guide/parallelReduce/#p_58",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 51 is our loop condition."
  },
  {
    "objectID": "/guide/parallelReduce/#p_59",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "The {!rsh} parallelReduce is going to leave our DApp in a state where API members can call our function and update the values, but also allow howMany to be accesible in the frontend with a call to the {!rsh} View."
  },
  {
    "objectID": "/guide/parallelReduce/#p_60",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "More information on accessing {!rsh} Views from the frontend can be found at {!js} ctc.views."
  },
  {
    "objectID": "/guide/parallelReduce/#p_61",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Now, what if we want the user to pay some amount to access this function?"
  },
  {
    "objectID": "/guide/parallelReduce/#p_62",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "For network tokens, we can just change the zero from our counter program to some amount."
  },
  {
    "objectID": "/guide/parallelReduce/#p_63",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "In the following example from ticket-sales, the seller first sets some cost for the ticket and we include this for the PAY_EXPR."
  },
  {
    "objectID": "/guide/parallelReduce/#p_64",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 31 is the outer {!rsh} return and will prompt the user to pay cost at their wallet interface to execute the consensus code."
  },
  {
    "objectID": "/guide/parallelReduce/#p_65",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "In the rsvp-6-vevt example, we ask the user to pay reservation."
  },
  {
    "objectID": "/guide/parallelReduce/#p_66",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 55 starts the outer {!rsh} return and asks the user to pay reservation before executing the consesus step."
  },
  {
    "objectID": "/guide/parallelReduce/#p_67",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "All of our examples have so far demonstrated using network tokens. But what if you need the user to pay the contract in a non-network token?"
  },
  {
    "objectID": "/guide/parallelReduce/#p_68",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Any token that is not the native token of a protocol is considered a non-network token."
  },
  {
    "objectID": "/guide/parallelReduce/#p_69",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "The gas or txn fees, are paid in network tokens."
  },
  {
    "objectID": "/guide/parallelReduce/#p_70",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Examples of non-network tokens include all Contract Tokens on ETH (ERC20, ERC721, etc..) and all ASA Tokens on Algorand based networks. How do network and non-network tokens differ?"
  },
  {
    "objectID": "/guide/parallelReduce/#p_71",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "First, we need to teach the Smart Contract about our non-network {!rsh} Token. This means providing it from the frontend (usually the Admin does this) -- and {!rsh} publishing this token ID."
  },
  {
    "objectID": "/guide/parallelReduce/#p_72",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "On ETH the token ID is an Address. On Algorand it is a unique ID number."
  },
  {
    "objectID": "/guide/parallelReduce/#p_73",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "We will examine the point-of-sale example for this."
  },
  {
    "objectID": "/guide/parallelReduce/#p_74",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 19 starts a local step for A."
  },
  {
    "objectID": "/guide/parallelReduce/#p_75",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 20 unpacks values from the frontend params object."
  },
  {
    "objectID": "/guide/parallelReduce/#p_76",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 22 {!rsh} publishes these values to the blockchain."
  },
  {
    "objectID": "/guide/parallelReduce/#p_77",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "We cannot attach the {!rsh} A.pay([[supply, tok]]) to the first {!rsh} publish of the DApp. This is because the Smart Contract doesn't yet know of our token. We first need to complete a {!rsh} publish of the token ID."
  },
  {
    "objectID": "/guide/parallelReduce/#p_78",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Reach supports network tokens by default, which is why this constraint does not exist when paying network tokens."
  },
  {
    "objectID": "/guide/parallelReduce/#p_79",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "You may have noticed the syntactic Tuple in the {!rsh} .pay."
  },
  {
    "objectID": "/guide/parallelReduce/#p_80",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "{!rsh} Token IDs and the amounts to be paid need to be specified in {!rsh} Tuples."
  },
  {
    "objectID": "/guide/parallelReduce/#p_81",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "The first argument is the default network token and is synthesized for you, just specify the quantity -- if you leave the quantity out it will be synthesized to zero for you."
  },
  {
    "objectID": "/guide/parallelReduce/#p_82",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "This means {!rsh} A.pay([[supply, tok]]) is equal to {!rsh} A.pay([0, [supply, tok]]). Where zero specifies the number of network tokens."
  },
  {
    "objectID": "/guide/parallelReduce/#p_83",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "This syntax will come up again."
  },
  {
    "objectID": "/guide/parallelReduce/#p_84",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "This particular program sells these as loyalty tokens, but also allows the user to return the token in the event of a refund."
  },
  {
    "objectID": "/guide/parallelReduce/#p_85",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "This means that our {!rsh} parallelReduce will need to accept these non-network tokens as payment in our API member function."
  },
  {
    "objectID": "/guide/parallelReduce/#p_86",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 28 starts our {!rsh} parallelReduce."
  },
  {
    "objectID": "/guide/parallelReduce/#p_87",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 29 is new. {!rsh} .paySpec([tok]) tells our {!rsh} parallelReduce that it can also accept payment in this non-network token."
  },
  {
    "objectID": "/guide/parallelReduce/#p_88",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "This is structured as an array, so you can just list out the other tokens seperated by a comma."
  },
  {
    "objectID": "/guide/parallelReduce/#p_89",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Just be sure they have been {!rsh} published and you have Reach {!rsh} assume(tok1 != tok2) for each token."
  },
  {
    "objectID": "/guide/parallelReduce/#p_90",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 34 specifies the API_EXPR and takes an input purchasePrice from the caller."
  },
  {
    "objectID": "/guide/parallelReduce/#p_91",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Lines 35-37 perform various verification checks."
  },
  {
    "objectID": "/guide/parallelReduce/#p_92",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 38 starts our outer {!rsh} return. This is where we need to specify the PAY_EXPR, but it also needs to account for our non-network token syntax. [purchasePrice, [0, tok]] has the user pay the purchasePrice in network tokens and zero of our non-network token."
  },
  {
    "objectID": "/guide/parallelReduce/#p_93",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Now let's accept our non-network token from the user in the event of a refund."
  },
  {
    "objectID": "/guide/parallelReduce/#p_94",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Line 48 is our outer {!rsh} return. Notice the same syntax as the purchase function, but with different amounts. Now one tok is coming into the contract upon approval of the transaction."
  },
  {
    "objectID": "/guide/parallelReduce/#p_95",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "Hopefully this guide has helped you better understand the {!rsh} parallelReduce."
  },
  {
    "objectID": "/guide/parallelReduce/#p_96",
    "pt": "parallelReduce Guide",
    "t": 3,
    "c": "If you still have questions, Reach out to us in Discord!"
  },
  {
    "objectID": "/guide/race/#guide-race",
    "pt": "Racing non-determinism in decentralized applications",
    "t": 2,
    "c": "Racing non-determinism in decentralized applications"
  },
  {
    "objectID": "/guide/race/#p_0",
    "pt": "Racing non-determinism in decentralized applications",
    "t": 3,
    "c": "As discussed earlier in the guide, Reach computations have a deterministic structure, but non-deterministic values. This means that a program will always execute steps A, B, and then C, but the values manipulated by those steps may be different on every execution."
  },
  {
    "objectID": "/guide/race/#p_1",
    "pt": "Racing non-determinism in decentralized applications",
    "t": 3,
    "c": "The most common form of value non-determinism is through the {!rsh} interact expression and frontend-provided values. A Reach program merely specifies that a frontend must provide an unsigned integer that it will name {!rsh} bid, but not what value is actually provided."
  },
  {
    "objectID": "/guide/race/#p_2",
    "pt": "Racing non-determinism in decentralized applications",
    "t": 3,
    "c": "However, a more subtle form of value non-determinism occurs with the {!rsh} race expression. This expression allows multiple participants to all attempt to provide the same value for a publication. For example, consider a turn-based game, like Nim, where there is no a priori way to determine who goes first. We could write a Reach program like:"
  },
  {
    "objectID": "/guide/race/#p_3",
    "pt": "Racing non-determinism in decentralized applications",
    "t": 3,
    "c": "where a {!rsh} race determines the first player."
  },
  {
    "objectID": "/guide/race/#p_4",
    "pt": "Racing non-determinism in decentralized applications",
    "t": 3,
    "c": "This use-case demonstrates a major problem with {!rsh} races though. In the case of Nim, there is an advantage to whoever goes first: they can win if they choose the correct moves! Since Bob sent the previous publication, he will know about the opportunity to determine who goes first before Alice, so he can send both publications in back-to-back and be guaranteed to win."
  },
  {
    "objectID": "/guide/race/#p_5",
    "pt": "Racing non-determinism in decentralized applications",
    "t": 3,
    "c": "One strategy to avoid this would be to ensure that Alice and Bob both {!rsh} wait a pre-determined amount of time, after which they would each have a fair chance to race:"
  },
  {
    "objectID": "/guide/race/#p_6",
    "pt": "Racing non-determinism in decentralized applications",
    "t": 3,
    "c": "However, even this strategy is dangerous, because it just creates an arms race between Alice and Bob to acquire more computational and network resources to guarantee that they are the first one, because whoever is first is the actual winner of the game, whatever happens next. A classic example of a situation like this was the Fomo3D winner, who used their capital to acquire millions in ETH in 2018."
  },
  {
    "objectID": "/guide/race/#p_7",
    "pt": "Racing non-determinism in decentralized applications",
    "t": 3,
    "c": "A better strategy in this application would be to have each participant provide randomness using a commitment pattern (see {!rsh} makeCommitment and {!rsh} checkCommitment) then reveal that randomness to determine the winner. Or, to play a different game that is actually skill-based."
  },
  {
    "objectID": "/guide/race/#p_8",
    "pt": "Racing non-determinism in decentralized applications",
    "t": 3,
    "c": "This example demonstrates the crucial problem with the participant non-determinism enabled by {!rsh} race: it will always produce an arms race for resources if winning the race results in winning funds. It is only safe and acceptable if who the winner is has no bearing on the ultimate outcome of the computation."
  },
  {
    "objectID": "/guide/race/#p_9",
    "pt": "Racing non-determinism in decentralized applications",
    "t": 3,
    "c": "We can express this condition formally by saying that if {!rsh} A and {!rsh} B compete to provide value {!rsh} a and {!rsh} b respectively, then the computation should provide an opportunity for the first loser to provide their value later, such that it doesn't matter what order they are provided. Mathematically, we could say that the program should not be a one-parameter function f, where the computation is either f(a) or f(b). Instead, it should be a two-parameter function g, such that g(a, b) = g(b, a) (i.e. a commutative function)."
  },
  {
    "objectID": "/guide/reach/#guide-reach",
    "pt": "How does Reach work?",
    "t": 2,
    "c": "How does Reach work?"
  },
  {
    "objectID": "/guide/reach/#p_0",
    "pt": "How does Reach work?",
    "t": 3,
    "c": "It is not necessary to understand how Reach works to use it effectively, but many users are curious about how it works. The Reach compiler uses the following strategy for analysis and compiling programs:"
  },
  {
    "objectID": "/guide/reach/#p_1",
    "pt": "How does Reach work?",
    "t": 3,
    "c": "A partial evaluation of the source program that removes all function calls & compile-time values."
  },
  {
    "objectID": "/guide/reach/#p_2",
    "pt": "How does Reach work?",
    "t": 3,
    "c": "A linearization of the residual program that removes the need for a runtime stack to track any consensus state."
  },
  {
    "objectID": "/guide/reach/#p_3",
    "pt": "How does Reach work?",
    "t": 3,
    "c": "A conservative (sound) analysis of the knowledge of each participant."
  },
  {
    "objectID": "/guide/reach/#p_4",
    "pt": "How does Reach work?",
    "t": 3,
    "c": "A reduction of the program to an instance of an SMT (satisfiability modulo theories) theory of decentralized applications."
  },
  {
    "objectID": "/guide/reach/#p_5",
    "pt": "How does Reach work?",
    "t": 3,
    "c": "An end-point projection of the linearization to produce a perspective for each participant, as well as the consensus."
  },
  {
    "objectID": "/guide/reach/#p_6",
    "pt": "How does Reach work?",
    "t": 3,
    "c": "A single-pass top-down construction of backend and consensus programs."
  },
  {
    "objectID": "/guide/reach/#p_7",
    "pt": "How does Reach work?",
    "t": 3,
    "c": "Reach is proud to: be implemented in Haskell using the Glorious Haskell Compiler; use the Z3 theorem prover for verification; and use Docker for containerization."
  },
  {
    "objectID": "/guide/roadmap/#guide-roadmap",
    "pt": "Reach's Roadmap",
    "t": 2,
    "c": "Reach's Roadmap"
  },
  {
    "objectID": "/guide/roadmap/#p_0",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "This section describes in a vague way some of the bigger future plans for Reach's development. These are vague for expediency, but we're willing to elaborate if you ask in the Discord community. We welcome your contributions on GitHub and in the Discord community to help bring these plans to fruition."
  },
  {
    "objectID": "/guide/roadmap/#p_1",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Last updated: 2022/05/"
  },
  {
    "objectID": "/guide/roadmap/#p_2",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Short term:"
  },
  {
    "objectID": "/guide/roadmap/#p_3",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Language - {!rsh} interact continuations"
  },
  {
    "objectID": "/guide/roadmap/#p_4",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Networks - Participant fast catch-up"
  },
  {
    "objectID": "/guide/roadmap/#p_5",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Optimization - Unify view functions with identical bodies"
  },
  {
    "objectID": "/guide/roadmap/#p_6",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Frontends - Session resumption"
  },
  {
    "objectID": "/guide/roadmap/#p_7",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "General - Reach debugger"
  },
  {
    "objectID": "/guide/roadmap/#p_8",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Medium term:"
  },
  {
    "objectID": "/guide/roadmap/#p_9",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "IDE - Language Server Protocol implementation"
  },
  {
    "objectID": "/guide/roadmap/#p_10",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Language - threading / futures"
  },
  {
    "objectID": "/guide/roadmap/#p_11",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Language - {!rsh} for to {!rsh} while syntactic sugar"
  },
  {
    "objectID": "/guide/roadmap/#p_12",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Language - tail-recursive function to {!rsh} while"
  },
  {
    "objectID": "/guide/roadmap/#p_13",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Language - fixed range integer types"
  },
  {
    "objectID": "/guide/roadmap/#p_14",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Optimization - data-type coallescing"
  },
  {
    "objectID": "/guide/roadmap/#p_15",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Language - non-communicating guaranteed termination loops"
  },
  {
    "objectID": "/guide/roadmap/#p_16",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Verification - Constrain eventual use of values"
  },
  {
    "objectID": "/guide/roadmap/#p_17",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Verification - {!rsh} exit() reachability"
  },
  {
    "objectID": "/guide/roadmap/#p_18",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Verification - network analysis"
  },
  {
    "objectID": "/guide/roadmap/#p_19",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Language - Dynamic token tracking"
  },
  {
    "objectID": "/guide/roadmap/#p_20",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Long term:"
  },
  {
    "objectID": "/guide/roadmap/#p_21",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Language - substructural types to allow mutation"
  },
  {
    "objectID": "/guide/roadmap/#p_22",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Language - pay-as-you-go closures"
  },
  {
    "objectID": "/guide/roadmap/#p_23",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Language - general recursion through closure conversion of non-contifiable continuations"
  },
  {
    "objectID": "/guide/roadmap/#p_24",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Verification - game-theoretic property verification"
  },
  {
    "objectID": "/guide/roadmap/#p_25",
    "pt": "Reach's Roadmap",
    "t": 3,
    "c": "Verification - verified compiler"
  },
  {
    "objectID": "/guide/rpc/#guide-rpc",
    "pt": "Do I have to use JavaScript to write my frontend? What about Python, Go, or other languages?",
    "t": 2,
    "c": "Do I have to use JavaScript to write my frontend? What about Python, Go, or other languages?"
  },
  {
    "objectID": "/guide/rpc/#p_0",
    "pt": "Do I have to use JavaScript to write my frontend? What about Python, Go, or other languages?",
    "t": 3,
    "c": "Most Reach examples, tutorials, and workshops use JavaScript as the language of choice for frontend implementation, but Reach supports frontend development in any language via the Reach RPC Server. This server allows backends compiled to JavaScript to be provided to another language via a simple RPC protocol."
  },
  {
    "objectID": "/guide/rpc/#p_1",
    "pt": "Do I have to use JavaScript to write my frontend? What about Python, Go, or other languages?",
    "t": 3,
    "c": "Presently, Reach provides RPC client implementations for:"
  },
  {
    "objectID": "/guide/rpc/#p_2",
    "pt": "Do I have to use JavaScript to write my frontend? What about Python, Go, or other languages?",
    "t": 3,
    "c": "The tutorial section on RPC-based frontends provides a walkthrough of using these libraries."
  },
  {
    "objectID": "/guide/rpc/#p_3",
    "pt": "Do I have to use JavaScript to write my frontend? What about Python, Go, or other languages?",
    "t": 3,
    "c": "If your language of choice isn't available yet, it is very simple to implement one yourself if you've ever used a JSON-based RPC protocol before. Most implementations are less than 100 lines of code! Or, you could submit a request for Reach to build one on the Reach GitHub issue tracker or on the Discord community."
  },
  {
    "objectID": "/guide/solidity/#guide-solidity",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 2,
    "c": "How does Reach development compare to Solidity development?"
  },
  {
    "objectID": "/guide/solidity/#solidity-development",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 2,
    "c": "Solidity Development"
  },
  {
    "objectID": "/guide/solidity/#reach-development",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 2,
    "c": "Reach Development"
  },
  {
    "objectID": "/guide/solidity/#conclusion",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 2,
    "c": "Conclusion"
  },
  {
    "objectID": "/guide/solidity/#p_0",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "The Reach documentation is written from the perspective of a developer who has never done any DApp development of any kind before starting to use Reach. However, mastering Reach development is a valuable skill for those developers with experience using tools like Solidity. But, when these developers read the Reach documentation, they are often at loss to see how what they're reading relates to what they already know. This article attempts to bridge that gap and help Solidity-style developers understand Reach."
  },
  {
    "objectID": "/guide/solidity/#p_1",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "For the rest of this article, when we use the term \"Solidity development\", we're referring to blockchain development without Reach and not literally only the programming language Solidity. For example, \"Solidity development\" includes Vyper developers, as well as users of tools like Truffle Suite, web3.js, and so on. We're talking about a paradigm of DApp programming and not a specific tool."
  },
  {
    "objectID": "/guide/solidity/#p_2",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "A great Solidity project typically includes seven components:"
  },
  {
    "objectID": "/guide/solidity/#p_3",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Protocol Design --- A DApp starts with a protocol diagram, perhaps written using a pidgin UML format, where a developer thinks about the state space of an application and the valid transitions in that state space. This diagram includes annotations about typical use-cases and workflows for particular paths through the protocol."
  },
  {
    "objectID": "/guide/solidity/#p_4",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Smart Contract --- A developer studies the protocol design and defines a smart contract program whose implicit state space matches the protocol. For example, if a protocol has two nodes, A and B, connected by a transition labeled f, then the smart contract might have a Boolean storage variable with a name like inA and a method named f that checks if that variable is true and modifies it to be false---thus A in the diagram corresponds to inA = true and B in the diagram corresponds to inB = false. Part of the challenge of smart contract development is understanding the connection between the implicit state of the smart contract and the original protocol design."
  },
  {
    "objectID": "/guide/solidity/#p_5",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Middleware --- A developer builds a library in a language like JavaScript or Go that uses an SDK like web3.js or ethers to connect to their smart contract. This middleware is co-developed with the smart contract and duplicates details like the names of methods and their arguments. It abstracts these details into higher-level patterns of operation that roughly correspond to the use-cases and workflows in the protocol design."
  },
  {
    "objectID": "/guide/solidity/#p_6",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Frontend --- A developer builds a user interface that connects to the middleware and potentially a wallet, like MetaMask, and provides a high-level user-facing perspective on the software. This is mostly insulated from the details of the particular protocol and contract, but is typically specialized to the consensus network, because the user interface surfaces details about the underlying network."
  },
  {
    "objectID": "/guide/solidity/#p_7",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Testing --- Developers typically use tools like Truffle Suite or a developer instance of geth to launch a test consensus network and then build a suite of unit and end-to-end tests of their application, typically by either directly interacting with the middleware or the smart contract itself. This same testing environment may be used to back a sample version of the frontend."
  },
  {
    "objectID": "/guide/solidity/#p_8",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Verification --- High quality DApps are verified and audited for a variety of properties, from basic checking of things like integer and buffer overflows, to checking of the absence of famous attacks like reentrancy attacks, to more thorough checking of properties related to the particular domain of the application. There are a wide variety of tools and companies that provide this kind of verification as a service and the best DApps are not deployed until they pass these tests, sometimes multiple of them. Verification typically involves only the smart contract and the best versions often require a mechanical representation of the protocol design to analyze the behavior of the DApp across all its workflows."
  },
  {
    "objectID": "/guide/solidity/#p_9",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Deployment --- Once the DApp is ready to be released, it will either be embedded in the frontend, if users are expected to launch their own independent instances of the smart contract, or it is launched a single time (perhaps as a contract factory) at a well-publicized address that might be embedded in the frontend."
  },
  {
    "objectID": "/guide/solidity/#p_10",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Obviously, we've left out a lot of details, but this is a sketch of the typical components of Solidity-style development. There are a huge number of options and techniques for almost all of these components, with some being dropped or minimized depending on the needs of the particular application. For example, an extremely simple DApp might combine the middleware and frontend or embed a description of the protocol design as comments or some ASCII art in the smart contract source code."
  },
  {
    "objectID": "/guide/solidity/#p_11",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Reach development includes each one of these seven components. But rather than requiring the use of a variety of different tools, the difficulties associated with each component are solved by a different aspect of Reach."
  },
  {
    "objectID": "/guide/solidity/#p_12",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Protocol Design --- As a programming language, Reach operates at a different level of abstraction than a language like Solidity. Reach programs encode the same information that would be in the informal protocol design diagrams that often accompany smart contracts. A Reach program specifically names the various participants in a DApp and their individual workflows as a single chronological workflow that shows how and when the various individual workflows intertwine."
  },
  {
    "objectID": "/guide/solidity/#p_13",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Smart Contract --- By operating at this higher-level of abstraction, Reach developers are not responsible for determining the state space of the smart contract. Instead, the Reach compiler analyzes the structure of communication in the protocol design and derives the necessary state and transition functions. This doesn't mean that Reach developers don't think about \"consensus\"; indeed, the consensus step is a fundamental part of a Reach program. However, Reach developers can focus on the constraints on individual publications and the consensual actions of the computation, rather than the mechanics of ensuring the smart contract is in the appropriate state and transitions to the correct next state."
  },
  {
    "objectID": "/guide/solidity/#p_14",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Middleware --- Similarly, a Reach program includes a specification of the API of the middleware layer, via a participant interact interface. This part of a Reach program is particular to each participant and explicitly names the points of contact between the participant workflow (embedded in the Reach program) and the frontend. This means that Reach developers do not need to manually keep the middleware and smart contract in sync or update either as the protocol design changes: the Reach compiler does all of that for them."
  },
  {
    "objectID": "/guide/solidity/#p_15",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Frontend --- Reach programs do not embed the frontend, like they embed the protocol design, smart contract, and middleware. Reach developers design and build user interfaces just like they do in Solidity-style development, except that they tend to have an easier time, because the automatically-generated middleware layer thoroughly insulates them from the low-level details of the consensus network. Reach developers can easily build their interface with JavaScript using the Reach standard library. They can also use the language of their choice via the Reach RPC server."
  },
  {
    "objectID": "/guide/solidity/#p_16",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Testing --- Reach facilitates testing in two ways. First, the Reach language embeds a high-quality property-based testing system via the {!rsh} assert and {!rsh} forall primitives, which can be used in a basic way to write simple test cases. Second, the Reach deployment tool, reach run, allows for the easy construction and running of automated test suites for the workflows of a DApp. In both cases, it is not necessary for Reach developers to directly manage their own development networks or otherwise interact with the consensus networks they're testing with in any way."
  },
  {
    "objectID": "/guide/solidity/#p_17",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Verification --- Every Reach compilation includes a thorough formal verification of the DApp using an SMT-based theorem prover. This theorem prover verifies general properties that all programs should exhibit, such as never overflowing finite memory bounds or accessing uninitialized memory. It verifies properties that all DApps should exhibit, such as token linearity property which guarantees that funds are not double-spent or forgotten about. Furthermore, it verifies bespoke properties that are unique to the particular DApp, as specified with the {!rsh} assert primitive."
  },
  {
    "objectID": "/guide/solidity/#p_18",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "Deployment --- Some aspects of deployment decisions are embedded inside of Reach programs, such as whether to use a contract factory or whether to have each instance of the DApp use an independent smart contract deployed by one of the participants. Other aspects are part of the configuration of the Reach compiler, such as which consensus network will be targeted. Still others are part of the configuration of the Reach standard library and testing infrastructure, like which wallet the middleware should connect to or which kind of development node should be launched and managed by Reach."
  },
  {
    "objectID": "/guide/solidity/#p_19",
    "pt": "How does Reach development compare to Solidity development?",
    "t": 3,
    "c": "In summary, a vibrant ecosystem of many tools, techniques, and traditions have grown up around the creation of DApps in the Solidity-style. Reach leverages the experience of that ecosystem and provides a total solution that incorporates all of the different components into one environment, so that it can provide more services with high quality and lower cost by integrating them together."
  },
  {
    "objectID": "/guide/staking/#guide-staking",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 2,
    "c": "Example: Staking and Unstaking Tokens"
  },
  {
    "objectID": "/guide/staking/#staking",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 2,
    "c": "Staking"
  },
  {
    "objectID": "/guide/staking/#unstaking",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 2,
    "c": "Unstaking"
  },
  {
    "objectID": "/guide/staking/#elided-reach",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 2,
    "c": "Elided Reach"
  },
  {
    "objectID": "/guide/staking/#connecting-from-javascript",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 2,
    "c": "Connecting from JavaScript"
  },
  {
    "objectID": "/guide/staking/#conclusion",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 2,
    "c": "Conclusion"
  },
  {
    "objectID": "/guide/staking/#p_0",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "Reach makes DApp development safer, faster, and more secure. This guide offers a real example of the advantages of using Reach."
  },
  {
    "objectID": "/guide/staking/#p_1",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "Here's an example provided by Austin Wilshire at xBacked. Follow Austin on Twitter @awoldes."
  },
  {
    "objectID": "/guide/staking/#p_2",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "Imagine you want to stake a token and at a later date unstake it with all the rewards. Let's look at a snippet from the perspective of a Deployer."
  },
  {
    "objectID": "/guide/staking/#p_3",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "As the deployer, you want to set the reward rate, {!rsh} Token being staked, the rewarded {!rsh} Token, and the initial supply of the reward token."
  },
  {
    "objectID": "/guide/staking/#p_4",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "After this, the contract is fully configured and deployed. The next step is to enable users to interact with it."
  },
  {
    "objectID": "/guide/staking/#p_5",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "First, we want to enable a user to add a stake. We do this by adding an API call so that when the user calls the function, they will pay {!rsh} tokenAmt of the {!rsh} stakeToken which the Deployer set."
  },
  {
    "objectID": "/guide/staking/#p_6",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "In a full implementation, we would enable users to stake multiple times and combine their stakes. (This version resets the stake each time, so it is dangerous and would lose track of a user's funds.)"
  },
  {
    "objectID": "/guide/staking/#p_7",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "Similarly, we want the user to be able to unstake and claim their rewards. We do this with an API call as well."
  },
  {
    "objectID": "/guide/staking/#p_8",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "In a full implementation, we would have to specify how the pendingRewards value was computed. We could make it automatic by connecting it to something like {!rsh} lastConsensusTime."
  },
  {
    "objectID": "/guide/staking/#p_9",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "We haven't shown the entire Reach program. We didn't show the definition of the participants, APIs, or Views. We didn't show the main {!rsh} parallelReduce or its invariants."
  },
  {
    "objectID": "/guide/staking/#p_10",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "Next, we'll want to use this program in a Web application. In this code, we assume that the Web application is written with React."
  },
  {
    "objectID": "/guide/staking/#p_11",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "We use the Reach standard library to connect to the contract, define the User's API calls, and the View."
  },
  {
    "objectID": "/guide/staking/#p_12",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "Next, we get the user's state by reading the view:"
  },
  {
    "objectID": "/guide/staking/#p_13",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "Then, create an event listener that connects to the API calls:"
  },
  {
    "objectID": "/guide/staking/#p_14",
    "pt": "Example: Staking and Unstaking Tokens",
    "t": 3,
    "c": "This demonstrates the essential (but not quite complete) elements of implementing a DApp with Reach. There's no magic involved, but it definitely feels like there is when you're building a Reach application. As a developer, you don't need to think about forming transaction groups, SDK calls, \"opting in\", or \"ASA ids\". Because you don't think about these things, your application works on multiple networks. You focus on the business logic of your DApp and plug into the consensus network of your choice."
  },
  {
    "objectID": "/guide/testing/#guide-testing",
    "pt": "How should I test a DApp?",
    "t": 2,
    "c": "How should I test a DApp?"
  },
  {
    "objectID": "/guide/testing/#p_0",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "When you are writing a DApp in Reach, you should test it thoroughly."
  },
  {
    "objectID": "/guide/testing/#p_1",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "You may think that because Reach has a verification engine you don't need to write tests. This is incorrect: The general verification checks that Reach performs ensure that your program does not do obviously bad things, like violate the linearity of tokens, but it does not check that you wrote the correct program. Furthermore, the specific verification checks that Reach allows you to write cannot specify every bad thing you want to avoid or every good thing that you want to happen. Therefore, you need to use a variety of quality assurance mechanisms."
  },
  {
    "objectID": "/guide/testing/#p_2",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "Your general philosophy for thinking about testing is that you write the program multiple times and make sure that each time you write the program, you write the same program:"
  },
  {
    "objectID": "/guide/testing/#p_3",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "You write the program in Reach."
  },
  {
    "objectID": "/guide/testing/#p_4",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "You write the program in Reach's {!rsh} assert and {!rsh} invariant forms."
  },
  {
    "objectID": "/guide/testing/#p_5",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "You write the program with an automated JavaScript test suite."
  },
  {
    "objectID": "/guide/testing/#p_6",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "You write the program with an interactive user interface."
  },
  {
    "objectID": "/guide/testing/#p_7",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "You write the program with an automated test suite over that user interface."
  },
  {
    "objectID": "/guide/testing/#p_8",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "The connection between any of these two versions of the program is good if whenever you change one, the other one breaks and detects the change. For example, if you change the program (#1) to use a non-network token, rather than the network token, then your test suite (#3) should reflect this, because your testing accounts will need to get a balance of this non-network token."
  },
  {
    "objectID": "/guide/testing/#p_9",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "Reach provides tools for writing #1, #2, and #3. You don't have to use our tool for #3 ({!js} test) and could use any testing framework you wanted. We don't provide tools for #4 or #5 and you can use any user interface toolkit or testing regime; we like to use React for #4 and Cypress for #5."
  },
  {
    "objectID": "/guide/testing/#p_10",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "At the micro-level, your testing outlook should be that tests either:"
  },
  {
    "objectID": "/guide/testing/#p_11",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "Establish that something bad does not happen. Or,"
  },
  {
    "objectID": "/guide/testing/#p_12",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "Establish that something good does happen."
  },
  {
    "objectID": "/guide/testing/#p_13",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "In order to build a large number of these tests succinctly, you should build a simple \"library\" that can succinctly initialize your DApp and then run a scenario. Like this:"
  },
  {
    "objectID": "/guide/testing/#p_14",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "Then, you can write lots of different scenarios:"
  },
  {
    "objectID": "/guide/testing/#p_15",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "The {!js} test.one function is designed for being used in contexts like this. Then you can use {!js} test.run and command-line arguments to select a particular test to run while developing."
  },
  {
    "objectID": "/guide/testing/#p_16",
    "pt": "How should I test a DApp?",
    "t": 3,
    "c": "Finally, you should use \"standard\" software testing and quality assurance practices, like continuous integration. Wikipedia has a great article on Software Testing that is a good place to get started finding more resources."
  },
  {
    "objectID": "/guide/timeout/#guide-timeout",
    "pt": "Non-participation: What it is and how to protect against it",
    "t": 2,
    "c": "Non-participation: What it is and how to protect against it"
  },
  {
    "objectID": "/guide/timeout/#p_0",
    "pt": "Non-participation: What it is and how to protect against it",
    "t": 3,
    "c": "Non-participation refers to the act of one party ceasing to continue playing their role in an application."
  },
  {
    "objectID": "/guide/timeout/#p_1",
    "pt": "Non-participation: What it is and how to protect against it",
    "t": 3,
    "c": "In traditional client-server programs, like a Web server, this would be the case of a client stopping sending requests to the server, or the server stopping sending responses to the client. In these sorts of traditional programs, non-participation is an exceptional circumstance that normally leads to an error message for clients and, at most, a log entry for servers. Sometimes traditional programs will need to recycle resources, like network ports, on non-participation, but they would have also needed to do that if the transaction ended by normal means. In other words, for traditional client-server programs, it is not necessary for designers to meticulously consider the consequences of non-participation."
  },
  {
    "objectID": "/guide/timeout/#p_2",
    "pt": "Non-participation: What it is and how to protect against it",
    "t": 3,
    "c": "In contrast, decentralized applications must be carefully designed with an eye towards their behavior in the face of non-participation."
  },
  {
    "objectID": "/guide/timeout/#p_3",
    "pt": "Non-participation: What it is and how to protect against it",
    "t": 3,
    "c": "There are two general strategies for dealing with non-participation: punishment and disincentivizing."
  },
  {
    "objectID": "/guide/timeout/#p_4",
    "pt": "Non-participation: What it is and how to protect against it",
    "t": 3,
    "c": "Punishment. The punishment strategy entails allowing the remaining participants of the application to take all of the assets that would have gone to the non-participator and splitting them. This is the strategy used in the tutorial, where Alice's wager is lost if she fails to send her next publication."
  },
  {
    "objectID": "/guide/timeout/#p_5",
    "pt": "Non-participation: What it is and how to protect against it",
    "t": 3,
    "c": "Punishment is a dangerous strategy, because it is difficult to know a priori what the threshold of non-participation is. If you estimate too low, then you will inappropriately punish parties that are honestly delayed. In consensus networks where transactions bid for space in blocks, like Ethereum, low-value transactions may be starved when high-value activity is happening on the network concurrently. Reach allows timeout deadlines to be dynamically set, because the deadline expression of a {!rsh} timeout clause can be any equation over {!rsh} consensus state. This does, however, imply that the application must decide the deadline for a message before or during the immediately preceding message."
  },
  {
    "objectID": "/guide/timeout/#p_6",
    "pt": "Non-participation: What it is and how to protect against it",
    "t": 3,
    "c": "Disincentivizing. The disincentivizing strategy allows all participants to drop participation, but ensures that if they do so, they will punish themselves by forgoing some resource held in escrow by the application. This strategy is only effective if the escrow amount is significantly larger than the payout in a normal execution of the computation. For example, in the Rock, Paper, Scissors! tutorial, we could have had each participant contribute something on the order of ten times that wager into the application, which would not be reimbursed unless the game ended."
  },
  {
    "objectID": "/guide/timeout/#p_7",
    "pt": "Non-participation: What it is and how to protect against it",
    "t": 3,
    "c": "Disincentivizing has the advantage of allowing all programs to eventually finish, but the downside of allowing one participant to disrupt all participants by refusing to continue, thereby locking away the escrows of all parties. It is, therefore, better to only use such incentives when combined with judicious timeouts and asymmetry in the program."
  },
  {
    "objectID": "/guide/versions/#guide-versions",
    "pt": "How does Reach use version numbers?",
    "t": 2,
    "c": "How does Reach use version numbers?"
  },
  {
    "objectID": "/guide/versions/#p_0",
    "pt": "How does Reach use version numbers?",
    "t": 3,
    "c": "Reach uses semantic versioning, which means that given Reach version number MAJOR.MINOR.PATCH,"
  },
  {
    "objectID": "/guide/versions/#p_1",
    "pt": "How does Reach use version numbers?",
    "t": 3,
    "c": "MAJOR versions are incompatible."
  },
  {
    "objectID": "/guide/versions/#p_2",
    "pt": "How does Reach use version numbers?",
    "t": 3,
    "c": "MINOR versions are compatible, but have additional features relative to earlier versions."
  },
  {
    "objectID": "/guide/versions/#p_3",
    "pt": "How does Reach use version numbers?",
    "t": 3,
    "c": "PATCH versions are entirely compatible."
  },
  {
    "objectID": "/guide/versions/#p_4",
    "pt": "How does Reach use version numbers?",
    "t": 3,
    "c": "However, the major version 0.y.z is pre-stability and makes no promises about compatibility of any kind."
  },
  {
    "objectID": "/guide/versions/#p_5",
    "pt": "How does Reach use version numbers?",
    "t": 3,
    "c": "Reach source code starts with"
  },
  {
    "objectID": "/guide/versions/#p_6",
    "pt": "How does Reach use version numbers?",
    "t": 3,
    "c": "because this indicates that it relies on this major version and the features added in this minor version."
  },
  {
    "objectID": "/guide/versions/#p_7",
    "pt": "How does Reach use version numbers?",
    "t": 3,
    "c": "Reach tools are specified by the entire version number with a v at the front, vMAJOR.MINOR.PATCH, but are also available at all prefixes (i.e., vMAJOR.MINOR and vMAJOR). Additionally, there is a version stable which resolves to the most recent stable vMAJOR version."
  },
  {
    "objectID": "/guide/windows/#guide-windows",
    "pt": "Using Reach on Windows",
    "t": 2,
    "c": "Using Reach on Windows"
  },
  {
    "objectID": "/guide/windows/#p_0",
    "pt": "Using Reach on Windows",
    "t": 3,
    "c": "Reach assumes the presence of a POSIX-compliant shell, as well as Docker and Docker Compose."
  },
  {
    "objectID": "/guide/windows/#p_1",
    "pt": "Using Reach on Windows",
    "t": 3,
    "c": "The best way to get this set up on Windows is to"
  },
  {
    "objectID": "/guide/windows/#p_2",
    "pt": "Using Reach on Windows",
    "t": 3,
    "c": "Install Windows 10, version 2004 or higher."
  },
  {
    "objectID": "/guide/windows/#p_3",
    "pt": "Using Reach on Windows",
    "t": 3,
    "c": "Enable the Windows Subsystem for Linux feature, specifically the WSL 2 option."
  },
  {
    "objectID": "/guide/windows/#p_4",
    "pt": "Using Reach on Windows",
    "t": 3,
    "c": "Download and install Docker Desktop, and enable the Docker Desktop WSL 2 backend."
  },
  {
    "objectID": "/guide/windows/#p_5",
    "pt": "Using Reach on Windows",
    "t": 3,
    "c": "Follow the instructions from Docker on developing with Docker and WSL 2."
  },
  {
    "objectID": "/guide/windows/#p_6",
    "pt": "Using Reach on Windows",
    "t": 3,
    "c": "At this point, you'll have your VSCode IDE set up with a terminal in your Linux distribution."
  },
  {
    "objectID": "/guide/windows/#p_7",
    "pt": "Using Reach on Windows",
    "t": 3,
    "c": "You can now follow the instructions in the reference manual on installation or the first part of the tutorial to download, install, and execute all Reach commands."
  },
  {
    "objectID": "/guide/windows/#p_8",
    "pt": "Using Reach on Windows",
    "t": 3,
    "c": "You can watch a five minute video going through these steps on YouTube."
  },
  {
    "objectID": "/rpc/client/#ref-backends-rpc-client",
    "pt": "Client Walkthrough",
    "t": 2,
    "c": "Client Walkthrough"
  },
  {
    "objectID": "/rpc/client/#p_0",
    "pt": "Client Walkthrough",
    "t": 3,
    "c": "The Reach RPC Protocol is designed to be simple to implement in languages that support HTTP and JSON interaction. This document walks through the implementation of an RPC client in Python. An example use of this library is shown in the tutorial section on RPC-based frontends. The entire library is 80 lines of code."
  },
  {
    "objectID": "/rpc/client/#p_1",
    "pt": "Client Walkthrough",
    "t": 3,
    "c": "The library uses a few standard Python libraries for interacting with JSON, HTTP servers, and networking:"
  },
  {
    "objectID": "/rpc/client/#p_2",
    "pt": "Client Walkthrough",
    "t": 3,
    "c": "The library provides a single function, {!py} mk_rpc, that accepts the Reach RPC Client Standard Options."
  },
  {
    "objectID": "/rpc/client/#p_3",
    "pt": "Client Walkthrough",
    "t": 3,
    "c": "It starts by observing the verify option and informing the Python library it uses for HTTPS interaction to turn off warnings. It displays a warning to users that they should be nervous about using this setting."
  },
  {
    "objectID": "/rpc/client/#p_4",
    "pt": "Client Walkthrough",
    "t": 3,
    "c": "Next, it attempts to connect to the Reach RPC Server and throws an error if it does not respond quickly enough."
  },
  {
    "objectID": "/rpc/client/#p_5",
    "pt": "Client Walkthrough",
    "t": 3,
    "c": "It defines a function, {!py} rpc, which will be returned later on, that implements the protocol for synchronous value RPC methods. It formats a given request, posts it, and then returns the deserialized result. It prints debugging information for convenience."
  },
  {
    "objectID": "/rpc/client/#p_6",
    "pt": "Client Walkthrough",
    "t": 3,
    "c": "It defines a function, {!py} rpc_callbacks, which will be returned later on, that implements the protocol for interactive RPC methods. On lines 64 and 65, this function inspects its third argument, {!py} cbacks, and separates the {!py} callable arguments from the values and creates the intermediate objects, {!py} vals and {!py} meths, to provide the RPC invocation. After it makes the call, in the {!py} while loop starting on line 68, it inspects the result to determine if it is a final answer or an interactive RPC callback. If it is a callback, as indicated by the test on line 72, then it extracts the name of the method, {!py} p['m'], and invokes it in the original third argument, {!py} cbacks, with the provided arguments. It replaces the {!py} p value with the result of that continuation invocation and continues."
  },
  {
    "objectID": "/rpc/client/#p_7",
    "pt": "Client Walkthrough",
    "t": 3,
    "c": "Finally, it returns {!py} rpc and {!py} rpc_callbacks to the user."
  },
  {
    "objectID": "/rpc/cs/#ref-frontends-rpc-cs",
    "pt": "C#",
    "t": 2,
    "c": "C#"
  },
  {
    "objectID": "/rpc/cs/#p_0",
    "pt": "C#",
    "t": 3,
    "c": "This frontend library relies on the Reach RPC Server."
  },
  {
    "objectID": "/rpc/cs/#p_1",
    "pt": "C#",
    "t": 3,
    "c": "A C# client library for the Reach RPC protocol may be installed by copying the code at https://github.com/reach-sh/reach-lang/tree/master/rpc-client/cs."
  },
  {
    "objectID": "/rpc/cs/#p_2",
    "pt": "C#",
    "t": 3,
    "c": "Please inspect the tutorial example program for usage: https://github.com/reach-sh/reach-lang/blob/master/examples/rps-7-rpc/client-cs/index.cs."
  },
  {
    "objectID": "/rpc/go/#go_reachrpc.Mk",
    "pt": "Go",
    "t": 0,
    "s": "go",
    "c": "reachrpc.Mk"
  },
  {
    "objectID": "/rpc/go/#go_rpc",
    "pt": "Go",
    "t": 0,
    "s": "go",
    "c": "rpc"
  },
  {
    "objectID": "/rpc/go/#go_rpcCallbacks",
    "pt": "Go",
    "t": 0,
    "s": "go",
    "c": "rpcCallbacks"
  },
  {
    "objectID": "/rpc/go/#ref-frontends-rpc-go",
    "pt": "Go",
    "t": 2,
    "c": "Go"
  },
  {
    "objectID": "/rpc/go/#p_0",
    "pt": "Go",
    "t": 3,
    "c": "This frontend library relies on the Reach RPC Server."
  },
  {
    "objectID": "/rpc/go/#p_1",
    "pt": "Go",
    "t": 3,
    "c": "A Go client library for the Reach RPC protocol may be installed by running:"
  },
  {
    "objectID": "/rpc/go/#p_2",
    "pt": "Go",
    "t": 3,
    "c": "Once installed, add the following import line to your Go file which will connect to the RPC server:"
  },
  {
    "objectID": "/rpc/go/#p_3",
    "pt": "Go",
    "t": 3,
    "c": "The library provides the following bindings:"
  },
  {
    "objectID": "/rpc/go/#p_4",
    "pt": "Go",
    "t": 3,
    "c": "{!go} reachrpc.Mk accepts the Reach RPC Client Standard Options as a {!go} map and returns two functions, traditionally called {!go} rpc and {!go} rpcCallbacks."
  },
  {
    "objectID": "/rpc/go/#p_5",
    "pt": "Go",
    "t": 3,
    "c": "{!go} rpc is a function that invokes a synchronous value RPC method. It takes a string, naming the RPC method, and some JSON values to provide as arguments. It returns a single JSON value as the result."
  },
  {
    "objectID": "/rpc/go/#p_6",
    "pt": "Go",
    "t": 3,
    "c": "For example,"
  },
  {
    "objectID": "/rpc/go/#p_7",
    "pt": "Go",
    "t": 3,
    "c": "calls {!js} formatCurrency with some value {!go} i and {!go} 4 and returns the result as a string."
  },
  {
    "objectID": "/rpc/go/#p_8",
    "pt": "Go",
    "t": 3,
    "c": "{!go} rpcCallbacks is a function that invokes an interactive RPC method, such as for a backend. It takes a string, naming the RPC method, a JSON value as an argument, and map from strings to JSON values or functions. The functions will be provided as interactive RPC callbacks to the RPC method and should expect JSON values as arguments and return a JSON value as a result. It returns {!go} void."
  },
  {
    "objectID": "/rpc/go/#p_9",
    "pt": "Go",
    "t": 3,
    "c": "For example,"
  },
  {
    "objectID": "/rpc/go/#p_10",
    "pt": "Go",
    "t": 3,
    "c": "calls a backend named Alice with the contract {!go} ctc and a value named price and a method named showX that prints out a result from the Reach backend."
  },
  {
    "objectID": "/rpc/js/#js_mkRPC",
    "pt": "JavaScript",
    "t": 0,
    "s": "js",
    "c": "mkRPC"
  },
  {
    "objectID": "/rpc/js/#js_rpc",
    "pt": "JavaScript",
    "t": 0,
    "s": "js",
    "c": "rpc"
  },
  {
    "objectID": "/rpc/js/#js_rpcCallbacks",
    "pt": "JavaScript",
    "t": 0,
    "s": "js",
    "c": "rpcCallbacks"
  },
  {
    "objectID": "/rpc/js/#ref-frontends-rpc-js",
    "pt": "JavaScript",
    "t": 2,
    "c": "JavaScript"
  },
  {
    "objectID": "/rpc/js/#p_0",
    "pt": "JavaScript",
    "t": 3,
    "c": "This frontend library relies on the Reach RPC Server."
  },
  {
    "objectID": "/rpc/js/#p_1",
    "pt": "JavaScript",
    "t": 3,
    "c": "A JavaScript client library for the Reach RPC protocol may be installed by running:"
  },
  {
    "objectID": "/rpc/js/#p_2",
    "pt": "JavaScript",
    "t": 3,
    "c": "Once installed, add the following import line to your JavaScript file which will connect to the RPC server:"
  },
  {
    "objectID": "/rpc/js/#p_3",
    "pt": "JavaScript",
    "t": 3,
    "c": "The library provides the following bindings:"
  },
  {
    "objectID": "/rpc/js/#p_4",
    "pt": "JavaScript",
    "t": 3,
    "c": "{!js} mkRPC accepts the Reach RPC Client Standard Options as an object and returns a Promise of an object with two fields, {!js} rpc and {!js} rpcCallbacks."
  },
  {
    "objectID": "/rpc/js/#p_5",
    "pt": "JavaScript",
    "t": 3,
    "c": "{!js} rpc is a function that invokes a synchronous value RPC method. It takes a string, naming the RPC method, and some JSON values to provide as arguments. It returns a Promise of a single JSON value as the result."
  },
  {
    "objectID": "/rpc/js/#p_6",
    "pt": "JavaScript",
    "t": 3,
    "c": "For example,"
  },
  {
    "objectID": "/rpc/js/#p_7",
    "pt": "JavaScript",
    "t": 3,
    "c": "calls {!js} formatCurrency with some value {!js} i and {!js} 4."
  },
  {
    "objectID": "/rpc/js/#p_8",
    "pt": "JavaScript",
    "t": 3,
    "c": "{!js} rpcCallbacks is a function that invokes an interactive RPC method, such as for a backend. It takes a string, naming the RPC method, a JSON value as an argument, and dictionary from strings to JSON values or {!js} async functions. The functions will be provided as interactive RPC callbacks to the RPC method and should expect JSON values as arguments and return a Promise of a JSON value as a result. It returns a Promise that does not contain a value."
  },
  {
    "objectID": "/rpc/js/#p_9",
    "pt": "JavaScript",
    "t": 3,
    "c": "For example,"
  },
  {
    "objectID": "/rpc/js/#p_10",
    "pt": "JavaScript",
    "t": 3,
    "c": "calls a backend named Alice with the contract {!js} ctc and a value named price and a method named showX that prints out a result from the Reach backend."
  },
  {
    "objectID": "/rpc/proto/#term_API%20key",
    "pt": "Specification",
    "t": 1,
    "c": "API key"
  },
  {
    "objectID": "/rpc/proto/#term_RPC%20handles",
    "pt": "Specification",
    "t": 1,
    "c": "RPC handles"
  },
  {
    "objectID": "/rpc/proto/#term_Synchronous%20value%20RPC%20methods",
    "pt": "Specification",
    "t": 1,
    "c": "Synchronous value RPC methods"
  },
  {
    "objectID": "/rpc/proto/#term_Interactive%20RPC%20methods",
    "pt": "Specification",
    "t": 1,
    "c": "Interactive RPC methods"
  },
  {
    "objectID": "/rpc/proto/#term_interactive%20RPC%20callback",
    "pt": "Specification",
    "t": 1,
    "c": "interactive RPC callback"
  },
  {
    "objectID": "/rpc/proto/#term_interactive%20RPC%20continuation",
    "pt": "Specification",
    "t": 1,
    "c": "interactive RPC continuation"
  },
  {
    "objectID": "/rpc/proto/#ref-backends-rpc-proto",
    "pt": "Specification",
    "t": 2,
    "c": "Specification"
  },
  {
    "objectID": "/rpc/proto/#p_0",
    "pt": "Specification",
    "t": 3,
    "c": "The Reach RPC Protocol (hereafter, \"the protocol\" or \"it\") is an instance of JSON-based RPC protocol."
  },
  {
    "objectID": "/rpc/proto/#p_1",
    "pt": "Specification",
    "t": 3,
    "c": "It should be transported over HTTPS (i.e. HTTP over TLS)."
  },
  {
    "objectID": "/rpc/proto/#p_2",
    "pt": "Specification",
    "t": 3,
    "c": "Requests must include an X-API-Key header whose value is a shared secret between a server instance and an RPC client, referred to as the API key. Typically this value comes from the environment variable REACH_RPC_KEY and is the Base64 encoding of 24 random bytes."
  },
  {
    "objectID": "/rpc/proto/#p_3",
    "pt": "Specification",
    "t": 3,
    "c": "Requests must use the POST HTTP method."
  },
  {
    "objectID": "/rpc/proto/#p_4",
    "pt": "Specification",
    "t": 3,
    "c": "Requests specify the RPC method to be invoked via the HTTP request target."
  },
  {
    "objectID": "/rpc/proto/#p_5",
    "pt": "Specification",
    "t": 3,
    "c": "Requests must include a JSON-encoded array in their body. Requests should indicate this by setting the Content-Type header to application/json; charset=utf-8. This array is interpreted as the arguments to the RPC method."
  },
  {
    "objectID": "/rpc/proto/#p_6",
    "pt": "Specification",
    "t": 3,
    "c": "Responses must include a JSON-encoded value in their body. Responses should indicate this by setting the Content-Type header to application/json; charset=utf-8."
  },
  {
    "objectID": "/rpc/proto/#p_7",
    "pt": "Specification",
    "t": 3,
    "c": "Responses may include RPC handles, which are strings that represent intermediate resources held on the RPC server that cannot be serialized to JSON."
  },
  {
    "objectID": "/rpc/proto/#p_8",
    "pt": "Specification",
    "t": 3,
    "c": "RPC methods are either synchronous value RPC methods or interactive RPC methods."
  },
  {
    "objectID": "/rpc/proto/#p_9",
    "pt": "Specification",
    "t": 3,
    "c": "Synchronous value RPC methods consume arguments and produce a single result without further interaction with the client. The result is the body of the response."
  },
  {
    "objectID": "/rpc/proto/#p_10",
    "pt": "Specification",
    "t": 3,
    "c": "For example, {!js} formatCurrency is a synchronous value RPC method. A call to {!js} formatCurrency(\"19283.1035819471\", 4) would be represented by the following HTTP session, with request lines indicated by + and response lines indicated by -:"
  },
  {
    "objectID": "/rpc/proto/#p_11",
    "pt": "Specification",
    "t": 3,
    "c": "Interactive RPC methods consume arguments, including a specification of interactive RPC callbacks, and produce an interactive RPC continuation."
  },
  {
    "objectID": "/rpc/proto/#p_12",
    "pt": "Specification",
    "t": 3,
    "c": "An interactive RPC callback is a key of a JSON object, bound to {!js} true, that indicates that the initiator of an interactive RPC method responds to requests for further data during the execution of this call."
  },
  {
    "objectID": "/rpc/proto/#p_13",
    "pt": "Specification",
    "t": 3,
    "c": "An interactive RPC continuation is a JSON object that matches either:"
  },
  {
    "objectID": "/rpc/proto/#p_14",
    "pt": "Specification",
    "t": 3,
    "c": "{!js} {t: \"Done\", ans}, where {!js} ans is the final result of the original interactive RPC method."
  },
  {
    "objectID": "/rpc/proto/#p_15",
    "pt": "Specification",
    "t": 3,
    "c": "{!js} {t: \"Kont\", kid, m, args}, where {!js} kid is an RPC handle, {!js} m is a string naming one of the interactive RPC callback methods, and {!js} args is an array of the arguments to that method."
  },
  {
    "objectID": "/rpc/proto/#p_16",
    "pt": "Specification",
    "t": 3,
    "c": "When a {!js} Kont value is produced, then the interactive RPC method is suspended until the /kont RPC method is invoked with the continuation RPC handle and the return value of the interactive RPC callback. The result of the /kont RPC method is another interactive RPC continuation."
  },
  {
    "objectID": "/rpc/proto/#p_17",
    "pt": "Specification",
    "t": 3,
    "c": "Clients may perform any RPC methods while an interactive RPC method is suspended."
  },
  {
    "objectID": "/rpc/proto/#p_18",
    "pt": "Specification",
    "t": 3,
    "c": "The server may re-use the same interactive RPC continuation handle many times."
  },
  {
    "objectID": "/rpc/proto/#p_19",
    "pt": "Specification",
    "t": 3,
    "c": "For example, the execution of a backend is an interactive RPC method. An example interaction might be represented by the following HTTP session, with request lines indicated by + and response lines indicated by -:"
  },
  {
    "objectID": "/rpc/py/#py_mk_rpc",
    "pt": "Python",
    "t": 0,
    "s": "py",
    "c": "mk_rpc"
  },
  {
    "objectID": "/rpc/py/#py_rpc",
    "pt": "Python",
    "t": 0,
    "s": "py",
    "c": "rpc"
  },
  {
    "objectID": "/rpc/py/#py_rpc_callbacks",
    "pt": "Python",
    "t": 0,
    "s": "py",
    "c": "rpc_callbacks"
  },
  {
    "objectID": "/rpc/py/#ref-frontends-rpc-py",
    "pt": "Python",
    "t": 2,
    "c": "Python"
  },
  {
    "objectID": "/rpc/py/#p_0",
    "pt": "Python",
    "t": 3,
    "c": "This frontend library relies on the Reach RPC Server."
  },
  {
    "objectID": "/rpc/py/#p_1",
    "pt": "Python",
    "t": 3,
    "c": "A Python client library for the Reach RPC protocol may be installed by running:"
  },
  {
    "objectID": "/rpc/py/#p_2",
    "pt": "Python",
    "t": 3,
    "c": "Once installed, add the following import line to your Python file which will connect to the RPC server:"
  },
  {
    "objectID": "/rpc/py/#p_3",
    "pt": "Python",
    "t": 3,
    "c": "The library provides the following bindings:"
  },
  {
    "objectID": "/rpc/py/#p_4",
    "pt": "Python",
    "t": 3,
    "c": "{!py} mk_rpc accepts the Reach RPC Client Standard Options as a dictionary and returns two functions, traditionally called {!py} rpc and {!py} rpc_callbacks."
  },
  {
    "objectID": "/rpc/py/#p_5",
    "pt": "Python",
    "t": 3,
    "c": "{!py} rpc is a function that invokes a synchronous value RPC method. It takes a string, naming the RPC method, and some JSON values to provide as arguments. It returns a single JSON value as the result."
  },
  {
    "objectID": "/rpc/py/#p_6",
    "pt": "Python",
    "t": 3,
    "c": "For example,"
  },
  {
    "objectID": "/rpc/py/#p_7",
    "pt": "Python",
    "t": 3,
    "c": "calls {!js} formatCurrency with some value {!py} i and {!py} 4."
  },
  {
    "objectID": "/rpc/py/#p_8",
    "pt": "Python",
    "t": 3,
    "c": "{!py} rpc_callbacks is a function that invokes an interactive RPC method, such as for a backend. It takes a string, naming the RPC method, a JSON value as an argument, and dictionary from strings to JSON values or functions. The functions will be provided as interactive RPC callbacks to the RPC method and should expect JSON values as arguments and return a JSON value as a result. It does not return a value."
  },
  {
    "objectID": "/rpc/py/#p_9",
    "pt": "Python",
    "t": 3,
    "c": "For example,"
  },
  {
    "objectID": "/rpc/py/#p_10",
    "pt": "Python",
    "t": 3,
    "c": "calls a backend named Alice with the contract {!py} ctc and a value named price and a method named showX that prints out a result from the Reach backend."
  },
  {
    "objectID": "/workshop/fomo/#workshop-fomo",
    "pt": "Fear of Missing Out",
    "t": 2,
    "c": "Fear of Missing Out"
  },
  {
    "objectID": "/workshop/fomo/#workshop-fomo-pr",
    "pt": "Fear of Missing Out",
    "t": 2,
    "c": "Problem Analysis"
  },
  {
    "objectID": "/workshop/fomo/#workshop-fomo-dd",
    "pt": "Fear of Missing Out",
    "t": 2,
    "c": "Data Definition"
  },
  {
    "objectID": "/workshop/fomo/#workshop-fomo-cc",
    "pt": "Fear of Missing Out",
    "t": 2,
    "c": "Communication Construction"
  },
  {
    "objectID": "/workshop/fomo/#workshop-fomo-ai",
    "pt": "Fear of Missing Out",
    "t": 2,
    "c": "Assertion Insertion"
  },
  {
    "objectID": "/workshop/fomo/#workshop-fomo-ii",
    "pt": "Fear of Missing Out",
    "t": 2,
    "c": "Interaction Introduction"
  },
  {
    "objectID": "/workshop/fomo/#workshop-fomo-de",
    "pt": "Fear of Missing Out",
    "t": 2,
    "c": "Deployment Decisions"
  },
  {
    "objectID": "/workshop/fomo/#workshop-fomo-dns",
    "pt": "Fear of Missing Out",
    "t": 2,
    "c": "Discussion and Next Steps"
  },
  {
    "objectID": "/workshop/fomo/#p_0",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "In this workshop, we'll design an application that allows a Funder to create an auction where participants may purchase tickets. The Funder sets a ticket price and a relative deadline. When a Buyer purchases a ticket, the deadline is reset. Whoever is the last person to buy a ticket—when the deadline finally hits—wins the entire balance. This program is based off of the crypto game, FOMO3DGame."
  },
  {
    "objectID": "/workshop/fomo/#p_1",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "This workshop utilizes participant classes to represent Buyers, which allows us to handle multiple participants in a generic way."
  },
  {
    "objectID": "/workshop/fomo/#p_2",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "This workshop is independent of all others."
  },
  {
    "objectID": "/workshop/fomo/#p_3",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "We assume that you'll go through this workshop in a directory named ~/reach/workshop-fomo:"
  },
  {
    "objectID": "/workshop/fomo/#p_4",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "And that you have a copy of Reach installed in ~/reach so you can write"
  },
  {
    "objectID": "/workshop/fomo/#p_5",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "And it will run Reach. You should start off by initializing your Reach program:"
  },
  {
    "objectID": "/workshop/fomo/#p_6",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "First, we should think over the details of the application and answer some questions to help reason about the implementation of the program."
  },
  {
    "objectID": "/workshop/fomo/#p_7",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "You should write the answer to the following questions in your Reach program (index.rsh) using a comment. {!rsh} /* Remember comments are written like this. */"
  },
  {
    "objectID": "/workshop/fomo/#p_8",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Who is involved in this application?"
  },
  {
    "objectID": "/workshop/fomo/#p_9",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "What information do they know at the start of the program?"
  },
  {
    "objectID": "/workshop/fomo/#p_10",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "What information are they going to discover and use in the program?"
  },
  {
    "objectID": "/workshop/fomo/#p_11",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "What funds change ownership during the application and how?"
  },
  {
    "objectID": "/workshop/fomo/#p_12",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Let's see how your answers compare to ours:"
  },
  {
    "objectID": "/workshop/fomo/#p_13",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "This program involves two parties: a Funder who deploys the auction and the Buyers who purchase tickets."
  },
  {
    "objectID": "/workshop/fomo/#p_14",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "The Funder knows the deadline and the ticket price at the start of the application."
  },
  {
    "objectID": "/workshop/fomo/#p_15",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "The Buyers do not know anything of the deadline or ticket price when the application begins."
  },
  {
    "objectID": "/workshop/fomo/#p_16",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "The Funder does not learn anything during the program execution."
  },
  {
    "objectID": "/workshop/fomo/#p_17",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "The Buyers learn of the ticket price and deadline during the program execution."
  },
  {
    "objectID": "/workshop/fomo/#p_18",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Buyers continually add funds to the balance during execution until one Buyer wins the entire balance."
  },
  {
    "objectID": "/workshop/fomo/#p_19",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "It's okay if some of your answers differ from ours!"
  },
  {
    "objectID": "/workshop/fomo/#p_20",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "After problem analysis, we need to decide how we will represent the information in the program:"
  },
  {
    "objectID": "/workshop/fomo/#p_21",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "What data type will represent the deadline set by the Funder?"
  },
  {
    "objectID": "/workshop/fomo/#p_22",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "What data type will represent the ticket price set by the Funder?"
  },
  {
    "objectID": "/workshop/fomo/#p_23",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "What data type will represent the Buyer's decision to purchase a ticket?"
  },
  {
    "objectID": "/workshop/fomo/#p_24",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Refer to Types for a reminder of what data types are available in Reach."
  },
  {
    "objectID": "/workshop/fomo/#p_25",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Now that we've decided what data types to use, we need to determine how the programs will obtain this information. We need to outline the participant interact interface for each participant."
  },
  {
    "objectID": "/workshop/fomo/#p_26",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "What participant interact interface will Funder use?"
  },
  {
    "objectID": "/workshop/fomo/#p_27",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "What participant interact interface will Buyer use?"
  },
  {
    "objectID": "/workshop/fomo/#p_28",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Revisit the problem analysis section when completing this section. Whenever a participant starts off with some knowledge, that will be a field in the {!rsh} interact object. If they learn something, then it will be an argument to a function. If they provide something later, then it will be the result of a function."
  },
  {
    "objectID": "/workshop/fomo/#p_29",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "You should write your answers in your Reach file (index.rsh) as the participant interact interface for each of the participants."
  },
  {
    "objectID": "/workshop/fomo/#p_30",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Let's compare your answers with ours:"
  },
  {
    "objectID": "/workshop/fomo/#p_31",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "The deadline will be represented with a {!rsh} UInt, as it is a relative time delta signifying a change in block numbers."
  },
  {
    "objectID": "/workshop/fomo/#p_32",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "The ticketPrice will be represented with a {!rsh} UInt"
  },
  {
    "objectID": "/workshop/fomo/#p_33",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "The decision to buy a ticket will be represented by a function {!rsh} Fun([UInt], Bool)"
  },
  {
    "objectID": "/workshop/fomo/#p_34",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Our participant interact interface, with the addition of some handy logging functions, looks like this so far:"
  },
  {
    "objectID": "/workshop/fomo/#p_35",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "At this point, you can modify your JavaScript file (index.mjs) to contain definitions of these values, although you may want to use placeholders for the actual values. When you're writing a Reach program, especially in the early phases, you should have these two files open side-by-side and update them in tandem as you're deciding the participant interact interface."
  },
  {
    "objectID": "/workshop/fomo/#p_36",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "A fundamental aspect of a decentralized application is the pattern of communication and transfer among the participants. We should write down this structure as comments in our program to serve as an outline and guide us in implementation. For example, for the tutorial version of Rock, Paper, Scissors!, we might write:"
  },
  {
    "objectID": "/workshop/fomo/#p_37",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "You should do this now, in your Reach program (index.rsh)."
  },
  {
    "objectID": "/workshop/fomo/#p_38",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Here's what we wrote for our outline:"
  },
  {
    "objectID": "/workshop/fomo/#p_39",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Now, this outline needs to be converted to a real program."
  },
  {
    "objectID": "/workshop/fomo/#p_40",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "The body of your application should look something like this:"
  },
  {
    "objectID": "/workshop/fomo/#p_41",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "We use {!rsh} parallelReduce to allow Buyers to purchase tickets until the deadline passes and accumulate the current winner. We maintain the invariant that the balance must be equal to the number of tickets sold multiplied by the ticket price."
  },
  {
    "objectID": "/workshop/fomo/#p_42",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "This program doesn't have many interesting properties to prove as assertions, beyond the token linearity property. The only property of interest is the {!rsh} parallelReduce invariant which states that the balance must be equal to the number of tickets sold multiplied by the ticket price."
  },
  {
    "objectID": "/workshop/fomo/#p_43",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Next, we need to insert the appropriate calls to {!rsh} interact. In this case, our program is very simple and we expect you'll do a great job without further discussion."
  },
  {
    "objectID": "/workshop/fomo/#p_44",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Let's look at our whole program now:"
  },
  {
    "objectID": "/workshop/fomo/#p_45",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Next, it is time to test our program. As usual, we'll present a completely automated test deployment, rather than an interactive one."
  },
  {
    "objectID": "/workshop/fomo/#p_46",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "The program is fairly straightfoward to test. We just create test accounts for the Funder and any number of Buyers. The decision to purchase a ticket by a Buyer will rely simply on generating a random boolean."
  },
  {
    "objectID": "/workshop/fomo/#p_47",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Here's the JavaScript frontend we wrote:"
  },
  {
    "objectID": "/workshop/fomo/#p_48",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Let's see what it looks like when we run the program:"
  },
  {
    "objectID": "/workshop/fomo/#p_49",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "Great job!"
  },
  {
    "objectID": "/workshop/fomo/#p_50",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "If you found this workshop rewarding, please let us know on the Discord community!"
  },
  {
    "objectID": "/workshop/fomo/#p_51",
    "pt": "Fear of Missing Out",
    "t": 3,
    "c": "If you'd like to make this application a little more interesting, maybe you'd like to extend this program to make the last N buyers split the winnings. Check out Fear of Missing Out Generalized for our solution!"
  },
  {
    "objectID": "/workshop/fomo-generalized/#workshop-fomo-generalized",
    "pt": "Fear of Missing Out+",
    "t": 2,
    "c": "Fear of Missing Out+"
  },
  {
    "objectID": "/workshop/fomo-generalized/#workshop-fomo-generalized-pr",
    "pt": "Fear of Missing Out+",
    "t": 2,
    "c": "Problem Analysis"
  },
  {
    "objectID": "/workshop/fomo-generalized/#workshop-fomo-generalized-dd",
    "pt": "Fear of Missing Out+",
    "t": 2,
    "c": "Data Definition"
  },
  {
    "objectID": "/workshop/fomo-generalized/#workshop-fomo-generalized-cc",
    "pt": "Fear of Missing Out+",
    "t": 2,
    "c": "Communication Construction"
  },
  {
    "objectID": "/workshop/fomo-generalized/#workshop-fomo-generalized-ai",
    "pt": "Fear of Missing Out+",
    "t": 2,
    "c": "Assertion Insertion"
  },
  {
    "objectID": "/workshop/fomo-generalized/#workshop-fomo-generalized-ii",
    "pt": "Fear of Missing Out+",
    "t": 2,
    "c": "Interaction Introduction"
  },
  {
    "objectID": "/workshop/fomo-generalized/#workshop-fomo-generalized-de",
    "pt": "Fear of Missing Out+",
    "t": 2,
    "c": "Deployment Decisions"
  },
  {
    "objectID": "/workshop/fomo-generalized/#workshop-fomo-generalized-dns",
    "pt": "Fear of Missing Out+",
    "t": 2,
    "c": "Discussion and Next Steps"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_0",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "In this workshop, we will extend our Fear of Missing Out application with the ability to split the reward between the N most recent Buyers."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_1",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "In this version, the Funder will have the advantage that, if there are less than N Buyers, the Funder will earn the rewards for every absent Buyer. For example, if the auction is set to have 5 winners, yet only 3 Buyers bid, the first three Buyers will receive 1/5 of the funds each, and the Funder will receive the remaining 2/5 of the funds."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_2",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Fear of Missing Out."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_3",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "We assume that you'll go through this workshop in a directory named ~/reach/workshop-fomo-generalized:"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_4",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "And that you have a copy of Reach installed in ~/reach so you can write"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_5",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "And it will run Reach. You should start off by initializing your Reach program:"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_6",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Our problem analysis is practically the same as the original Fear of Missing Out application, except for one difference:"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_7",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "What funds change ownership during the application and how?"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_8",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Let's compare answers for how funds should change ownership in this generalized version:"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_9",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Buyers continually add funds to the balance during execution until the last N Buyers, and potentially the Funder, split the balance."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_10",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "The data type representation of this program will basically be the same as the regular Fear of Missing Out program. However, instead of tracking the latest Buyer as an {!rsh} Address, we will track the last N Buyers as an {!rsh} Array(Address, N)."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_11",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Refer to Types for a reminder of what data types are available in Reach."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_12",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "You should take the time now to fill out the interaction interface for the participants."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_13",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Our participant interact interface, with the addition of some handy logging functions, looks like this so far:"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_14",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "It is worth noting that Reach does not support arbitrarily sized arrays, so we could not determine NUM_OF_WINNERS at runtime, e.g. from the interaction interface. However, we can still write a program that is generic in the size of the array, then specialize it when we compile."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_15",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "At this point, you can modify your JavaScript file (index.mjs) to contain definitions of these values, although you may want to use placeholders for the actual values. When you're writing a Reach program, especially in the early phases, you should have these two files open side-by-side and update them in tandem as you're deciding the participant interact interface."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_16",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "A fundamental aspect of a decentralized application is the pattern of communication and transfer among the participants. We should write down this structure as comments in our program to serve as an outline and guide us in implementation. In our original Fear of Missing Out implementation, we outlined the pattern of communication as follows:"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_17",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "This outline will need to be updated for our generalized version. You should do this now, in your Reach program (index.rsh)."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_18",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Here's what we wrote for our outline:"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_19",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Now, this outline needs to be converted to a real program."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_20",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "The body of your application should look something like this:"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_21",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Extending this program to track an array of {!rsh} Addresses, as opposed to a single {!rsh} Address is fairly straightforward. We maintain an array of size NUM_OF_WINNERS and implement a ring buffer to keep it up to date with the most recent N winners, as demonstrated in step 2b."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_22",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Another aspect of this code worth highlighting is step 3. We transfer {!rsh} balance() % NUM_OF_WINNERS to the winner because the total balance may not be evenly divisible by the number of winners."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_23",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "For example, if the ticket price is 4 ETH and there are 10 tickets purchased by Buyers, then the total balance will be 40 ETH. However, if the application is set to select 3 winners, then 40 cannot be evenly distributed to 3 participants. So, we will transfer 1 ETH to the Funder, and split the remaining 39 ETH between the 3 Buyers."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_24",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "This program doesn't have many interesting properties to prove as assertions, beyond the token linearity property. The only property of interest is the {!rsh} parallelReduce invariant which states that the balance must be equal to the number of tickets sold multiplied by the ticket price."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_25",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Next, we need to insert the appropriate calls to {!rsh} interact. In this case, our program is very simple and we expect you'll do a great job without further discussion."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_26",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Let's look at our whole program now:"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_27",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Next, it is time to test our program. As usual, we'll present a completely automated test deployment, rather than an interactive one."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_28",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "The program is fairly straightfoward to test. We just create test accounts for the Funder and any number of Buyers. The decision to purchase a ticket by a Buyer will rely simply on generating a random boolean."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_29",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Here's the JavaScript frontend we wrote:"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_30",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Let's see what it looks like when we run the program:"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_31",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Great job!"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_32",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "You've now implemented a generalized Fear of Missing Out game. You can try extending this application with additional features such as:"
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_33",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Slightly increasing the ticket price with each purchase."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_34",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "Introducing a small payout system (dividends) to Buyers as the game progresses. e.g. every time the ring buffer is filled."
  },
  {
    "objectID": "/workshop/fomo-generalized/#p_35",
    "pt": "Fear of Missing Out+",
    "t": 3,
    "c": "If you found this workshop rewarding, please let us know on the Discord community!"
  },
  {
    "objectID": "/workshop/hash-lock/#workshop-hash-lock",
    "pt": "Hash Lock",
    "t": 2,
    "c": "Hash Lock"
  },
  {
    "objectID": "/workshop/hash-lock/#workshop-hash-lock-pr",
    "pt": "Hash Lock",
    "t": 2,
    "c": "Problem Analysis"
  },
  {
    "objectID": "/workshop/hash-lock/#workshop-hash-lock-dd",
    "pt": "Hash Lock",
    "t": 2,
    "c": "Data Definition"
  },
  {
    "objectID": "/workshop/hash-lock/#workshop-hash-lock-cc",
    "pt": "Hash Lock",
    "t": 2,
    "c": "Communication Construction"
  },
  {
    "objectID": "/workshop/hash-lock/#workshop-hash-lock-ai",
    "pt": "Hash Lock",
    "t": 2,
    "c": "Assertion Insertion"
  },
  {
    "objectID": "/workshop/hash-lock/#workshop-hash-lock-ii",
    "pt": "Hash Lock",
    "t": 2,
    "c": "Interaction Introduction"
  },
  {
    "objectID": "/workshop/hash-lock/#workshop-hash-lock-de",
    "pt": "Hash Lock",
    "t": 2,
    "c": "Deployment Decisions"
  },
  {
    "objectID": "/workshop/hash-lock/#workshop-hash-lock-dns",
    "pt": "Hash Lock",
    "t": 2,
    "c": "Discussion"
  },
  {
    "objectID": "/workshop/hash-lock/#p_0",
    "pt": "Hash Lock",
    "t": 3,
    "c": "In this workshop, we'll design an application that allows a payer to lock funds with a secret password, independent from their consensus network identity, which can be drawn by anyone possessing the secret password. This is a useful way for a payer to show that they have funds and have committed to disbursing them, without deciding beforehand who they are paying."
  },
  {
    "objectID": "/workshop/hash-lock/#p_1",
    "pt": "Hash Lock",
    "t": 3,
    "c": "This workshop is independent of all others."
  },
  {
    "objectID": "/workshop/hash-lock/#p_2",
    "pt": "Hash Lock",
    "t": 3,
    "c": "We assume that you'll go through this workshop in a directory named ~/reach/workshop-hash-lock:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_3",
    "pt": "Hash Lock",
    "t": 3,
    "c": "And that you have a copy of Reach installed in ~/reach so you can write"
  },
  {
    "objectID": "/workshop/hash-lock/#p_4",
    "pt": "Hash Lock",
    "t": 3,
    "c": "And it will run Reach. You should start off by initializing your Reach program:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_5",
    "pt": "Hash Lock",
    "t": 3,
    "c": "The first step in any program design is to perform problem analysis and determine what information is relevant to the problem. When writing decentralized applications in Reach, this information analysis includes an analysis of the set of participants involved in a computation."
  },
  {
    "objectID": "/workshop/hash-lock/#p_6",
    "pt": "Hash Lock",
    "t": 3,
    "c": "In this case, let's ask the questions:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_7",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Who is involved in this application?"
  },
  {
    "objectID": "/workshop/hash-lock/#p_8",
    "pt": "Hash Lock",
    "t": 3,
    "c": "What information do they know at the start of the program?"
  },
  {
    "objectID": "/workshop/hash-lock/#p_9",
    "pt": "Hash Lock",
    "t": 3,
    "c": "What information are they going to discover and use in the program?"
  },
  {
    "objectID": "/workshop/hash-lock/#p_10",
    "pt": "Hash Lock",
    "t": 3,
    "c": "What funds change ownership during the application and how?"
  },
  {
    "objectID": "/workshop/hash-lock/#p_11",
    "pt": "Hash Lock",
    "t": 3,
    "c": "You should write your answers in your Reach program (index.rsh) using a comment. {!rsh} /* Remember comments are written like this. */"
  },
  {
    "objectID": "/workshop/hash-lock/#p_12",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Let's see how your answers compare to our answers:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_13",
    "pt": "Hash Lock",
    "t": 3,
    "c": "This program involves two parties: the payer sending the funds and the receiver of those funds. By tradition, we'll call the first 'Alice' and the second 'Bob'. You might like to use other names, like 'Sender' and 'Receiver'."
  },
  {
    "objectID": "/workshop/hash-lock/#p_14",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Alice starts off knowing the amount she wants to send and the secret password."
  },
  {
    "objectID": "/workshop/hash-lock/#p_15",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Bob starts off like Jon Snow and knows nothing."
  },
  {
    "objectID": "/workshop/hash-lock/#p_16",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Alice doesn't learn anything during the execution of the program, but Bob learns the password."
  },
  {
    "objectID": "/workshop/hash-lock/#p_17",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Alice transfers funds at the beginning of the program and Bob receives those funds at the end, after he learns the password."
  },
  {
    "objectID": "/workshop/hash-lock/#p_18",
    "pt": "Hash Lock",
    "t": 3,
    "c": "It's okay if your answers are different than ours. Problem analysis is a \"loose\" process that is more like creative artistry than it is like rote calculation. But, that doesn't mean it is superfluous and unnecessary or unneeded."
  },
  {
    "objectID": "/workshop/hash-lock/#p_19",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Problem analysis is a crucial step that helps us understand what our application is supposed to be doing. Remember, programming in general, and Reach in particular, does not solve problems for you; instead, programs encode automatic solutions to problems you've already solved. Compared to normal languages, Reach does do a bit automatically for you: it automatically discovers problems you may not have realized your program had. You still have to solve them yourself though! But, at least you know about them because of Reach."
  },
  {
    "objectID": "/workshop/hash-lock/#p_20",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Humans and their social systems deal with information, but computers can only interact with data, which is merely a representation of information using particular structures, like numbers, arrays, and so on. After problem analysis, we know what information our program will deal with, but next we need to decide how to translate that information into concrete data."
  },
  {
    "objectID": "/workshop/hash-lock/#p_21",
    "pt": "Hash Lock",
    "t": 3,
    "c": "So, for this program, we should decide:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_22",
    "pt": "Hash Lock",
    "t": 3,
    "c": "What data type will represent the amount Alice transfers?"
  },
  {
    "objectID": "/workshop/hash-lock/#p_23",
    "pt": "Hash Lock",
    "t": 3,
    "c": "What data type will represent Alice's password?"
  },
  {
    "objectID": "/workshop/hash-lock/#p_24",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Refer to Types for a reminder of what data types are available in Reach."
  },
  {
    "objectID": "/workshop/hash-lock/#p_25",
    "pt": "Hash Lock",
    "t": 3,
    "c": "After deciding those things, you should think about how the program will be provided these values. In other words:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_26",
    "pt": "Hash Lock",
    "t": 3,
    "c": "What participant interact interface will each participant use?"
  },
  {
    "objectID": "/workshop/hash-lock/#p_27",
    "pt": "Hash Lock",
    "t": 3,
    "c": "You should look back at your problem analysis to do this step. Whenever a participant starts off knowing something, then it is a field in the {!rsh} interact object. If they learn something, then it will be an argument to a function. If they provide something later, then it will be the result of a function."
  },
  {
    "objectID": "/workshop/hash-lock/#p_28",
    "pt": "Hash Lock",
    "t": 3,
    "c": "You should write your answers in your Reach file (index.rsh) as the participant interact interface for each of the participants."
  },
  {
    "objectID": "/workshop/hash-lock/#p_29",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Let's compare notes again."
  },
  {
    "objectID": "/workshop/hash-lock/#p_30",
    "pt": "Hash Lock",
    "t": 3,
    "c": "We're going to represent the amount Alice transfers as an unsigned integer ({!rsh} UInt) named {!rsh} amt."
  },
  {
    "objectID": "/workshop/hash-lock/#p_31",
    "pt": "Hash Lock",
    "t": 3,
    "c": "We will represent the password as another unsigned integer ({!rsh} UInt) named {!rsh} pass."
  },
  {
    "objectID": "/workshop/hash-lock/#p_32",
    "pt": "Hash Lock",
    "t": 3,
    "c": "These two values are the only fields of Alice's interface, but Bob will have a function named {!rsh} getPass that will return the password that he knows."
  },
  {
    "objectID": "/workshop/hash-lock/#p_33",
    "pt": "Hash Lock",
    "t": 3,
    "c": "We wrote this in our program as:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_34",
    "pt": "Hash Lock",
    "t": 3,
    "c": "It would be very surprising if you choose the exact same names as us in your code, but did you choose the same types? We expect that many of you might have chosen to represent the password by a string of bytes using the Reach type, {!rsh} Bytes. There's nothing necessarily wrong with this option, but we did not choose it because it is hard to decide exactly how long to make it, but we are satisfied with an unsigned integer, because it has a minimum of 64 bits on typical consensus networks."
  },
  {
    "objectID": "/workshop/hash-lock/#p_35",
    "pt": "Hash Lock",
    "t": 3,
    "c": "At this point, you can modify your JavaScript file (index.mjs) to contain definitions of these values, although you may want to use a placeholder like {!js} 42 or something for the actual value. When you're writing a Reach program, especially in the early phases, you should have these two files open side-by-side and update them in tandem as you're deciding the participant interact interface."
  },
  {
    "objectID": "/workshop/hash-lock/#p_36",
    "pt": "Hash Lock",
    "t": 3,
    "c": "A fundamental aspect of a decentralized application is the pattern of communication and transfer among the participants, including the consensus network. For example, who initiates the application? Who responds next? Is there a repeated segment of the program that occurs over and over again? We should explicitly write down this structure as comments in our program. For example, for the tutorial version of Rock, Paper, Scissors!, we might write:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_37",
    "pt": "Hash Lock",
    "t": 3,
    "c": "You should do this now, in your Reach program (index.rsh)."
  },
  {
    "objectID": "/workshop/hash-lock/#p_38",
    "pt": "Hash Lock",
    "t": 3,
    "c": "This is a simple application, so we should all share the same communication pattern. Here's what we wrote:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_39",
    "pt": "Hash Lock",
    "t": 3,
    "c": "However, looking at this pattern reveals a subtlety in this application: how can the consensus ensure that Bob publishes the correct password? The only way is for Alice to publish something first that can be checked by the consensus. For example, we could use the pattern:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_40",
    "pt": "Hash Lock",
    "t": 3,
    "c": "However, this is definitely wrong, because Alice doesn't want to share her password with the world across the network, she only wants to share it with Bob, potentially at some later moment. So, she should not publish the password, but instead, publish a digest of the password, that can be checked against the actual password later. In other words, we should use a pattern like:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_41",
    "pt": "Hash Lock",
    "t": 3,
    "c": "It is cheaper to go through this iteration process in the human-centered design phase than in the code-centered programming phase, even when you're using a high-level language like Reach for programming."
  },
  {
    "objectID": "/workshop/hash-lock/#p_42",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Next, we need to convert this pattern into actual program code using {!rsh} publish, {!rsh} pay, and {!rsh} commit."
  },
  {
    "objectID": "/workshop/hash-lock/#p_43",
    "pt": "Hash Lock",
    "t": 3,
    "c": "The body of your application should look something like:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_44",
    "pt": "Hash Lock",
    "t": 3,
    "c": "We can now move on to the next part of designing a decentralized application: verification."
  },
  {
    "objectID": "/workshop/hash-lock/#p_45",
    "pt": "Hash Lock",
    "t": 3,
    "c": "When we are programming, we hold a complex theory of the behavior of the program inside of our minds that helps us know what should happen next in the program based on what has happened before and what is true at every point in the program. As programs become more complex, this theory becomes more and more difficult to grasp, so we might make mistakes. Furthermore, when another programmer reads our code (such as a version of ourselves from the future trying to modify the program), it can be very difficult to understand this theory for ourselves. Assertions are ways of encoding this theory directly into the text of the program in a way that will be checked by Reach and available to all future readers and editors of the code."
  },
  {
    "objectID": "/workshop/hash-lock/#p_46",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Look at your application. What are the assumptions you have about the values in the program?"
  },
  {
    "objectID": "/workshop/hash-lock/#p_47",
    "pt": "Hash Lock",
    "t": 3,
    "c": "There are three main assumptions we came up with for this program:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_48",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Before Bob publishes the password, it is unknowable by him and everyone else except Alice."
  },
  {
    "objectID": "/workshop/hash-lock/#p_49",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Bob assumes that the password digest published by Alice matches the digest of the password he's publishing."
  },
  {
    "objectID": "/workshop/hash-lock/#p_50",
    "pt": "Hash Lock",
    "t": 3,
    "c": "The consensus requires that Alice's digest and the digest of Bob's password match."
  },
  {
    "objectID": "/workshop/hash-lock/#p_51",
    "pt": "Hash Lock",
    "t": 3,
    "c": "We expect that the third of these is the least controversial and the most obvious property, but the others are important too. The first property essentially guarantees that the erroneous version of the application we contemplated, where Alice directly sent her password over the network, is disallowed. The second property encodes Bob's assumption of good will and integrity when he submits his value: an honest version of the Bob participant would not willingly send a password that wasn't the correct one. Furthermore, it is possible for any participant to check, without going through consensus, if they know what the password is."
  },
  {
    "objectID": "/workshop/hash-lock/#p_52",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Now that we know what the properties are, we need to encode them into our program via calls to Reach functions like {!rsh} unknowable, {!rsh} assume, and {!rsh} require. Let's do that now."
  },
  {
    "objectID": "/workshop/hash-lock/#p_53",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Here's what we did:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_54",
    "pt": "Hash Lock",
    "t": 3,
    "c": "First, we assert that Bob can't know Alice's password, based on what the Reach program does."
  },
  {
    "objectID": "/workshop/hash-lock/#p_55",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Next, we assert that Bob believes his password is correct (and that an honest Bob will check it.)"
  },
  {
    "objectID": "/workshop/hash-lock/#p_56",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Finally, we assert that the consensus can only continue if this is the case."
  },
  {
    "objectID": "/workshop/hash-lock/#p_57",
    "pt": "Hash Lock",
    "t": 3,
    "c": "At this point, we are almost ready to complete our program and make it so that we can run it. You've probably noticed that in our samples, the variables {!rsh} pass, {!rsh} amt, and {!rsh} passDigest are undefined. We'll handle that next."
  },
  {
    "objectID": "/workshop/hash-lock/#p_58",
    "pt": "Hash Lock",
    "t": 3,
    "c": "A key concept of Reach programs is that they are concerned solely with the communication and consensus portions of a decentralized application. Frontends are responsible for all other aspects of the program. Thus, eventually a Reach programmer needs to insert calls into their code to send data to and from the frontend via the participant interact interfaces that they defined during the Data Definition step."
  },
  {
    "objectID": "/workshop/hash-lock/#p_59",
    "pt": "Hash Lock",
    "t": 3,
    "c": "In our program, that means defining {!rsh} amt and {!rsh} passDigest by Alice and {!rsh} pass by Bob. Do that now."
  },
  {
    "objectID": "/workshop/hash-lock/#p_60",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Here's what we did:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_61",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Lines 11-14 have Alice declassify some of her values."
  },
  {
    "objectID": "/workshop/hash-lock/#p_62",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Line 21 has Bob provide his password."
  },
  {
    "objectID": "/workshop/hash-lock/#p_63",
    "pt": "Hash Lock",
    "t": 3,
    "c": "At this point, when we"
  },
  {
    "objectID": "/workshop/hash-lock/#p_64",
    "pt": "Hash Lock",
    "t": 3,
    "c": "We'll get a happy message that all our theorems are true. Great job! But we still need to run our program!"
  },
  {
    "objectID": "/workshop/hash-lock/#p_65",
    "pt": "Hash Lock",
    "t": 3,
    "c": "At this point, we need to decide how we're going to deploy this program and really use it in the world. We need to decide how to deploy the contract, as well as what kind of user interaction modality we'll implement inside of our frontend."
  },
  {
    "objectID": "/workshop/hash-lock/#p_66",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Unfortunately, on many consensus networks, like Ethereum and Algorand, this application is dangerous to run. The problem is that a malicious miner, like Eve, can intercept Bob's message that provides him the funds, refuse to forward it through to the consensus network, take the password from it, and submit it for her own account. There is not a good general solution to this problem, meaning a theorem that we could insert into our program to make sure this attack isn't possible, because the whole point of this application is that Bob's identity is not known at the time that Alice sends the first message. Ideally, such networks would support a kind of cryptographic operation where Bob could prove that he knows the password without revealing it. There are some ideas on how to provide this sort of thing through zero-knowledge proofs and homomorphic encryption, but there is no widely accepted and available solution."
  },
  {
    "objectID": "/workshop/hash-lock/#p_67",
    "pt": "Hash Lock",
    "t": 3,
    "c": "In short: Don't run this program. If you want to do something like this, then continue to the next workshop on relays. If you want to do exactly this, then stay tuned for a more complex zero-knowledge version."
  },
  {
    "objectID": "/workshop/hash-lock/#p_68",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Next, we'll settle for a simple testing program for now to show the application, and let the rest of our full stack team deal with actually building the interface. Here's the JavaScript frontend we wrote:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_69",
    "pt": "Hash Lock",
    "t": 3,
    "c": "In this case, Bob learns the password outside of the Reach program by directly sharing memory with Alice. In a real deployment, she might give Bob the password through some other channel, like an encrypted email message, or a calligraphic scroll delivered by raven or intoned from Himalayan cliffs."
  },
  {
    "objectID": "/workshop/hash-lock/#p_70",
    "pt": "Hash Lock",
    "t": 3,
    "c": "With this testing frontend in place, we can run"
  },
  {
    "objectID": "/workshop/hash-lock/#p_71",
    "pt": "Hash Lock",
    "t": 3,
    "c": "and see an example execution:"
  },
  {
    "objectID": "/workshop/hash-lock/#p_72",
    "pt": "Hash Lock",
    "t": 3,
    "c": "You did it!"
  },
  {
    "objectID": "/workshop/hash-lock/#p_73",
    "pt": "Hash Lock",
    "t": 3,
    "c": "You implemented a Reach program totally on your own, with only a little bit of prodding."
  },
  {
    "objectID": "/workshop/hash-lock/#p_74",
    "pt": "Hash Lock",
    "t": 3,
    "c": "Unlike the tutorial, this workshop uses a \"top-down\" perspective on Reach application design, where you derive the program from the requirements and slowly fill out the shell, while knowing that each step was correct before moving on. In contrast, in the tutorial, we demonstrated a \"bottom-up\" style where you start implementing the easy parts and realize the problems and their fixes as you go. There's no right way to program and in our own Reach development, we use a combination of the two tactics. Try both and keep them both in mind during your own development."
  },
  {
    "objectID": "/workshop/hash-lock/#p_75",
    "pt": "Hash Lock",
    "t": 3,
    "c": "If you found this workshop rewarding, please let us know on the Discord community!"
  },
  {
    "objectID": "/workshop/hash-lock/#p_76",
    "pt": "Hash Lock",
    "t": 3,
    "c": "If you want to know what to do next, a natural extension of the concepts in this workshop is a relay account. Why don't you check it out?"
  },
  {
    "objectID": "/workshop/relay/#term_relay%20account",
    "pt": "Relay Account",
    "t": 1,
    "c": "relay account"
  },
  {
    "objectID": "/workshop/relay/#workshop-relay",
    "pt": "Relay Account",
    "t": 2,
    "c": "Relay Account"
  },
  {
    "objectID": "/workshop/relay/#workshop-relay-pr",
    "pt": "Relay Account",
    "t": 2,
    "c": "Problem Analysis"
  },
  {
    "objectID": "/workshop/relay/#workshop-relay-dd",
    "pt": "Relay Account",
    "t": 2,
    "c": "Data Definition"
  },
  {
    "objectID": "/workshop/relay/#workshop-relay-cc",
    "pt": "Relay Account",
    "t": 2,
    "c": "Communication Construction"
  },
  {
    "objectID": "/workshop/relay/#workshop-relay-ai",
    "pt": "Relay Account",
    "t": 2,
    "c": "Assertion Insertion"
  },
  {
    "objectID": "/workshop/relay/#workshop-relay-ii",
    "pt": "Relay Account",
    "t": 2,
    "c": "Interaction Introduction"
  },
  {
    "objectID": "/workshop/relay/#workshop-relay-de",
    "pt": "Relay Account",
    "t": 2,
    "c": "Deployment Decisions"
  },
  {
    "objectID": "/workshop/relay/#workshop-relay-dns",
    "pt": "Relay Account",
    "t": 2,
    "c": "Discussion and Next Steps"
  },
  {
    "objectID": "/workshop/relay/#p_0",
    "pt": "Relay Account",
    "t": 3,
    "c": "In this workshop, we'll revisit the problem of allowing a payer to transfer funds to another party before knowing their identity. However, unlike in Hash Lock, we will use a technique that is safe against malicious miners. One deployment of a decentralized application like this is as a \"gift card\" where a funder provides a fixed amount of currency to another without knowing their identity."
  },
  {
    "objectID": "/workshop/relay/#p_1",
    "pt": "Relay Account",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Hash Lock."
  },
  {
    "objectID": "/workshop/relay/#p_2",
    "pt": "Relay Account",
    "t": 3,
    "c": "We assume that you'll go through this workshop in a directory named ~/reach/workshop-relay:"
  },
  {
    "objectID": "/workshop/relay/#p_3",
    "pt": "Relay Account",
    "t": 3,
    "c": "And that you have a copy of Reach installed in ~/reach so you can write"
  },
  {
    "objectID": "/workshop/relay/#p_4",
    "pt": "Relay Account",
    "t": 3,
    "c": "And it will run Reach. You should start off by initializing your Reach program:"
  },
  {
    "objectID": "/workshop/relay/#p_5",
    "pt": "Relay Account",
    "t": 3,
    "c": "For this workshop, we'll provide some constraints on your solution and problem analysis, since we'd like you to explore writing a Reach program with a specific design."
  },
  {
    "objectID": "/workshop/relay/#p_6",
    "pt": "Relay Account",
    "t": 3,
    "c": "The overall purpose of this application is so that:"
  },
  {
    "objectID": "/workshop/relay/#p_7",
    "pt": "Relay Account",
    "t": 3,
    "c": "Alice can decide an amount of funds to provide."
  },
  {
    "objectID": "/workshop/relay/#p_8",
    "pt": "Relay Account",
    "t": 3,
    "c": "Alice later decides who will have access to this by sharing a secret with them. We call this person, Bob."
  },
  {
    "objectID": "/workshop/relay/#p_9",
    "pt": "Relay Account",
    "t": 3,
    "c": "Bob can transfer the funds to wherever he'd like."
  },
  {
    "objectID": "/workshop/relay/#p_10",
    "pt": "Relay Account",
    "t": 3,
    "c": "In Hash Lock, we designed the application so that the \"secret\" was a special number that the contract compared against a known digest to release the funds. This approach was flawed, because when Bob used the secret to gain access, it was possible for anyone else to see the transaction and attempt to play it themselves."
  },
  {
    "objectID": "/workshop/relay/#p_11",
    "pt": "Relay Account",
    "t": 3,
    "c": "In today's workshop, we'll use a crucial insight about decentralized applications: account ownership is fluid and account credentials are a form of secret knowledge that every consensus network builds in to their foundation. With that in mind, let's use the following design:"
  },
  {
    "objectID": "/workshop/relay/#p_12",
    "pt": "Relay Account",
    "t": 3,
    "c": "This is called a relay account, because it exists temporarily to faciliate the relaying of funds from Alice to Bob."
  },
  {
    "objectID": "/workshop/relay/#p_13",
    "pt": "Relay Account",
    "t": 3,
    "c": "With this in mind, let's answer the questions:"
  },
  {
    "objectID": "/workshop/relay/#p_14",
    "pt": "Relay Account",
    "t": 3,
    "c": "Who are the principals of the application?"
  },
  {
    "objectID": "/workshop/relay/#p_15",
    "pt": "Relay Account",
    "t": 3,
    "c": "What are the participants of the program?"
  },
  {
    "objectID": "/workshop/relay/#p_16",
    "pt": "Relay Account",
    "t": 3,
    "c": "What information do they know at the start of the program?"
  },
  {
    "objectID": "/workshop/relay/#p_17",
    "pt": "Relay Account",
    "t": 3,
    "c": "What information are they going to discover and use in the program?"
  },
  {
    "objectID": "/workshop/relay/#p_18",
    "pt": "Relay Account",
    "t": 3,
    "c": "What funds change ownership during the application and how?"
  },
  {
    "objectID": "/workshop/relay/#p_19",
    "pt": "Relay Account",
    "t": 3,
    "c": "Let's see how your answers compare to our answers:"
  },
  {
    "objectID": "/workshop/relay/#p_20",
    "pt": "Relay Account",
    "t": 3,
    "c": "This application involves two principals: Alice, who sends funds, and Bob, who receives funds."
  },
  {
    "objectID": "/workshop/relay/#p_21",
    "pt": "Relay Account",
    "t": 3,
    "c": "The program has two participants: Alice, who initiates the application, and the Relay, which transfers the funds to Bob."
  },
  {
    "objectID": "/workshop/relay/#p_22",
    "pt": "Relay Account",
    "t": 3,
    "c": "Alice starts knowing the amount she wants to transfer."
  },
  {
    "objectID": "/workshop/relay/#p_23",
    "pt": "Relay Account",
    "t": 3,
    "c": "Alice creates the Relay account, while the Relay account learns the address of Bob, who will receive the funds."
  },
  {
    "objectID": "/workshop/relay/#p_24",
    "pt": "Relay Account",
    "t": 3,
    "c": "The funds start with Alice and then move to Bob under the instruction of the Relay."
  },
  {
    "objectID": "/workshop/relay/#p_25",
    "pt": "Relay Account",
    "t": 3,
    "c": "The most surprising thing about this application is that Bob is not one of the participants in the application! Of course, the Relay will actually run under the auspices of Bob, after Alice shares the account credentials with him, but there is a distinction in the program between Bob's identity and the Relay's."
  },
  {
    "objectID": "/workshop/relay/#p_26",
    "pt": "Relay Account",
    "t": 3,
    "c": "The next step of designing our program is representing this information in our program and deciding the participant interact interface for each participant. Which pieces of information go with which participants? Which are functions and which are values? Finally, how should the Relay account information and Bob's identity be represented? (Hint: Reach has a type named {!rsh} Address that represents an account address!)"
  },
  {
    "objectID": "/workshop/relay/#p_27",
    "pt": "Relay Account",
    "t": 3,
    "c": "Refer to Types for a reminder of what data types are available in Reach."
  },
  {
    "objectID": "/workshop/relay/#p_28",
    "pt": "Relay Account",
    "t": 3,
    "c": "Let's compare notes again. Here's what we wrote in our program:"
  },
  {
    "objectID": "/workshop/relay/#p_29",
    "pt": "Relay Account",
    "t": 3,
    "c": "We chose to represent the amount as a {!rsh} UInt field, which should be unsurprising. We then have two functions that take no arguments and return an {!rsh} Address which respectively return the Relay identity and the Bob identity. The idea here is that Alice will create the Relay account in the midst of the program and Bob will provide his own identity when he's acting as Relay."
  },
  {
    "objectID": "/workshop/relay/#p_30",
    "pt": "Relay Account",
    "t": 3,
    "c": "Now, we can write down the structure of communication and action in our application. Try this on your own based on your experience with Hash Lock."
  },
  {
    "objectID": "/workshop/relay/#p_31",
    "pt": "Relay Account",
    "t": 3,
    "c": "Here's what we wrote:"
  },
  {
    "objectID": "/workshop/relay/#p_32",
    "pt": "Relay Account",
    "t": 3,
    "c": "We assume that most of you found it natural to think of steps one, three, and four, but found step two to be a strange addition. Perhaps you felt that step two is implied by step one, where Alice says who the Relay is. But, it all depends upon what the meaning of the word \"is\" is. Since that is unclear to some, we'll make it explicit by stating that the consensus will remember the Relay's identity."
  },
  {
    "objectID": "/workshop/relay/#p_33",
    "pt": "Relay Account",
    "t": 3,
    "c": "The next step is to convert this pattern into actual program code using {!rsh} publish, {!rsh} pay, and {!rsh} commit. However, we expect that you'll need a bit of help with step two. Reach has a special operation, available only in consensus steps, for asserting the identity of a participant: {!rsh} Participant.set. You can write {!rsh} Relay.set(someAddr) to assert that the address of the Relay is {!rsh} someAddr. With that in mind..."
  },
  {
    "objectID": "/workshop/relay/#p_34",
    "pt": "Relay Account",
    "t": 3,
    "c": "The body of your application should look something like:"
  },
  {
    "objectID": "/workshop/relay/#p_35",
    "pt": "Relay Account",
    "t": 3,
    "c": "We expect that for most of you, the coding of step four is also a bit strange, because we've never seen an example where the destination of a transfer is not a participant. You may have thought that the {!rsh} to position in a {!rsh} transfer must be a participant, but actually it can be any address. Participants, however, can be used as addresses if they are bound."
  },
  {
    "objectID": "/workshop/relay/#p_36",
    "pt": "Relay Account",
    "t": 3,
    "c": "You might like to re-write this program to have a third participant, Bob, who takes no actions, and try to write {!rsh} transfer(amt).to(Bob). You'll find that Reach rejects this program because Bob is not bound. You can correct this by adding {!rsh} Bob.set(bob) after the Relay publishes Bob's address. There's nothing better about this version of the program, but it is unneccessary to have a participant like Bob that performs no part in the computation."
  },
  {
    "objectID": "/workshop/relay/#p_37",
    "pt": "Relay Account",
    "t": 3,
    "c": "As usual, we should consider what assertions we can add to our program. In some ways this is what we just did with the {!rsh} Relay.set(relay) line above, but that is unlike a normal assertion in that it is added primarily to direct the runtime activities on the consensus contract, rather than as a statement about the logical properties of our program variables."
  },
  {
    "objectID": "/workshop/relay/#p_38",
    "pt": "Relay Account",
    "t": 3,
    "c": "Sometimes it can be difficult to decide which things are part of the application, like this, and which things are properties of the application, like the assertions we've seen before. This is a general problem in verification where the logical properties of the desired program are often mixed up with the logical properties of the actual program. If you're interested in this topic, you might like to spend time reading about formal specification on Wikipedia."
  },
  {
    "objectID": "/workshop/relay/#p_39",
    "pt": "Relay Account",
    "t": 3,
    "c": "Now, if we were devious, we might send you on a SNARK hunt after some more assertions to add to our program, but we're not mean, so we'll just tell you that there's nothing else to assert about this program."
  },
  {
    "objectID": "/workshop/relay/#p_40",
    "pt": "Relay Account",
    "t": 3,
    "c": "Next, we need to insert the appropriate calls to {!rsh} interact. In this case, our program is very simple and we expect you'll do a great job without further discussion."
  },
  {
    "objectID": "/workshop/relay/#p_41",
    "pt": "Relay Account",
    "t": 3,
    "c": "Let's look at our whole program now:"
  },
  {
    "objectID": "/workshop/relay/#p_42",
    "pt": "Relay Account",
    "t": 3,
    "c": "This program is a bit odd to test, because it relies on Alice creating a temporary account and then sharing its information with Bob. We don't know of any beautiful way to derive this program from first principles, and instead must appeal to your JavaScript programming skills. If you'd like a hint, remember that you can call {!js} stdlib.newTestAccount any number of times and that a backend's participant functions don't need to be called at the same time."
  },
  {
    "objectID": "/workshop/relay/#p_43",
    "pt": "Relay Account",
    "t": 3,
    "c": "If you're brave, then try it yourself; otherwise, scroll down to see our solution."
  },
  {
    "objectID": "/workshop/relay/#p_44",
    "pt": "Relay Account",
    "t": 3,
    "c": "Here's the JavaScript frontend we wrote:"
  },
  {
    "objectID": "/workshop/relay/#p_45",
    "pt": "Relay Account",
    "t": 3,
    "c": "We do a few sneaky things in this program:"
  },
  {
    "objectID": "/workshop/relay/#p_46",
    "pt": "Relay Account",
    "t": 3,
    "c": "Lines 17 through 20 create a JavaScript Promise that will be filled in later by Alice."
  },
  {
    "objectID": "/workshop/relay/#p_47",
    "pt": "Relay Account",
    "t": 3,
    "c": "Alice's {!rsh} getRelay function (lines 25 through 31) creates the new account and communicates it \"outside of the network\" through the aforementioned Promise."
  },
  {
    "objectID": "/workshop/relay/#p_48",
    "pt": "Relay Account",
    "t": 3,
    "c": "Bob's thread (lines 33 through 47) waits for the Promise to resolve and then connects to the application with this new account."
  },
  {
    "objectID": "/workshop/relay/#p_49",
    "pt": "Relay Account",
    "t": 3,
    "c": "The Relay's {!rsh} getBob function (lines 42 through 45) returns his own address to receive the funds."
  },
  {
    "objectID": "/workshop/relay/#p_50",
    "pt": "Relay Account",
    "t": 3,
    "c": "If this program is scary for you, don't worry! It uses some fairly esoteric JavaScript features to make a completely automated test of this program. If instead you wrote it so that it ran interactively and had Bob paste in the information about the new Relay account, it might be easier for you to code with those two aspects totally separated."
  },
  {
    "objectID": "/workshop/relay/#p_51",
    "pt": "Relay Account",
    "t": 3,
    "c": "Let's see what it looks like when we run this program:"
  },
  {
    "objectID": "/workshop/relay/#p_52",
    "pt": "Relay Account",
    "t": 3,
    "c": "Great job! You could use this application today and start minting gift cards of tokens for your friends on their birthdays! Wouldn't that be fun?"
  },
  {
    "objectID": "/workshop/relay/#p_53",
    "pt": "Relay Account",
    "t": 3,
    "c": "If you found this workshop rewarding, please let us know on the Discord community!"
  },
  {
    "objectID": "/workshop/relay/#p_54",
    "pt": "Relay Account",
    "t": 3,
    "c": "If you'd like to make this application a little more interesting, maybe you'd like to have a secret password just like the hash lock as well, so Alice can separate the revealing of information to Bob."
  },
  {
    "objectID": "/workshop/relay/#p_55",
    "pt": "Relay Account",
    "t": 3,
    "c": "If you want to know what to do next to advance your study of decentralized application design, a natural extension of the concepts in this workshop is a trust fund. Why don't you check it out?"
  },
  {
    "objectID": "/workshop/trust-fund/#workshop-trust-fund",
    "pt": "Trust Fund",
    "t": 2,
    "c": "Trust Fund"
  },
  {
    "objectID": "/workshop/trust-fund/#workshop-trust-fund-pr",
    "pt": "Trust Fund",
    "t": 2,
    "c": "Problem Analysis"
  },
  {
    "objectID": "/workshop/trust-fund/#workshop-trust-fund-dd",
    "pt": "Trust Fund",
    "t": 2,
    "c": "Data Definition"
  },
  {
    "objectID": "/workshop/trust-fund/#workshop-trust-fund-cc",
    "pt": "Trust Fund",
    "t": 2,
    "c": "Communication Construction"
  },
  {
    "objectID": "/workshop/trust-fund/#workshop-trust-fund-ai",
    "pt": "Trust Fund",
    "t": 2,
    "c": "Assertion Insertion"
  },
  {
    "objectID": "/workshop/trust-fund/#workshop-trust-fund-ii",
    "pt": "Trust Fund",
    "t": 2,
    "c": "Interaction Introduction"
  },
  {
    "objectID": "/workshop/trust-fund/#workshop-trust-fund-de",
    "pt": "Trust Fund",
    "t": 2,
    "c": "Deployment Decisions"
  },
  {
    "objectID": "/workshop/trust-fund/#workshop-trust-fund-dns",
    "pt": "Trust Fund",
    "t": 2,
    "c": "Discussion and Next Steps"
  },
  {
    "objectID": "/workshop/trust-fund/#p_0",
    "pt": "Trust Fund",
    "t": 3,
    "c": "In this workshop, we'll look at yet another strategy for transferring funds, but in this version, we'll think about it as establishing a \"trust fund\": a funder will establish an account for the receiver, which they must wait a certain amount of time to access, and if they do not, then it reverts to the funder, and if the funder does not claim it, then it is dormant and any third party can remove the funds. You could think of this as a variant of the relay account, with a mandatory waiting period and two fallbacks on non-participation."
  },
  {
    "objectID": "/workshop/trust-fund/#p_1",
    "pt": "Trust Fund",
    "t": 3,
    "c": "This workshop assumes that you have recently completed Relay Account."
  },
  {
    "objectID": "/workshop/trust-fund/#p_2",
    "pt": "Trust Fund",
    "t": 3,
    "c": "We assume that you'll go through this workshop in a directory named ~/reach/workshop-trust-fund:"
  },
  {
    "objectID": "/workshop/trust-fund/#p_3",
    "pt": "Trust Fund",
    "t": 3,
    "c": "And that you have a copy of Reach installed in ~/reach so you can write"
  },
  {
    "objectID": "/workshop/trust-fund/#p_4",
    "pt": "Trust Fund",
    "t": 3,
    "c": "And it will run Reach. You should start off by initializing your Reach program:"
  },
  {
    "objectID": "/workshop/trust-fund/#p_5",
    "pt": "Trust Fund",
    "t": 3,
    "c": "For this workshop, we'll provide some constraints on your solution and problem analysis, since we'd like you to explore writing a Reach program with a specific design."
  },
  {
    "objectID": "/workshop/trust-fund/#p_6",
    "pt": "Trust Fund",
    "t": 3,
    "c": "The overall purpose of this application is so that:"
  },
  {
    "objectID": "/workshop/trust-fund/#p_7",
    "pt": "Trust Fund",
    "t": 3,
    "c": "The Funder must decide an amount of funds to provide, as well as all of the other parameters of the application."
  },
  {
    "objectID": "/workshop/trust-fund/#p_8",
    "pt": "Trust Fund",
    "t": 3,
    "c": "The Funder will know the identity of the Receiver at the beginning."
  },
  {
    "objectID": "/workshop/trust-fund/#p_9",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Whomever ultimately receives the funds transfers it to themselves."
  },
  {
    "objectID": "/workshop/trust-fund/#p_10",
    "pt": "Trust Fund",
    "t": 3,
    "c": "With this in mind, let's answer the questions:"
  },
  {
    "objectID": "/workshop/trust-fund/#p_11",
    "pt": "Trust Fund",
    "t": 3,
    "c": "What are the participants of the application?"
  },
  {
    "objectID": "/workshop/trust-fund/#p_12",
    "pt": "Trust Fund",
    "t": 3,
    "c": "What information do they know at the start of the program?"
  },
  {
    "objectID": "/workshop/trust-fund/#p_13",
    "pt": "Trust Fund",
    "t": 3,
    "c": "What information are they going to discover and use in the program?"
  },
  {
    "objectID": "/workshop/trust-fund/#p_14",
    "pt": "Trust Fund",
    "t": 3,
    "c": "What funds change ownership during the application and how?"
  },
  {
    "objectID": "/workshop/trust-fund/#p_15",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Let's see how your answers compare to our answers:"
  },
  {
    "objectID": "/workshop/trust-fund/#p_16",
    "pt": "Trust Fund",
    "t": 3,
    "c": "This application involves three participants: the Funder, the Receiver, and a Bystander."
  },
  {
    "objectID": "/workshop/trust-fund/#p_17",
    "pt": "Trust Fund",
    "t": 3,
    "c": "The Funder knows the identity of the Receiver, the amount, as well as the maturity of the fund, and the delays before which it will be declared dormant or forsook."
  },
  {
    "objectID": "/workshop/trust-fund/#p_18",
    "pt": "Trust Fund",
    "t": 3,
    "c": "The Receiver and the Bystander don't learn or provide anything, aside from the existence of the fund and its maturity."
  },
  {
    "objectID": "/workshop/trust-fund/#p_19",
    "pt": "Trust Fund",
    "t": 3,
    "c": "The funds start with the Funder and then move to either the Receiver, the Funder, or the Bystander, depending on when they are claimed."
  },
  {
    "objectID": "/workshop/trust-fund/#p_20",
    "pt": "Trust Fund",
    "t": 3,
    "c": "The next step of designing our program is representing this information in our program and deciding the participant interact interface for each participant. In this application, we'll be using a new concept of Reach: the time delta. The trust fund has a \"maturity\", as well as the lengths of time before which the fund is forsook or abandoned. In the fiat world, these would likely be expressed as real time durations, like months and years. However, on most consensus networks there is an abstraction of time into something like a \"block height\", which represents the number of rounds of consensus which have reached their conclusion. There is a loose relationship of these notions to real-time, but most networks do not guarantee any particular connection. (Indeed, such a connection between the abstract world of consensus networks and the \"real\" world is typically provided by an oracle.) Reach abstracts the details of particular consensus networks away into the concept of a time delta, which is represented by an integer in Reach programs, and used in positions that reference time."
  },
  {
    "objectID": "/workshop/trust-fund/#p_21",
    "pt": "Trust Fund",
    "t": 3,
    "c": "With that knowledge in hand,"
  },
  {
    "objectID": "/workshop/trust-fund/#p_22",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Let's compare notes again. Here's what we wrote in our program:"
  },
  {
    "objectID": "/workshop/trust-fund/#p_23",
    "pt": "Trust Fund",
    "t": 3,
    "c": "We've represented most values as {!rsh} UInt fields, and created a \"common\" interface that has a series of signals for the different phases of the application: one for when the account is {!rsh} funded, one for when the particular participant is {!rsh} ready to extract the funds, and finally one for when they have successfuly {!rsh} recvd (received) them."
  },
  {
    "objectID": "/workshop/trust-fund/#p_24",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Now, we can write down the structure of communication and action in our application. Try this on your own based on your experience with Relay Account."
  },
  {
    "objectID": "/workshop/trust-fund/#p_25",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Here's what we wrote:"
  },
  {
    "objectID": "/workshop/trust-fund/#p_26",
    "pt": "Trust Fund",
    "t": 3,
    "c": "The next step is to convert this pattern into actual program code using {!rsh} publish, {!rsh} pay, and {!rsh} commit. However, this program gives us the opportunity to look at a few more features of Reach."
  },
  {
    "objectID": "/workshop/trust-fund/#p_27",
    "pt": "Trust Fund",
    "t": 3,
    "c": "First, how do we implement step three, where each party waits for the fund to mature? Reach has a primitive named {!rsh} wait which causes this to happen. This may only occur in a step, which is the same context where {!rsh} publish may occur. This primitive, however, doesn't just cause the participants to wait, instead it guarantees that the entire computation waits. In other words, this means that the contract will ensure that the later steps do not occur until after the waiting time."
  },
  {
    "objectID": "/workshop/trust-fund/#p_28",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Second, how do we implement steps four and five, where there is a deadline for an action to take place? Reach publication steps take an option called {!rsh} .timeout that specifies an alternative computation to occur if the first does not take place before the deadline. The syntax looks like: {!rsh} publish().timeout(deadline, () => alternative), which uses the arrow expression syntax for specifying the alternative computation."
  },
  {
    "objectID": "/workshop/trust-fund/#p_29",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Finally, we hope you notice that steps four, five, and six are extremely similar. Consider trying to write a function that is used three times to implement all of them!"
  },
  {
    "objectID": "/workshop/trust-fund/#p_30",
    "pt": "Trust Fund",
    "t": 3,
    "c": "The body of your application should look something like:"
  },
  {
    "objectID": "/workshop/trust-fund/#p_31",
    "pt": "Trust Fund",
    "t": 3,
    "c": "If you'd like to see how you might contain the repetition into a function, keep reading!"
  },
  {
    "objectID": "/workshop/trust-fund/#p_32",
    "pt": "Trust Fund",
    "t": 3,
    "c": "As usual, we should consider what assertions we can add to our program, but this program doesn't have any interesting properties to prove, so we'll move on. Or rather, all of its interesting properties are the ones automatically included in all Reach programs, like that the funds are used linearly and nothing is left over in the account at the end, or that the protocol steps must be received before the corresponding deadlines."
  },
  {
    "objectID": "/workshop/trust-fund/#p_33",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Next, we need to insert the appropriate calls to {!rsh} interact. In this case, our program is very simple and we expect you'll do a great job without further discussion. However, if you want to simplify things, you might like to use {!rsh} each to signal to all the parties that the account is funded, rather than duplicating the interaction code over and over."
  },
  {
    "objectID": "/workshop/trust-fund/#p_34",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Let's look at our whole program now:"
  },
  {
    "objectID": "/workshop/trust-fund/#p_35",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Lines 33 and 34 use {!rsh} each to run the same code block {!rsh} only in each of the given participants."
  },
  {
    "objectID": "/workshop/trust-fund/#p_36",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Lines 51 through 59 abstract the duplicate copied repeated structure of the program into three calls to the same function."
  },
  {
    "objectID": "/workshop/trust-fund/#p_37",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Lines 37 through 49 define this function as one that abstracts over who is permitted to extract the funds and whether there is a deadline."
  },
  {
    "objectID": "/workshop/trust-fund/#p_38",
    "pt": "Trust Fund",
    "t": 3,
    "c": "This program demonstrates some of the remarkable features of Reach: we were able to abstract away a pattern of communication into a function and use it repeatedly and in different ways. Behind the scenes, when Reach compiles this program into a contract, it will derive a four step protocol with implicit state to check that the appropriate participant takes their action only when allowed."
  },
  {
    "objectID": "/workshop/trust-fund/#p_39",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Next, it is time to test our program. As usual, we'll present a completely automated test deployment, rather than an interactive one. This means that we'll have to have our participants purposefully \"miss\" their deadlines so we can see that the timeouts and deadlines work correctly. We'll implement it by abstracting away the test into a function of two parameters: booleans that decide whether the Receiver and Funder (respectively) should miss their deadline. We'll implement this miss by using the standard library function {!js} stdlib.wait which takes a time delta encoded as a number. This function is like {!rsh} wait, except it is local only to a single participant and has no bearing on the rules of the application. It's just a convenience mechanism for allowing time to pass on the consensus network."
  },
  {
    "objectID": "/workshop/trust-fund/#p_40",
    "pt": "Trust Fund",
    "t": 3,
    "c": "We highly recommend that you try to implement a test setup like this yourself; when you're done, scroll down to see our solution."
  },
  {
    "objectID": "/workshop/trust-fund/#p_41",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Here's the JavaScript frontend we wrote:"
  },
  {
    "objectID": "/workshop/trust-fund/#p_42",
    "pt": "Trust Fund",
    "t": 3,
    "c": "The most interesting part of this program is on lines 20 through 23 when we optionally cause a delay in the participant after they receive the signal that the account is funded."
  },
  {
    "objectID": "/workshop/trust-fund/#p_43",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Let's see what it looks like when we run this program:"
  },
  {
    "objectID": "/workshop/trust-fund/#p_44",
    "pt": "Trust Fund",
    "t": 3,
    "c": "Great job! You could use this application today and start putting your child's college funds away for safe keeping! Although, perhaps you should wait until you read the workshop about interest-bearing accounts like this."
  },
  {
    "objectID": "/workshop/trust-fund/#p_45",
    "pt": "Trust Fund",
    "t": 3,
    "c": "If you found this workshop rewarding, please let us know on the Discord community!"
  },
  {
    "objectID": "/workshop/trust-fund/#p_46",
    "pt": "Trust Fund",
    "t": 3,
    "c": "If you'd like to make this application a little more interesting, maybe you'd like to have a secret password just like the hash lock as well, so the Funder can separate the revealing of information to Receiver. Similarly, you could make it like a relay account and have the Receiver generated by the Funder and allow the Receiver to specify a third-party (fourth-party) to receive the actual funds."
  },
  {
    "objectID": "/workshop/trust-fund/#p_47",
    "pt": "Trust Fund",
    "t": 3,
    "c": "We recommend that you take a pause from workshops like this and revisit the Rock, Paper, Scissors! application in the fairness workshop. Why don't you check it out?"
  },
  {
    "objectID": "/tut/rps/7-rpc/#tut-7-rpc",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 2,
    "c": "Rock, Paper, Scissors in Python"
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_0",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "The main sequence of the tutorial uses the JavaScript frontend support library to implement a frontend for our Reach program using JavaScript. But, Reach supports using any programming language through the Reach RPC Server."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_1",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "This tutorial walks through using this technique to implement a Rock, Paper, Scissors! frontend in Python. It is based on the frontend from Play and Play Again, so it does not include a text-based interface, or a Web interface, but uses the final version of the Reach code."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_2",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Below we will compare the Play and Play Again JavaScript frontend with the equivalent Python code communicating via RPC, section by section. Follow along by typing the Python code into a file called index.py."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_3",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "We begin by comparing the necessary imports and program body:"
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_4",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Rather than importing {!js} loadStdlib and {!js} backend as with the JavaScript version, the Python frontend instead plucks {!py} mk_rpc from its supporting {!py} reach_rpc library. It is unnecessary for an RPC frontend to import a backend because the RPC Server handles doing so instead."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_5",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "The Python version also borrows functionality from the {!py} random and {!py} threading libraries. These will be necessary when providing callable methods in the participant interact interface it offers the RPC server."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_6",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "On line 9 the Python program binds {!py} rpc and {!py} rpc_callbacks out of {!py} mk_rpc. These two functions are the only tools we will need to communicate with the RPC server. See Python for more details on how they work."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_7",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Next, we define our Alice and Bob accounts and pre-fund them each with a starting balance of 10."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_8",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Translating code which uses the JavaScript frontend support library to its Python RPC equivalent is a simple matter of specifying the corresponding RPC method (e.g. '/stdlib/newTestAccount'), and supplying the same arguments thereafter."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_9",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Now we define two helper functions and use them to query Alice and Bob's beginning balances:"
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_10",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Deploying and attaching to contracts works slightly differently over RPC:"
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_11",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "As previously mentioned, it is the responsibility of the RPC Server (rather than that of the frontend communicating over RPC) to interface with the DApp's backend, so that argument is absent in the Python version shown above. Instead, Alice's account RPC handle alone is sufficient for her to deploy. We also need to delay Bob's attach until later, because Python lacks Promises that work like JavaScript's. When we do attach Bob, only Bob's account RPC handle and Alice's contract RPC handle are necessary for him to attach."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_12",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "{!py} HAND and {!py} OUTCOME only differ syntactically from their JavaScript equivalents:"
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_13",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Even participant interact interface definitions remain largely the same:"
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_14",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Here, both the JavaScript and Python frontends begin declaring a reusable \"player constructor\". This constructor represents those fields which are common to both Alice and Bob's participant interact interfaces."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_15",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "The JavaScript code explicitly includes {!js} ...stdlib.hasRandom itself, but the Python code can instead direct the RPC server to append it to the interface by including {!py} 'stdlib.hasRandom': True as a field in the constructor's return value."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_16",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Next, they each define a {!py} getHand function which randomly selects an element from the previously defined {!py} HAND set and returns it to the backend. This function will be passed as a callable method of the interface later."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_17",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "The Python version does not mimic the JavaScript's occasional \"pause behavior\", although it easily could with a few extra lines of code."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_18",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "{!py} informTimeout requires no subsequent backend interaction and is accordingly easily to implement in either language:"
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_19",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "The same is true of {!py} seeOutcome:"
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_20",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "At the end of the Python code we return a {!py} dict that represents those fields which are common to both Alice and Bob's participant interact interfaces."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_21",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Again, {!py} 'stdlib.hasRandom': True has special significance when communicating via RPC: it instructs the server to append this signature on the receiving end."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_22",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Finally, we proceed to the most interesting part of the program and use the code we have built up thus far to actually play a game of Rock, Paper, Scissors!:"
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_23",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "In the Python version we create a function called {!py} play_alice and spawn it as a concurrent thread, which begins running in the background on line 56."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_24",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "{!py} play_alice sends Alice's contract RPC handle and her participant interact interface to the server with {!py} rpc_callbacks. The interface includes methods and values created by {!py} player('Alice'), and adds an additional {!py} wager value which is set to the result of {!py} rpc('/stdlib/parseCurrency', 5), as well as setting a {!py} deadline of {!py} 10."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_25",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Bob's interface is likewise defined and spawned as another thread, which also begins running concurrently on line 69. In Bob's case we add an {!py} acceptWager method instead of another value to his participant interact interface. Furthermore, his function is more complex, because we delay creating his contract handle until this time, so that the main thread does not block waiting for Alice's contract information to resolve. This separation is not necessary in JavaScript, because of how JavaScript Promises work."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_26",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Calling {!py} .join() on {!py} alice and {!py} bob instructs the main thread to wait until both child threads have run to completion, signifying the end of the Rock, Paper, Scissors! game. At this point we again collect each player's remaining balance and print them to the console. Each player's child thread will have already printed their success/failure result to the screen prior to reaching this step, because that is how we encoded their {!py} seeOutcome methods."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_27",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "All that remains is to release Alice and Bob's RPC handles from the server's memory on lines 80 and 81 with the /forget/acc and /forget/ctc methods, then instruct the Python process' interpreter to invoke our {!py} main function."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_28",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Now that we have written an entire Rock, Paper, Scissors! game in Python it is time to try running it."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_29",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "First you will need to copy the index.rsh file you used for the tutorial into the directory where you saved index.py."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_30",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Next, open a terminal in that directory and install the Reach Python RPC client:"
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_31",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "What is this \"venv\" thing?"
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_32",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "A Python venv is a \"virtual environment\" that sandboxes dependencies to avoid cluttering your system directories."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_33",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Then use ./reach rpc-run to play a game of Rock, Paper, Scissors!:"
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_34",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Consult the command-line reference section for more details on how this sub-command works."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_35",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Its output will be the same as the final tutorial version of the frontend:"
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_36",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "This will launch an RPC server using the development API key \"opensesame\" and a TLS certificate designed for testing."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_37",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Deploying your DApp into production with the RPC server requires obtaining a certificate which is specific to your DNS domain and which has been signed by a certificate authority such as Let's Encrypt."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_38",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Users who are ready to go live should consult the RPC Server command-line reference section for configuration details."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_39",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "When you are done, type deactivate to exit your venv."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_40",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "Well done! You have just reimplemented the tutorial in Python."
  },
  {
    "objectID": "/tut/rps/7-rpc/#p_41",
    "pt": "Rock, Paper, Scissors in Python",
    "t": 3,
    "c": "This tutorial uses Python to demonstrate how RPC frontends are built in Reach, but it is similarly easy to write RPC frontends in other languages, such as with the JavaScript and Go libraries."
  }
]