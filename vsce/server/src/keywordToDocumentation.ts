/*
A program called
updateKeywordDocumentation.ts
wrote this file.

Do not modify this file directly.
*/

const KEYWORD_TO_DOCUMENTATION: {
  [key: string] : string
} = {
  "API": "\n```javascript\nAPI('Voter', { vote: Fun([Address], UInt) })\n// or\nAPI({ vote: Fun([Address], UInt) })\n// or\nAPI('Voter', { vote: Fun([Address], UInt)}, { vote: \"castVote\" })\n// or\nAPI({ add2: Fun([UInt, UInt], UInt), add1: Fun([UInt], UInt) }, { add1: \"add\", add2: \"add\" })\n```\n\nAPIs are functions that can be called by other contracts, as well as off-chain.\n\nAn API is defined with `API(apiName, apiInterface, ?apiAlias)` or `API(apiInterface, ?apiAlias)`, where `apiName` is a string that labels the API, `apiInterface` is an object where each field indicates the type of a function provided by the contract as an API, and `apiAlias` is an optional object that maps function names from the `apiInterface` to an alias.\nThis function alias allows overloaded methods to be created.\nMany functions may map to the same alias as long as each function domain is unique.\nThese APIs are available in frontends via the `ctc.apis` object, wherein fields are the members of `apiInterface` and may be used in `.api` components of `fork` and `parallelReduce` to specify the behavior of the corresponding call.\nThese are called API member functions.\nEach function must occur exactly once in the entire program.\n\n```\n  const I = API('Investor', {\n    invest: Fun([], Null),\n    collectFailPay: Fun([], Null),\n  });\n```\n\nThis example creates an API that has a name of `Investor`, and it has two functions.\nThe first function is to invest in the contract, and the second function is to collect the payment if the `Entrepreneur` fails to form a quorum.  \n",
  "Address": " `Address`, which denotes an account address.\n+  `Contract`, which denotes the identifying information of a contract.\n\n---\n**NOTE**\n\nReach has different representations of contracts across connectors.\nFor example, on Algorand a `Contract` is an Application ID, but on Ethereum it is an Address.\n\n---\n\n+  `Token`, which denotes a non-network token. [Networks](https://docs.reach.sh/networks/#ref-networks) discusses how `Token`s are represented on specific networks.\n\n---\n**NOTE**\n\nReach assumes that every `Token` in your program refers to a different non-network token.\nIt will automatically insert `require` statements that enforce this constraint.\n\n---\n\n+  `Fun([Domain_0, ..., Domain_N], Range)`, which denotes a function type, when `Domain_i` and `Range` are types.\nThe domain of a function is negative position.\nThe range of a function is positive position.\n+ `Fun(true, Range)`, which denotes an unconstrained domain function type, when `Range` is a type.\nThese functions may only appear in participant interact interfaces.\n+  `Tuple(Field_0, ..., FieldN)`, which denotes a tuple.\n(Refer to [Tuples](https://docs.reach.sh/rsh/compute/#ref-programs-tuples) for constructing tuples.)\n+  `Object({key_0: Type_0, ..., key_N: Type_N})`, which denotes an object.\n(Refer to [Objects](https://docs.reach.sh/rsh/compute/#ref-programs-objects) for constructing objects.)\n+  `Struct([[key_0, Type_0], ..., [key_N, Type_N]])`, which denotes a struct.\n(Refer to [Structs](https://docs.reach.sh/rsh/compute/#ref-programs-structs) for constructing structs.)\n+  `Array(Type_0, size)`, which denotes a statically-sized array.\n`Type_0` must be a type that can exist at runtime (i.e., not a function type.)\n(Refer to [Arrays](https://docs.reach.sh/rsh/compute/#ref-programs-arrays) for constructing arrays.)\n+  `Data({variant_0: Type_0, ..., variant_N: Type_N})`, which denotes a [tagged union](https://en.wikipedia.org/wiki/Tagged_union) (or _sum type_).\n(Refer to [Data](https://docs.reach.sh/rsh/compute/#ref-programs-data) for constructing data instances.)\n+  `Refine(Type_0, Predicate, ?Message)`, where `Predicate` is a unary function returning a boolean, which denotes a [refinement type](https://en.wikipedia.org/wiki/Refinement_type), that is instances of `Type_0` that satisfy `Predicate`.\nWhen a refinement type appears in a negative position (such as in an `is` or in the domain of a `Fun` of a participant interact interface), it introduces an `assert`;\nwhile when it is in a positive position, it introduces an `assume`.\n`Message` is an optional string to display if the predicate fails verification.\n\nFor example, if `f` had type\n```javascript\nFun([Refine(UInt, (x => x < 5))], Refine(UInt, (x => x > 10)))\n```\n\nthen `const z = f(y)` is equivalent to\n\n```javascript\nassert(y < 5);\nconst z = f(y);\nassume(z > 10);\n```\n\n+ `Refine(Type_0, PreCondition, PostCondition, ?Messages)`, where `Type_0` is a function type, `PreCondition` is a unary function that accepts a tuple of the domain and returns a boolean, and `PostCondition` is a binary function that accepts a tuple of the domain and the range and returns a boolean, denotes a function type with a [precondition](https://en.wikipedia.org/wiki/Precondition) and [postcondition](https://en.wikipedia.org/wiki/Postcondition).\nPreconditions are enforced with `assert` and postconditions are enforced with `assume`.\n`Messages` is an optional two-tuple of `Bytes`.\nThe first message will be displayed when the precondition fails verification and the second when the postcondition fails verification.\n\nFor example, `Refine(Fun([UInt, UInt], UInt), ([x, y] => x < y), (([x, y], z) => x + y < z))` is a function that requires its second argument to be larger than its first and its result to be larger than its input.\n\n`Object` and `Data` are commonly used to implemented [algebraic data types](https://en.wikipedia.org/wiki/Algebraic_data_type) in Reach.\n\n\n```javascript\ntypeOf(x) // type\nisType(t) // Bool\nis(x, t) // t\n```\n\nThe `typeOf` primitive function is the same as `typeof`:\nit returns the type of its argument.\n\nThe `isType` function returns `true` if its argument is a type.\nAny expression satisfying `isType` is compiled away and does not exist at runtime.\n\nThe `is` function returns its first argument if it satisfies the type specified by the second argument.\nIf it is not, then the program is invalid.\nFor example, `is(5, UInt)` returns `5`, while `is(5, Bool)` is an invalid program.\nThe value returned by `is` may not be identical to the input, because in some cases, such as for functions, it will record the applied to type and enforce it on future invocations.\nThese applications are considered negative positions for `Refine`.\n",
  "Anybody": "\n```javascript\nAnybody.publish(); // race(...Participants).publish()\n```\n\n Reach provides a shorthand, `Anybody`, which serves as a\n`race` between all participants.\nThis shorthand can be useful for situations where\nit does not matter who `publish`es, such as in a `timeout`.\n\n`Anybody` is strictly an abbreviation of a `race` involving all of the named participants of the application.\nIn an application with a participant class, this means any principal at all, because there is no restriction on which principals (i.e. addresses) may serve as a member of that class.\nIn an application without any participant classes, `Anybody` instead would mean only the actual previously-bound participants.\n",
  "Array": " `Array(Type_0, size)`, which denotes a statically-sized array.\n`Type_0` must be a type that can exist at runtime (i.e., not a function type.)\n(Refer to [Arrays](https://docs.reach.sh/rsh/compute/#ref-programs-arrays) for constructing arrays.)\n+  `Data({variant_0: Type_0, ..., variant_N: Type_N})`, which denotes a [tagged union](https://en.wikipedia.org/wiki/Tagged_union) (or _sum type_).\n(Refer to [Data](https://docs.reach.sh/rsh/compute/#ref-programs-data) for constructing data instances.)\n+  `Refine(Type_0, Predicate, ?Message)`, where `Predicate` is a unary function returning a boolean, which denotes a [refinement type](https://en.wikipedia.org/wiki/Refinement_type), that is instances of `Type_0` that satisfy `Predicate`.\nWhen a refinement type appears in a negative position (such as in an `is` or in the domain of a `Fun` of a participant interact interface), it introduces an `assert`;\nwhile when it is in a positive position, it introduces an `assume`.\n`Message` is an optional string to display if the predicate fails verification.\n\nFor example, if `f` had type\n```javascript\nFun([Refine(UInt, (x => x < 5))], Refine(UInt, (x => x > 10)))\n```\n\nthen `const z = f(y)` is equivalent to\n\n```javascript\nassert(y < 5);\nconst z = f(y);\nassume(z > 10);\n```\n\n+ `Refine(Type_0, PreCondition, PostCondition, ?Messages)`, where `Type_0` is a function type, `PreCondition` is a unary function that accepts a tuple of the domain and returns a boolean, and `PostCondition` is a binary function that accepts a tuple of the domain and the range and returns a boolean, denotes a function type with a [precondition](https://en.wikipedia.org/wiki/Precondition) and [postcondition](https://en.wikipedia.org/wiki/Postcondition).\nPreconditions are enforced with `assert` and postconditions are enforced with `assume`.\n`Messages` is an optional two-tuple of `Bytes`.\nThe first message will be displayed when the precondition fails verification and the second when the postcondition fails verification.\n\nFor example, `Refine(Fun([UInt, UInt], UInt), ([x, y] => x < y), (([x, y], z) => x + y < z))` is a function that requires its second argument to be larger than its first and its result to be larger than its input.\n\n`Object` and `Data` are commonly used to implemented [algebraic data types](https://en.wikipedia.org/wiki/Algebraic_data_type) in Reach.\n\n\n```javascript\ntypeOf(x) // type\nisType(t) // Bool\nis(x, t) // t\n```\n\nThe `typeOf` primitive function is the same as `typeof`:\nit returns the type of its argument.\n\nThe `isType` function returns `true` if its argument is a type.\nAny expression satisfying `isType` is compiled away and does not exist at runtime.\n\nThe `is` function returns its first argument if it satisfies the type specified by the second argument.\nIf it is not, then the program is invalid.\nFor example, `is(5, UInt)` returns `5`, while `is(5, Bool)` is an invalid program.\nThe value returned by `is` may not be identical to the input, because in some cases, such as for functions, it will record the applied to type and enforce it on future invocations.\nThese applications are considered negative positions for `Refine`.\n",
  "Array.all": "\n\n```javascript\nFoldable.all(c, f)\nArray.all(c, f)\nMap.all(c, f)\nc.all(f)\n```\n\n `Foldable.all(c, f)` determines whether the predicate, `f`, is satisfied\nby every element of the container, `c`.\n",
  "Array.and": "\n\n\n\n```javascript\nFoldable.and(c)\nArray.and(c)\nMap.and(c)\nc.and()\n```\n\n `Foldable.and(c)` returns the conjunction of a container of `Bool`s.\n",
  "Array.any": "\n\n```javascript\nFoldable.any(c, f)\nArray.any(c, f)\nMap.any(c, f)\nc.any(f)\n```\n\n `Foldable.any(c, f)` determines whether the predicate, `f`, is satisfied\nby at least one element of the container, `c`.\n",
  "Array.average": "\n\n```javascript\nFoldable.average(c)\nArray.average(c)\nMap.average(c)\nc.average()\n```\n\n `Foldable.average(c)` returns the mean of a container of `UInt`s.\n Note that because this uses integer division, the result is effectively truncated.\n",
  "Array.concat": "\n\n```javascript\nArray.concat(x, y)\nx.concat(y)\n```\n\n `Array.concat(x, y)` concatenates the two arrays `x` and `y`.\nThis may be abbreviated as `x.concat(y)`.\n",
  "Array.count": "\n\n```javascript\nFoldable.count(c, f)\nArray.count(c, f)\nMap.count(c, f)\nc.count(f)\n```\n\n `Foldable.count(c, f)` returns the number of elements in `c` that\nsatisfy the predicate, `f`.\n",
  "Array.elemType": "\n\n```javascript\nArray.elemType(arr)\narr.elemType\n```\n\n `Array.elemType` Returns the `Type` of elements that the array contains.\n",
  "Array.empty": "\n```javascript\nArray_empty\nArray.empty\n```\n\n `Array.empty` is an array with no elements.\nIt is the identity element of `Array.concat`.\nIt may also be written `Array_empty`.\n",
  "Array.find": "\n\n```javascript\nArray.find(arr, f)\narr.find(f)\n```\n\n `Array.find(arr, f)` returns the first element in the array, `arr`,\nthat satisfies the predicate `f`. The return value is of type `Maybe`. If no value in the\narray satisfies the predicate, `None` is returned.\n",
  "Array.findIndex": "\n\n```javascript\nArray.findIndex(arr, f)\narr.findIndex(f)\n```\n\n `Array.findIndex(arr, f)` returns the index of the first element\nin the given array that satisfies the predicate `f`. The return value is of type `Maybe(UInt)`. If\nno value in the array satisfies the predicate, `None` is returned.\n",
  "Array.forEach": "\n\n```javascript\nc.forEach(f)\nFoldable.forEach(c, f)\nArray.forEach(c, f)\nMap.forEach(c, f)\n```\n\n `Foldable.forEach(c, f)` iterates the function `f` over the elements of a container `c`, discarding the result.\nThis may be abbreviated as `c.forEach(f)`.\n",
  "Array.forEachWithIndex": "\n\n```javascript\nArray.forEachWithIndex(arr, f)\narr.forEachWithIndex(f)\n```\n\n `Array.forEachWithIndex(arr, f)` is similar to `Array.forEach`, except it\nprovides `f` with an additional argument, which is the index of the current element in `arr`.\nUnlike `Array.forEach`, this function is not generalized to an arbitrary number of arrays; it only accepts one array.\n",
  "Array.imax": "\n\n\n```javascript\nFoldable.imin(c)\nFoldable.imax(c)\nArray.imin(c)\nArray.imax(c)\nMap.imin(c)\nMap.imax(c)\nc.imin()\nc.imax()\n```\n\n`Foldable.imin(c)` and `Foldable.imax(c)` return the minimum and maximum of a container of `Int`s, respectively.\n",
  "Array.imin": "\n\n\n\n```javascript\nFoldable.imin(c)\nFoldable.imax(c)\nArray.imin(c)\nArray.imax(c)\nMap.imin(c)\nMap.imax(c)\nc.imin()\nc.imax()\n```\n\n`Foldable.imin(c)` and `Foldable.imax(c)` return the minimum and maximum of a container of `Int`s, respectively.\n",
  "Array.includes": "\n\n```javascript\nFoldable.includes(c, x)\nArray.includes(c, x)\nMap.includes(c, x)\nc.includes(x)\n```\n\n `Foldable.includes(c, x)` determines whether the container includes\nthe element, `x`.\n",
  "Array.indexOf": "\n\n```javascript\nArray.indexOf(arr, x)\narr.indexOf(x)\n```\n\n `Array.indexOf(arr, x)` returns the index of the first element\nin the given array that is equal to `x`. The return value is of type `Maybe(UInt)`. If\nthe value is not present in the array, `None` is returned.\n",
  "Array.iota": "\n```javascript\nArray.iota(5)\n```\n\n `Array.iota(len)` returns an array of length `len`, where each element is the same as its index.\nFor example, `Array.iota(4)` returns `[0, 1, 2, 3]`.\nThe given `len` must evaluate to an integer at compile-time.\n",
  "Array.length": "\n\n```javascript\nTuple.length(tup);\ntup.length;\nArray.length(arr);\narr.length;\n```\n\n `Tuple.length` Returns the length of the given tuple.\n\n `Array.length` Returns the length of the given array.\n\nBoth may be abbreviated as `expr.length` where `expr` evaluates to a tuple or an array.\n",
  "Array.map": "\n\n```javascript\nArray.map(arr, f)\narr.map(f)\n```\n\n `Array.map(arr, f)` returns a new array, `arr_mapped`, the same size as `arr`, where `arr_mapped[i] = f(arr[i])` for all `i`.\nFor example, `Array.iota(4).map(x => x+1)` returns `[1, 2, 3, 4]`.\nThis may be abbreviated as `arr.map(f)`.\n\nThis function is generalized to an arbitrary number of arrays of the same size, which are provided before the `f` argument.\nFor example, `Array.iota(4).map(Array.iota(4), add)` returns `[0, 2, 4, 6]`.\n",
  "Array.mapWithIndex": "\n\n```javascript\nArray.mapWithIndex(arr, f)\narr.mapWithIndex(f)\n```\n\n `Array.mapWithIndex(arr, f)` is similar to `Array.map`, except it\nprovides `f` with an additional argument, which is the index of the current element in `arr`.\nThe index argument is the last argument of the given function `f`.\n",
  "Array.max": "\n\n```javascript\nFoldable.max(c)\nArray.max(c)\nMap.max(c)\nc.max()\n```\n\n `Foldable.max(c)` returns the largest number in a container of `UInt`s.\n",
  "Array.min": "\n\n```javascript\nFoldable.min(c)\nArray.min(c)\nMap.min(c)\nc.min()\n```\n\n `Foldable.min(c)` returns the lowest number in a container of `UInt`s.\n",
  "Array.or": "\n\n```javascript\nFoldable.or(c)\nArray.or(c)\nMap.or(c)\nc.or()\n```\n\n `Foldable.or(c)` returns the disjunction of a container of `Bool`s.\n",
  "Array.product": "\n\n```javascript\nFoldable.product(c)\nArray.product(c)\nMap.product(c)\nc.product()\n```\n\n `Foldable.product(c)` returns the product of a container of `UInt`s.\n",
  "Array.reduce": "\n\n```javascript\nArray.reduce(arr, z, f)\narr.reduce(z, f)\n```\n\n `Array.reduce(arr, z, f)` returns the [left fold](https://en.wikipedia.org/wiki/Fold_(higher-order_function)) of the function `f` over the given array with the initial value `z`.\nFor example, `Array.iota(4).reduce(0, add)` returns `((0 + 1) + 2) + 3 = 6`.\nThis may be abbreviated as `arr.reduce(z, f)`.\n\nThis function is generalized to an arbitrary number of arrays of the same size, which are provided before the `z` argument.\nFor example, `Array.iota(4).reduce(Array.iota(4), 0, (x, y, z) => (z + x + y))` returns `((((0 + 0 + 0) + 1 + 1) + 2 + 2) + 3 + 3)`.\n\nThe supplied function `f` is in the form `(ACCUM, A0_i, A1_i, ...) => BODY`.\nIn the example `a1.reduce(a2, a3, 0, (accum, v1, v2, v3) => 0)`, the `vN` values are drawn from the corresponding `aN` arrays.\n",
  "Array.reduceWithIndex": "\n\n```javascript\nArray.reduceWithIndex(arr, z, f)\narr.reduceWithIndex(z, f)\n```\n\n `Array.reduceWithIndex(arr, z, f)` is similar to `Array.reduce`, except it\nprovides `f` with an additional argument, which is the index of the current element in `arr`.\nThe index argument is the last argument of the given function `f`.\n",
  "Array.replicate": "\n```javascript\nArray.replicate(5, \"five\")\nArray_replicate(5, \"five\")\n```\n\n `Array.replicate(len, val)` returns an array of length `len`, where each element is `val`.\nFor example, `Array.replicate(4, \"four\")` returns `[\"four\", \"four\", \"four\", \"four\"]`.\nThe given `len` must evaluate to an integer at compile-time.\n",
  "Array.set": "\n\n```javascript\nTuple.set(tup, idx, val);\ntup.set(idx, val);\nArray.set(arr, idx, val);\narr.set(idx, val);\n```\n\n `Tuple.set` Returns a new tuple identical to `tup`,\nexcept that index `idx` is replaced with `val`.\nThe `idx` must be a compile-time constant, because tuples do not support dynamic access, because each element may be a different type.\n\n `Array.set` Returns a new array identical to `arr`, except that index `idx` is replaced with `val`.\n\nBoth may be abbreviated as `expr.set(idx, val)` where `expr` evaluates to a tuple or an array.\n",
  "Array.size": "\n\n```javascript\nFoldable.size(c)\nArray.size(c)\nMap.size(c)\nc.size()\n```\n\n `Foldable.size(c)` returns the number of elements in `c`.\n",
  "Array.slice": "\n\n```javascript\nArray.slice(arr, start, length)\narr.slice(start, length)\n```\n\n `Array.slice(arr, start, length)` returns a portion of `arr`, starting from\nthe `start` index, up to the `start + length` index.\n",
  "Array.sum": "\n\n```javascript\nFoldable.sum(c)\nArray.sum(c)\nMap.sum(c)\nc.sum()\n```\n\n `Foldable.sum(c)` returns the sum of a container of `UInt`s.\n",
  "Array.withIndex": "\n\n```javascript\nArray.withIndex(arr)\narr.withIndex()\n```\n\n `Array.withIndex(arr)` returns an array where every element of `arr`\nis paired with its index. For example, `array(Bool, [false, true]).withIndex()` returns\n`array(Tuple(Bool, UInt), [[false, 0], [true, 1]])`.\n",
  "Array.zip": "\n\n```javascript\nArray.zip(x, y)\nx.zip(y)\n```\n\n `Array.zip(x, y)` returns a new array the same size as `x` and `y` (which must be the same size) whose elements are tuples of the elements of `x` and `y`.\nThis may be abbreviated as `x.zip(y)`.\nThis function is generalized to an arbitrary number of arrays of the same size.\n",
  "Bool": " `Bool`, which denotes a boolean.\n+  `UInt`, which denotes an unsigned integer.\n   `UInt.max` is the largest value that may be assigned to a `UInt`.\n+  `UInt256`, which denotes an unsigned integer with 256 bits.\n   `UInt256.max` is the largest value that may be assigned to a `UInt256`.\n+ `Int`, which denotes a signed integer.\n+ `FixedPoint`, which denotes a fractional number.\n+  `Bytes(length)`, which denotes a string of bytes of length at most `length`.\nBytes of different lengths are not compatible; however the shorter bytes may be [padded](https://docs.reach.sh/rsh/compute/#padding).\n+  `Digest`, which denotes a digest.\n+  `Address`, which denotes an account address.\n+  `Contract`, which denotes the identifying information of a contract.\n\n---\n**NOTE**\n\nReach has different representations of contracts across connectors.\nFor example, on Algorand a `Contract` is an Application ID, but on Ethereum it is an Address.\n\n---\n\n+  `Token`, which denotes a non-network token. [Networks](https://docs.reach.sh/networks/#ref-networks) discusses how `Token`s are represented on specific networks.\n\n---\n**NOTE**\n\nReach assumes that every `Token` in your program refers to a different non-network token.\nIt will automatically insert `require` statements that enforce this constraint.\n\n---\n\n+  `Fun([Domain_0, ..., Domain_N], Range)`, which denotes a function type, when `Domain_i` and `Range` are types.\nThe domain of a function is negative position.\nThe range of a function is positive position.\n+ `Fun(true, Range)`, which denotes an unconstrained domain function type, when `Range` is a type.\nThese functions may only appear in participant interact interfaces.\n+  `Tuple(Field_0, ..., FieldN)`, which denotes a tuple.\n(Refer to [Tuples](https://docs.reach.sh/rsh/compute/#ref-programs-tuples) for constructing tuples.)\n+  `Object({key_0: Type_0, ..., key_N: Type_N})`, which denotes an object.\n(Refer to [Objects](https://docs.reach.sh/rsh/compute/#ref-programs-objects) for constructing objects.)\n+  `Struct([[key_0, Type_0], ..., [key_N, Type_N]])`, which denotes a struct.\n(Refer to [Structs](https://docs.reach.sh/rsh/compute/#ref-programs-structs) for constructing structs.)\n+  `Array(Type_0, size)`, which denotes a statically-sized array.\n`Type_0` must be a type that can exist at runtime (i.e., not a function type.)\n(Refer to [Arrays](https://docs.reach.sh/rsh/compute/#ref-programs-arrays) for constructing arrays.)\n+  `Data({variant_0: Type_0, ..., variant_N: Type_N})`, which denotes a [tagged union](https://en.wikipedia.org/wiki/Tagged_union) (or _sum type_).\n(Refer to [Data](https://docs.reach.sh/rsh/compute/#ref-programs-data) for constructing data instances.)\n+  `Refine(Type_0, Predicate, ?Message)`, where `Predicate` is a unary function returning a boolean, which denotes a [refinement type](https://en.wikipedia.org/wiki/Refinement_type), that is instances of `Type_0` that satisfy `Predicate`.\nWhen a refinement type appears in a negative position (such as in an `is` or in the domain of a `Fun` of a participant interact interface), it introduces an `assert`;\nwhile when it is in a positive position, it introduces an `assume`.\n`Message` is an optional string to display if the predicate fails verification.\n\nFor example, if `f` had type\n```javascript\nFun([Refine(UInt, (x => x < 5))], Refine(UInt, (x => x > 10)))\n```\n\nthen `const z = f(y)` is equivalent to\n\n```javascript\nassert(y < 5);\nconst z = f(y);\nassume(z > 10);\n```\n\n+ `Refine(Type_0, PreCondition, PostCondition, ?Messages)`, where `Type_0` is a function type, `PreCondition` is a unary function that accepts a tuple of the domain and returns a boolean, and `PostCondition` is a binary function that accepts a tuple of the domain and the range and returns a boolean, denotes a function type with a [precondition](https://en.wikipedia.org/wiki/Precondition) and [postcondition](https://en.wikipedia.org/wiki/Postcondition).\nPreconditions are enforced with `assert` and postconditions are enforced with `assume`.\n`Messages` is an optional two-tuple of `Bytes`.\nThe first message will be displayed when the precondition fails verification and the second when the postcondition fails verification.\n\nFor example, `Refine(Fun([UInt, UInt], UInt), ([x, y] => x < y), (([x, y], z) => x + y < z))` is a function that requires its second argument to be larger than its first and its result to be larger than its input.\n\n`Object` and `Data` are commonly used to implemented [algebraic data types](https://en.wikipedia.org/wiki/Algebraic_data_type) in Reach.\n\n\n```javascript\ntypeOf(x) // type\nisType(t) // Bool\nis(x, t) // t\n```\n\nThe `typeOf` primitive function is the same as `typeof`:\nit returns the type of its argument.\n\nThe `isType` function returns `true` if its argument is a type.\nAny expression satisfying `isType` is compiled away and does not exist at runtime.\n\nThe `is` function returns its first argument if it satisfies the type specified by the second argument.\nIf it is not, then the program is invalid.\nFor example, `is(5, UInt)` returns `5`, while `is(5, Bool)` is an invalid program.\nThe value returned by `is` may not be identical to the input, because in some cases, such as for functions, it will record the applied to type and enforce it on future invocations.\nThese applications are considered negative positions for `Refine`.\n",
  "Bytes": " `Bytes(length)`, which denotes a string of bytes of length at most `length`.\nBytes of different lengths are not compatible; however the shorter bytes may be [padded](https://docs.reach.sh/rsh/compute/#padding).\n+  `Digest`, which denotes a digest.\n+  `Address`, which denotes an account address.\n+  `Contract`, which denotes the identifying information of a contract.\n\n---\n**NOTE**\n\nReach has different representations of contracts across connectors.\nFor example, on Algorand a `Contract` is an Application ID, but on Ethereum it is an Address.\n\n---\n\n+  `Token`, which denotes a non-network token. [Networks](https://docs.reach.sh/networks/#ref-networks) discusses how `Token`s are represented on specific networks.\n\n---\n**NOTE**\n\nReach assumes that every `Token` in your program refers to a different non-network token.\nIt will automatically insert `require` statements that enforce this constraint.\n\n---\n\n+  `Fun([Domain_0, ..., Domain_N], Range)`, which denotes a function type, when `Domain_i` and `Range` are types.\nThe domain of a function is negative position.\nThe range of a function is positive position.\n+ `Fun(true, Range)`, which denotes an unconstrained domain function type, when `Range` is a type.\nThese functions may only appear in participant interact interfaces.\n+  `Tuple(Field_0, ..., FieldN)`, which denotes a tuple.\n(Refer to [Tuples](https://docs.reach.sh/rsh/compute/#ref-programs-tuples) for constructing tuples.)\n+  `Object({key_0: Type_0, ..., key_N: Type_N})`, which denotes an object.\n(Refer to [Objects](https://docs.reach.sh/rsh/compute/#ref-programs-objects) for constructing objects.)\n+  `Struct([[key_0, Type_0], ..., [key_N, Type_N]])`, which denotes a struct.\n(Refer to [Structs](https://docs.reach.sh/rsh/compute/#ref-programs-structs) for constructing structs.)\n+  `Array(Type_0, size)`, which denotes a statically-sized array.\n`Type_0` must be a type that can exist at runtime (i.e., not a function type.)\n(Refer to [Arrays](https://docs.reach.sh/rsh/compute/#ref-programs-arrays) for constructing arrays.)\n+  `Data({variant_0: Type_0, ..., variant_N: Type_N})`, which denotes a [tagged union](https://en.wikipedia.org/wiki/Tagged_union) (or _sum type_).\n(Refer to [Data](https://docs.reach.sh/rsh/compute/#ref-programs-data) for constructing data instances.)\n+  `Refine(Type_0, Predicate, ?Message)`, where `Predicate` is a unary function returning a boolean, which denotes a [refinement type](https://en.wikipedia.org/wiki/Refinement_type), that is instances of `Type_0` that satisfy `Predicate`.\nWhen a refinement type appears in a negative position (such as in an `is` or in the domain of a `Fun` of a participant interact interface), it introduces an `assert`;\nwhile when it is in a positive position, it introduces an `assume`.\n`Message` is an optional string to display if the predicate fails verification.\n\nFor example, if `f` had type\n```javascript\nFun([Refine(UInt, (x => x < 5))], Refine(UInt, (x => x > 10)))\n```\n\nthen `const z = f(y)` is equivalent to\n\n```javascript\nassert(y < 5);\nconst z = f(y);\nassume(z > 10);\n```\n\n+ `Refine(Type_0, PreCondition, PostCondition, ?Messages)`, where `Type_0` is a function type, `PreCondition` is a unary function that accepts a tuple of the domain and returns a boolean, and `PostCondition` is a binary function that accepts a tuple of the domain and the range and returns a boolean, denotes a function type with a [precondition](https://en.wikipedia.org/wiki/Precondition) and [postcondition](https://en.wikipedia.org/wiki/Postcondition).\nPreconditions are enforced with `assert` and postconditions are enforced with `assume`.\n`Messages` is an optional two-tuple of `Bytes`.\nThe first message will be displayed when the precondition fails verification and the second when the postcondition fails verification.\n\nFor example, `Refine(Fun([UInt, UInt], UInt), ([x, y] => x < y), (([x, y], z) => x + y < z))` is a function that requires its second argument to be larger than its first and its result to be larger than its input.\n\n`Object` and `Data` are commonly used to implemented [algebraic data types](https://en.wikipedia.org/wiki/Algebraic_data_type) in Reach.\n\n\n```javascript\ntypeOf(x) // type\nisType(t) // Bool\nis(x, t) // t\n```\n\nThe `typeOf` primitive function is the same as `typeof`:\nit returns the type of its argument.\n\nThe `isType` function returns `true` if its argument is a type.\nAny expression satisfying `isType` is compiled away and does not exist at runtime.\n\nThe `is` function returns its first argument if it satisfies the type specified by the second argument.\nIf it is not, then the program is invalid.\nFor example, `is(5, UInt)` returns `5`, while `is(5, Bool)` is an invalid program.\nThe value returned by `is` may not be identical to the input, because in some cases, such as for functions, it will record the applied to type and enforce it on future invocations.\nThese applications are considered negative positions for `Refine`.\n",
  "Closed": "\n\n```javascript\nexport const [ isIntervalType, Closed, Open ] = mkEnum(2);\nexport const IntervalType = Refine(UInt, isIntervalType);\n```\n",
  "Contract": " `Contract`, which denotes the identifying information of a contract.\n\n---\n**NOTE**\n\nReach has different representations of contracts across connectors.\nFor example, on Algorand a `Contract` is an Application ID, but on Ethereum it is an Address.\n\n---\n\n+  `Token`, which denotes a non-network token. [Networks](https://docs.reach.sh/networks/#ref-networks) discusses how `Token`s are represented on specific networks.\n\n---\n**NOTE**\n\nReach assumes that every `Token` in your program refers to a different non-network token.\nIt will automatically insert `require` statements that enforce this constraint.\n\n---\n\n+  `Fun([Domain_0, ..., Domain_N], Range)`, which denotes a function type, when `Domain_i` and `Range` are types.\nThe domain of a function is negative position.\nThe range of a function is positive position.\n+ `Fun(true, Range)`, which denotes an unconstrained domain function type, when `Range` is a type.\nThese functions may only appear in participant interact interfaces.\n+  `Tuple(Field_0, ..., FieldN)`, which denotes a tuple.\n(Refer to [Tuples](https://docs.reach.sh/rsh/compute/#ref-programs-tuples) for constructing tuples.)\n+  `Object({key_0: Type_0, ..., key_N: Type_N})`, which denotes an object.\n(Refer to [Objects](https://docs.reach.sh/rsh/compute/#ref-programs-objects) for constructing objects.)\n+  `Struct([[key_0, Type_0], ..., [key_N, Type_N]])`, which denotes a struct.\n(Refer to [Structs](https://docs.reach.sh/rsh/compute/#ref-programs-structs) for constructing structs.)\n+  `Array(Type_0, size)`, which denotes a statically-sized array.\n`Type_0` must be a type that can exist at runtime (i.e., not a function type.)\n(Refer to [Arrays](https://docs.reach.sh/rsh/compute/#ref-programs-arrays) for constructing arrays.)\n+  `Data({variant_0: Type_0, ..., variant_N: Type_N})`, which denotes a [tagged union](https://en.wikipedia.org/wiki/Tagged_union) (or _sum type_).\n(Refer to [Data](https://docs.reach.sh/rsh/compute/#ref-programs-data) for constructing data instances.)\n+  `Refine(Type_0, Predicate, ?Message)`, where `Predicate` is a unary function returning a boolean, which denotes a [refinement type](https://en.wikipedia.org/wiki/Refinement_type), that is instances of `Type_0` that satisfy `Predicate`.\nWhen a refinement type appears in a negative position (such as in an `is` or in the domain of a `Fun` of a participant interact interface), it introduces an `assert`;\nwhile when it is in a positive position, it introduces an `assume`.\n`Message` is an optional string to display if the predicate fails verification.\n\nFor example, if `f` had type\n```javascript\nFun([Refine(UInt, (x => x < 5))], Refine(UInt, (x => x > 10)))\n```\n\nthen `const z = f(y)` is equivalent to\n\n```javascript\nassert(y < 5);\nconst z = f(y);\nassume(z > 10);\n```\n\n+ `Refine(Type_0, PreCondition, PostCondition, ?Messages)`, where `Type_0` is a function type, `PreCondition` is a unary function that accepts a tuple of the domain and returns a boolean, and `PostCondition` is a binary function that accepts a tuple of the domain and the range and returns a boolean, denotes a function type with a [precondition](https://en.wikipedia.org/wiki/Precondition) and [postcondition](https://en.wikipedia.org/wiki/Postcondition).\nPreconditions are enforced with `assert` and postconditions are enforced with `assume`.\n`Messages` is an optional two-tuple of `Bytes`.\nThe first message will be displayed when the precondition fails verification and the second when the postcondition fails verification.\n\nFor example, `Refine(Fun([UInt, UInt], UInt), ([x, y] => x < y), (([x, y], z) => x + y < z))` is a function that requires its second argument to be larger than its first and its result to be larger than its input.\n\n`Object` and `Data` are commonly used to implemented [algebraic data types](https://en.wikipedia.org/wiki/Algebraic_data_type) in Reach.\n\n\n```javascript\ntypeOf(x) // type\nisType(t) // Bool\nis(x, t) // t\n```\n\nThe `typeOf` primitive function is the same as `typeof`:\nit returns the type of its argument.\n\nThe `isType` function returns `true` if its argument is a type.\nAny expression satisfying `isType` is compiled away and does not exist at runtime.\n\nThe `is` function returns its first argument if it satisfies the type specified by the second argument.\nIf it is not, then the program is invalid.\nFor example, `is(5, UInt)` returns `5`, while `is(5, Bool)` is an invalid program.\nThe value returned by `is` may not be identical to the input, because in some cases, such as for functions, it will record the applied to type and enforce it on future invocations.\nThese applications are considered negative positions for `Refine`.\n",
  "Contract.addressEq": "\n```javascript\nContract.addressEq(getContract(), getAddress())\n```\n\nAlthough `Contract` and `Address` are not necessarily the same\ntype, they often have a connection.\n`Contract.addressEq(ctc, addr)` returns a boolean that is `true`\nif `ctc` refers to the same contract as `addr`.\n",
  "Data": " `Data({variant_0: Type_0, ..., variant_N: Type_N})`, which denotes a [tagged union](https://en.wikipedia.org/wiki/Tagged_union) (or _sum type_).\n(Refer to [Data](https://docs.reach.sh/rsh/compute/#ref-programs-data) for constructing data instances.)\n+  `Refine(Type_0, Predicate, ?Message)`, where `Predicate` is a unary function returning a boolean, which denotes a [refinement type](https://en.wikipedia.org/wiki/Refinement_type), that is instances of `Type_0` that satisfy `Predicate`.\nWhen a refinement type appears in a negative position (such as in an `is` or in the domain of a `Fun` of a participant interact interface), it introduces an `assert`;\nwhile when it is in a positive position, it introduces an `assume`.\n`Message` is an optional string to display if the predicate fails verification.\n\nFor example, if `f` had type\n```javascript\nFun([Refine(UInt, (x => x < 5))], Refine(UInt, (x => x > 10)))\n```\n\nthen `const z = f(y)` is equivalent to\n\n```javascript\nassert(y < 5);\nconst z = f(y);\nassume(z > 10);\n```\n\n+ `Refine(Type_0, PreCondition, PostCondition, ?Messages)`, where `Type_0` is a function type, `PreCondition` is a unary function that accepts a tuple of the domain and returns a boolean, and `PostCondition` is a binary function that accepts a tuple of the domain and the range and returns a boolean, denotes a function type with a [precondition](https://en.wikipedia.org/wiki/Precondition) and [postcondition](https://en.wikipedia.org/wiki/Postcondition).\nPreconditions are enforced with `assert` and postconditions are enforced with `assume`.\n`Messages` is an optional two-tuple of `Bytes`.\nThe first message will be displayed when the precondition fails verification and the second when the postcondition fails verification.\n\nFor example, `Refine(Fun([UInt, UInt], UInt), ([x, y] => x < y), (([x, y], z) => x + y < z))` is a function that requires its second argument to be larger than its first and its result to be larger than its input.\n\n`Object` and `Data` are commonly used to implemented [algebraic data types](https://en.wikipedia.org/wiki/Algebraic_data_type) in Reach.\n\n\n```javascript\ntypeOf(x) // type\nisType(t) // Bool\nis(x, t) // t\n```\n\nThe `typeOf` primitive function is the same as `typeof`:\nit returns the type of its argument.\n\nThe `isType` function returns `true` if its argument is a type.\nAny expression satisfying `isType` is compiled away and does not exist at runtime.\n\nThe `is` function returns its first argument if it satisfies the type specified by the second argument.\nIf it is not, then the program is invalid.\nFor example, `is(5, UInt)` returns `5`, while `is(5, Bool)` is an invalid program.\nThe value returned by `is` may not be identical to the input, because in some cases, such as for functions, it will record the applied to type and enforce it on future invocations.\nThese applications are considered negative positions for `Refine`.\n",
  "Digest": " `Digest`, which denotes a digest.\n+  `Address`, which denotes an account address.\n+  `Contract`, which denotes the identifying information of a contract.\n\n---\n**NOTE**\n\nReach has different representations of contracts across connectors.\nFor example, on Algorand a `Contract` is an Application ID, but on Ethereum it is an Address.\n\n---\n\n+  `Token`, which denotes a non-network token. [Networks](https://docs.reach.sh/networks/#ref-networks) discusses how `Token`s are represented on specific networks.\n\n---\n**NOTE**\n\nReach assumes that every `Token` in your program refers to a different non-network token.\nIt will automatically insert `require` statements that enforce this constraint.\n\n---\n\n+  `Fun([Domain_0, ..., Domain_N], Range)`, which denotes a function type, when `Domain_i` and `Range` are types.\nThe domain of a function is negative position.\nThe range of a function is positive position.\n+ `Fun(true, Range)`, which denotes an unconstrained domain function type, when `Range` is a type.\nThese functions may only appear in participant interact interfaces.\n+  `Tuple(Field_0, ..., FieldN)`, which denotes a tuple.\n(Refer to [Tuples](https://docs.reach.sh/rsh/compute/#ref-programs-tuples) for constructing tuples.)\n+  `Object({key_0: Type_0, ..., key_N: Type_N})`, which denotes an object.\n(Refer to [Objects](https://docs.reach.sh/rsh/compute/#ref-programs-objects) for constructing objects.)\n+  `Struct([[key_0, Type_0], ..., [key_N, Type_N]])`, which denotes a struct.\n(Refer to [Structs](https://docs.reach.sh/rsh/compute/#ref-programs-structs) for constructing structs.)\n+  `Array(Type_0, size)`, which denotes a statically-sized array.\n`Type_0` must be a type that can exist at runtime (i.e., not a function type.)\n(Refer to [Arrays](https://docs.reach.sh/rsh/compute/#ref-programs-arrays) for constructing arrays.)\n+  `Data({variant_0: Type_0, ..., variant_N: Type_N})`, which denotes a [tagged union](https://en.wikipedia.org/wiki/Tagged_union) (or _sum type_).\n(Refer to [Data](https://docs.reach.sh/rsh/compute/#ref-programs-data) for constructing data instances.)\n+  `Refine(Type_0, Predicate, ?Message)`, where `Predicate` is a unary function returning a boolean, which denotes a [refinement type](https://en.wikipedia.org/wiki/Refinement_type), that is instances of `Type_0` that satisfy `Predicate`.\nWhen a refinement type appears in a negative position (such as in an `is` or in the domain of a `Fun` of a participant interact interface), it introduces an `assert`;\nwhile when it is in a positive position, it introduces an `assume`.\n`Message` is an optional string to display if the predicate fails verification.\n\nFor example, if `f` had type\n```javascript\nFun([Refine(UInt, (x => x < 5))], Refine(UInt, (x => x > 10)))\n```\n\nthen `const z = f(y)` is equivalent to\n\n```javascript\nassert(y < 5);\nconst z = f(y);\nassume(z > 10);\n```\n\n+ `Refine(Type_0, PreCondition, PostCondition, ?Messages)`, where `Type_0` is a function type, `PreCondition` is a unary function that accepts a tuple of the domain and returns a boolean, and `PostCondition` is a binary function that accepts a tuple of the domain and the range and returns a boolean, denotes a function type with a [precondition](https://en.wikipedia.org/wiki/Precondition) and [postcondition](https://en.wikipedia.org/wiki/Postcondition).\nPreconditions are enforced with `assert` and postconditions are enforced with `assume`.\n`Messages` is an optional two-tuple of `Bytes`.\nThe first message will be displayed when the precondition fails verification and the second when the postcondition fails verification.\n\nFor example, `Refine(Fun([UInt, UInt], UInt), ([x, y] => x < y), (([x, y], z) => x + y < z))` is a function that requires its second argument to be larger than its first and its result to be larger than its input.\n\n`Object` and `Data` are commonly used to implemented [algebraic data types](https://en.wikipedia.org/wiki/Algebraic_data_type) in Reach.\n\n\n```javascript\ntypeOf(x) // type\nisType(t) // Bool\nis(x, t) // t\n```\n\nThe `typeOf` primitive function is the same as `typeof`:\nit returns the type of its argument.\n\nThe `isType` function returns `true` if its argument is a type.\nAny expression satisfying `isType` is compiled away and does not exist at runtime.\n\nThe `is` function returns its first argument if it satisfies the type specified by the second argument.\nIf it is not, then the program is invalid.\nFor example, `is(5, UInt)` returns `5`, while `is(5, Bool)` is an invalid program.\nThe value returned by `is` may not be identical to the input, because in some cases, such as for functions, it will record the applied to type and enforce it on future invocations.\nThese applications are considered negative positions for `Refine`.\n",
  "Either": "\n\n\n`Either` is defined by\n```javascript\nexport const Either = (A, B) => Data({Left: A, Right: B});\n```\n\n`Either` can be used to represent values with two possible types.\n\nSimilar to `Maybe`, `Either` may be used to represent values that are correct or erroneous.\nA successful result is stored, by convention, in `Right`. Unlike `None`, `Left` may\ncarry additional information about the error.\n\n\n```javascript\neither(e, onLeft, onRight)\n```\n\n `either(e, onLeft, onRight)` will either apply the function `onLeft` or `onRight` depending on `e`.\n\n\n```javascript\nconst e = Either(UInt, Bool);\nconst l = e.Left(1);\nconst r = e.Right(true);\nisLeft(l);  // true\nisRight(l); // false\nconst x = fromLeft(l, 0);      // x = 1\nconst y = fromRight(l, false); // y = false\n```\n\n `isLeft` is a convenience method that determines whether the variant is `Left`.\n\n `isRight` is a convenience method that determines whether the variant is `Right`.\n\n `fromLeft(e, default)` is a convenience method that returns the value in `Left`,\nor `default` if the variant is `Right`.\n\n `fromRight(e, default)` is a convenience method that returns the value in `Right`,\nor `default` if the variant is `Left`.\n",
  "Events": "\n```javascript\nEvents('Logger', {\n  log: [UInt, Byte(64)]\n})\n// or\nEvents({\n  log: [UInt, Byte(64)]\n})\n```\n\nAn event is defined with `Events(eventName, eventInterface)` or `Events(eventInterface)`, where `eventName` is a string that labels the event and `eventInterface` is an object where each field is a `Tuple` of `Type`s, representing the type of values that an event will emit.\n\nFor example, the `Events` in the code below has no `eventName`:\n```javascript\n  const Logger = Events({\n    log: [E],\n  });\n  init();\n```\n\nWhile the `Events` in following example has an `eventName`:\n```javascript\n  const CP = Events('ContractPhase', { phase: [Phase] });\n  init();\n```\n\nThese events are available in the frontends via the `ctc.events` object.\nIn the DApp, the result of this application argument is referred to as an event object.",
  "FixedPoint": "\n```javascript\nexport const FixedPoint = Object({ sign: bool, i: Object({ scale: UInt, i: UInt }) });\n```\n\n`FixedPoint` can be used to represent numbers with a fixed number of digits after the decimal point.\nThey are handy for representing fractional values, especially in base 10. The value of a fixed point number is determined\nby dividing the underlying integer value, `i`, by its scale factor, `scale`. For example, we could\nrepresent the value `1.234` with `{ sign: Pos, i: { scale: 1000, i : 1234 } }` or `fx(1000)(Pos, 1234)`.\nAlternatively, Reach provides syntactic sugar for defining `FixedPoint` numbers. One can simply write\n`1.234`, which will assume the value is in base 10. A scale factor of `1000` correlates to 3 decimal\nplaces of precision. Similarly, a scale factor of `100` would have 2 decimal places of precision.\n\n\n```javascript\nconst scale = 10;\nconst i = 56;\nfx(scale)(Neg, i); // represents - 5.6\n```\n\n `fx(scale)(i)` will return a function that can be used to\ninstantiate fixed point numbers with a particular scale factor.\n\n\n```javascript\nconst i = 4;\nfxint(-i); // represents - 4.0\n```\n\n `fxint(Int)` will cast the `Int` arg as a `FixedPoint`\nnumber with a `scale` of 1.\n\n\n```javascript\nconst x = fx(1000)(Pos, 1234); // x = 1.234\nfxrescale(x, 100);    // => 1.23\n```\n\n `fxrescale(x, scale)` will convert a fixed point number from using\none scale to another. This operation can result in loss of precision, as demonstrated in the above example.\n\n\n```javascript\nconst x = fx(1000)(Pos, 824345); // x = 824.345\nconst y = 45.67;\nfxunify(x, y);    // => [ 1000, 824.345, 45.670 ]\n```\n\n `fxunify(x, y)` will convert the fixed point numbers\nto use the same scale. The larger scale of the two arguments will be chosen. The function will return a `3-tuple` consisting\nof the common scale and the newly scaled values.\n\n\n `fxadd(x, y)` adds two fixed point numbers.\n\n\n `fxsub(x, y)` subtracts two fixed point numbers.\n\n\n `fxmul(x, y)` multiplies two fixed point numbers.\n\n\n```javascript\nfxdiv(34.56, 1.234, 10)     // => 28\nfxdiv(34.56, 1.234, 100000) // => 28.0064\n```\n\n `fxdiv(x, y, scale_factor)` divides two fixed point numbers. The numerator, `x`,\nwill be multiplied by the scale factor to provide a more precise answer. For example,\n\n\n `fxmod(x, y)` finds the remainder of dividing `x` by `y`.\n\n\n `fxfloor(x)` returns the greatest integer not greater than `x`.\n\n\n `fxsqrt(x, k)` returns the square root of the fixed number, `x`.\n\n\n `fxsqrtApprox(x, k)` approximates the square root of the fixed number, `x`, using `k` iterations of the `sqrtApprox` algorithm.\n\n\n`const base  = 2.0;\nconst power = 0.33;\nfxpow(base, power, 10, 1000);    // 1.260\nfxpow(base, power, 10, 10000);   // 1.2599\nfxpow(base, power, 10, 1000000); // 1.259921 `\n\n `fxpow(base, power, precision, scalePrecision)` approximates the power of the fixed number, `base`,\nraised to the fixed point number, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform.\nThe `scalePrecision` argument must be a `UInt` and represents the scale of the return value. Choosing a larger\n`scalePrecision` allows for more precision when approximating the power, as demonstrated in the example below:\n\n\n `fxpowi(base, power, precision)` approximates the power of the fixed number, `base`,\nraised to the `Int`, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform. For reference, `6` iterations\nprovides enough accuracy to calculate up to `2^64 - 1`, so the largest power it can compute is `63`.\n\n\n`fxpowui(5.8, 3, 10); // 195.112 `\n\n `fxpowui(base, power, precision)` approximates the power of\nthe fixed number, `base`, raised to the `UInt`, `power`. The third\nargument must be a `UInt` whose value is known at compile time.\n\n\n `fxcmp(op, x, y)` applies the comparison\noperator to the two fixed point numbers after unifying their scales.\n\nThere are convenience methods defined for comparing fixed point numbers:\n\n\n `fxlt(x, y)` tests whether `x` is less than `y`.\n\n\n `fxle(x, y)` tests whether `x` is less than or equal to `y`.\n\n\n `fxgt(x, y)` tests whether `x` is greater than `y`.\n\n\n `fxge(x, y)` tests whether `x` is greater than or equal to `y`.\n\n\n `fxeq(x, y)` tests whether `x` is equal to `y`.\n\n\n `fxne(x, y)` tests whether `x` is not equal to `y`.\n",
  "Foldable": "`Foldable` containers, such as: `Array`s and `Map`s.\n",
  "Foldable.all": "\n\n\n\n```javascript\nFoldable.all(c, f)\nArray.all(c, f)\nMap.all(c, f)\nc.all(f)\n```\n\n `Foldable.all(c, f)` determines whether the predicate, `f`, is satisfied\nby every element of the container, `c`.\n",
  "Foldable.and": "\n\n\n```javascript\nFoldable.and(c)\nArray.and(c)\nMap.and(c)\nc.and()\n```\n\n `Foldable.and(c)` returns the conjunction of a container of `Bool`s.\n",
  "Foldable.any": "\n\n\n\n```javascript\nFoldable.any(c, f)\nArray.any(c, f)\nMap.any(c, f)\nc.any(f)\n```\n\n `Foldable.any(c, f)` determines whether the predicate, `f`, is satisfied\nby at least one element of the container, `c`.\n",
  "Foldable.average": "\n\n\n\n```javascript\nFoldable.average(c)\nArray.average(c)\nMap.average(c)\nc.average()\n```\n\n `Foldable.average(c)` returns the mean of a container of `UInt`s.\n Note that because this uses integer division, the result is effectively truncated.\n",
  "Foldable.count": "\n\n\n\n```javascript\nFoldable.count(c, f)\nArray.count(c, f)\nMap.count(c, f)\nc.count(f)\n```\n\n `Foldable.count(c, f)` returns the number of elements in `c` that\nsatisfy the predicate, `f`.\n",
  "Foldable.forEach": "\n\n\n\n```javascript\nc.forEach(f)\nFoldable.forEach(c, f)\nArray.forEach(c, f)\nMap.forEach(c, f)\n```\n\n `Foldable.forEach(c, f)` iterates the function `f` over the elements of a container `c`, discarding the result.\nThis may be abbreviated as `c.forEach(f)`.\n",
  "Foldable.imax": "\n\n\n\n\n```javascript\nFoldable.imin(c)\nFoldable.imax(c)\nArray.imin(c)\nArray.imax(c)\nMap.imin(c)\nMap.imax(c)\nc.imin()\nc.imax()\n```\n\n`Foldable.imin(c)` and `Foldable.imax(c)` return the minimum and maximum of a container of `Int`s, respectively.\n",
  "Foldable.imin": "\n\n\n\n\n\n```javascript\nFoldable.imin(c)\nFoldable.imax(c)\nArray.imin(c)\nArray.imax(c)\nMap.imin(c)\nMap.imax(c)\nc.imin()\nc.imax()\n```\n\n`Foldable.imin(c)` and `Foldable.imax(c)` return the minimum and maximum of a container of `Int`s, respectively.\n",
  "Foldable.includes": "\n\n\n\n```javascript\nFoldable.includes(c, x)\nArray.includes(c, x)\nMap.includes(c, x)\nc.includes(x)\n```\n\n `Foldable.includes(c, x)` determines whether the container includes\nthe element, `x`.\n",
  "Foldable.max": "\n\n\n\n```javascript\nFoldable.max(c)\nArray.max(c)\nMap.max(c)\nc.max()\n```\n\n `Foldable.max(c)` returns the largest number in a container of `UInt`s.\n",
  "Foldable.min": "\n\n\n\n```javascript\nFoldable.min(c)\nArray.min(c)\nMap.min(c)\nc.min()\n```\n\n `Foldable.min(c)` returns the lowest number in a container of `UInt`s.\n",
  "Foldable.or": "\n\n\n\n```javascript\nFoldable.or(c)\nArray.or(c)\nMap.or(c)\nc.or()\n```\n\n `Foldable.or(c)` returns the disjunction of a container of `Bool`s.\n",
  "Foldable.product": "\n\n\n\n```javascript\nFoldable.product(c)\nArray.product(c)\nMap.product(c)\nc.product()\n```\n\n `Foldable.product(c)` returns the product of a container of `UInt`s.\n",
  "Foldable.size": "\n\n\n\n```javascript\nFoldable.size(c)\nArray.size(c)\nMap.size(c)\nc.size()\n```\n\n `Foldable.size(c)` returns the number of elements in `c`.\n",
  "Foldable.sum": "\n\n\n\n```javascript\nFoldable.sum(c)\nArray.sum(c)\nMap.sum(c)\nc.sum()\n```\n\n `Foldable.sum(c)` returns the sum of a container of `UInt`s.\n",
  "Fun": " `Fun([Domain_0, ..., Domain_N], Range)`, which denotes a function type, when `Domain_i` and `Range` are types.\nThe domain of a function is negative position.\nThe range of a function is positive position.\n+ `Fun(true, Range)`, which denotes an unconstrained domain function type, when `Range` is a type.\nThese functions may only appear in participant interact interfaces.\n+  `Tuple(Field_0, ..., FieldN)`, which denotes a tuple.\n(Refer to [Tuples](https://docs.reach.sh/rsh/compute/#ref-programs-tuples) for constructing tuples.)\n+  `Object({key_0: Type_0, ..., key_N: Type_N})`, which denotes an object.\n(Refer to [Objects](https://docs.reach.sh/rsh/compute/#ref-programs-objects) for constructing objects.)\n+  `Struct([[key_0, Type_0], ..., [key_N, Type_N]])`, which denotes a struct.\n(Refer to [Structs](https://docs.reach.sh/rsh/compute/#ref-programs-structs) for constructing structs.)\n+  `Array(Type_0, size)`, which denotes a statically-sized array.\n`Type_0` must be a type that can exist at runtime (i.e., not a function type.)\n(Refer to [Arrays](https://docs.reach.sh/rsh/compute/#ref-programs-arrays) for constructing arrays.)\n+  `Data({variant_0: Type_0, ..., variant_N: Type_N})`, which denotes a [tagged union](https://en.wikipedia.org/wiki/Tagged_union) (or _sum type_).\n(Refer to [Data](https://docs.reach.sh/rsh/compute/#ref-programs-data) for constructing data instances.)\n+  `Refine(Type_0, Predicate, ?Message)`, where `Predicate` is a unary function returning a boolean, which denotes a [refinement type](https://en.wikipedia.org/wiki/Refinement_type), that is instances of `Type_0` that satisfy `Predicate`.\nWhen a refinement type appears in a negative position (such as in an `is` or in the domain of a `Fun` of a participant interact interface), it introduces an `assert`;\nwhile when it is in a positive position, it introduces an `assume`.\n`Message` is an optional string to display if the predicate fails verification.\n\nFor example, if `f` had type\n```javascript\nFun([Refine(UInt, (x => x < 5))], Refine(UInt, (x => x > 10)))\n```\n\nthen `const z = f(y)` is equivalent to\n\n```javascript\nassert(y < 5);\nconst z = f(y);\nassume(z > 10);\n```\n\n+ `Refine(Type_0, PreCondition, PostCondition, ?Messages)`, where `Type_0` is a function type, `PreCondition` is a unary function that accepts a tuple of the domain and returns a boolean, and `PostCondition` is a binary function that accepts a tuple of the domain and the range and returns a boolean, denotes a function type with a [precondition](https://en.wikipedia.org/wiki/Precondition) and [postcondition](https://en.wikipedia.org/wiki/Postcondition).\nPreconditions are enforced with `assert` and postconditions are enforced with `assume`.\n`Messages` is an optional two-tuple of `Bytes`.\nThe first message will be displayed when the precondition fails verification and the second when the postcondition fails verification.\n\nFor example, `Refine(Fun([UInt, UInt], UInt), ([x, y] => x < y), (([x, y], z) => x + y < z))` is a function that requires its second argument to be larger than its first and its result to be larger than its input.\n\n`Object` and `Data` are commonly used to implemented [algebraic data types](https://en.wikipedia.org/wiki/Algebraic_data_type) in Reach.\n\n\n```javascript\ntypeOf(x) // type\nisType(t) // Bool\nis(x, t) // t\n```\n\nThe `typeOf` primitive function is the same as `typeof`:\nit returns the type of its argument.\n\nThe `isType` function returns `true` if its argument is a type.\nAny expression satisfying `isType` is compiled away and does not exist at runtime.\n\nThe `is` function returns its first argument if it satisfies the type specified by the second argument.\nIf it is not, then the program is invalid.\nFor example, `is(5, UInt)` returns `5`, while `is(5, Bool)` is an invalid program.\nThe value returned by `is` may not be identical to the input, because in some cases, such as for functions, it will record the applied to type and enforce it on future invocations.\nThese applications are considered negative positions for `Refine`.\n",
  "Int": "\n```javascript\nconst Int = { sign: Bool, i: UInt };\nconst Pos = true;\nconst Neg = false;\n```\n\n `int(Bool, UInt)` is shorthand for defining an `Int` record. You may also\nuse the `+` and `-` unary operators to declare integers instead of `UInt`s.\n\n\n```javascript\nint(Pos, 4); // represents 4\nint(Neg, 4); // represents -4\n-4;          // represents -4\n+4;          // represents 4 : Int\n 4;          // represents 4 : UInt\n```\n\n\n `iadd(x, y)` adds the `Int` `x` and the `Int` `y`.\n\n\n `isub(x, y)` subtracts the `Int` `y` from the `Int` `x`.\n\n\n `imul(x, y)` multiplies the `Int` `x` and the `Int` `y`.\n\n\n `idiv(x, y)` divides the `Int` `x` by the `Int` `y`.\n\n\n `imod(x, y)` finds the remainder of dividing the `Int` `x` by the `Int` `y`.\n\n\n `ilt(x, y)` determines whether `x` is less than `y`.\n\n\n `ile(x, y)` determines whether `x` is less than or equal to `y`.\n\n\n `igt(x, y)` determines whether `x` is greather than `y`.\n\n\n `ige(x, y)` determines whether `x` is greater than or equal to `y`.\n\n\n `ieq(x, y)` determines whether `x` is equal to `y`.\n\n\n `ine(x, y)` determines whether `x` is not equal to `y`.\n\n\n `imax(x, y)` returns the larger of two `Int`s.\n\n\n `abs(i)` returns the absolute value of an `Int`. The return value is of type `UInt`.\n",
  "Interval": "\n\n```javascript\nexport const Interval = Tuple(IntervalType, Int, Int, IntervalType);\n```\n\nwhere `IntervalType` is defined by\n\n\n\n\n\n```javascript\nexport const [ isIntervalType, Closed, Open ] = mkEnum(2);\nexport const IntervalType = Refine(UInt, isIntervalType);\n```\n",
  "IntervalType": "\n\n\n\n```javascript\nexport const [ isIntervalType, Closed, Open ] = mkEnum(2);\nexport const IntervalType = Refine(UInt, isIntervalType);\n```\n",
  "Map": "\n```javascript\nconst bidsM = new Map(Address, UInt);\n       // or `new Map(UInt);`\nbidsM[this] = 17;\ndelete bidsM[this];\n```\n\nA new mapping of linear state may be constructed in a consensus step by writing `new Map(VAL_TYPE_EXPR)` or `new Map(KEY_TYPE_EXPR, VAL_TYPE_EXPR)`, where `KEY_TYPE_EXPR` and `VAL_TYPE_EXPR` are types.\nIf `KEY_TYPE_EXPR` is not specified, it will default to `Address`.\n\nThis returns a value which may be used to dereference particular mappings via `map[EXPR]`.\nSuch dereferences return a value of type `Maybe(VAL_TYPE_EXPR)`, because the mapping may not contain a value for `EXPR`.\n\nA mapping may be modified by writing `map[EXPR] = VALUE_EXPR` to install `VALUE_EXPR` (of type `VAL_TYPE_EXPR`) at `EXPR`, or by writing `delete map[EXPR]` to remove the mapping entry.\nSuch modifications may only occur in a consensus step.\n\nN+2 relations can be created by using a `Tuple` as the Map key.\nFor example, a nested mapping: `Map(Address, Map(Address, UInt))`, can be simulated by coalescing the Map keys into a `Tuple`: `Map(Tuple(Address, Address), UInt)`.\n",
  "Map.all": "\n\n\n```javascript\nFoldable.all(c, f)\nArray.all(c, f)\nMap.all(c, f)\nc.all(f)\n```\n\n `Foldable.all(c, f)` determines whether the predicate, `f`, is satisfied\nby every element of the container, `c`.\n",
  "Map.and": "\n\n```javascript\nFoldable.and(c)\nArray.and(c)\nMap.and(c)\nc.and()\n```\n\n `Foldable.and(c)` returns the conjunction of a container of `Bool`s.\n",
  "Map.any": "\n\n\n```javascript\nFoldable.any(c, f)\nArray.any(c, f)\nMap.any(c, f)\nc.any(f)\n```\n\n `Foldable.any(c, f)` determines whether the predicate, `f`, is satisfied\nby at least one element of the container, `c`.\n",
  "Map.average": "\n\n\n```javascript\nFoldable.average(c)\nArray.average(c)\nMap.average(c)\nc.average()\n```\n\n `Foldable.average(c)` returns the mean of a container of `UInt`s.\n Note that because this uses integer division, the result is effectively truncated.\n",
  "Map.count": "\n\n\n```javascript\nFoldable.count(c, f)\nArray.count(c, f)\nMap.count(c, f)\nc.count(f)\n```\n\n `Foldable.count(c, f)` returns the number of elements in `c` that\nsatisfy the predicate, `f`.\n",
  "Map.forEach": "\n\n\n```javascript\nc.forEach(f)\nFoldable.forEach(c, f)\nArray.forEach(c, f)\nMap.forEach(c, f)\n```\n\n `Foldable.forEach(c, f)` iterates the function `f` over the elements of a container `c`, discarding the result.\nThis may be abbreviated as `c.forEach(f)`.\n",
  "Map.imax": "\n```javascript\nFoldable.imin(c)\nFoldable.imax(c)\nArray.imin(c)\nArray.imax(c)\nMap.imin(c)\nMap.imax(c)\nc.imin()\nc.imax()\n```\n\n`Foldable.imin(c)` and `Foldable.imax(c)` return the minimum and maximum of a container of `Int`s, respectively.\n",
  "Map.imin": "\n\n```javascript\nFoldable.imin(c)\nFoldable.imax(c)\nArray.imin(c)\nArray.imax(c)\nMap.imin(c)\nMap.imax(c)\nc.imin()\nc.imax()\n```\n\n`Foldable.imin(c)` and `Foldable.imax(c)` return the minimum and maximum of a container of `Int`s, respectively.\n",
  "Map.includes": "\n\n\n```javascript\nFoldable.includes(c, x)\nArray.includes(c, x)\nMap.includes(c, x)\nc.includes(x)\n```\n\n `Foldable.includes(c, x)` determines whether the container includes\nthe element, `x`.\n",
  "Map.max": "\n\n\n```javascript\nFoldable.max(c)\nArray.max(c)\nMap.max(c)\nc.max()\n```\n\n `Foldable.max(c)` returns the largest number in a container of `UInt`s.\n",
  "Map.min": "\n\n\n```javascript\nFoldable.min(c)\nArray.min(c)\nMap.min(c)\nc.min()\n```\n\n `Foldable.min(c)` returns the lowest number in a container of `UInt`s.\n",
  "Map.new": "\n\n\n`new f(a)` is equivalent to `f.new(a)` and is a convenient short-hand for writing class-oriented programs.\n",
  "Map.or": "\n\n\n```javascript\nFoldable.or(c)\nArray.or(c)\nMap.or(c)\nc.or()\n```\n\n `Foldable.or(c)` returns the disjunction of a container of `Bool`s.\n",
  "Map.product": "\n\n\n```javascript\nFoldable.product(c)\nArray.product(c)\nMap.product(c)\nc.product()\n```\n\n `Foldable.product(c)` returns the product of a container of `UInt`s.\n",
  "Map.reduce": "\n```javascript\nMap.reduce(map, z, f)\nmap.reduce(z, f)\n```\n\n `Map.reduce(map, z, f)` returns the [left fold](https://en.wikipedia.org/wiki/Fold_(higher-order_function)) of the function `f` over the given mapping with the initial value `z`.\nFor example, `m.reduce(0, add)` sums the elements of the mapping.\nThis may be abbreviated as `map.reduce(z, f)`.\n\nThe function `f` must satisfy the property, for all `z`, `a`, `b`, `f(f(z, b), a) == f(f(z, a), b)`, because the order of evaluation is unpredictable.\n",
  "Map.size": "\n\n\n```javascript\nFoldable.size(c)\nArray.size(c)\nMap.size(c)\nc.size()\n```\n\n `Foldable.size(c)` returns the number of elements in `c`.\n",
  "Map.sum": "\n\n\n```javascript\nFoldable.sum(c)\nArray.sum(c)\nMap.sum(c)\nc.sum()\n```\n\n `Foldable.sum(c)` returns the sum of a container of `UInt`s.\n",
  "Maybe": "\n```javascript\nconst MayInt = Maybe(UInt);\nconst bidA = MayInt.Some(42);\nconst bidB = MayInt.None(null);\n\nconst getBid = (m) => fromMaybe(m, (() => 0), ((x) => x));\nconst bidSum = getBid(bidA) + getBid(bidB);\nassert(bidSum == 42);\n```\n\n[Option types](https://en.wikipedia.org/wiki/Option_type) are represented in Reach through the built-in `Data` type, `Maybe`, which has two variants: `Some` and `None`.\n\n`Maybe` is defined by\n```javascript\nexport const Maybe = (A) => Data({None: Null, Some: A});\n```\n\nThis means it is a function that returns a `Data` type specialized to a particular type in the `Some` variant.\n\n`Maybe` instances can be conveniently consumed by `fromMaybe(mValue, onNone, onSome)`, where `onNone` is a function of no arguments which is called when `mValue` is `None`, `onSome` is a function of one argument which is called with the value when `mValue` is `Some`, and `mValue` is a data instance of `Maybe`.\n\n\n```javascript\nconst m = Maybe(UInt).Some(5);\nisNone(m); // false\nisSome(m); // true\n```\n\n `isNone` is a convenience method that determines whether the variant is `None`.\n\n `isSome` is a convenience method that determines whether the variant is `Some`.\n\n\n```javascript\nfromSome(Maybe(UInt).Some(1), 0); // 1\nfromSome(Maybe(UInt).None(), 0);  // 0\n```\n\n `fromSome` receives a `Maybe` value and a default value as arguments and will return the value inside\nof the `Some` variant or the default value otherwise.\n\n\n```javascript\nconst add1 = (x) => x + 1;\nmaybe(Maybe(UInt).Some(1), 0, add1); // 2\nmaybe(Maybe(UInt).None(), 0, add1);  // 0\n```\n\n `maybe(m, defaultVal, f)` receives a `Maybe` value, a default value, and a unary function as arguments. The function will\neither return the application of the function, `f`, to the `Some` value or return the default value provided.\n\nThe following examples demonstrate different usage of `Maybe`:\n\n```javascript\nconst MUInt = Maybe(UInt);\n```\n\n```javascript\n        interact.printBool(Maybe(UInt).Some(5) == Maybe(UInt).Some(5));\n```\n\n```javascript\n  var [ claimed_by, keep_going ] = [ Maybe(Address).None(), true ];\n```\n",
  "Neg": "\n```javascript\nconst Int = { sign: Bool, i: UInt };\nconst Pos = true;\nconst Neg = false;\n```\n\n `int(Bool, UInt)` is shorthand for defining an `Int` record. You may also\nuse the `+` and `-` unary operators to declare integers instead of `UInt`s.\n\n\n```javascript\nint(Pos, 4); // represents 4\nint(Neg, 4); // represents -4\n-4;          // represents -4\n+4;          // represents 4 : Int\n 4;          // represents 4 : UInt\n```\n\n\n `iadd(x, y)` adds the `Int` `x` and the `Int` `y`.\n\n\n `isub(x, y)` subtracts the `Int` `y` from the `Int` `x`.\n\n\n `imul(x, y)` multiplies the `Int` `x` and the `Int` `y`.\n\n\n `idiv(x, y)` divides the `Int` `x` by the `Int` `y`.\n\n\n `imod(x, y)` finds the remainder of dividing the `Int` `x` by the `Int` `y`.\n\n\n `ilt(x, y)` determines whether `x` is less than `y`.\n\n\n `ile(x, y)` determines whether `x` is less than or equal to `y`.\n\n\n `igt(x, y)` determines whether `x` is greather than `y`.\n\n\n `ige(x, y)` determines whether `x` is greater than or equal to `y`.\n\n\n `ieq(x, y)` determines whether `x` is equal to `y`.\n\n\n `ine(x, y)` determines whether `x` is not equal to `y`.\n\n\n `imax(x, y)` returns the larger of two `Int`s.\n\n\n `abs(i)` returns the absolute value of an `Int`. The return value is of type `UInt`.\n",
  "Null": " `Null`.\n+  `Bool`, which denotes a boolean.\n+  `UInt`, which denotes an unsigned integer.\n   `UInt.max` is the largest value that may be assigned to a `UInt`.\n+  `UInt256`, which denotes an unsigned integer with 256 bits.\n   `UInt256.max` is the largest value that may be assigned to a `UInt256`.\n+ `Int`, which denotes a signed integer.\n+ `FixedPoint`, which denotes a fractional number.\n+  `Bytes(length)`, which denotes a string of bytes of length at most `length`.\nBytes of different lengths are not compatible; however the shorter bytes may be [padded](https://docs.reach.sh/rsh/compute/#padding).\n+  `Digest`, which denotes a digest.\n+  `Address`, which denotes an account address.\n+  `Contract`, which denotes the identifying information of a contract.\n\n---\n**NOTE**\n\nReach has different representations of contracts across connectors.\nFor example, on Algorand a `Contract` is an Application ID, but on Ethereum it is an Address.\n\n---\n\n+  `Token`, which denotes a non-network token. [Networks](https://docs.reach.sh/networks/#ref-networks) discusses how `Token`s are represented on specific networks.\n\n---\n**NOTE**\n\nReach assumes that every `Token` in your program refers to a different non-network token.\nIt will automatically insert `require` statements that enforce this constraint.\n\n---\n\n+  `Fun([Domain_0, ..., Domain_N], Range)`, which denotes a function type, when `Domain_i` and `Range` are types.\nThe domain of a function is negative position.\nThe range of a function is positive position.\n+ `Fun(true, Range)`, which denotes an unconstrained domain function type, when `Range` is a type.\nThese functions may only appear in participant interact interfaces.\n+  `Tuple(Field_0, ..., FieldN)`, which denotes a tuple.\n(Refer to [Tuples](https://docs.reach.sh/rsh/compute/#ref-programs-tuples) for constructing tuples.)\n+  `Object({key_0: Type_0, ..., key_N: Type_N})`, which denotes an object.\n(Refer to [Objects](https://docs.reach.sh/rsh/compute/#ref-programs-objects) for constructing objects.)\n+  `Struct([[key_0, Type_0], ..., [key_N, Type_N]])`, which denotes a struct.\n(Refer to [Structs](https://docs.reach.sh/rsh/compute/#ref-programs-structs) for constructing structs.)\n+  `Array(Type_0, size)`, which denotes a statically-sized array.\n`Type_0` must be a type that can exist at runtime (i.e., not a function type.)\n(Refer to [Arrays](https://docs.reach.sh/rsh/compute/#ref-programs-arrays) for constructing arrays.)\n+  `Data({variant_0: Type_0, ..., variant_N: Type_N})`, which denotes a [tagged union](https://en.wikipedia.org/wiki/Tagged_union) (or _sum type_).\n(Refer to [Data](https://docs.reach.sh/rsh/compute/#ref-programs-data) for constructing data instances.)\n+  `Refine(Type_0, Predicate, ?Message)`, where `Predicate` is a unary function returning a boolean, which denotes a [refinement type](https://en.wikipedia.org/wiki/Refinement_type), that is instances of `Type_0` that satisfy `Predicate`.\nWhen a refinement type appears in a negative position (such as in an `is` or in the domain of a `Fun` of a participant interact interface), it introduces an `assert`;\nwhile when it is in a positive position, it introduces an `assume`.\n`Message` is an optional string to display if the predicate fails verification.\n\nFor example, if `f` had type\n```javascript\nFun([Refine(UInt, (x => x < 5))], Refine(UInt, (x => x > 10)))\n```\n\nthen `const z = f(y)` is equivalent to\n\n```javascript\nassert(y < 5);\nconst z = f(y);\nassume(z > 10);\n```\n\n+ `Refine(Type_0, PreCondition, PostCondition, ?Messages)`, where `Type_0` is a function type, `PreCondition` is a unary function that accepts a tuple of the domain and returns a boolean, and `PostCondition` is a binary function that accepts a tuple of the domain and the range and returns a boolean, denotes a function type with a [precondition](https://en.wikipedia.org/wiki/Precondition) and [postcondition](https://en.wikipedia.org/wiki/Postcondition).\nPreconditions are enforced with `assert` and postconditions are enforced with `assume`.\n`Messages` is an optional two-tuple of `Bytes`.\nThe first message will be displayed when the precondition fails verification and the second when the postcondition fails verification.\n\nFor example, `Refine(Fun([UInt, UInt], UInt), ([x, y] => x < y), (([x, y], z) => x + y < z))` is a function that requires its second argument to be larger than its first and its result to be larger than its input.\n\n`Object` and `Data` are commonly used to implemented [algebraic data types](https://en.wikipedia.org/wiki/Algebraic_data_type) in Reach.\n\n\n```javascript\ntypeOf(x) // type\nisType(t) // Bool\nis(x, t) // t\n```\n\nThe `typeOf` primitive function is the same as `typeof`:\nit returns the type of its argument.\n\nThe `isType` function returns `true` if its argument is a type.\nAny expression satisfying `isType` is compiled away and does not exist at runtime.\n\nThe `is` function returns its first argument if it satisfies the type specified by the second argument.\nIf it is not, then the program is invalid.\nFor example, `is(5, UInt)` returns `5`, while `is(5, Bool)` is an invalid program.\nThe value returned by `is` may not be identical to the input, because in some cases, such as for functions, it will record the applied to type and enforce it on future invocations.\nThese applications are considered negative positions for `Refine`.\n",
  "Object": " `Object({key_0: Type_0, ..., key_N: Type_N})`, which denotes an object.\n(Refer to [Objects](https://docs.reach.sh/rsh/compute/#ref-programs-objects) for constructing objects.)\n+  `Struct([[key_0, Type_0], ..., [key_N, Type_N]])`, which denotes a struct.\n(Refer to [Structs](https://docs.reach.sh/rsh/compute/#ref-programs-structs) for constructing structs.)\n+  `Array(Type_0, size)`, which denotes a statically-sized array.\n`Type_0` must be a type that can exist at runtime (i.e., not a function type.)\n(Refer to [Arrays](https://docs.reach.sh/rsh/compute/#ref-programs-arrays) for constructing arrays.)\n+  `Data({variant_0: Type_0, ..., variant_N: Type_N})`, which denotes a [tagged union](https://en.wikipedia.org/wiki/Tagged_union) (or _sum type_).\n(Refer to [Data](https://docs.reach.sh/rsh/compute/#ref-programs-data) for constructing data instances.)\n+  `Refine(Type_0, Predicate, ?Message)`, where `Predicate` is a unary function returning a boolean, which denotes a [refinement type](https://en.wikipedia.org/wiki/Refinement_type), that is instances of `Type_0` that satisfy `Predicate`.\nWhen a refinement type appears in a negative position (such as in an `is` or in the domain of a `Fun` of a participant interact interface), it introduces an `assert`;\nwhile when it is in a positive position, it introduces an `assume`.\n`Message` is an optional string to display if the predicate fails verification.\n\nFor example, if `f` had type\n```javascript\nFun([Refine(UInt, (x => x < 5))], Refine(UInt, (x => x > 10)))\n```\n\nthen `const z = f(y)` is equivalent to\n\n```javascript\nassert(y < 5);\nconst z = f(y);\nassume(z > 10);\n```\n\n+ `Refine(Type_0, PreCondition, PostCondition, ?Messages)`, where `Type_0` is a function type, `PreCondition` is a unary function that accepts a tuple of the domain and returns a boolean, and `PostCondition` is a binary function that accepts a tuple of the domain and the range and returns a boolean, denotes a function type with a [precondition](https://en.wikipedia.org/wiki/Precondition) and [postcondition](https://en.wikipedia.org/wiki/Postcondition).\nPreconditions are enforced with `assert` and postconditions are enforced with `assume`.\n`Messages` is an optional two-tuple of `Bytes`.\nThe first message will be displayed when the precondition fails verification and the second when the postcondition fails verification.\n\nFor example, `Refine(Fun([UInt, UInt], UInt), ([x, y] => x < y), (([x, y], z) => x + y < z))` is a function that requires its second argument to be larger than its first and its result to be larger than its input.\n\n`Object` and `Data` are commonly used to implemented [algebraic data types](https://en.wikipedia.org/wiki/Algebraic_data_type) in Reach.\n\n\n```javascript\ntypeOf(x) // type\nisType(t) // Bool\nis(x, t) // t\n```\n\nThe `typeOf` primitive function is the same as `typeof`:\nit returns the type of its argument.\n\nThe `isType` function returns `true` if its argument is a type.\nAny expression satisfying `isType` is compiled away and does not exist at runtime.\n\nThe `is` function returns its first argument if it satisfies the type specified by the second argument.\nIf it is not, then the program is invalid.\nFor example, `is(5, UInt)` returns `5`, while `is(5, Bool)` is an invalid program.\nThe value returned by `is` may not be identical to the input, because in some cases, such as for functions, it will record the applied to type and enforce it on future invocations.\nThese applications are considered negative positions for `Refine`.\n",
  "Object.has": "\n```javascript\nObject.has(obj, fld);\n```\n\n Returns a boolean indicating whether the object has the field `fld`.\nThis is statically known.\n",
  "Object.set": "\n@{ref(\"rsh\", \"Object_set\")}\n```javascript\nObject.set(obj, fld, val);\nObject_set(obj, fld, val);\n{ ...obj, [fld]: val };\n```\n\n Returns a new object identical to `obj`,\nexcept that field `fld` is replaced with `val`.\n",
  "Object.setIfUnset": "\n@{ref(\"rsh\", \"Object_setIfUnset\")}\n```javascript\nObject.setIfUnset(obj, fld, val);\nObject_setIfUnset(obj, fld, val);\n```\n\n Returns a new object identical to `obj`,\nexcept that field `fld` is `val` if `fld` is not already present in `obj`.\n",
  "Open": "\n```javascript\nexport const [ isIntervalType, Closed, Open ] = mkEnum(2);\nexport const IntervalType = Refine(UInt, isIntervalType);\n```\n",
  "Participant": "\n```javascript\nParticipant(participantName, participantInteractInterface)\n```\n\nand\n\n\n```javascript\nParticipantClass(participantName, participantInteractInterface)\n```\n\nrespectively.\n\n---\n**NOTE**\n \nSince `ParticipantClass` is being deprecated, it is preferable to use `API`.\n\n---\n\n`participantName` is a string which indicates the name of the participant function in the generated backend code.\nEach `participantName` must be unique.\n\n`participantInteractInterface` is a participant interact interface, an object where each field indicates the type of a function or value which must be provided to the backend by the frontend for interacting with the participant.\n\nIn the [Rock, Paper, and Scissors](https://docs.reach.sh/tut/rps/#tut-3) tutorial, Alice and Bob receive the `getHand` and `seeOutcome` interact interfaces from the construct `Player` in the following sample code:\n\n```\n'reach 0.1';\n\nconst Player = {\n  getHand: Fun([], UInt),\n  seeOutcome: Fun([UInt], Null),\n};\n\nexport const main = Reach.App(() => {\n  const Alice = Participant('Alice', {\n    ...Player,\n  });\n  const Bob   = Participant('Bob', {\n    ...Player,\n  });\n```\n",
  "Participant.set": "\n```javascript\nParticipant.set(PART, ADDR);\nPART.set(ADDR);\n```\n\n After execution, the given participant is fixed to the given address.\nIt is invalid to attempt to `.set` a participant class.\nIf a backend is running for this participant and its address does not match the given address, then it will abort.\nThis may only occur within a consensus step.\n\n---\n**NOTE**\n\n[Relay Account](https://docs.reach.sh/workshop/relay/#workshop-relay) is a good introductory project that demonstrates how to use this feature of Reach.\n\n---\n",
  "ParticipantClass": "\n```javascript\nParticipantClass(participantName, participantInteractInterface)\n```\n\nrespectively.\n\n---\n**NOTE**\n \nSince `ParticipantClass` is being deprecated, it is preferable to use `API`.\n\n---\n\n`participantName` is a string which indicates the name of the participant function in the generated backend code.\nEach `participantName` must be unique.\n\n`participantInteractInterface` is a participant interact interface, an object where each field indicates the type of a function or value which must be provided to the backend by the frontend for interacting with the participant.\n\nIn the [Rock, Paper, and Scissors](https://docs.reach.sh/tut/rps/#tut-3) tutorial, Alice and Bob receive the `getHand` and `seeOutcome` interact interfaces from the construct `Player` in the following sample code:\n\n```\n'reach 0.1';\n\nconst Player = {\n  getHand: Fun([], UInt),\n  seeOutcome: Fun([UInt], Null),\n};\n\nexport const main = Reach.App(() => {\n  const Alice = Participant('Alice', {\n    ...Player,\n  });\n  const Bob   = Participant('Bob', {\n    ...Player,\n  });\n```\n",
  "Pos": "\n```javascript\nconst Int = { sign: Bool, i: UInt };\nconst Pos = true;\nconst Neg = false;\n```\n\n `int(Bool, UInt)` is shorthand for defining an `Int` record. You may also\nuse the `+` and `-` unary operators to declare integers instead of `UInt`s.\n\n\n```javascript\nint(Pos, 4); // represents 4\nint(Neg, 4); // represents -4\n-4;          // represents -4\n+4;          // represents 4 : Int\n 4;          // represents 4 : UInt\n```\n\n\n `iadd(x, y)` adds the `Int` `x` and the `Int` `y`.\n\n\n `isub(x, y)` subtracts the `Int` `y` from the `Int` `x`.\n\n\n `imul(x, y)` multiplies the `Int` `x` and the `Int` `y`.\n\n\n `idiv(x, y)` divides the `Int` `x` by the `Int` `y`.\n\n\n `imod(x, y)` finds the remainder of dividing the `Int` `x` by the `Int` `y`.\n\n\n `ilt(x, y)` determines whether `x` is less than `y`.\n\n\n `ile(x, y)` determines whether `x` is less than or equal to `y`.\n\n\n `igt(x, y)` determines whether `x` is greather than `y`.\n\n\n `ige(x, y)` determines whether `x` is greater than or equal to `y`.\n\n\n `ieq(x, y)` determines whether `x` is equal to `y`.\n\n\n `ine(x, y)` determines whether `x` is not equal to `y`.\n\n\n `imax(x, y)` returns the larger of two `Int`s.\n\n\n `abs(i)` returns the absolute value of an `Int`. The return value is of type `UInt`.\n",
  "Reach": "\n```javascript\nexport const main = Reach.App(() => {\n const A = Participant(\"A\", {\n  displayResult: Fun(Int, Null),\n });\n init();\n\n const result = 0;\n A.only(() => { interact.displayResult(result); });\n\n exit();\n});\n```\n\nReach.App accepts a no-argument function that specifies a DApp.\nThis function is applied during compilation as an application initialization.\nIt specifies the entire DApp in its body.\n\nIf the result of `Reach.App` is eventually bound to an identifier that is exported, then that identifier may be a target given to the compiler, as discussed in [the section on usage](https://docs.reach.sh/tool/#ref-usage-compile).\n",
  "Reach.App": "\n```javascript\nexport const main = Reach.App(() => {\n const A = Participant(\"A\", {\n  displayResult: Fun(Int, Null),\n });\n init();\n\n const result = 0;\n A.only(() => { interact.displayResult(result); });\n\n exit();\n});\n```\n\nReach.App accepts a no-argument function that specifies a DApp.\nThis function is applied during compilation as an application initialization.\nIt specifies the entire DApp in its body.\n\nIf the result of `Reach.App` is eventually bound to an identifier that is exported, then that identifier may be a target given to the compiler, as discussed in [the section on usage](https://docs.reach.sh/tool/#ref-usage-compile).\n",
  "Refine": " `Refine(Type_0, Predicate, ?Message)`, where `Predicate` is a unary function returning a boolean, which denotes a [refinement type](https://en.wikipedia.org/wiki/Refinement_type), that is instances of `Type_0` that satisfy `Predicate`.\nWhen a refinement type appears in a negative position (such as in an `is` or in the domain of a `Fun` of a participant interact interface), it introduces an `assert`;\nwhile when it is in a positive position, it introduces an `assume`.\n`Message` is an optional string to display if the predicate fails verification.\n\nFor example, if `f` had type\n```javascript\nFun([Refine(UInt, (x => x < 5))], Refine(UInt, (x => x > 10)))\n```\n\nthen `const z = f(y)` is equivalent to\n\n```javascript\nassert(y < 5);\nconst z = f(y);\nassume(z > 10);\n```\n\n+ `Refine(Type_0, PreCondition, PostCondition, ?Messages)`, where `Type_0` is a function type, `PreCondition` is a unary function that accepts a tuple of the domain and returns a boolean, and `PostCondition` is a binary function that accepts a tuple of the domain and the range and returns a boolean, denotes a function type with a [precondition](https://en.wikipedia.org/wiki/Precondition) and [postcondition](https://en.wikipedia.org/wiki/Postcondition).\nPreconditions are enforced with `assert` and postconditions are enforced with `assume`.\n`Messages` is an optional two-tuple of `Bytes`.\nThe first message will be displayed when the precondition fails verification and the second when the postcondition fails verification.\n\nFor example, `Refine(Fun([UInt, UInt], UInt), ([x, y] => x < y), (([x, y], z) => x + y < z))` is a function that requires its second argument to be larger than its first and its result to be larger than its input.\n\n`Object` and `Data` are commonly used to implemented [algebraic data types](https://en.wikipedia.org/wiki/Algebraic_data_type) in Reach.\n\n\n```javascript\ntypeOf(x) // type\nisType(t) // Bool\nis(x, t) // t\n```\n\nThe `typeOf` primitive function is the same as `typeof`:\nit returns the type of its argument.\n\nThe `isType` function returns `true` if its argument is a type.\nAny expression satisfying `isType` is compiled away and does not exist at runtime.\n\nThe `is` function returns its first argument if it satisfies the type specified by the second argument.\nIf it is not, then the program is invalid.\nFor example, `is(5, UInt)` returns `5`, while `is(5, Bool)` is an invalid program.\nThe value returned by `is` may not be identical to the input, because in some cases, such as for functions, it will record the applied to type and enforce it on future invocations.\nThese applications are considered negative positions for `Refine`.\n",
  "Set": "\n\n\n\n\n```javascript\nconst bidders = new Set();\nbidders.insert(Alice);\nbidders.Map.size(); // 1\nbidders.remove(Alice);\nbidders.member(Alice); // false\nbidders.Map.size(); // 0\n```\n\nA `Set` is another container for linear state. It is simply a type alias of `Map(Null)`;\nit is only useful for tracking `Address`es. Because a `Set` is internally a `Map`, it may\nonly be constructed in a consensus step.\n\nA `Set` may be modified by writing `s.insert(ADDRESS)` to install `ADDRESS` in the\nset, `s`, or `s.remove(ADDRESS)` to remove the `ADDRESS` from the set.\nSuch modifications may only occur in a consensus step.\n\n`s.member(ADDRESS)` will return a `Bool` representing whether the address is in the set.\n\n`s.Map` will return the underlying `Map`, so you can use foldable\ninstance methods.",
  "Set.new": "\n\n`new f(a)` is equivalent to `f.new(a)` and is a convenient short-hand for writing class-oriented programs.\n",
  "Struct": " `Struct([[key_0, Type_0], ..., [key_N, Type_N]])`, which denotes a struct.\n(Refer to [Structs](https://docs.reach.sh/rsh/compute/#ref-programs-structs) for constructing structs.)\n+  `Array(Type_0, size)`, which denotes a statically-sized array.\n`Type_0` must be a type that can exist at runtime (i.e., not a function type.)\n(Refer to [Arrays](https://docs.reach.sh/rsh/compute/#ref-programs-arrays) for constructing arrays.)\n+  `Data({variant_0: Type_0, ..., variant_N: Type_N})`, which denotes a [tagged union](https://en.wikipedia.org/wiki/Tagged_union) (or _sum type_).\n(Refer to [Data](https://docs.reach.sh/rsh/compute/#ref-programs-data) for constructing data instances.)\n+  `Refine(Type_0, Predicate, ?Message)`, where `Predicate` is a unary function returning a boolean, which denotes a [refinement type](https://en.wikipedia.org/wiki/Refinement_type), that is instances of `Type_0` that satisfy `Predicate`.\nWhen a refinement type appears in a negative position (such as in an `is` or in the domain of a `Fun` of a participant interact interface), it introduces an `assert`;\nwhile when it is in a positive position, it introduces an `assume`.\n`Message` is an optional string to display if the predicate fails verification.\n\nFor example, if `f` had type\n```javascript\nFun([Refine(UInt, (x => x < 5))], Refine(UInt, (x => x > 10)))\n```\n\nthen `const z = f(y)` is equivalent to\n\n```javascript\nassert(y < 5);\nconst z = f(y);\nassume(z > 10);\n```\n\n+ `Refine(Type_0, PreCondition, PostCondition, ?Messages)`, where `Type_0` is a function type, `PreCondition` is a unary function that accepts a tuple of the domain and returns a boolean, and `PostCondition` is a binary function that accepts a tuple of the domain and the range and returns a boolean, denotes a function type with a [precondition](https://en.wikipedia.org/wiki/Precondition) and [postcondition](https://en.wikipedia.org/wiki/Postcondition).\nPreconditions are enforced with `assert` and postconditions are enforced with `assume`.\n`Messages` is an optional two-tuple of `Bytes`.\nThe first message will be displayed when the precondition fails verification and the second when the postcondition fails verification.\n\nFor example, `Refine(Fun([UInt, UInt], UInt), ([x, y] => x < y), (([x, y], z) => x + y < z))` is a function that requires its second argument to be larger than its first and its result to be larger than its input.\n\n`Object` and `Data` are commonly used to implemented [algebraic data types](https://en.wikipedia.org/wiki/Algebraic_data_type) in Reach.\n\n\n```javascript\ntypeOf(x) // type\nisType(t) // Bool\nis(x, t) // t\n```\n\nThe `typeOf` primitive function is the same as `typeof`:\nit returns the type of its argument.\n\nThe `isType` function returns `true` if its argument is a type.\nAny expression satisfying `isType` is compiled away and does not exist at runtime.\n\nThe `is` function returns its first argument if it satisfies the type specified by the second argument.\nIf it is not, then the program is invalid.\nFor example, `is(5, UInt)` returns `5`, while `is(5, Bool)` is an invalid program.\nThe value returned by `is` may not be identical to the input, because in some cases, such as for functions, it will record the applied to type and enforce it on future invocations.\nThese applications are considered negative positions for `Refine`.\n",
  "Struct.toObject": "\n\n```javascript\nconst Posn = Struct([[\"x\", UInt], [\"y\", UInt]]);\nconst p1 = Posn.fromObject({x: 1, y: 2});\nconst p2 = Posn.fromTuple([1, 2]);\n```\n\nA struct is a combination of a tuple and an object.\nIt has named elements, like an object, but is ordered like a tuple, so its elements may be accessed by either name or position.\nStructs exist for interfacing with non-Reach remote objects, where both parties must agree to the runtime representation of the values.\n\nA struct instance may be constructed by calling the `fromTuple` method of a struct type instance (like `Posn`) with a tuple of the appropriate length.\n\nA struct instance may be constructed by calling the `fromObject` method of a struct type instance (like `Posn`) with an object with the appropriate fields.\n\nStructs may be converted into a corresponding tuple or object via the `toTuple` and `toObject` methods on the `Struct` value (as well as struct type instances, like `Posn` in the example above):\n\n```javascript\nassert(Posn.toTuple(p1)[0] == 1);\nassert(Struct.toObject(p2).y == 2);\n```\n\nThe names of elements may be restricted to avoid conflicting with reserved words of the specified connectors.\n",
  "Struct.toTuple": "\n```javascript\nconst Posn = Struct([[\"x\", UInt], [\"y\", UInt]]);\nconst p1 = Posn.fromObject({x: 1, y: 2});\nconst p2 = Posn.fromTuple([1, 2]);\n```\n\nA struct is a combination of a tuple and an object.\nIt has named elements, like an object, but is ordered like a tuple, so its elements may be accessed by either name or position.\nStructs exist for interfacing with non-Reach remote objects, where both parties must agree to the runtime representation of the values.\n\nA struct instance may be constructed by calling the `fromTuple` method of a struct type instance (like `Posn`) with a tuple of the appropriate length.\n\nA struct instance may be constructed by calling the `fromObject` method of a struct type instance (like `Posn`) with an object with the appropriate fields.\n\nStructs may be converted into a corresponding tuple or object via the `toTuple` and `toObject` methods on the `Struct` value (as well as struct type instances, like `Posn` in the example above):\n\n```javascript\nassert(Posn.toTuple(p1)[0] == 1);\nassert(Struct.toObject(p2).y == 2);\n```\n\nThe names of elements may be restricted to avoid conflicting with reserved words of the specified connectors.\n",
  "Token": " `Token`, which denotes a non-network token. [Networks](https://docs.reach.sh/networks/#ref-networks) discusses how `Token`s are represented on specific networks.\n\n---\n**NOTE**\n\nReach assumes that every `Token` in your program refers to a different non-network token.\nIt will automatically insert `require` statements that enforce this constraint.\n\n---\n\n+  `Fun([Domain_0, ..., Domain_N], Range)`, which denotes a function type, when `Domain_i` and `Range` are types.\nThe domain of a function is negative position.\nThe range of a function is positive position.\n+ `Fun(true, Range)`, which denotes an unconstrained domain function type, when `Range` is a type.\nThese functions may only appear in participant interact interfaces.\n+  `Tuple(Field_0, ..., FieldN)`, which denotes a tuple.\n(Refer to [Tuples](https://docs.reach.sh/rsh/compute/#ref-programs-tuples) for constructing tuples.)\n+  `Object({key_0: Type_0, ..., key_N: Type_N})`, which denotes an object.\n(Refer to [Objects](https://docs.reach.sh/rsh/compute/#ref-programs-objects) for constructing objects.)\n+  `Struct([[key_0, Type_0], ..., [key_N, Type_N]])`, which denotes a struct.\n(Refer to [Structs](https://docs.reach.sh/rsh/compute/#ref-programs-structs) for constructing structs.)\n+  `Array(Type_0, size)`, which denotes a statically-sized array.\n`Type_0` must be a type that can exist at runtime (i.e., not a function type.)\n(Refer to [Arrays](https://docs.reach.sh/rsh/compute/#ref-programs-arrays) for constructing arrays.)\n+  `Data({variant_0: Type_0, ..., variant_N: Type_N})`, which denotes a [tagged union](https://en.wikipedia.org/wiki/Tagged_union) (or _sum type_).\n(Refer to [Data](https://docs.reach.sh/rsh/compute/#ref-programs-data) for constructing data instances.)\n+  `Refine(Type_0, Predicate, ?Message)`, where `Predicate` is a unary function returning a boolean, which denotes a [refinement type](https://en.wikipedia.org/wiki/Refinement_type), that is instances of `Type_0` that satisfy `Predicate`.\nWhen a refinement type appears in a negative position (such as in an `is` or in the domain of a `Fun` of a participant interact interface), it introduces an `assert`;\nwhile when it is in a positive position, it introduces an `assume`.\n`Message` is an optional string to display if the predicate fails verification.\n\nFor example, if `f` had type\n```javascript\nFun([Refine(UInt, (x => x < 5))], Refine(UInt, (x => x > 10)))\n```\n\nthen `const z = f(y)` is equivalent to\n\n```javascript\nassert(y < 5);\nconst z = f(y);\nassume(z > 10);\n```\n\n+ `Refine(Type_0, PreCondition, PostCondition, ?Messages)`, where `Type_0` is a function type, `PreCondition` is a unary function that accepts a tuple of the domain and returns a boolean, and `PostCondition` is a binary function that accepts a tuple of the domain and the range and returns a boolean, denotes a function type with a [precondition](https://en.wikipedia.org/wiki/Precondition) and [postcondition](https://en.wikipedia.org/wiki/Postcondition).\nPreconditions are enforced with `assert` and postconditions are enforced with `assume`.\n`Messages` is an optional two-tuple of `Bytes`.\nThe first message will be displayed when the precondition fails verification and the second when the postcondition fails verification.\n\nFor example, `Refine(Fun([UInt, UInt], UInt), ([x, y] => x < y), (([x, y], z) => x + y < z))` is a function that requires its second argument to be larger than its first and its result to be larger than its input.\n\n`Object` and `Data` are commonly used to implemented [algebraic data types](https://en.wikipedia.org/wiki/Algebraic_data_type) in Reach.\n\n\n```javascript\ntypeOf(x) // type\nisType(t) // Bool\nis(x, t) // t\n```\n\nThe `typeOf` primitive function is the same as `typeof`:\nit returns the type of its argument.\n\nThe `isType` function returns `true` if its argument is a type.\nAny expression satisfying `isType` is compiled away and does not exist at runtime.\n\nThe `is` function returns its first argument if it satisfies the type specified by the second argument.\nIf it is not, then the program is invalid.\nFor example, `is(5, UInt)` returns `5`, while `is(5, Bool)` is an invalid program.\nThe value returned by `is` may not be identical to the input, because in some cases, such as for functions, it will record the applied to type and enforce it on future invocations.\nThese applications are considered negative positions for `Refine`.\n",
  "Token.burn": "\n\n\n\n\n\n\n```javascript\nrequire(supply >= 2 * amt);\nconst tok = new Token({ name, symbol, url, metadata, supply, decimals });\ntransfer(amt, tok).to(who);\ntok.burn(amt);\nassert(tok.supply() == supply - amt);\ntok.burn();\nassert(tok.destroyed() == false);\ntok.destroy();\n```\n\n---\n**NOTE**\n\n[Networks](https://docs.reach.sh/networks/#ref-networks) discusses how Reach supports token minting on specific consensus networks.\n\n---\n\nWe refer to creation of a new non-network token as token minting.\nIt is written with the expression `new Token(PARAMS)`, where `PARAMS` is an object with the following keys:\n+ `name`: A value of type `Bytes(32)`; defaults to empty.\n+ `symbol`: A value of type `Bytes(8)`; defaults to empty.\n+ `url`: A value of type `Bytes(96)`; defaults to empty.\n+ `metadata`: A value of type `Bytes(32)`; defaults to empty.\nThis value is intended to be a digest of a larger metadata document.\n+ `supply`: A value of type `UInt`; defaults to `UInt.max`.\n+ `decimals`: A value of type `UInt`; defaults to `6` on Algorand, and `18` on Ethereum and Conflux.\n\nThe following examples demonstrate how the details above may be used:\n```javascript\n  A.publish(decimals);\n\n  const supply = UInt.max;\n  const t = new Token({ supply, decimals });\n```\n\n```javascript\n  A.publish(name, symbol, url, metadata, supply, amt);\n  require(4 * amt <= supply);\n  require(4 * amt <= UInt.max);\n\n  const md1 = {name, symbol, url, metadata, supply};\n  const tok1 = new Token(md1);\n```\n\nThis returns a `Token` value and deposits a `supply` amount of the new non-network tokens into the contract account associated with the DApp.\nThese tokens must be destroyed by the end of the DApp.\n\n---\n**NOTE**\n\nReach assumes that network tokens and non-network tokens behave identically, but often they do not; [this article](https://docs.reach.sh/guide/nntoks/#guide-nntoks) discusses the causes and consequences of this.\n\n---\n\n---\n\n`Token.burn(tok, amt)`, or `tok.burn(amt)`, where `tok` is a `Token` value and `amt` is a `UInt` value, may be used to burn tokens in the contract account, meaning that they are utterly destroyed and can never be recovered.\n\n---\n\n`Token.destroy(tok)`, or `tok.destroy()`, where `tok` is a `Token` value, may be used to destroy the token so that it may never be used again by any users on the consensus network.\nThis must be called before the application exits.\n\n---\n\n`Token.destroyed(tok)`, or `tok.destroyed()`, where `tok` is a `Token` value, returns whether `destroy`\nhas been called on `tok` yet.\n\n---\n\n`Token.supply(tok)`, or `tok.supply()`, where `tok` is a `Token` value, may be used to query the current supply of tokens, i.e. the number of tokens which have not been burnt.\n",
  "Token.destroy": "\n\n\n\n\n```javascript\nrequire(supply >= 2 * amt);\nconst tok = new Token({ name, symbol, url, metadata, supply, decimals });\ntransfer(amt, tok).to(who);\ntok.burn(amt);\nassert(tok.supply() == supply - amt);\ntok.burn();\nassert(tok.destroyed() == false);\ntok.destroy();\n```\n\n---\n**NOTE**\n\n[Networks](https://docs.reach.sh/networks/#ref-networks) discusses how Reach supports token minting on specific consensus networks.\n\n---\n\nWe refer to creation of a new non-network token as token minting.\nIt is written with the expression `new Token(PARAMS)`, where `PARAMS` is an object with the following keys:\n+ `name`: A value of type `Bytes(32)`; defaults to empty.\n+ `symbol`: A value of type `Bytes(8)`; defaults to empty.\n+ `url`: A value of type `Bytes(96)`; defaults to empty.\n+ `metadata`: A value of type `Bytes(32)`; defaults to empty.\nThis value is intended to be a digest of a larger metadata document.\n+ `supply`: A value of type `UInt`; defaults to `UInt.max`.\n+ `decimals`: A value of type `UInt`; defaults to `6` on Algorand, and `18` on Ethereum and Conflux.\n\nThe following examples demonstrate how the details above may be used:\n```javascript\n  A.publish(decimals);\n\n  const supply = UInt.max;\n  const t = new Token({ supply, decimals });\n```\n\n```javascript\n  A.publish(name, symbol, url, metadata, supply, amt);\n  require(4 * amt <= supply);\n  require(4 * amt <= UInt.max);\n\n  const md1 = {name, symbol, url, metadata, supply};\n  const tok1 = new Token(md1);\n```\n\nThis returns a `Token` value and deposits a `supply` amount of the new non-network tokens into the contract account associated with the DApp.\nThese tokens must be destroyed by the end of the DApp.\n\n---\n**NOTE**\n\nReach assumes that network tokens and non-network tokens behave identically, but often they do not; [this article](https://docs.reach.sh/guide/nntoks/#guide-nntoks) discusses the causes and consequences of this.\n\n---\n\n---\n\n`Token.burn(tok, amt)`, or `tok.burn(amt)`, where `tok` is a `Token` value and `amt` is a `UInt` value, may be used to burn tokens in the contract account, meaning that they are utterly destroyed and can never be recovered.\n\n---\n\n`Token.destroy(tok)`, or `tok.destroy()`, where `tok` is a `Token` value, may be used to destroy the token so that it may never be used again by any users on the consensus network.\nThis must be called before the application exits.\n\n---\n\n`Token.destroyed(tok)`, or `tok.destroyed()`, where `tok` is a `Token` value, returns whether `destroy`\nhas been called on `tok` yet.\n\n---\n\n`Token.supply(tok)`, or `tok.supply()`, where `tok` is a `Token` value, may be used to query the current supply of tokens, i.e. the number of tokens which have not been burnt.\n",
  "Token.destroyed": "\n```javascript\nrequire(supply >= 2 * amt);\nconst tok = new Token({ name, symbol, url, metadata, supply, decimals });\ntransfer(amt, tok).to(who);\ntok.burn(amt);\nassert(tok.supply() == supply - amt);\ntok.burn();\nassert(tok.destroyed() == false);\ntok.destroy();\n```\n\n---\n**NOTE**\n\n[Networks](https://docs.reach.sh/networks/#ref-networks) discusses how Reach supports token minting on specific consensus networks.\n\n---\n\nWe refer to creation of a new non-network token as token minting.\nIt is written with the expression `new Token(PARAMS)`, where `PARAMS` is an object with the following keys:\n+ `name`: A value of type `Bytes(32)`; defaults to empty.\n+ `symbol`: A value of type `Bytes(8)`; defaults to empty.\n+ `url`: A value of type `Bytes(96)`; defaults to empty.\n+ `metadata`: A value of type `Bytes(32)`; defaults to empty.\nThis value is intended to be a digest of a larger metadata document.\n+ `supply`: A value of type `UInt`; defaults to `UInt.max`.\n+ `decimals`: A value of type `UInt`; defaults to `6` on Algorand, and `18` on Ethereum and Conflux.\n\nThe following examples demonstrate how the details above may be used:\n```javascript\n  A.publish(decimals);\n\n  const supply = UInt.max;\n  const t = new Token({ supply, decimals });\n```\n\n```javascript\n  A.publish(name, symbol, url, metadata, supply, amt);\n  require(4 * amt <= supply);\n  require(4 * amt <= UInt.max);\n\n  const md1 = {name, symbol, url, metadata, supply};\n  const tok1 = new Token(md1);\n```\n\nThis returns a `Token` value and deposits a `supply` amount of the new non-network tokens into the contract account associated with the DApp.\nThese tokens must be destroyed by the end of the DApp.\n\n---\n**NOTE**\n\nReach assumes that network tokens and non-network tokens behave identically, but often they do not; [this article](https://docs.reach.sh/guide/nntoks/#guide-nntoks) discusses the causes and consequences of this.\n\n---\n\n---\n\n`Token.burn(tok, amt)`, or `tok.burn(amt)`, where `tok` is a `Token` value and `amt` is a `UInt` value, may be used to burn tokens in the contract account, meaning that they are utterly destroyed and can never be recovered.\n\n---\n\n`Token.destroy(tok)`, or `tok.destroy()`, where `tok` is a `Token` value, may be used to destroy the token so that it may never be used again by any users on the consensus network.\nThis must be called before the application exits.\n\n---\n\n`Token.destroyed(tok)`, or `tok.destroyed()`, where `tok` is a `Token` value, returns whether `destroy`\nhas been called on `tok` yet.\n\n---\n\n`Token.supply(tok)`, or `tok.supply()`, where `tok` is a `Token` value, may be used to query the current supply of tokens, i.e. the number of tokens which have not been burnt.\n",
  "Token.new": "\n`new f(a)` is equivalent to `f.new(a)` and is a convenient short-hand for writing class-oriented programs.\n",
  "Token.supply": "\n\n\n```javascript\nrequire(supply >= 2 * amt);\nconst tok = new Token({ name, symbol, url, metadata, supply, decimals });\ntransfer(amt, tok).to(who);\ntok.burn(amt);\nassert(tok.supply() == supply - amt);\ntok.burn();\nassert(tok.destroyed() == false);\ntok.destroy();\n```\n\n---\n**NOTE**\n\n[Networks](https://docs.reach.sh/networks/#ref-networks) discusses how Reach supports token minting on specific consensus networks.\n\n---\n\nWe refer to creation of a new non-network token as token minting.\nIt is written with the expression `new Token(PARAMS)`, where `PARAMS` is an object with the following keys:\n+ `name`: A value of type `Bytes(32)`; defaults to empty.\n+ `symbol`: A value of type `Bytes(8)`; defaults to empty.\n+ `url`: A value of type `Bytes(96)`; defaults to empty.\n+ `metadata`: A value of type `Bytes(32)`; defaults to empty.\nThis value is intended to be a digest of a larger metadata document.\n+ `supply`: A value of type `UInt`; defaults to `UInt.max`.\n+ `decimals`: A value of type `UInt`; defaults to `6` on Algorand, and `18` on Ethereum and Conflux.\n\nThe following examples demonstrate how the details above may be used:\n```javascript\n  A.publish(decimals);\n\n  const supply = UInt.max;\n  const t = new Token({ supply, decimals });\n```\n\n```javascript\n  A.publish(name, symbol, url, metadata, supply, amt);\n  require(4 * amt <= supply);\n  require(4 * amt <= UInt.max);\n\n  const md1 = {name, symbol, url, metadata, supply};\n  const tok1 = new Token(md1);\n```\n\nThis returns a `Token` value and deposits a `supply` amount of the new non-network tokens into the contract account associated with the DApp.\nThese tokens must be destroyed by the end of the DApp.\n\n---\n**NOTE**\n\nReach assumes that network tokens and non-network tokens behave identically, but often they do not; [this article](https://docs.reach.sh/guide/nntoks/#guide-nntoks) discusses the causes and consequences of this.\n\n---\n\n---\n\n`Token.burn(tok, amt)`, or `tok.burn(amt)`, where `tok` is a `Token` value and `amt` is a `UInt` value, may be used to burn tokens in the contract account, meaning that they are utterly destroyed and can never be recovered.\n\n---\n\n`Token.destroy(tok)`, or `tok.destroy()`, where `tok` is a `Token` value, may be used to destroy the token so that it may never be used again by any users on the consensus network.\nThis must be called before the application exits.\n\n---\n\n`Token.destroyed(tok)`, or `tok.destroyed()`, where `tok` is a `Token` value, returns whether `destroy`\nhas been called on `tok` yet.\n\n---\n\n`Token.supply(tok)`, or `tok.supply()`, where `tok` is a `Token` value, may be used to query the current supply of tokens, i.e. the number of tokens which have not been burnt.\n",
  "Tuple": " `Tuple(Field_0, ..., FieldN)`, which denotes a tuple.\n(Refer to [Tuples](https://docs.reach.sh/rsh/compute/#ref-programs-tuples) for constructing tuples.)\n+  `Object({key_0: Type_0, ..., key_N: Type_N})`, which denotes an object.\n(Refer to [Objects](https://docs.reach.sh/rsh/compute/#ref-programs-objects) for constructing objects.)\n+  `Struct([[key_0, Type_0], ..., [key_N, Type_N]])`, which denotes a struct.\n(Refer to [Structs](https://docs.reach.sh/rsh/compute/#ref-programs-structs) for constructing structs.)\n+  `Array(Type_0, size)`, which denotes a statically-sized array.\n`Type_0` must be a type that can exist at runtime (i.e., not a function type.)\n(Refer to [Arrays](https://docs.reach.sh/rsh/compute/#ref-programs-arrays) for constructing arrays.)\n+  `Data({variant_0: Type_0, ..., variant_N: Type_N})`, which denotes a [tagged union](https://en.wikipedia.org/wiki/Tagged_union) (or _sum type_).\n(Refer to [Data](https://docs.reach.sh/rsh/compute/#ref-programs-data) for constructing data instances.)\n+  `Refine(Type_0, Predicate, ?Message)`, where `Predicate` is a unary function returning a boolean, which denotes a [refinement type](https://en.wikipedia.org/wiki/Refinement_type), that is instances of `Type_0` that satisfy `Predicate`.\nWhen a refinement type appears in a negative position (such as in an `is` or in the domain of a `Fun` of a participant interact interface), it introduces an `assert`;\nwhile when it is in a positive position, it introduces an `assume`.\n`Message` is an optional string to display if the predicate fails verification.\n\nFor example, if `f` had type\n```javascript\nFun([Refine(UInt, (x => x < 5))], Refine(UInt, (x => x > 10)))\n```\n\nthen `const z = f(y)` is equivalent to\n\n```javascript\nassert(y < 5);\nconst z = f(y);\nassume(z > 10);\n```\n\n+ `Refine(Type_0, PreCondition, PostCondition, ?Messages)`, where `Type_0` is a function type, `PreCondition` is a unary function that accepts a tuple of the domain and returns a boolean, and `PostCondition` is a binary function that accepts a tuple of the domain and the range and returns a boolean, denotes a function type with a [precondition](https://en.wikipedia.org/wiki/Precondition) and [postcondition](https://en.wikipedia.org/wiki/Postcondition).\nPreconditions are enforced with `assert` and postconditions are enforced with `assume`.\n`Messages` is an optional two-tuple of `Bytes`.\nThe first message will be displayed when the precondition fails verification and the second when the postcondition fails verification.\n\nFor example, `Refine(Fun([UInt, UInt], UInt), ([x, y] => x < y), (([x, y], z) => x + y < z))` is a function that requires its second argument to be larger than its first and its result to be larger than its input.\n\n`Object` and `Data` are commonly used to implemented [algebraic data types](https://en.wikipedia.org/wiki/Algebraic_data_type) in Reach.\n\n\n```javascript\ntypeOf(x) // type\nisType(t) // Bool\nis(x, t) // t\n```\n\nThe `typeOf` primitive function is the same as `typeof`:\nit returns the type of its argument.\n\nThe `isType` function returns `true` if its argument is a type.\nAny expression satisfying `isType` is compiled away and does not exist at runtime.\n\nThe `is` function returns its first argument if it satisfies the type specified by the second argument.\nIf it is not, then the program is invalid.\nFor example, `is(5, UInt)` returns `5`, while `is(5, Bool)` is an invalid program.\nThe value returned by `is` may not be identical to the input, because in some cases, such as for functions, it will record the applied to type and enforce it on future invocations.\nThese applications are considered negative positions for `Refine`.\n",
  "Tuple.length": "\n\n\n```javascript\nTuple.length(tup);\ntup.length;\nArray.length(arr);\narr.length;\n```\n\n `Tuple.length` Returns the length of the given tuple.\n\n `Array.length` Returns the length of the given array.\n\nBoth may be abbreviated as `expr.length` where `expr` evaluates to a tuple or an array.\n",
  "Tuple.set": "\n\n\n```javascript\nTuple.set(tup, idx, val);\ntup.set(idx, val);\nArray.set(arr, idx, val);\narr.set(idx, val);\n```\n\n `Tuple.set` Returns a new tuple identical to `tup`,\nexcept that index `idx` is replaced with `val`.\nThe `idx` must be a compile-time constant, because tuples do not support dynamic access, because each element may be a different type.\n\n `Array.set` Returns a new array identical to `arr`, except that index `idx` is replaced with `val`.\n\nBoth may be abbreviated as `expr.set(idx, val)` where `expr` evaluates to a tuple or an array.\n",
  "UInt": " `UInt`, which denotes an unsigned integer.\n   `UInt.max` is the largest value that may be assigned to a `UInt`.\n+  `UInt256`, which denotes an unsigned integer with 256 bits.\n   `UInt256.max` is the largest value that may be assigned to a `UInt256`.\n+ `Int`, which denotes a signed integer.\n+ `FixedPoint`, which denotes a fractional number.\n+  `Bytes(length)`, which denotes a string of bytes of length at most `length`.\nBytes of different lengths are not compatible; however the shorter bytes may be [padded](https://docs.reach.sh/rsh/compute/#padding).\n+  `Digest`, which denotes a digest.\n+  `Address`, which denotes an account address.\n+  `Contract`, which denotes the identifying information of a contract.\n\n---\n**NOTE**\n\nReach has different representations of contracts across connectors.\nFor example, on Algorand a `Contract` is an Application ID, but on Ethereum it is an Address.\n\n---\n\n+  `Token`, which denotes a non-network token. [Networks](https://docs.reach.sh/networks/#ref-networks) discusses how `Token`s are represented on specific networks.\n\n---\n**NOTE**\n\nReach assumes that every `Token` in your program refers to a different non-network token.\nIt will automatically insert `require` statements that enforce this constraint.\n\n---\n\n+  `Fun([Domain_0, ..., Domain_N], Range)`, which denotes a function type, when `Domain_i` and `Range` are types.\nThe domain of a function is negative position.\nThe range of a function is positive position.\n+ `Fun(true, Range)`, which denotes an unconstrained domain function type, when `Range` is a type.\nThese functions may only appear in participant interact interfaces.\n+  `Tuple(Field_0, ..., FieldN)`, which denotes a tuple.\n(Refer to [Tuples](https://docs.reach.sh/rsh/compute/#ref-programs-tuples) for constructing tuples.)\n+  `Object({key_0: Type_0, ..., key_N: Type_N})`, which denotes an object.\n(Refer to [Objects](https://docs.reach.sh/rsh/compute/#ref-programs-objects) for constructing objects.)\n+  `Struct([[key_0, Type_0], ..., [key_N, Type_N]])`, which denotes a struct.\n(Refer to [Structs](https://docs.reach.sh/rsh/compute/#ref-programs-structs) for constructing structs.)\n+  `Array(Type_0, size)`, which denotes a statically-sized array.\n`Type_0` must be a type that can exist at runtime (i.e., not a function type.)\n(Refer to [Arrays](https://docs.reach.sh/rsh/compute/#ref-programs-arrays) for constructing arrays.)\n+  `Data({variant_0: Type_0, ..., variant_N: Type_N})`, which denotes a [tagged union](https://en.wikipedia.org/wiki/Tagged_union) (or _sum type_).\n(Refer to [Data](https://docs.reach.sh/rsh/compute/#ref-programs-data) for constructing data instances.)\n+  `Refine(Type_0, Predicate, ?Message)`, where `Predicate` is a unary function returning a boolean, which denotes a [refinement type](https://en.wikipedia.org/wiki/Refinement_type), that is instances of `Type_0` that satisfy `Predicate`.\nWhen a refinement type appears in a negative position (such as in an `is` or in the domain of a `Fun` of a participant interact interface), it introduces an `assert`;\nwhile when it is in a positive position, it introduces an `assume`.\n`Message` is an optional string to display if the predicate fails verification.\n\nFor example, if `f` had type\n```javascript\nFun([Refine(UInt, (x => x < 5))], Refine(UInt, (x => x > 10)))\n```\n\nthen `const z = f(y)` is equivalent to\n\n```javascript\nassert(y < 5);\nconst z = f(y);\nassume(z > 10);\n```\n\n+ `Refine(Type_0, PreCondition, PostCondition, ?Messages)`, where `Type_0` is a function type, `PreCondition` is a unary function that accepts a tuple of the domain and returns a boolean, and `PostCondition` is a binary function that accepts a tuple of the domain and the range and returns a boolean, denotes a function type with a [precondition](https://en.wikipedia.org/wiki/Precondition) and [postcondition](https://en.wikipedia.org/wiki/Postcondition).\nPreconditions are enforced with `assert` and postconditions are enforced with `assume`.\n`Messages` is an optional two-tuple of `Bytes`.\nThe first message will be displayed when the precondition fails verification and the second when the postcondition fails verification.\n\nFor example, `Refine(Fun([UInt, UInt], UInt), ([x, y] => x < y), (([x, y], z) => x + y < z))` is a function that requires its second argument to be larger than its first and its result to be larger than its input.\n\n`Object` and `Data` are commonly used to implemented [algebraic data types](https://en.wikipedia.org/wiki/Algebraic_data_type) in Reach.\n\n\n```javascript\ntypeOf(x) // type\nisType(t) // Bool\nis(x, t) // t\n```\n\nThe `typeOf` primitive function is the same as `typeof`:\nit returns the type of its argument.\n\nThe `isType` function returns `true` if its argument is a type.\nAny expression satisfying `isType` is compiled away and does not exist at runtime.\n\nThe `is` function returns its first argument if it satisfies the type specified by the second argument.\nIf it is not, then the program is invalid.\nFor example, `is(5, UInt)` returns `5`, while `is(5, Bool)` is an invalid program.\nThe value returned by `is` may not be identical to the input, because in some cases, such as for functions, it will record the applied to type and enforce it on future invocations.\nThese applications are considered negative positions for `Refine`.\n",
  "UInt.max": " `UInt.max` is the largest value that may be assigned to a `UInt`.\n+  `UInt256`, which denotes an unsigned integer with 256 bits.\n   `UInt256.max` is the largest value that may be assigned to a `UInt256`.\n+ `Int`, which denotes a signed integer.\n+ `FixedPoint`, which denotes a fractional number.\n+  `Bytes(length)`, which denotes a string of bytes of length at most `length`.\nBytes of different lengths are not compatible; however the shorter bytes may be [padded](https://docs.reach.sh/rsh/compute/#padding).\n+  `Digest`, which denotes a digest.\n+  `Address`, which denotes an account address.\n+  `Contract`, which denotes the identifying information of a contract.\n\n---\n**NOTE**\n\nReach has different representations of contracts across connectors.\nFor example, on Algorand a `Contract` is an Application ID, but on Ethereum it is an Address.\n\n---\n\n+  `Token`, which denotes a non-network token. [Networks](https://docs.reach.sh/networks/#ref-networks) discusses how `Token`s are represented on specific networks.\n\n---\n**NOTE**\n\nReach assumes that every `Token` in your program refers to a different non-network token.\nIt will automatically insert `require` statements that enforce this constraint.\n\n---\n\n+  `Fun([Domain_0, ..., Domain_N], Range)`, which denotes a function type, when `Domain_i` and `Range` are types.\nThe domain of a function is negative position.\nThe range of a function is positive position.\n+ `Fun(true, Range)`, which denotes an unconstrained domain function type, when `Range` is a type.\nThese functions may only appear in participant interact interfaces.\n+  `Tuple(Field_0, ..., FieldN)`, which denotes a tuple.\n(Refer to [Tuples](https://docs.reach.sh/rsh/compute/#ref-programs-tuples) for constructing tuples.)\n+  `Object({key_0: Type_0, ..., key_N: Type_N})`, which denotes an object.\n(Refer to [Objects](https://docs.reach.sh/rsh/compute/#ref-programs-objects) for constructing objects.)\n+  `Struct([[key_0, Type_0], ..., [key_N, Type_N]])`, which denotes a struct.\n(Refer to [Structs](https://docs.reach.sh/rsh/compute/#ref-programs-structs) for constructing structs.)\n+  `Array(Type_0, size)`, which denotes a statically-sized array.\n`Type_0` must be a type that can exist at runtime (i.e., not a function type.)\n(Refer to [Arrays](https://docs.reach.sh/rsh/compute/#ref-programs-arrays) for constructing arrays.)\n+  `Data({variant_0: Type_0, ..., variant_N: Type_N})`, which denotes a [tagged union](https://en.wikipedia.org/wiki/Tagged_union) (or _sum type_).\n(Refer to [Data](https://docs.reach.sh/rsh/compute/#ref-programs-data) for constructing data instances.)\n+  `Refine(Type_0, Predicate, ?Message)`, where `Predicate` is a unary function returning a boolean, which denotes a [refinement type](https://en.wikipedia.org/wiki/Refinement_type), that is instances of `Type_0` that satisfy `Predicate`.\nWhen a refinement type appears in a negative position (such as in an `is` or in the domain of a `Fun` of a participant interact interface), it introduces an `assert`;\nwhile when it is in a positive position, it introduces an `assume`.\n`Message` is an optional string to display if the predicate fails verification.\n\nFor example, if `f` had type\n```javascript\nFun([Refine(UInt, (x => x < 5))], Refine(UInt, (x => x > 10)))\n```\n\nthen `const z = f(y)` is equivalent to\n\n```javascript\nassert(y < 5);\nconst z = f(y);\nassume(z > 10);\n```\n\n+ `Refine(Type_0, PreCondition, PostCondition, ?Messages)`, where `Type_0` is a function type, `PreCondition` is a unary function that accepts a tuple of the domain and returns a boolean, and `PostCondition` is a binary function that accepts a tuple of the domain and the range and returns a boolean, denotes a function type with a [precondition](https://en.wikipedia.org/wiki/Precondition) and [postcondition](https://en.wikipedia.org/wiki/Postcondition).\nPreconditions are enforced with `assert` and postconditions are enforced with `assume`.\n`Messages` is an optional two-tuple of `Bytes`.\nThe first message will be displayed when the precondition fails verification and the second when the postcondition fails verification.\n\nFor example, `Refine(Fun([UInt, UInt], UInt), ([x, y] => x < y), (([x, y], z) => x + y < z))` is a function that requires its second argument to be larger than its first and its result to be larger than its input.\n\n`Object` and `Data` are commonly used to implemented [algebraic data types](https://en.wikipedia.org/wiki/Algebraic_data_type) in Reach.\n\n\n```javascript\ntypeOf(x) // type\nisType(t) // Bool\nis(x, t) // t\n```\n\nThe `typeOf` primitive function is the same as `typeof`:\nit returns the type of its argument.\n\nThe `isType` function returns `true` if its argument is a type.\nAny expression satisfying `isType` is compiled away and does not exist at runtime.\n\nThe `is` function returns its first argument if it satisfies the type specified by the second argument.\nIf it is not, then the program is invalid.\nFor example, `is(5, UInt)` returns `5`, while `is(5, Bool)` is an invalid program.\nThe value returned by `is` may not be identical to the input, because in some cases, such as for functions, it will record the applied to type and enforce it on future invocations.\nThese applications are considered negative positions for `Refine`.\n",
  "UInt256": " `UInt256`, which denotes an unsigned integer with 256 bits.\n   `UInt256.max` is the largest value that may be assigned to a `UInt256`.\n+ `Int`, which denotes a signed integer.\n+ `FixedPoint`, which denotes a fractional number.\n+  `Bytes(length)`, which denotes a string of bytes of length at most `length`.\nBytes of different lengths are not compatible; however the shorter bytes may be [padded](https://docs.reach.sh/rsh/compute/#padding).\n+  `Digest`, which denotes a digest.\n+  `Address`, which denotes an account address.\n+  `Contract`, which denotes the identifying information of a contract.\n\n---\n**NOTE**\n\nReach has different representations of contracts across connectors.\nFor example, on Algorand a `Contract` is an Application ID, but on Ethereum it is an Address.\n\n---\n\n+  `Token`, which denotes a non-network token. [Networks](https://docs.reach.sh/networks/#ref-networks) discusses how `Token`s are represented on specific networks.\n\n---\n**NOTE**\n\nReach assumes that every `Token` in your program refers to a different non-network token.\nIt will automatically insert `require` statements that enforce this constraint.\n\n---\n\n+  `Fun([Domain_0, ..., Domain_N], Range)`, which denotes a function type, when `Domain_i` and `Range` are types.\nThe domain of a function is negative position.\nThe range of a function is positive position.\n+ `Fun(true, Range)`, which denotes an unconstrained domain function type, when `Range` is a type.\nThese functions may only appear in participant interact interfaces.\n+  `Tuple(Field_0, ..., FieldN)`, which denotes a tuple.\n(Refer to [Tuples](https://docs.reach.sh/rsh/compute/#ref-programs-tuples) for constructing tuples.)\n+  `Object({key_0: Type_0, ..., key_N: Type_N})`, which denotes an object.\n(Refer to [Objects](https://docs.reach.sh/rsh/compute/#ref-programs-objects) for constructing objects.)\n+  `Struct([[key_0, Type_0], ..., [key_N, Type_N]])`, which denotes a struct.\n(Refer to [Structs](https://docs.reach.sh/rsh/compute/#ref-programs-structs) for constructing structs.)\n+  `Array(Type_0, size)`, which denotes a statically-sized array.\n`Type_0` must be a type that can exist at runtime (i.e., not a function type.)\n(Refer to [Arrays](https://docs.reach.sh/rsh/compute/#ref-programs-arrays) for constructing arrays.)\n+  `Data({variant_0: Type_0, ..., variant_N: Type_N})`, which denotes a [tagged union](https://en.wikipedia.org/wiki/Tagged_union) (or _sum type_).\n(Refer to [Data](https://docs.reach.sh/rsh/compute/#ref-programs-data) for constructing data instances.)\n+  `Refine(Type_0, Predicate, ?Message)`, where `Predicate` is a unary function returning a boolean, which denotes a [refinement type](https://en.wikipedia.org/wiki/Refinement_type), that is instances of `Type_0` that satisfy `Predicate`.\nWhen a refinement type appears in a negative position (such as in an `is` or in the domain of a `Fun` of a participant interact interface), it introduces an `assert`;\nwhile when it is in a positive position, it introduces an `assume`.\n`Message` is an optional string to display if the predicate fails verification.\n\nFor example, if `f` had type\n```javascript\nFun([Refine(UInt, (x => x < 5))], Refine(UInt, (x => x > 10)))\n```\n\nthen `const z = f(y)` is equivalent to\n\n```javascript\nassert(y < 5);\nconst z = f(y);\nassume(z > 10);\n```\n\n+ `Refine(Type_0, PreCondition, PostCondition, ?Messages)`, where `Type_0` is a function type, `PreCondition` is a unary function that accepts a tuple of the domain and returns a boolean, and `PostCondition` is a binary function that accepts a tuple of the domain and the range and returns a boolean, denotes a function type with a [precondition](https://en.wikipedia.org/wiki/Precondition) and [postcondition](https://en.wikipedia.org/wiki/Postcondition).\nPreconditions are enforced with `assert` and postconditions are enforced with `assume`.\n`Messages` is an optional two-tuple of `Bytes`.\nThe first message will be displayed when the precondition fails verification and the second when the postcondition fails verification.\n\nFor example, `Refine(Fun([UInt, UInt], UInt), ([x, y] => x < y), (([x, y], z) => x + y < z))` is a function that requires its second argument to be larger than its first and its result to be larger than its input.\n\n`Object` and `Data` are commonly used to implemented [algebraic data types](https://en.wikipedia.org/wiki/Algebraic_data_type) in Reach.\n\n\n```javascript\ntypeOf(x) // type\nisType(t) // Bool\nis(x, t) // t\n```\n\nThe `typeOf` primitive function is the same as `typeof`:\nit returns the type of its argument.\n\nThe `isType` function returns `true` if its argument is a type.\nAny expression satisfying `isType` is compiled away and does not exist at runtime.\n\nThe `is` function returns its first argument if it satisfies the type specified by the second argument.\nIf it is not, then the program is invalid.\nFor example, `is(5, UInt)` returns `5`, while `is(5, Bool)` is an invalid program.\nThe value returned by `is` may not be identical to the input, because in some cases, such as for functions, it will record the applied to type and enforce it on future invocations.\nThese applications are considered negative positions for `Refine`.\n",
  "UInt256.max": " `UInt256.max` is the largest value that may be assigned to a `UInt256`.\n+ `Int`, which denotes a signed integer.\n+ `FixedPoint`, which denotes a fractional number.\n+  `Bytes(length)`, which denotes a string of bytes of length at most `length`.\nBytes of different lengths are not compatible; however the shorter bytes may be [padded](https://docs.reach.sh/rsh/compute/#padding).\n+  `Digest`, which denotes a digest.\n+  `Address`, which denotes an account address.\n+  `Contract`, which denotes the identifying information of a contract.\n\n---\n**NOTE**\n\nReach has different representations of contracts across connectors.\nFor example, on Algorand a `Contract` is an Application ID, but on Ethereum it is an Address.\n\n---\n\n+  `Token`, which denotes a non-network token. [Networks](https://docs.reach.sh/networks/#ref-networks) discusses how `Token`s are represented on specific networks.\n\n---\n**NOTE**\n\nReach assumes that every `Token` in your program refers to a different non-network token.\nIt will automatically insert `require` statements that enforce this constraint.\n\n---\n\n+  `Fun([Domain_0, ..., Domain_N], Range)`, which denotes a function type, when `Domain_i` and `Range` are types.\nThe domain of a function is negative position.\nThe range of a function is positive position.\n+ `Fun(true, Range)`, which denotes an unconstrained domain function type, when `Range` is a type.\nThese functions may only appear in participant interact interfaces.\n+  `Tuple(Field_0, ..., FieldN)`, which denotes a tuple.\n(Refer to [Tuples](https://docs.reach.sh/rsh/compute/#ref-programs-tuples) for constructing tuples.)\n+  `Object({key_0: Type_0, ..., key_N: Type_N})`, which denotes an object.\n(Refer to [Objects](https://docs.reach.sh/rsh/compute/#ref-programs-objects) for constructing objects.)\n+  `Struct([[key_0, Type_0], ..., [key_N, Type_N]])`, which denotes a struct.\n(Refer to [Structs](https://docs.reach.sh/rsh/compute/#ref-programs-structs) for constructing structs.)\n+  `Array(Type_0, size)`, which denotes a statically-sized array.\n`Type_0` must be a type that can exist at runtime (i.e., not a function type.)\n(Refer to [Arrays](https://docs.reach.sh/rsh/compute/#ref-programs-arrays) for constructing arrays.)\n+  `Data({variant_0: Type_0, ..., variant_N: Type_N})`, which denotes a [tagged union](https://en.wikipedia.org/wiki/Tagged_union) (or _sum type_).\n(Refer to [Data](https://docs.reach.sh/rsh/compute/#ref-programs-data) for constructing data instances.)\n+  `Refine(Type_0, Predicate, ?Message)`, where `Predicate` is a unary function returning a boolean, which denotes a [refinement type](https://en.wikipedia.org/wiki/Refinement_type), that is instances of `Type_0` that satisfy `Predicate`.\nWhen a refinement type appears in a negative position (such as in an `is` or in the domain of a `Fun` of a participant interact interface), it introduces an `assert`;\nwhile when it is in a positive position, it introduces an `assume`.\n`Message` is an optional string to display if the predicate fails verification.\n\nFor example, if `f` had type\n```javascript\nFun([Refine(UInt, (x => x < 5))], Refine(UInt, (x => x > 10)))\n```\n\nthen `const z = f(y)` is equivalent to\n\n```javascript\nassert(y < 5);\nconst z = f(y);\nassume(z > 10);\n```\n\n+ `Refine(Type_0, PreCondition, PostCondition, ?Messages)`, where `Type_0` is a function type, `PreCondition` is a unary function that accepts a tuple of the domain and returns a boolean, and `PostCondition` is a binary function that accepts a tuple of the domain and the range and returns a boolean, denotes a function type with a [precondition](https://en.wikipedia.org/wiki/Precondition) and [postcondition](https://en.wikipedia.org/wiki/Postcondition).\nPreconditions are enforced with `assert` and postconditions are enforced with `assume`.\n`Messages` is an optional two-tuple of `Bytes`.\nThe first message will be displayed when the precondition fails verification and the second when the postcondition fails verification.\n\nFor example, `Refine(Fun([UInt, UInt], UInt), ([x, y] => x < y), (([x, y], z) => x + y < z))` is a function that requires its second argument to be larger than its first and its result to be larger than its input.\n\n`Object` and `Data` are commonly used to implemented [algebraic data types](https://en.wikipedia.org/wiki/Algebraic_data_type) in Reach.\n\n\n```javascript\ntypeOf(x) // type\nisType(t) // Bool\nis(x, t) // t\n```\n\nThe `typeOf` primitive function is the same as `typeof`:\nit returns the type of its argument.\n\nThe `isType` function returns `true` if its argument is a type.\nAny expression satisfying `isType` is compiled away and does not exist at runtime.\n\nThe `is` function returns its first argument if it satisfies the type specified by the second argument.\nIf it is not, then the program is invalid.\nFor example, `is(5, UInt)` returns `5`, while `is(5, Bool)` is an invalid program.\nThe value returned by `is` may not be identical to the input, because in some cases, such as for functions, it will record the applied to type and enforce it on future invocations.\nThese applications are considered negative positions for `Refine`.\n",
  "View": "\n```javascript\nView('NFT', { owner: Address })\n// or\nView({ owner: Address })\n```\n\nViews are read-only functions that can be called by other contracts, as well as off-chain.\n\nA view is defined with `View(viewName, viewInterface)` or `View(viewInterface)`, where `viewName` is a string that labels the view and `viewInterface` is an object where each field indicates the type of a function or value provided by the contract associated with the specified DApp.\n\nFor example, `View` is used in the code below without a `viewName`:\n```javascript\n  const V = View({\n    x: UInt,\n    tok: Token,\n  });\n```\n\nWhile the `View` in the following code contains a `viewName`:\n```javascript\n  const vMain = View('Main', { last: Address, i: UInt });\n  init();\n```\n\nThese views are available in frontends via the `ctc.views` object.\nIn the DApp, the result of this application argument is referred to as a view object.\n",
  "abs": "\n `abs(i)` returns the absolute value of an `Int`. The return value is of type `UInt`.\n",
  "absoluteSecs": "\n```javascript\nrelativeTime(amt, ?claim)\nabsoluteTime(time, ?claim)\nrelativeSecs(amt, ?claim)\nabsoluteSecs(secs, ?claim)\n```\n\nThese functions return time arguments, which are instances of the type `Either(UInt, UInt)`, where `Left` variants refer to absolute network time and `Right` variants refer to absolute network seconds.\n\nThese functions take an optional function argument, `claim`, which will be used to verify arithmetic when necessary.\nIn most cases, one would pass `assume`, `require`, or `assert`.\nThis argument is only needed when `verifyArithmetic` is enabled.\nThe default value of this argument is a no-op.\n\nThe `absoluteTime` and `absoluteSecs` are equivalent to `Left` and `Right` variant tags.\n\nThe `relativeTime` and `relativeSecs` functions add `baseWaitTime` and `baseWaitSecs` to their arguments before tagging with the appropriate variant.\n\nIf a time argument is required, an integer value is allowed and is interpreted as a `relativeTime`, but this behavior is deprecated and you will see a warning.\n",
  "absoluteTime": "\n```javascript\nrelativeTime(amt, ?claim)\nabsoluteTime(time, ?claim)\nrelativeSecs(amt, ?claim)\nabsoluteSecs(secs, ?claim)\n```\n\nThese functions return time arguments, which are instances of the type `Either(UInt, UInt)`, where `Left` variants refer to absolute network time and `Right` variants refer to absolute network seconds.\n\nThese functions take an optional function argument, `claim`, which will be used to verify arithmetic when necessary.\nIn most cases, one would pass `assume`, `require`, or `assert`.\nThis argument is only needed when `verifyArithmetic` is enabled.\nThe default value of this argument is a no-op.\n\nThe `absoluteTime` and `absoluteSecs` are equivalent to `Left` and `Right` variant tags.\n\nThe `relativeTime` and `relativeSecs` functions add `baseWaitTime` and `baseWaitSecs` to their arguments before tagging with the appropriate variant.\n\nIf a time argument is required, an integer value is allowed and is interpreted as a `relativeTime`, but this behavior is deprecated and you will see a warning.\n",
  "add": "\n```javascript\nand(a, b)     // &&\nor(a, b)      // ||\nxor(a, b)     // ^\nadd(a, b)     // +\nsub(a, b)     // -\nmul(a, b)     // *\ndiv(a, b)     // /\npolyMod(a, b) // %\neq(a, b)      // ==\nlt(a, b)      // <\nle(a, b)      // <=\nge(a, b)      // >=\ngt(a, b)      // >\nlsh(a, b)     // <<\nrsh(a, b)     // >>\nband(a, b)    // &\nbior(a, b)    // |\npolyEq(a, b)  // ==, ===\npolyNeq(a, b) // !=, !==\n```\n\nAll binary expression operators have a corresponding named function in the standard library.\nWhile `&&` and `||` may not evaluate their second argument,\ntheir corresponding named functions `and`, `or`, and `xor`, always do.\n\n\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "addressEq": "\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "and": "\n```javascript\nand(a, b)     // &&\nor(a, b)      // ||\nxor(a, b)     // ^\nadd(a, b)     // +\nsub(a, b)     // -\nmul(a, b)     // *\ndiv(a, b)     // /\npolyMod(a, b) // %\neq(a, b)      // ==\nlt(a, b)      // <\nle(a, b)      // <=\nge(a, b)      // >=\ngt(a, b)      // >\nlsh(a, b)     // <<\nrsh(a, b)     // >>\nband(a, b)    // &\nbior(a, b)    // |\npolyEq(a, b)  // ==, ===\npolyNeq(a, b) // !=, !==\n```\n\nAll binary expression operators have a corresponding named function in the standard library.\nWhile `&&` and `||` may not evaluate their second argument,\ntheir corresponding named functions `and`, `or`, and `xor`, always do.\n\n\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "array": "\n```javascript\nconst x = array(UInt, [1, 2, 3]);\n```\n\nConverts a tuple of homogeneous values of the specific type into an array.\n",
  "assert": "\n```javascript\nassert( claim, [msg] )\n```\n\n A static assertion which is only valid if `claim` always evaluates to `true`. \n\n For example, the following assertions were made in the [Rock, Paper, Scissors tutorial](https://docs.reach.sh/tut/rps/#tut-5):\n\n ```javascript\n const winner = (handAlice, handBob) =>\n  ((handAlice + (4 - handBob)) % 3);\n\nassert(winner(ROCK, PAPER) == B_WINS);\nassert(winner(PAPER, ROCK) == A_WINS);\nassert(winner(ROCK, ROCK) == DRAW);\n ```\n\n---\n**NOTE**\n\nThe Reach compiler will produce a counter-example (i.e. an assignment of the identifiers in the program to falsify the `claim`) when an invalid `claim` is provided.\nIt is possible to write a `claim` that actually always evaluates to `true`, but for which our current approach cannot prove always evaluates to `true`; if this is the case, Reach will fail to compile the program, reporting that its analysis is incomplete.\nReach will never produce an erroneous counter-example.\n\n---\n\nIt accepts an optional bytes argument, which is included in any reported violation.\n\n---\n**NOTE**\n\nSee [the guide section on verification](https://docs.reach.sh/guide/assert/#guide-assert) to better understand how and what to verify in your program.\n\n---\n",
  "assume": "\n```javascript\nassume( claim, [msg] ) \n```\n\nAn assumption where `claim` evaluates to `true` with honest frontends.\nThis may only appear in a local step.\nIt accepts an optional bytes argument, which is included in any reported violation.\n\nIf the claim dynamically evaluates to `false`, the frontend will raise an exception.\n\n```javascript\n  A.only(() => {\n    const [ tokenA, amtA, tokenB, amtB, time ] = declassify(interact.getSwap());\n    assume(tokenA != tokenB); });\n```\n\nIn this example, the claim is that the two tokens, tokenA and tokenB, are not the same, and there is no message that displays.\n",
  "async": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis error indicates you are using an illegal JavaScript expression in Reach. Not all JavaScript\nexpressions are valid Reach, as they are not applicable to the language.\n",
  "await": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis error indicates you are using an illegal JavaScript expression in Reach. Not all JavaScript\nexpressions are valid Reach, as they are not applicable to the language.\n",
  "balance": "\n```javascript\nbalance();\nbalance(gil);\n```\n\nThe balance primitive returns the balance of the contract account for the DApp.\nIt takes an optional non-network token value, in which case it returns the balance of the given token.\n\nThe example below shows the non-network token being passed as an argument to `balance`:\n```javascript\n  const chkBal = (i) => {\n    A.interact.checkBal(i, balance(token1), balance(token2));\n  };\n```\n\nWhile in the following example, `balance` takes no argument:\n```javascript\n  invariant( balance() == 2 * wager && isOutcome(outcome) );\n```\n",
  "band": "\n```javascript\nand(a, b)     // &&\nor(a, b)      // ||\nxor(a, b)     // ^\nadd(a, b)     // +\nsub(a, b)     // -\nmul(a, b)     // *\ndiv(a, b)     // /\npolyMod(a, b) // %\neq(a, b)      // ==\nlt(a, b)      // <\nle(a, b)      // <=\nge(a, b)      // >=\ngt(a, b)      // >\nlsh(a, b)     // <<\nrsh(a, b)     // >>\nband(a, b)    // &\nbior(a, b)    // |\npolyEq(a, b)  // ==, ===\npolyNeq(a, b) // !=, !==\n```\n\nAll binary expression operators have a corresponding named function in the standard library.\nWhile `&&` and `||` may not evaluate their second argument,\ntheir corresponding named functions `and`, `or`, and `xor`, always do.\n\n\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "baseWaitSecs": "\n```javascript\nbaseWaitTime()\nbaseWaitSecs()\n```\n\nThese primitives return the network time (network seconds) that a relative time argument refers to.\nThis is either the same as `lastConsensusTime` (`lastConsensusSecs`) or the deadline of the previous `wait` or `.timeout`.\n",
  "baseWaitTime": "\n```javascript\nbaseWaitTime()\nbaseWaitSecs()\n```\n\nThese primitives return the network time (network seconds) that a relative time argument refers to.\nThis is either the same as `lastConsensusTime` (`lastConsensusSecs`) or the deadline of the previous `wait` or `.timeout`.\n",
  "bior": "\n```javascript\nand(a, b)     // &&\nor(a, b)      // ||\nxor(a, b)     // ^\nadd(a, b)     // +\nsub(a, b)     // -\nmul(a, b)     // *\ndiv(a, b)     // /\npolyMod(a, b) // %\neq(a, b)      // ==\nlt(a, b)      // <\nle(a, b)      // <=\nge(a, b)      // >=\ngt(a, b)      // >\nlsh(a, b)     // <<\nrsh(a, b)     // >>\nband(a, b)    // &\nbior(a, b)    // |\npolyEq(a, b)  // ==, ===\npolyNeq(a, b) // !=, !==\n```\n\nAll binary expression operators have a corresponding named function in the standard library.\nWhile `&&` and `||` may not evaluate their second argument,\ntheir corresponding named functions `and`, `or`, and `xor`, always do.\n\n\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "boolEq": "\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "boolXor": "\n```javascript\nboolXor(false, false); // false\nboolXor(false, true);  // true\nboolXor(true, false);  // true\nboolXor(true, true);   // false\n```\n\n`boolXor(Bool, Bool)` returns `true` only when the inputs differ in value.\nThis function is specialized to `Bool`s; `xor` supports more types.\n",
  "break": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis error indicates you are using an illegal JavaScript expression in Reach. Not all JavaScript\nexpressions are valid Reach, as they are not applicable to the language.\n",
  "bxor": "\n```javascript\nand(a, b)     // &&\nor(a, b)      // ||\nxor(a, b)     // ^\nadd(a, b)     // +\nsub(a, b)     // -\nmul(a, b)     // *\ndiv(a, b)     // /\npolyMod(a, b) // %\neq(a, b)      // ==\nlt(a, b)      // <\nle(a, b)      // <=\nge(a, b)      // >=\ngt(a, b)      // >\nlsh(a, b)     // <<\nrsh(a, b)     // >>\nband(a, b)    // &\nbior(a, b)    // |\npolyEq(a, b)  // ==, ===\npolyNeq(a, b) // !=, !==\n```\n\nAll binary expression operators have a corresponding named function in the standard library.\nWhile `&&` and `||` may not evaluate their second argument,\ntheir corresponding named functions `and`, `or`, and `xor`, always do.\n\n\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "call": "\n\n\n\n\nA call is written:\n\n```javascript\nconst [ DOMAIN, RET_FUN ] =\n  call(API_EXPR)\n    .pay(API_PAY_EXPR)\n    .assume(API_ASSUME_EXPR)\n    .check(API_CHECK_EXPR)\n    .throwTimeout(DELAY_EXPR, THROW_EXPR)\n```\n\nwhere:\n+ `DOMAIN` is the the domain of the API member function.\n+ `RET_FUN` is a function that returns a value to the API call. This function must be called.\n+ `API_EXPR` is an expression that evaluates to an API member function.\n+ `API_CHECK_EXPR` is a function parameterized over the domain of the API function.\nThis function can be used to add `check`s involving the domain.\nThese checks will be applied as assumptions and requirements.\n+ `API_PAY_EXPR` and `API_ASSUME_EXPR` are like the corresponding parts in a `fork` statement, and `call.throwTimeout` is like in `fork.throwTimeout`.\nThey are optional.\n\n `call` will call the given API member function, returning a pair, `[DOMAIN, RET_FUN]`.\n`call` will publish the domain of the API member function, transferring the program from\na step to consensus step.",
  "case": "\n```javascript\nconst mi = Maybe(UInt).Some(42);\nswitch ( mi ) {\n case None: return 8;\n case Some: return mi + 10; }\nswitch ( mi ) {\n case None: return 8;\n default: return 41; }\n```\n\nA switch statement,\nwritten `switch (VAR) { CASE ... }`,\nwhere `VAR` is a variable bound to a data instance\nand `CASE` is either `case VARIANT: STMT ...`, where `VARIANT` is a variant, or `default: STMT ...`, and `STMT` is a sequence of statements,\nselects the appropriate sequence of statements based on which variant `VAR` holds.\nWithin the body of a `switch` case, `VAR` has the type of variant; i.e. in a `Some` case of a `Maybe(UInt)` `switch`, the variable is bound to an integer.\n\nAll cases have empty tails, i.e. the tail of the switch statement is not propagated.\n\nA switch statement may only include a consensus transfer in its cases if it is within a consensus step, because its statements are in the same context as the conditional statement itself.\n\nIt is invalid for a case to appear multiple times, or be missing, or to be superfluous (i.e. for a variant that does not exist in the `Data` type of `VAR`).\n\nIf one case of a `switch` contains a `return`, then all must.\n",
  "catch": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis error indicates you are using an illegal JavaScript expression in Reach. Not all JavaScript\nexpressions are valid Reach, as they are not applicable to the language.\n",
  "check": "\n```javascript\ncheck( claim, [msg] )\n```\n\nA dynamic assertion that `claim` evaluates to `true`, which expands to either a `require` or `assume` depending on where it is used in a program.\nIt accepts an optional bytes argument, which is included in any reported violation.\n\nFor example, `A` makes the following `check` with a second (optional) argument on line 21:\n```javascript\n  A.only(() => { const a = declassify(interact.get()); });\n  A.publish(a);\n  m[A] = a;\n  A.interact.check(m[A], MUInt.Some(a));\n  commit();\n```\n\nWhile the `check` in the following example, takes just the first argument on line 62:\n```javascript\n  const x = calc.mul1(2);\n  check(x == 2);\n```\n",
  "checkCommitment": "\n```javascript\ncheckCommitment( commitment, salt, x )\n```\n\n Makes a requirement that `commitment` is the digest of `salt` and `x`.\nThis is used in a consensus step after `makeCommitment` was used in a local step.\n\nThe example below shows `checkCommitment` being used in a consensus step on line 87 after `makeCommitment` was used in a local step on line 66:\n\n```javascript\n    Alice.only(() => {\n      const _handAlice = interact.getHand();\n      const [_commitAlice, _saltAlice] = makeCommitment(interact, _handAlice);\n      const commitAlice = declassify(_commitAlice);\n    });\n```\n\n```javascript\n    Alice.publish(saltAlice, handAlice)\n      .timeout(relativeTime(deadline), () => closeTo(Bob, informTimeout));\n    checkCommitment(commitAlice, saltAlice, handAlice);\n```\n",
  "class": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis error indicates you are using an illegal JavaScript expression in Reach. Not all JavaScript\nexpressions are valid Reach, as they are not applicable to the language.\n",
  "closeTo": " Has participant `Anybody` make a publication, then transfer the `balance()` and the non-network pay amount to `Who` and end the DApp after executing the function `after` in a step.\n\nAs an example, codifying the prose above would look like:\n\n```javascript\n// Has participant 'Anybody' make a publication\nAnybody.publish();\n// Transfer the balance() and the non-network payment amount to 'Who'\ntransfer([ balance(), ...nonNetPayAmt ]).to(Who);\ncommit();\n// End the DApp after executing the function 'after' in a step\nafter();\nexit();\n```\n\nBy comparing this example to `closeTo`, you can see that using this Reach standard library function helps save thinking, as well as additional lines of code, reducing the chances of introducing new errors.\n\nThe `nonNetPayAmt` parameter should be a pay amount. For example, when closing a program that uses a `Token` `token`, the argument would be `[ [balance(tok), tok] ]`.\n\n```javascript\n    .timeout(relativeTime(maxLenderDelay), () =>\n      closeTo(Borrower,\n        sendOutcome(LENDER_TIMEOUT),\n        [[balance(tok), tok]]));\n```\n\nThe `after` and `nonNetPayAmt` arguments are optional.\n",
  "commit": "\n```javascript\ncommit();\n```\n\nA commit statement, written `commit();`, commits to statement's continuation as the next step of the DApp computation. In other words, it ends the current consensus step and allows more local steps.\n\nFor example, in the code below, the `commit();` on line 79 allows `Alice` to perform a local step after a consensus step:\n\n```javascript\n    Bob.publish(handBob)\n      .timeout(relativeTime(deadline), () => closeTo(Alice, informTimeout));\n    commit();\n\n    Alice.only(() => {\n      const saltAlice = declassify(_saltAlice);\n      const handAlice = declassify(_handAlice);\n    });\n```\n",
  "compose": "\n```javascript\ncompose(f, g)\n```\n\n Creates a new function that applies its argument to `g`, then pipes the result to the function `f`.\nThe argument type of `f` must be the return type of `g`.\n",
  "const": "\n```javascript\nconst DELAY = 10;\nconst [ Good, Bad ] = [ 42, 43 ];\nconst { x, y } = { x: 1, y: 2 };\nconst [ x, [ y ] ] = [ 1, [ 2 ] ];\nconst [ x, { y } ] = [ 1, { y: 2 } ];\nconst { x: [ a, b ] } = { x: [ 1, 2 ] };\n```\n\n---\n**NOTE**\n\nValid identifiers follow the same rules as JavaScript identifiers:\nthey may consist of Unicode alphanumeric characters,\nor `_` or `$`,\nbut may not begin with a digit.\n\n---\n\nA value definition is written `const LHS = RHS;`.\n\n`LHS` must obey the grammar:\n\n```\nLHS =\n  | id\n  | \"[\" LHS-tuple-seq \"]\"\n  | \"{\" LHS-obj-seq \"}\"\nLHS-tuple-seq =\n  |\n  | \"...\" LHS\n  | LHS\n  | LHS \",\" LHS-tuple-seq\nLHS-obj-seq =\n  |\n  | \"...\" LHS\n  | LHS-obj-elem\n  | LHS-obj-elem \",\" LHS-obj-seq\nLHS-obj-elem =\n  | id\n  | propertyName \":\" LHS\npropertyName =\n  | id\n  | string\n  | number\n  | \"[\" expr \"]\"\n```\n\n`RHS` must be compatible with the given `LHS`.\nThat is, if a `LHS` is an `LHS-tuple-seq`, then the corresponding `RHS` must be a tuple with the correct number of elements.\nIf a `LHS` is an `LHS-obj-seq`, then the corresponding `RHS` must be an object with the correct fields.\n\nThose values are available as their corresponding bound identifiers in the statement's tail.\n\n---\n\n\n```javascript\nfunction randomBool() {\n  return (interact.random() % 2) == 0; };\n```\n\nA function definition, written `function FUN(LHS_0, ..., LHS_n) BLOCK;`, defines `FUN` as a function which abstracts its function body, the block `BLOCK`, over the left-hand sides `LHS_0` through `LHS_n`.\n\nFunction parameters may specify default arguments. The expressions used to instantiate these parameters\nhave access to any variables in the scope of which the function was defined. Additionally, these expressions\nmay reference previous arguments of the function definition.\nParameters with default arguments must come after all other parameters.\n\n```javascript\nfunction f(a, b, c = a + 1, d = b + c) =>\n  a + b + c + d;\n```\n\nThe last parameter of a function may be a rest parameter, which allows the function to be called\nwith an arbitrary number of arguments. A rest parameter is specified via `...IDENT`, where\n`IDENT` is bound to a `Tuple` containing all the remaining arguments.\n\n---\n\nAll identifiers in Reach programs must be unbound\nat the position of the program where they are bound,\ni.e., it is invalid to shadow identifiers with new definitions.\nFor example,\n\n```javascript\nconst x = 3;\nconst x = 4;\n```\n\nis invalid.\nThis restriction is independent of whether a binding is\nonly known to a single participant. For example,\n\n```javascript\nAlice.only(() => {\n  const x = 3; });\nBob.only(() => {\n  const x = 3; });\n```\n\nis invalid.\n\nThe special identifier `_` is an exception to this rule.\nThe `_` binding is always considered to be unbound.\nThis means means that `_` is both\nan identifier that can never be read,\nas well as an identifier that may be bound many times.\nThis may be useful for ignoring unwanted values, for example:\n\n```javascript\nconst [_, x, _] = [1, 2, 3];\n```\n",
  "continue": "\n```javascript\n[ heap1, heap2 ] = [ heap1 - 1, heap2 ];\ncontinue;\n```\n\nA continue statement may occur within a while statement's block and is written:\n\n```javascript\nLHS = UPDATE_EXPR;\ncontinue;\n```\n\nwhere the identifiers bound by `LHS` are a subset of the variables bound by the nearest enclosing while statement and `UPDATE_EXPR` is an expression which may be bound by `LHS`.\n\nA continue statement is a terminator statement, so it must have an empty tail.\n\nA continue statement may be written without the preceding identifier update, which is equivalent to writing\n\n```javascript\n[] = [];\ncontinue;\n```\n\nA continue statement must be dominated by a consensus transfer, which means that the body of a while statement must always `commit();` before calling `continue;`.\nThis restriction may be lifted in future versions of Reach, which will perform termination checking.\n\n---\n\nAs a special case, a continue statement may occur in a step, if the `UPDATE_EXPR` transitions to a consensus step.\nIn other words, this is a valid program:\n```javascript\nconst f = () => {\n commit();\n A.publish();\n return 1;\n};\n\nvar x = 0;\ninvariant(balance() == 0);\nwhile ( x == 0 ) {\n x = f();\n continue;\n}\n```\n\nThe following example displays how a `continue` is used inside of a `while` loop that started in line 43.\nBob and Alice race to be the first to `publish` and therefore be the round winner.\nWhen one of them publishes, the `keepGoing` function returns false, and the program hits `continue` where it exits the `race` and moves on with the rest of the program.\n\n```javascript\n        race(Alice, Bob).publish(isAlice).when(go)\n          .timeout(relativeTime(deadline), () => {\n            showOutcome(TIMEOUT)();\n            race(Alice, Bob).publish();\n            keepGoing = false;\n            continue; });\n```\n",
  "debugger": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis error indicates you are using an illegal JavaScript expression in Reach. Not all JavaScript\nexpressions are valid Reach, as they are not applicable to the language.\n",
  "declassify": "\n```javascript\ndeclassify( arg ) \n```\n\nThe declassify primitive performs a declassification of the given argument.\n\n```javascript\n      A.only(() => {\n        const wager = declassify(interact.wager); });\n      A.publish(wager)\n        .pay(wager);\n      commit();\n```\n\nIn this statement, Alice declassifies the wager and then publishes it so that Bob can know the wager.\n",
  "default": "\n```javascript\nconst mi = Maybe(UInt).Some(42);\nswitch ( mi ) {\n case None: return 8;\n case Some: return mi + 10; }\nswitch ( mi ) {\n case None: return 8;\n default: return 41; }\n```\n\nA switch statement,\nwritten `switch (VAR) { CASE ... }`,\nwhere `VAR` is a variable bound to a data instance\nand `CASE` is either `case VARIANT: STMT ...`, where `VARIANT` is a variant, or `default: STMT ...`, and `STMT` is a sequence of statements,\nselects the appropriate sequence of statements based on which variant `VAR` holds.\nWithin the body of a `switch` case, `VAR` has the type of variant; i.e. in a `Some` case of a `Maybe(UInt)` `switch`, the variable is bound to an integer.\n\nAll cases have empty tails, i.e. the tail of the switch statement is not propagated.\n\nA switch statement may only include a consensus transfer in its cases if it is within a consensus step, because its statements are in the same context as the conditional statement itself.\n\nIt is invalid for a case to appear multiple times, or be missing, or to be superfluous (i.e. for a variant that does not exist in the `Data` type of `VAR`).\n\nIf one case of a `switch` contains a `return`, then all must.\n",
  "delete": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis error indicates you are using an illegal JavaScript expression in Reach. Not all JavaScript\nexpressions are valid Reach, as they are not applicable to the language.\n",
  "didPublish": "\n```javascript\ndidPublish() \n```\n\nReturns a boolean that indicates whether the last publication was made by this principal.\nA `didPublish` call must be inside an `only` block of code and be after a `publish` call.\n\nFor example, in the code below, a `didPublish` call is made on line 62 in an `only` block of code after a `publish` call was made on line 35:\n\n```javascript\n      Sponsor.publish(ticketPrice, deadline, sponsortc);\n```\n\n```javascript\n            Player.only(() => { if ( didPublish() ) { interact.didBuy(); } });\n``",
  "digest": "\n```javascript\ndigest( arg_0, ..., arg_n )\n```\n\nThe digest primitive performs a [cryptographic hash](https://en.wikipedia.org/wiki/Cryptographic_hash_function) of the binary encoding of the given arguments.\nThis returns a `Digest` value.\nThe exact algorithm used depends on the connector.\n",
  "digestEq": "\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "distinct": "\n```javascript\ndistinct(1, 2, 3);\n```\n\n`distinct(...args)` evaluates to `true` when all its arguments\nare distinct from each other.",
  "div": "\n```javascript\nand(a, b)     // &&\nor(a, b)      // ||\nxor(a, b)     // ^\nadd(a, b)     // +\nsub(a, b)     // -\nmul(a, b)     // *\ndiv(a, b)     // /\npolyMod(a, b) // %\neq(a, b)      // ==\nlt(a, b)      // <\nle(a, b)      // <=\nge(a, b)      // >=\ngt(a, b)      // >\nlsh(a, b)     // <<\nrsh(a, b)     // >>\nband(a, b)    // &\nbior(a, b)    // |\npolyEq(a, b)  // ==, ===\npolyNeq(a, b) // !=, !==\n```\n\nAll binary expression operators have a corresponding named function in the standard library.\nWhile `&&` and `||` may not evaluate their second argument,\ntheir corresponding named functions `and`, `or`, and `xor`, always do.\n\n\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "do": "\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis error indicates you are using an illegal JavaScript expression in Reach. Not all JavaScript\nexpressions are valid Reach, as they are not applicable to the language.\n",
  "each": "\n```javascript\neach([Alice, Bob], () => {\n  const pretzel = interact.random(); });\n```\n\nAn each local step statement can be written as `each(PART_TUPLE () => BLOCK)`, where `PART_TUPLE` is a tuple of participants and `BLOCK` is a block.\nIt is an abbreviation of many local step statements that could have been written with `only`.\n",
  "either": "\n```javascript\neither(e, onLeft, onRight)\n```\n\n `either(e, onLeft, onRight)` will either apply the function `onLeft` or `onRight` depending on `e`.\n\n\n```javascript\nconst e = Either(UInt, Bool);\nconst l = e.Left(1);\nconst r = e.Right(true);\nisLeft(l);  // true\nisRight(l); // false\nconst x = fromLeft(l, 0);      // x = 1\nconst y = fromRight(l, false); // y = false\n```\n\n `isLeft` is a convenience method that determines whether the variant is `Left`.\n\n `isRight` is a convenience method that determines whether the variant is `Right`.\n\n `fromLeft(e, default)` is a convenience method that returns the value in `Left`,\nor `default` if the variant is `Right`.\n\n `fromRight(e, default)` is a convenience method that returns the value in `Right`,\nor `default` if the variant is `Left`.\n",
  "else": "\n```javascript\nif ( 1 + 2 < 3 ) {\n  return \"Yes!\";\n} else {\n  return \"No, waaah!\"; }\n```\n\nA conditional statement,\nwritten `if (COND) NOT_FALSE else FALSE`,\nwhere `COND` is an expression\nand `NOT_FALSE` and `FALSE` as statements\n(potentially block statements),\nselects between the `NOT_FALSE` statement and `FALSE` statement based on whether `COND` evaluates to `false`.\n\nBoth `NOT_FALSE` and `FALSE` have empty tails, i.e. the tail of the conditional statement is not propagated. For example,\n\n```javascript\nif ( x < y ) {\n  const z = 3; }\nelse {\n  const z = 4; }\nreturn z;\n```\n\nis erroneous, because the identifier `z` is not bound outside the conditional statement.\n\nA conditional statement may only include a consensus transfer in `NOT_FALSE` or `FALSE` if it is within a consensus step, because its statements are in the same context as the conditional statement itself.\n\nIf one branch of a conditional contains a `return`, then both must.\n",
  "ensure": "\n```javascript\nensure( pred, x )\n```\n\n Makes a static assertion that `pred(x)` is `true` and returns `x`.\n",
  "enum": "\n\n\n\n\n\n\n\n\n\n\n\n\nThis error indicates you are using an illegal JavaScript expression in Reach. Not all JavaScript\nexpressions are valid Reach, as they are not applicable to the language.\n",
  "eq": "\n```javascript\nand(a, b)     // &&\nor(a, b)      // ||\nxor(a, b)     // ^\nadd(a, b)     // +\nsub(a, b)     // -\nmul(a, b)     // *\ndiv(a, b)     // /\npolyMod(a, b) // %\neq(a, b)      // ==\nlt(a, b)      // <\nle(a, b)      // <=\nge(a, b)      // >=\ngt(a, b)      // >\nlsh(a, b)     // <<\nrsh(a, b)     // >>\nband(a, b)    // &\nbior(a, b)    // |\npolyEq(a, b)  // ==, ===\npolyNeq(a, b) // !=, !==\n```\n\nAll binary expression operators have a corresponding named function in the standard library.\nWhile `&&` and `||` may not evaluate their second argument,\ntheir corresponding named functions `and`, `or`, and `xor`, always do.\n\n\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "exit": "\n```javascript\nexit();\n```\n\nAn exit statement, written `exit();`, halts the computation.\nIt is a terminator statement, so it must have an empty tail.\nIt may only occur in a step.\n\n```javascript\n  transfer(lastPrice).to(Creator);\n  transfer(amt, nftId).to(highestBidder);\n  commit();\n\n  each([Creator, Bidder], () => interact.showOutcome(highestBidder));\n  exit();\n});\n```\n",
  "export": " `export` in front of them.\nFor example,\n```javascript\nexport const x = 1;\nexport const [a, b, ...more] = [ 0, 1, 2, 3, 4 ];\nexport function add1(x) { return x + 1; };\n```\n\nare valid exports.\n\nModule-level identifiers may also be exported after the fact,\nand may be renamed during export.\nFor example:\n\n```javascript\nconst w = 2;\nconst z = 0;\nexport {w, z as zero};\n```\n\nIdentifiers from other modules may be re-exported (and renamed),\neven if they are not imported in the current module.\nFor example:\n\n```javascript\nexport {u, x as other_x} from './other-module.rsh';\n```\n\nIn this case, there is a module with a name of `other-module.rsh` which contains `u` and `x`.\nIdentifier `u` is exported as `u`, and `x` is exported and renamed to be `other_x`.\nAn exported identifier in a given module may be imported by other modules.\nBoth `u` and `other_x` can be imported from the current module instead of importing them from `other-module.rsh`.\n\nExports are also exposed to the frontend via `getExports`. \nFor more information on `getExports` and exposing exports to the frontend, refer to [JavaScript](https://docs.reach.sh/cout/#ref-backends-js).\n\nFunctions are only exposed if they are typed, that is, if they are constructed with `is`.\nRefer to [Types](https://docs.reach.sh/rsh/compute/#ref-programs-types) for more information.\n",
  "extends": "\n\n\n\n\n\n\n\n\n\n\n\nThis error indicates you are using an illegal JavaScript expression in Reach. Not all JavaScript\nexpressions are valid Reach, as they are not applicable to the language.\n",
  "fail": "\n```javascript\nfail() \n```\n\nis a convenience method equivalent to `assume(false)`. This may only appear in a local step.\n",
  "for": "\n\n\n\n\n\n\n\n\n\n\nThis error indicates you are using an illegal JavaScript expression in Reach. Not all JavaScript\nexpressions are valid Reach, as they are not applicable to the language.\n",
  "forall": "\n```javascript\nforall( Type )\nforall( Type, (var) => BLOCK )\n```\n\n The single argument version returns an abstract value of the given type.\nIt may only be referenced inside of assertions; any other reference is invalid.\n\nThe two argument version is an abbreviation of calling the second argument with the result of `forall(Type)`.\nThis is convenient for writing general claims about expressions, such as\n\n```javascript\nforall(UInt, (x) => assert(x == x));\n```\n\nThe following code sample uses a couple of `forall` arguments to assert that `winner` always provides a valid outcome.\n\n```javascript\nforall(UInt, handAlice =>\n  forall(UInt, handBob =>\n    assert(isOutcome(winner(handAlice, handBob)))));\n```\n",
  "fork": "@{ref(\"rsh\", \"fork.api_\")}\n```javascript\nfork()\n.case(Alice, (() => ({\n  msg: 19,\n  when: declassify(interact.keepGoing()) })),\n  ((v) => v),\n  (v) => {\n    require(v == 19);\n    transfer(wager + 19).to(this);\n    commit();\n    exit();\n  })\n.case(Bob, (() => ({\n  when: declassify(interact.keepGoing())\n  _local: interact.secretVal })),\n  ((_) => wager),\n  (_, _secV) => {\n    commit();\n\n    Bob.only(() => interact.showSecret(_secV))\n\n    Alice.only(() => interact.showOpponent(Bob));\n\n    race(Alice, Bob).publish();\n    transfer(2 * wager).to(this);\n    commit();\n    exit();\n  })\n.timeout(deadline, () => {\n  race(Alice, Bob).publish();\n  transfer(wager).to(this);\n  commit();\n  exit(); });\n```\n\n---\n**NOTE**\n\nIf you're unsure of what kind of consensus transfer to use, you may want to read the [explanation of the differences](https://docs.reach.sh/guide/ctransfers/#guide-ctransfers) in the Guide.\n\n---\n\nA fork statement is written:\n\n```javascript\nfork()\n.paySpec(TOKENS_EXPR)\n.case(PART_EXPR,\n  CHECK_EXPR,\n  PUBLISH_EXPR,\n  PAY_EXPR | [PAY_EXPR, PAY_REQUIRE_EXPR],\n  CONSENSUS_EXPR)\n.api(API_EXPR,\n  API_ASSUME_EXPR,\n  API_PAY_EXPR | [API_PAY_EXPR, PAY_REQUIRE_EXPR],\n  API_CONSENSUS_EXPR)\n.api_(API_EXPR,\n  API_CHECKED_CONSENSUS_EXPR)\n.timeout(DELAY_EXPR, () =>\n  TIMEOUT_BLOCK);\n// or\n.throwTimeout(DELAY_EXPR, THROW_EXPR)\n```\nwhere:\n+ `TOKENS_EXPR` is a syntactic tuple of `Token` identifiers,\n  or a static ternary expression that evaluates to one;\n+ `PART_EXPR` is an expression that evaluates to a participant;\n+ (optional) `CHECK_EXPR` is a syntactic arrow expression that is evaluated in both the local step and consensus step.\nThis block can be used to specify `check`s and declare variable bindings.\nIf it is present, then `PAY_EXPR` must be included;\n+ `PUBLISH_EXPR` is a syntactic arrow expression that is evaluated in a local step for the specified participant and must evaluate to an object that may contain a `msg` field, which may be of any type, a `when` field, which must be a boolean, and a `_local` field, which may be of any type;\n+ (optional) `PAY_EXPR` is an expression that evaluates to a function parameterized over the `msg` value and returns a pay amount; if this component is left-out, it is synthesized to zero;\n+ (optional) `PAY_REQUIRE_EXPR` is a function parameterized over the `msg` value which is evaluated for effect in a consensus step; thus it may be used to add `require` constraints on the value used for payment.\nIf this is absent, then it is synthesized to an empty function.\n+ `CONSENSUS_EXPR` is a syntactic arrow expression parameterized over the `msg` and `_local` values which is evaluated in a consensus step;\n+ `API_EXPR` is an expression that evaluates to an API member function;\n+ (optional) `API_ASSUME_EXPR` is a function parameterized over the input to the API member function which is evaluated for effect in a local step; thus it may be used to add `assume` constraints on the values given by the API; if this is absent, then it is synthesized to an empty function; if it is present, then `API_PAY_EXPR` must be included;\n+ (optional) `API_PAY_EXPR` is a function parameterized over the input to the API member function which is evaluated to determine the pay amount, like `PAY_EXPR`;\n+ `API_CONSENSUS_EXPR` is a function parameterized over the input to the API member function and a function that returns a value to the API call; this function must be called;\n+ `API_CHECKED_CONSENSUS_EXPR` is a function parameterized over the input to the API member function.\nIt must return either a pair of `[ PAY_EXPR, CONSENSUS_RET_EXPR ]` or `[ CONSENSUS_RET_EXPR ]`, where `CONSENSUS_RET_EXPR` is a function parameterized over the function that returns a value to the API call.\nThe parameter of `CONSENSUS_RET_EXPR` must be called.\nAny `check`s performed before the `return` statement will be applied in the local step, during payment, and the consensus step of the API call.\n+ the `timeout` and `throwTimeout` parameter are as in an consensus transfer.\n\nIn the discussion of `.api` component, the phrase \"parameterized over the input\" means that if an API function has two arguments, such as `Fun([UInt, UInt], Null)`, then the corresponding expression must receive two arguments.\nFor example, the `API_PAY_EXPR` component would be a function that accepts two arguments, while the `API_CONSENSUS_EXPR` would be a function that acccepts three arguments---the two for the API and the function used to return a value.\nAll API functions must rely only on consensus state and the function domain.\n\nIf the `msg` field is absent from the object returned from `PUBLISH_EXPR`, then it is treated as if it were `null`.\n\nIf the `when` field is absent from the object returned from `PUBLISH_EXPR`, then it is treated as if it were `true`.\n\nIf the `_local` field is absent from the object returned from `PUBLISH_EXPR`, then it is treated as if it were `null`.\n\nIf the `PAY_EXPR` is absent, then it is treated as if it were `(_) => 0`.\n\nThe `TOKENS_EXPR` and `PAY_EXPR` have the same restrictions as the `.pay` component of a consensus transfer: i.e., they must be pure and can only refer to consensus state.\n\nThe `.case` and `.api` components may be repeated many times.\n\nThe same participant may specify multiple cases.\nIn this situation, the order of the cases is significant.\nThat is, a subsequent case will only be evaluated if the prior case's `when` field is `false`.\n\nIf the participant specified by `PART_EXPR` is not already fixed (in the sense of `Participant.set`), then if it wins the `race`, it is fixed, provided it is not a participant class.\n",
  "from": "\n```javascript\nimport {flipCoin, rollDice as d6} from 'games-of-chance.rsh';\n```\n\nImport statements may limit or rename the imported identifiers.\n\n```javascript\nimport * as gamesOfChance from 'games-of-chance.rsh';\n```\n\nImports may instead bind the entire module to a single identifier,\nwhich is an object with fields corresponding to that module's exports.\n\nImport cycles are invalid.\n\nThe path given to an import may **not** include `..` to specify files outside the current directory **nor** may it be an absolute path.\n\nIt **must** be a relative path, which is resolved relative to the parent directory of the source file in which they appear.\n",
  "fromLeft": "\n```javascript\nconst e = Either(UInt, Bool);\nconst l = e.Left(1);\nconst r = e.Right(true);\nisLeft(l);  // true\nisRight(l); // false\nconst x = fromLeft(l, 0);      // x = 1\nconst y = fromRight(l, false); // y = false\n```\n\n `isLeft` is a convenience method that determines whether the variant is `Left`.\n\n `isRight` is a convenience method that determines whether the variant is `Right`.\n\n `fromLeft(e, default)` is a convenience method that returns the value in `Left`,\nor `default` if the variant is `Right`.\n\n `fromRight(e, default)` is a convenience method that returns the value in `Right`,\nor `default` if the variant is `Left`.\n",
  "fromMaybe": "\n```javascript\nconst MayInt = Maybe(UInt);\nconst bidA = MayInt.Some(42);\nconst bidB = MayInt.None(null);\n\nconst getBid = (m) => fromMaybe(m, (() => 0), ((x) => x));\nconst bidSum = getBid(bidA) + getBid(bidB);\nassert(bidSum == 42);\n```\n\n[Option types](https://en.wikipedia.org/wiki/Option_type) are represented in Reach through the built-in `Data` type, `Maybe`, which has two variants: `Some` and `None`.\n\n`Maybe` is defined by\n```javascript\nexport const Maybe = (A) => Data({None: Null, Some: A});\n```\n\nThis means it is a function that returns a `Data` type specialized to a particular type in the `Some` variant.\n\n`Maybe` instances can be conveniently consumed by `fromMaybe(mValue, onNone, onSome)`, where `onNone` is a function of no arguments which is called when `mValue` is `None`, `onSome` is a function of one argument which is called with the value when `mValue` is `Some`, and `mValue` is a data instance of `Maybe`.\n\n\n```javascript\nconst m = Maybe(UInt).Some(5);\nisNone(m); // false\nisSome(m); // true\n```\n\n `isNone` is a convenience method that determines whether the variant is `None`.\n\n `isSome` is a convenience method that determines whether the variant is `Some`.\n\n\n```javascript\nfromSome(Maybe(UInt).Some(1), 0); // 1\nfromSome(Maybe(UInt).None(), 0);  // 0\n```\n\n `fromSome` receives a `Maybe` value and a default value as arguments and will return the value inside\nof the `Some` variant or the default value otherwise.\n\n\n```javascript\nconst add1 = (x) => x + 1;\nmaybe(Maybe(UInt).Some(1), 0, add1); // 2\nmaybe(Maybe(UInt).None(), 0, add1);  // 0\n```\n\n `maybe(m, defaultVal, f)` receives a `Maybe` value, a default value, and a unary function as arguments. The function will\neither return the application of the function, `f`, to the `Some` value or return the default value provided.\n\nThe following examples demonstrate different usage of `Maybe`:\n\n```javascript\nconst MUInt = Maybe(UInt);\n```\n\n```javascript\n        interact.printBool(Maybe(UInt).Some(5) == Maybe(UInt).Some(5));\n```\n\n```javascript\n  var [ claimed_by, keep_going ] = [ Maybe(Address).None(), true ];\n```\n",
  "fromRight": "\n```javascript\nconst e = Either(UInt, Bool);\nconst l = e.Left(1);\nconst r = e.Right(true);\nisLeft(l);  // true\nisRight(l); // false\nconst x = fromLeft(l, 0);      // x = 1\nconst y = fromRight(l, false); // y = false\n```\n\n `isLeft` is a convenience method that determines whether the variant is `Left`.\n\n `isRight` is a convenience method that determines whether the variant is `Right`.\n\n `fromLeft(e, default)` is a convenience method that returns the value in `Left`,\nor `default` if the variant is `Right`.\n\n `fromRight(e, default)` is a convenience method that returns the value in `Right`,\nor `default` if the variant is `Left`.\n",
  "fromSome": "\n```javascript\nfromSome(Maybe(UInt).Some(1), 0); // 1\nfromSome(Maybe(UInt).None(), 0);  // 0\n```\n\n `fromSome` receives a `Maybe` value and a default value as arguments and will return the value inside\nof the `Some` variant or the default value otherwise.\n\n\n```javascript\nconst add1 = (x) => x + 1;\nmaybe(Maybe(UInt).Some(1), 0, add1); // 2\nmaybe(Maybe(UInt).None(), 0, add1);  // 0\n```\n\n `maybe(m, defaultVal, f)` receives a `Maybe` value, a default value, and a unary function as arguments. The function will\neither return the application of the function, `f`, to the `Some` value or return the default value provided.\n\nThe following examples demonstrate different usage of `Maybe`:\n\n```javascript\nconst MUInt = Maybe(UInt);\n```\n\n```javascript\n        interact.printBool(Maybe(UInt).Some(5) == Maybe(UInt).Some(5));\n```\n\n```javascript\n  var [ claimed_by, keep_going ] = [ Maybe(Address).None(), true ];\n```\n",
  "function": "\n```javascript\nfunction randomBool() {\n  return (interact.random() % 2) == 0; };\n```\n\nA function definition, written `function FUN(LHS_0, ..., LHS_n) BLOCK;`, defines `FUN` as a function which abstracts its function body, the block `BLOCK`, over the left-hand sides `LHS_0` through `LHS_n`.\n\nFunction parameters may specify default arguments. The expressions used to instantiate these parameters\nhave access to any variables in the scope of which the function was defined. Additionally, these expressions\nmay reference previous arguments of the function definition.\nParameters with default arguments must come after all other parameters.\n\n```javascript\nfunction f(a, b, c = a + 1, d = b + c) =>\n  a + b + c + d;\n```\n\nThe last parameter of a function may be a rest parameter, which allows the function to be called\nwith an arbitrary number of arguments. A rest parameter is specified via `...IDENT`, where\n`IDENT` is bound to a `Tuple` containing all the remaining arguments.\n\n---\n\nAll identifiers in Reach programs must be unbound\nat the position of the program where they are bound,\ni.e., it is invalid to shadow identifiers with new definitions.\nFor example,\n\n```javascript\nconst x = 3;\nconst x = 4;\n```\n\nis invalid.\nThis restriction is independent of whether a binding is\nonly known to a single participant. For example,\n\n```javascript\nAlice.only(() => {\n  const x = 3; });\nBob.only(() => {\n  const x = 3; });\n```\n\nis invalid.\n\nThe special identifier `_` is an exception to this rule.\nThe `_` binding is always considered to be unbound.\nThis means means that `_` is both\nan identifier that can never be read,\nas well as an identifier that may be bound many times.\nThis may be useful for ignoring unwanted values, for example:\n\n```javascript\nconst [_, x, _] = [1, 2, 3];\n```\n",
  "fx": "\n```javascript\nconst scale = 10;\nconst i = 56;\nfx(scale)(Neg, i); // represents - 5.6\n```\n\n `fx(scale)(i)` will return a function that can be used to\ninstantiate fixed point numbers with a particular scale factor.\n\n\n```javascript\nconst i = 4;\nfxint(-i); // represents - 4.0\n```\n\n `fxint(Int)` will cast the `Int` arg as a `FixedPoint`\nnumber with a `scale` of 1.\n\n\n```javascript\nconst x = fx(1000)(Pos, 1234); // x = 1.234\nfxrescale(x, 100);    // => 1.23\n```\n\n `fxrescale(x, scale)` will convert a fixed point number from using\none scale to another. This operation can result in loss of precision, as demonstrated in the above example.\n\n\n```javascript\nconst x = fx(1000)(Pos, 824345); // x = 824.345\nconst y = 45.67;\nfxunify(x, y);    // => [ 1000, 824.345, 45.670 ]\n```\n\n `fxunify(x, y)` will convert the fixed point numbers\nto use the same scale. The larger scale of the two arguments will be chosen. The function will return a `3-tuple` consisting\nof the common scale and the newly scaled values.\n\n\n `fxadd(x, y)` adds two fixed point numbers.\n\n\n `fxsub(x, y)` subtracts two fixed point numbers.\n\n\n `fxmul(x, y)` multiplies two fixed point numbers.\n\n\n```javascript\nfxdiv(34.56, 1.234, 10)     // => 28\nfxdiv(34.56, 1.234, 100000) // => 28.0064\n```\n\n `fxdiv(x, y, scale_factor)` divides two fixed point numbers. The numerator, `x`,\nwill be multiplied by the scale factor to provide a more precise answer. For example,\n\n\n `fxmod(x, y)` finds the remainder of dividing `x` by `y`.\n\n\n `fxfloor(x)` returns the greatest integer not greater than `x`.\n\n\n `fxsqrt(x, k)` returns the square root of the fixed number, `x`.\n\n\n `fxsqrtApprox(x, k)` approximates the square root of the fixed number, `x`, using `k` iterations of the `sqrtApprox` algorithm.\n\n\n`const base  = 2.0;\nconst power = 0.33;\nfxpow(base, power, 10, 1000);    // 1.260\nfxpow(base, power, 10, 10000);   // 1.2599\nfxpow(base, power, 10, 1000000); // 1.259921 `\n\n `fxpow(base, power, precision, scalePrecision)` approximates the power of the fixed number, `base`,\nraised to the fixed point number, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform.\nThe `scalePrecision` argument must be a `UInt` and represents the scale of the return value. Choosing a larger\n`scalePrecision` allows for more precision when approximating the power, as demonstrated in the example below:\n\n\n `fxpowi(base, power, precision)` approximates the power of the fixed number, `base`,\nraised to the `Int`, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform. For reference, `6` iterations\nprovides enough accuracy to calculate up to `2^64 - 1`, so the largest power it can compute is `63`.\n\n\n`fxpowui(5.8, 3, 10); // 195.112 `\n\n `fxpowui(base, power, precision)` approximates the power of\nthe fixed number, `base`, raised to the `UInt`, `power`. The third\nargument must be a `UInt` whose value is known at compile time.\n\n\n `fxcmp(op, x, y)` applies the comparison\noperator to the two fixed point numbers after unifying their scales.\n\nThere are convenience methods defined for comparing fixed point numbers:\n\n\n `fxlt(x, y)` tests whether `x` is less than `y`.\n\n\n `fxle(x, y)` tests whether `x` is less than or equal to `y`.\n\n\n `fxgt(x, y)` tests whether `x` is greater than `y`.\n\n\n `fxge(x, y)` tests whether `x` is greater than or equal to `y`.\n\n\n `fxeq(x, y)` tests whether `x` is equal to `y`.\n\n\n `fxne(x, y)` tests whether `x` is not equal to `y`.\n",
  "fxadd": "\n `fxadd(x, y)` adds two fixed point numbers.\n\n\n `fxsub(x, y)` subtracts two fixed point numbers.\n\n\n `fxmul(x, y)` multiplies two fixed point numbers.\n\n\n```javascript\nfxdiv(34.56, 1.234, 10)     // => 28\nfxdiv(34.56, 1.234, 100000) // => 28.0064\n```\n\n `fxdiv(x, y, scale_factor)` divides two fixed point numbers. The numerator, `x`,\nwill be multiplied by the scale factor to provide a more precise answer. For example,\n\n\n `fxmod(x, y)` finds the remainder of dividing `x` by `y`.\n\n\n `fxfloor(x)` returns the greatest integer not greater than `x`.\n\n\n `fxsqrt(x, k)` returns the square root of the fixed number, `x`.\n\n\n `fxsqrtApprox(x, k)` approximates the square root of the fixed number, `x`, using `k` iterations of the `sqrtApprox` algorithm.\n\n\n`const base  = 2.0;\nconst power = 0.33;\nfxpow(base, power, 10, 1000);    // 1.260\nfxpow(base, power, 10, 10000);   // 1.2599\nfxpow(base, power, 10, 1000000); // 1.259921 `\n\n `fxpow(base, power, precision, scalePrecision)` approximates the power of the fixed number, `base`,\nraised to the fixed point number, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform.\nThe `scalePrecision` argument must be a `UInt` and represents the scale of the return value. Choosing a larger\n`scalePrecision` allows for more precision when approximating the power, as demonstrated in the example below:\n\n\n `fxpowi(base, power, precision)` approximates the power of the fixed number, `base`,\nraised to the `Int`, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform. For reference, `6` iterations\nprovides enough accuracy to calculate up to `2^64 - 1`, so the largest power it can compute is `63`.\n\n\n`fxpowui(5.8, 3, 10); // 195.112 `\n\n `fxpowui(base, power, precision)` approximates the power of\nthe fixed number, `base`, raised to the `UInt`, `power`. The third\nargument must be a `UInt` whose value is known at compile time.\n\n\n `fxcmp(op, x, y)` applies the comparison\noperator to the two fixed point numbers after unifying their scales.\n\nThere are convenience methods defined for comparing fixed point numbers:\n\n\n `fxlt(x, y)` tests whether `x` is less than `y`.\n\n\n `fxle(x, y)` tests whether `x` is less than or equal to `y`.\n\n\n `fxgt(x, y)` tests whether `x` is greater than `y`.\n\n\n `fxge(x, y)` tests whether `x` is greater than or equal to `y`.\n\n\n `fxeq(x, y)` tests whether `x` is equal to `y`.\n\n\n `fxne(x, y)` tests whether `x` is not equal to `y`.\n",
  "fxcmp": "\n `fxcmp(op, x, y)` applies the comparison\noperator to the two fixed point numbers after unifying their scales.\n\nThere are convenience methods defined for comparing fixed point numbers:\n\n\n `fxlt(x, y)` tests whether `x` is less than `y`.\n\n\n `fxle(x, y)` tests whether `x` is less than or equal to `y`.\n\n\n `fxgt(x, y)` tests whether `x` is greater than `y`.\n\n\n `fxge(x, y)` tests whether `x` is greater than or equal to `y`.\n\n\n `fxeq(x, y)` tests whether `x` is equal to `y`.\n\n\n `fxne(x, y)` tests whether `x` is not equal to `y`.\n",
  "fxdiv": "\n```javascript\nfxdiv(34.56, 1.234, 10)     // => 28\nfxdiv(34.56, 1.234, 100000) // => 28.0064\n```\n\n `fxdiv(x, y, scale_factor)` divides two fixed point numbers. The numerator, `x`,\nwill be multiplied by the scale factor to provide a more precise answer. For example,\n\n\n `fxmod(x, y)` finds the remainder of dividing `x` by `y`.\n\n\n `fxfloor(x)` returns the greatest integer not greater than `x`.\n\n\n `fxsqrt(x, k)` returns the square root of the fixed number, `x`.\n\n\n `fxsqrtApprox(x, k)` approximates the square root of the fixed number, `x`, using `k` iterations of the `sqrtApprox` algorithm.\n\n\n`const base  = 2.0;\nconst power = 0.33;\nfxpow(base, power, 10, 1000);    // 1.260\nfxpow(base, power, 10, 10000);   // 1.2599\nfxpow(base, power, 10, 1000000); // 1.259921 `\n\n `fxpow(base, power, precision, scalePrecision)` approximates the power of the fixed number, `base`,\nraised to the fixed point number, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform.\nThe `scalePrecision` argument must be a `UInt` and represents the scale of the return value. Choosing a larger\n`scalePrecision` allows for more precision when approximating the power, as demonstrated in the example below:\n\n\n `fxpowi(base, power, precision)` approximates the power of the fixed number, `base`,\nraised to the `Int`, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform. For reference, `6` iterations\nprovides enough accuracy to calculate up to `2^64 - 1`, so the largest power it can compute is `63`.\n\n\n`fxpowui(5.8, 3, 10); // 195.112 `\n\n `fxpowui(base, power, precision)` approximates the power of\nthe fixed number, `base`, raised to the `UInt`, `power`. The third\nargument must be a `UInt` whose value is known at compile time.\n\n\n `fxcmp(op, x, y)` applies the comparison\noperator to the two fixed point numbers after unifying their scales.\n\nThere are convenience methods defined for comparing fixed point numbers:\n\n\n `fxlt(x, y)` tests whether `x` is less than `y`.\n\n\n `fxle(x, y)` tests whether `x` is less than or equal to `y`.\n\n\n `fxgt(x, y)` tests whether `x` is greater than `y`.\n\n\n `fxge(x, y)` tests whether `x` is greater than or equal to `y`.\n\n\n `fxeq(x, y)` tests whether `x` is equal to `y`.\n\n\n `fxne(x, y)` tests whether `x` is not equal to `y`.\n",
  "fxeq": "\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "fxfloor": "\n `fxfloor(x)` returns the greatest integer not greater than `x`.\n\n\n `fxsqrt(x, k)` returns the square root of the fixed number, `x`.\n\n\n `fxsqrtApprox(x, k)` approximates the square root of the fixed number, `x`, using `k` iterations of the `sqrtApprox` algorithm.\n\n\n`const base  = 2.0;\nconst power = 0.33;\nfxpow(base, power, 10, 1000);    // 1.260\nfxpow(base, power, 10, 10000);   // 1.2599\nfxpow(base, power, 10, 1000000); // 1.259921 `\n\n `fxpow(base, power, precision, scalePrecision)` approximates the power of the fixed number, `base`,\nraised to the fixed point number, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform.\nThe `scalePrecision` argument must be a `UInt` and represents the scale of the return value. Choosing a larger\n`scalePrecision` allows for more precision when approximating the power, as demonstrated in the example below:\n\n\n `fxpowi(base, power, precision)` approximates the power of the fixed number, `base`,\nraised to the `Int`, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform. For reference, `6` iterations\nprovides enough accuracy to calculate up to `2^64 - 1`, so the largest power it can compute is `63`.\n\n\n`fxpowui(5.8, 3, 10); // 195.112 `\n\n `fxpowui(base, power, precision)` approximates the power of\nthe fixed number, `base`, raised to the `UInt`, `power`. The third\nargument must be a `UInt` whose value is known at compile time.\n\n\n `fxcmp(op, x, y)` applies the comparison\noperator to the two fixed point numbers after unifying their scales.\n\nThere are convenience methods defined for comparing fixed point numbers:\n\n\n `fxlt(x, y)` tests whether `x` is less than `y`.\n\n\n `fxle(x, y)` tests whether `x` is less than or equal to `y`.\n\n\n `fxgt(x, y)` tests whether `x` is greater than `y`.\n\n\n `fxge(x, y)` tests whether `x` is greater than or equal to `y`.\n\n\n `fxeq(x, y)` tests whether `x` is equal to `y`.\n\n\n `fxne(x, y)` tests whether `x` is not equal to `y`.\n",
  "fxge": "\n `fxge(x, y)` tests whether `x` is greater than or equal to `y`.\n\n\n `fxeq(x, y)` tests whether `x` is equal to `y`.\n\n\n `fxne(x, y)` tests whether `x` is not equal to `y`.\n",
  "fxgt": "\n `fxgt(x, y)` tests whether `x` is greater than `y`.\n\n\n `fxge(x, y)` tests whether `x` is greater than or equal to `y`.\n\n\n `fxeq(x, y)` tests whether `x` is equal to `y`.\n\n\n `fxne(x, y)` tests whether `x` is not equal to `y`.\n",
  "fxint": "\n```javascript\nconst i = 4;\nfxint(-i); // represents - 4.0\n```\n\n `fxint(Int)` will cast the `Int` arg as a `FixedPoint`\nnumber with a `scale` of 1.\n\n\n```javascript\nconst x = fx(1000)(Pos, 1234); // x = 1.234\nfxrescale(x, 100);    // => 1.23\n```\n\n `fxrescale(x, scale)` will convert a fixed point number from using\none scale to another. This operation can result in loss of precision, as demonstrated in the above example.\n\n\n```javascript\nconst x = fx(1000)(Pos, 824345); // x = 824.345\nconst y = 45.67;\nfxunify(x, y);    // => [ 1000, 824.345, 45.670 ]\n```\n\n `fxunify(x, y)` will convert the fixed point numbers\nto use the same scale. The larger scale of the two arguments will be chosen. The function will return a `3-tuple` consisting\nof the common scale and the newly scaled values.\n\n\n `fxadd(x, y)` adds two fixed point numbers.\n\n\n `fxsub(x, y)` subtracts two fixed point numbers.\n\n\n `fxmul(x, y)` multiplies two fixed point numbers.\n\n\n```javascript\nfxdiv(34.56, 1.234, 10)     // => 28\nfxdiv(34.56, 1.234, 100000) // => 28.0064\n```\n\n `fxdiv(x, y, scale_factor)` divides two fixed point numbers. The numerator, `x`,\nwill be multiplied by the scale factor to provide a more precise answer. For example,\n\n\n `fxmod(x, y)` finds the remainder of dividing `x` by `y`.\n\n\n `fxfloor(x)` returns the greatest integer not greater than `x`.\n\n\n `fxsqrt(x, k)` returns the square root of the fixed number, `x`.\n\n\n `fxsqrtApprox(x, k)` approximates the square root of the fixed number, `x`, using `k` iterations of the `sqrtApprox` algorithm.\n\n\n`const base  = 2.0;\nconst power = 0.33;\nfxpow(base, power, 10, 1000);    // 1.260\nfxpow(base, power, 10, 10000);   // 1.2599\nfxpow(base, power, 10, 1000000); // 1.259921 `\n\n `fxpow(base, power, precision, scalePrecision)` approximates the power of the fixed number, `base`,\nraised to the fixed point number, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform.\nThe `scalePrecision` argument must be a `UInt` and represents the scale of the return value. Choosing a larger\n`scalePrecision` allows for more precision when approximating the power, as demonstrated in the example below:\n\n\n `fxpowi(base, power, precision)` approximates the power of the fixed number, `base`,\nraised to the `Int`, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform. For reference, `6` iterations\nprovides enough accuracy to calculate up to `2^64 - 1`, so the largest power it can compute is `63`.\n\n\n`fxpowui(5.8, 3, 10); // 195.112 `\n\n `fxpowui(base, power, precision)` approximates the power of\nthe fixed number, `base`, raised to the `UInt`, `power`. The third\nargument must be a `UInt` whose value is known at compile time.\n\n\n `fxcmp(op, x, y)` applies the comparison\noperator to the two fixed point numbers after unifying their scales.\n\nThere are convenience methods defined for comparing fixed point numbers:\n\n\n `fxlt(x, y)` tests whether `x` is less than `y`.\n\n\n `fxle(x, y)` tests whether `x` is less than or equal to `y`.\n\n\n `fxgt(x, y)` tests whether `x` is greater than `y`.\n\n\n `fxge(x, y)` tests whether `x` is greater than or equal to `y`.\n\n\n `fxeq(x, y)` tests whether `x` is equal to `y`.\n\n\n `fxne(x, y)` tests whether `x` is not equal to `y`.\n",
  "fxle": "\n `fxle(x, y)` tests whether `x` is less than or equal to `y`.\n\n\n `fxgt(x, y)` tests whether `x` is greater than `y`.\n\n\n `fxge(x, y)` tests whether `x` is greater than or equal to `y`.\n\n\n `fxeq(x, y)` tests whether `x` is equal to `y`.\n\n\n `fxne(x, y)` tests whether `x` is not equal to `y`.\n",
  "fxlt": "\n `fxlt(x, y)` tests whether `x` is less than `y`.\n\n\n `fxle(x, y)` tests whether `x` is less than or equal to `y`.\n\n\n `fxgt(x, y)` tests whether `x` is greater than `y`.\n\n\n `fxge(x, y)` tests whether `x` is greater than or equal to `y`.\n\n\n `fxeq(x, y)` tests whether `x` is equal to `y`.\n\n\n `fxne(x, y)` tests whether `x` is not equal to `y`.\n",
  "fxmod": "\n `fxmod(x, y)` finds the remainder of dividing `x` by `y`.\n\n\n `fxfloor(x)` returns the greatest integer not greater than `x`.\n\n\n `fxsqrt(x, k)` returns the square root of the fixed number, `x`.\n\n\n `fxsqrtApprox(x, k)` approximates the square root of the fixed number, `x`, using `k` iterations of the `sqrtApprox` algorithm.\n\n\n`const base  = 2.0;\nconst power = 0.33;\nfxpow(base, power, 10, 1000);    // 1.260\nfxpow(base, power, 10, 10000);   // 1.2599\nfxpow(base, power, 10, 1000000); // 1.259921 `\n\n `fxpow(base, power, precision, scalePrecision)` approximates the power of the fixed number, `base`,\nraised to the fixed point number, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform.\nThe `scalePrecision` argument must be a `UInt` and represents the scale of the return value. Choosing a larger\n`scalePrecision` allows for more precision when approximating the power, as demonstrated in the example below:\n\n\n `fxpowi(base, power, precision)` approximates the power of the fixed number, `base`,\nraised to the `Int`, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform. For reference, `6` iterations\nprovides enough accuracy to calculate up to `2^64 - 1`, so the largest power it can compute is `63`.\n\n\n`fxpowui(5.8, 3, 10); // 195.112 `\n\n `fxpowui(base, power, precision)` approximates the power of\nthe fixed number, `base`, raised to the `UInt`, `power`. The third\nargument must be a `UInt` whose value is known at compile time.\n\n\n `fxcmp(op, x, y)` applies the comparison\noperator to the two fixed point numbers after unifying their scales.\n\nThere are convenience methods defined for comparing fixed point numbers:\n\n\n `fxlt(x, y)` tests whether `x` is less than `y`.\n\n\n `fxle(x, y)` tests whether `x` is less than or equal to `y`.\n\n\n `fxgt(x, y)` tests whether `x` is greater than `y`.\n\n\n `fxge(x, y)` tests whether `x` is greater than or equal to `y`.\n\n\n `fxeq(x, y)` tests whether `x` is equal to `y`.\n\n\n `fxne(x, y)` tests whether `x` is not equal to `y`.\n",
  "fxmul": "\n `fxmul(x, y)` multiplies two fixed point numbers.\n\n\n```javascript\nfxdiv(34.56, 1.234, 10)     // => 28\nfxdiv(34.56, 1.234, 100000) // => 28.0064\n```\n\n `fxdiv(x, y, scale_factor)` divides two fixed point numbers. The numerator, `x`,\nwill be multiplied by the scale factor to provide a more precise answer. For example,\n\n\n `fxmod(x, y)` finds the remainder of dividing `x` by `y`.\n\n\n `fxfloor(x)` returns the greatest integer not greater than `x`.\n\n\n `fxsqrt(x, k)` returns the square root of the fixed number, `x`.\n\n\n `fxsqrtApprox(x, k)` approximates the square root of the fixed number, `x`, using `k` iterations of the `sqrtApprox` algorithm.\n\n\n`const base  = 2.0;\nconst power = 0.33;\nfxpow(base, power, 10, 1000);    // 1.260\nfxpow(base, power, 10, 10000);   // 1.2599\nfxpow(base, power, 10, 1000000); // 1.259921 `\n\n `fxpow(base, power, precision, scalePrecision)` approximates the power of the fixed number, `base`,\nraised to the fixed point number, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform.\nThe `scalePrecision` argument must be a `UInt` and represents the scale of the return value. Choosing a larger\n`scalePrecision` allows for more precision when approximating the power, as demonstrated in the example below:\n\n\n `fxpowi(base, power, precision)` approximates the power of the fixed number, `base`,\nraised to the `Int`, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform. For reference, `6` iterations\nprovides enough accuracy to calculate up to `2^64 - 1`, so the largest power it can compute is `63`.\n\n\n`fxpowui(5.8, 3, 10); // 195.112 `\n\n `fxpowui(base, power, precision)` approximates the power of\nthe fixed number, `base`, raised to the `UInt`, `power`. The third\nargument must be a `UInt` whose value is known at compile time.\n\n\n `fxcmp(op, x, y)` applies the comparison\noperator to the two fixed point numbers after unifying their scales.\n\nThere are convenience methods defined for comparing fixed point numbers:\n\n\n `fxlt(x, y)` tests whether `x` is less than `y`.\n\n\n `fxle(x, y)` tests whether `x` is less than or equal to `y`.\n\n\n `fxgt(x, y)` tests whether `x` is greater than `y`.\n\n\n `fxge(x, y)` tests whether `x` is greater than or equal to `y`.\n\n\n `fxeq(x, y)` tests whether `x` is equal to `y`.\n\n\n `fxne(x, y)` tests whether `x` is not equal to `y`.\n",
  "fxne": "\n `fxne(x, y)` tests whether `x` is not equal to `y`.\n",
  "fxpow": "\n`const base  = 2.0;\nconst power = 0.33;\nfxpow(base, power, 10, 1000);    // 1.260\nfxpow(base, power, 10, 10000);   // 1.2599\nfxpow(base, power, 10, 1000000); // 1.259921 `\n\n `fxpow(base, power, precision, scalePrecision)` approximates the power of the fixed number, `base`,\nraised to the fixed point number, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform.\nThe `scalePrecision` argument must be a `UInt` and represents the scale of the return value. Choosing a larger\n`scalePrecision` allows for more precision when approximating the power, as demonstrated in the example below:\n\n\n `fxpowi(base, power, precision)` approximates the power of the fixed number, `base`,\nraised to the `Int`, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform. For reference, `6` iterations\nprovides enough accuracy to calculate up to `2^64 - 1`, so the largest power it can compute is `63`.\n\n\n`fxpowui(5.8, 3, 10); // 195.112 `\n\n `fxpowui(base, power, precision)` approximates the power of\nthe fixed number, `base`, raised to the `UInt`, `power`. The third\nargument must be a `UInt` whose value is known at compile time.\n\n\n `fxcmp(op, x, y)` applies the comparison\noperator to the two fixed point numbers after unifying their scales.\n\nThere are convenience methods defined for comparing fixed point numbers:\n\n\n `fxlt(x, y)` tests whether `x` is less than `y`.\n\n\n `fxle(x, y)` tests whether `x` is less than or equal to `y`.\n\n\n `fxgt(x, y)` tests whether `x` is greater than `y`.\n\n\n `fxge(x, y)` tests whether `x` is greater than or equal to `y`.\n\n\n `fxeq(x, y)` tests whether `x` is equal to `y`.\n\n\n `fxne(x, y)` tests whether `x` is not equal to `y`.\n",
  "fxpowi": "\n `fxpowi(base, power, precision)` approximates the power of the fixed number, `base`,\nraised to the `Int`, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform. For reference, `6` iterations\nprovides enough accuracy to calculate up to `2^64 - 1`, so the largest power it can compute is `63`.\n\n\n`fxpowui(5.8, 3, 10); // 195.112 `\n\n `fxpowui(base, power, precision)` approximates the power of\nthe fixed number, `base`, raised to the `UInt`, `power`. The third\nargument must be a `UInt` whose value is known at compile time.\n\n\n `fxcmp(op, x, y)` applies the comparison\noperator to the two fixed point numbers after unifying their scales.\n\nThere are convenience methods defined for comparing fixed point numbers:\n\n\n `fxlt(x, y)` tests whether `x` is less than `y`.\n\n\n `fxle(x, y)` tests whether `x` is less than or equal to `y`.\n\n\n `fxgt(x, y)` tests whether `x` is greater than `y`.\n\n\n `fxge(x, y)` tests whether `x` is greater than or equal to `y`.\n\n\n `fxeq(x, y)` tests whether `x` is equal to `y`.\n\n\n `fxne(x, y)` tests whether `x` is not equal to `y`.\n",
  "fxpowui": "\n`fxpowui(5.8, 3, 10); // 195.112 `\n\n `fxpowui(base, power, precision)` approximates the power of\nthe fixed number, `base`, raised to the `UInt`, `power`. The third\nargument must be a `UInt` whose value is known at compile time.\n\n\n `fxcmp(op, x, y)` applies the comparison\noperator to the two fixed point numbers after unifying their scales.\n\nThere are convenience methods defined for comparing fixed point numbers:\n\n\n `fxlt(x, y)` tests whether `x` is less than `y`.\n\n\n `fxle(x, y)` tests whether `x` is less than or equal to `y`.\n\n\n `fxgt(x, y)` tests whether `x` is greater than `y`.\n\n\n `fxge(x, y)` tests whether `x` is greater than or equal to `y`.\n\n\n `fxeq(x, y)` tests whether `x` is equal to `y`.\n\n\n `fxne(x, y)` tests whether `x` is not equal to `y`.\n",
  "fxrescale": "\n```javascript\nconst x = fx(1000)(Pos, 1234); // x = 1.234\nfxrescale(x, 100);    // => 1.23\n```\n\n `fxrescale(x, scale)` will convert a fixed point number from using\none scale to another. This operation can result in loss of precision, as demonstrated in the above example.\n\n\n```javascript\nconst x = fx(1000)(Pos, 824345); // x = 824.345\nconst y = 45.67;\nfxunify(x, y);    // => [ 1000, 824.345, 45.670 ]\n```\n\n `fxunify(x, y)` will convert the fixed point numbers\nto use the same scale. The larger scale of the two arguments will be chosen. The function will return a `3-tuple` consisting\nof the common scale and the newly scaled values.\n\n\n `fxadd(x, y)` adds two fixed point numbers.\n\n\n `fxsub(x, y)` subtracts two fixed point numbers.\n\n\n `fxmul(x, y)` multiplies two fixed point numbers.\n\n\n```javascript\nfxdiv(34.56, 1.234, 10)     // => 28\nfxdiv(34.56, 1.234, 100000) // => 28.0064\n```\n\n `fxdiv(x, y, scale_factor)` divides two fixed point numbers. The numerator, `x`,\nwill be multiplied by the scale factor to provide a more precise answer. For example,\n\n\n `fxmod(x, y)` finds the remainder of dividing `x` by `y`.\n\n\n `fxfloor(x)` returns the greatest integer not greater than `x`.\n\n\n `fxsqrt(x, k)` returns the square root of the fixed number, `x`.\n\n\n `fxsqrtApprox(x, k)` approximates the square root of the fixed number, `x`, using `k` iterations of the `sqrtApprox` algorithm.\n\n\n`const base  = 2.0;\nconst power = 0.33;\nfxpow(base, power, 10, 1000);    // 1.260\nfxpow(base, power, 10, 10000);   // 1.2599\nfxpow(base, power, 10, 1000000); // 1.259921 `\n\n `fxpow(base, power, precision, scalePrecision)` approximates the power of the fixed number, `base`,\nraised to the fixed point number, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform.\nThe `scalePrecision` argument must be a `UInt` and represents the scale of the return value. Choosing a larger\n`scalePrecision` allows for more precision when approximating the power, as demonstrated in the example below:\n\n\n `fxpowi(base, power, precision)` approximates the power of the fixed number, `base`,\nraised to the `Int`, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform. For reference, `6` iterations\nprovides enough accuracy to calculate up to `2^64 - 1`, so the largest power it can compute is `63`.\n\n\n`fxpowui(5.8, 3, 10); // 195.112 `\n\n `fxpowui(base, power, precision)` approximates the power of\nthe fixed number, `base`, raised to the `UInt`, `power`. The third\nargument must be a `UInt` whose value is known at compile time.\n\n\n `fxcmp(op, x, y)` applies the comparison\noperator to the two fixed point numbers after unifying their scales.\n\nThere are convenience methods defined for comparing fixed point numbers:\n\n\n `fxlt(x, y)` tests whether `x` is less than `y`.\n\n\n `fxle(x, y)` tests whether `x` is less than or equal to `y`.\n\n\n `fxgt(x, y)` tests whether `x` is greater than `y`.\n\n\n `fxge(x, y)` tests whether `x` is greater than or equal to `y`.\n\n\n `fxeq(x, y)` tests whether `x` is equal to `y`.\n\n\n `fxne(x, y)` tests whether `x` is not equal to `y`.\n",
  "fxsqrt": "\n `fxsqrt(x, k)` returns the square root of the fixed number, `x`.\n\n\n `fxsqrtApprox(x, k)` approximates the square root of the fixed number, `x`, using `k` iterations of the `sqrtApprox` algorithm.\n\n\n`const base  = 2.0;\nconst power = 0.33;\nfxpow(base, power, 10, 1000);    // 1.260\nfxpow(base, power, 10, 10000);   // 1.2599\nfxpow(base, power, 10, 1000000); // 1.259921 `\n\n `fxpow(base, power, precision, scalePrecision)` approximates the power of the fixed number, `base`,\nraised to the fixed point number, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform.\nThe `scalePrecision` argument must be a `UInt` and represents the scale of the return value. Choosing a larger\n`scalePrecision` allows for more precision when approximating the power, as demonstrated in the example below:\n\n\n `fxpowi(base, power, precision)` approximates the power of the fixed number, `base`,\nraised to the `Int`, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform. For reference, `6` iterations\nprovides enough accuracy to calculate up to `2^64 - 1`, so the largest power it can compute is `63`.\n\n\n`fxpowui(5.8, 3, 10); // 195.112 `\n\n `fxpowui(base, power, precision)` approximates the power of\nthe fixed number, `base`, raised to the `UInt`, `power`. The third\nargument must be a `UInt` whose value is known at compile time.\n\n\n `fxcmp(op, x, y)` applies the comparison\noperator to the two fixed point numbers after unifying their scales.\n\nThere are convenience methods defined for comparing fixed point numbers:\n\n\n `fxlt(x, y)` tests whether `x` is less than `y`.\n\n\n `fxle(x, y)` tests whether `x` is less than or equal to `y`.\n\n\n `fxgt(x, y)` tests whether `x` is greater than `y`.\n\n\n `fxge(x, y)` tests whether `x` is greater than or equal to `y`.\n\n\n `fxeq(x, y)` tests whether `x` is equal to `y`.\n\n\n `fxne(x, y)` tests whether `x` is not equal to `y`.\n",
  "fxsqrtApprox": "\n `fxsqrtApprox(x, k)` approximates the square root of the fixed number, `x`, using `k` iterations of the `sqrtApprox` algorithm.\n\n\n`const base  = 2.0;\nconst power = 0.33;\nfxpow(base, power, 10, 1000);    // 1.260\nfxpow(base, power, 10, 10000);   // 1.2599\nfxpow(base, power, 10, 1000000); // 1.259921 `\n\n `fxpow(base, power, precision, scalePrecision)` approximates the power of the fixed number, `base`,\nraised to the fixed point number, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform.\nThe `scalePrecision` argument must be a `UInt` and represents the scale of the return value. Choosing a larger\n`scalePrecision` allows for more precision when approximating the power, as demonstrated in the example below:\n\n\n `fxpowi(base, power, precision)` approximates the power of the fixed number, `base`,\nraised to the `Int`, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform. For reference, `6` iterations\nprovides enough accuracy to calculate up to `2^64 - 1`, so the largest power it can compute is `63`.\n\n\n`fxpowui(5.8, 3, 10); // 195.112 `\n\n `fxpowui(base, power, precision)` approximates the power of\nthe fixed number, `base`, raised to the `UInt`, `power`. The third\nargument must be a `UInt` whose value is known at compile time.\n\n\n `fxcmp(op, x, y)` applies the comparison\noperator to the two fixed point numbers after unifying their scales.\n\nThere are convenience methods defined for comparing fixed point numbers:\n\n\n `fxlt(x, y)` tests whether `x` is less than `y`.\n\n\n `fxle(x, y)` tests whether `x` is less than or equal to `y`.\n\n\n `fxgt(x, y)` tests whether `x` is greater than `y`.\n\n\n `fxge(x, y)` tests whether `x` is greater than or equal to `y`.\n\n\n `fxeq(x, y)` tests whether `x` is equal to `y`.\n\n\n `fxne(x, y)` tests whether `x` is not equal to `y`.\n",
  "fxsub": "\n `fxsub(x, y)` subtracts two fixed point numbers.\n\n\n `fxmul(x, y)` multiplies two fixed point numbers.\n\n\n```javascript\nfxdiv(34.56, 1.234, 10)     // => 28\nfxdiv(34.56, 1.234, 100000) // => 28.0064\n```\n\n `fxdiv(x, y, scale_factor)` divides two fixed point numbers. The numerator, `x`,\nwill be multiplied by the scale factor to provide a more precise answer. For example,\n\n\n `fxmod(x, y)` finds the remainder of dividing `x` by `y`.\n\n\n `fxfloor(x)` returns the greatest integer not greater than `x`.\n\n\n `fxsqrt(x, k)` returns the square root of the fixed number, `x`.\n\n\n `fxsqrtApprox(x, k)` approximates the square root of the fixed number, `x`, using `k` iterations of the `sqrtApprox` algorithm.\n\n\n`const base  = 2.0;\nconst power = 0.33;\nfxpow(base, power, 10, 1000);    // 1.260\nfxpow(base, power, 10, 10000);   // 1.2599\nfxpow(base, power, 10, 1000000); // 1.259921 `\n\n `fxpow(base, power, precision, scalePrecision)` approximates the power of the fixed number, `base`,\nraised to the fixed point number, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform.\nThe `scalePrecision` argument must be a `UInt` and represents the scale of the return value. Choosing a larger\n`scalePrecision` allows for more precision when approximating the power, as demonstrated in the example below:\n\n\n `fxpowi(base, power, precision)` approximates the power of the fixed number, `base`,\nraised to the `Int`, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform. For reference, `6` iterations\nprovides enough accuracy to calculate up to `2^64 - 1`, so the largest power it can compute is `63`.\n\n\n`fxpowui(5.8, 3, 10); // 195.112 `\n\n `fxpowui(base, power, precision)` approximates the power of\nthe fixed number, `base`, raised to the `UInt`, `power`. The third\nargument must be a `UInt` whose value is known at compile time.\n\n\n `fxcmp(op, x, y)` applies the comparison\noperator to the two fixed point numbers after unifying their scales.\n\nThere are convenience methods defined for comparing fixed point numbers:\n\n\n `fxlt(x, y)` tests whether `x` is less than `y`.\n\n\n `fxle(x, y)` tests whether `x` is less than or equal to `y`.\n\n\n `fxgt(x, y)` tests whether `x` is greater than `y`.\n\n\n `fxge(x, y)` tests whether `x` is greater than or equal to `y`.\n\n\n `fxeq(x, y)` tests whether `x` is equal to `y`.\n\n\n `fxne(x, y)` tests whether `x` is not equal to `y`.\n",
  "fxunify": "\n```javascript\nconst x = fx(1000)(Pos, 824345); // x = 824.345\nconst y = 45.67;\nfxunify(x, y);    // => [ 1000, 824.345, 45.670 ]\n```\n\n `fxunify(x, y)` will convert the fixed point numbers\nto use the same scale. The larger scale of the two arguments will be chosen. The function will return a `3-tuple` consisting\nof the common scale and the newly scaled values.\n\n\n `fxadd(x, y)` adds two fixed point numbers.\n\n\n `fxsub(x, y)` subtracts two fixed point numbers.\n\n\n `fxmul(x, y)` multiplies two fixed point numbers.\n\n\n```javascript\nfxdiv(34.56, 1.234, 10)     // => 28\nfxdiv(34.56, 1.234, 100000) // => 28.0064\n```\n\n `fxdiv(x, y, scale_factor)` divides two fixed point numbers. The numerator, `x`,\nwill be multiplied by the scale factor to provide a more precise answer. For example,\n\n\n `fxmod(x, y)` finds the remainder of dividing `x` by `y`.\n\n\n `fxfloor(x)` returns the greatest integer not greater than `x`.\n\n\n `fxsqrt(x, k)` returns the square root of the fixed number, `x`.\n\n\n `fxsqrtApprox(x, k)` approximates the square root of the fixed number, `x`, using `k` iterations of the `sqrtApprox` algorithm.\n\n\n`const base  = 2.0;\nconst power = 0.33;\nfxpow(base, power, 10, 1000);    // 1.260\nfxpow(base, power, 10, 10000);   // 1.2599\nfxpow(base, power, 10, 1000000); // 1.259921 `\n\n `fxpow(base, power, precision, scalePrecision)` approximates the power of the fixed number, `base`,\nraised to the fixed point number, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform.\nThe `scalePrecision` argument must be a `UInt` and represents the scale of the return value. Choosing a larger\n`scalePrecision` allows for more precision when approximating the power, as demonstrated in the example below:\n\n\n `fxpowi(base, power, precision)` approximates the power of the fixed number, `base`,\nraised to the `Int`, `power`. The third argument must be a `UInt` whose value is known\nat compile time, which represents the number of iterations the algorithm should perform. For reference, `6` iterations\nprovides enough accuracy to calculate up to `2^64 - 1`, so the largest power it can compute is `63`.\n\n\n`fxpowui(5.8, 3, 10); // 195.112 `\n\n `fxpowui(base, power, precision)` approximates the power of\nthe fixed number, `base`, raised to the `UInt`, `power`. The third\nargument must be a `UInt` whose value is known at compile time.\n\n\n `fxcmp(op, x, y)` applies the comparison\noperator to the two fixed point numbers after unifying their scales.\n\nThere are convenience methods defined for comparing fixed point numbers:\n\n\n `fxlt(x, y)` tests whether `x` is less than `y`.\n\n\n `fxle(x, y)` tests whether `x` is less than or equal to `y`.\n\n\n `fxgt(x, y)` tests whether `x` is greater than `y`.\n\n\n `fxge(x, y)` tests whether `x` is greater than or equal to `y`.\n\n\n `fxeq(x, y)` tests whether `x` is equal to `y`.\n\n\n `fxne(x, y)` tests whether `x` is not equal to `y`.\n",
  "ge": "\n```javascript\nand(a, b)     // &&\nor(a, b)      // ||\nxor(a, b)     // ^\nadd(a, b)     // +\nsub(a, b)     // -\nmul(a, b)     // *\ndiv(a, b)     // /\npolyMod(a, b) // %\neq(a, b)      // ==\nlt(a, b)      // <\nle(a, b)      // <=\nge(a, b)      // >=\ngt(a, b)      // >\nlsh(a, b)     // <<\nrsh(a, b)     // >>\nband(a, b)    // &\nbior(a, b)    // |\npolyEq(a, b)  // ==, ===\npolyNeq(a, b) // !=, !==\n```\n\nAll binary expression operators have a corresponding named function in the standard library.\nWhile `&&` and `||` may not evaluate their second argument,\ntheir corresponding named functions `and`, `or`, and `xor`, always do.\n\n\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "getAddress": "\n```javascript\ngetAddress()\n```\n\nThe getAddress primitive returns the `Address` value of the deployed contract's account.\nThis function may not be called until after the first publication (which creates the contract).\n\n```javascript\n  A.publish();\n  const info = getContract();\n  const addr = getAddress();\n\n  A.only(() => {\n    interact.showCtcInfo(info);\n    interact.showAddress(addr);\n  });\n```\n\nIn this code sample, Alice publishes to create the contract, and then an object named `info` is created to reference `getContract` that pulls in the contract information.\nAnother object is created named `addr` to reference `getAddress` to obtain the address of Alice.\nBoth `info` and `addr` are then used in the local step of Alice in her `interact` object.\n",
  "getContract": "\n```javascript\ngetContract()\n```\n\nThe getContract primitive returns the `Contract` value for the deployed contract.\nThis function may not be called until after the first publication (which creates the contract).\n\n```javascript\n  D.publish(x, tok);\n  V.x.set(x);\n  V.tok.set(tok);\n  D.interact.ready(getContract());\n```\n\t\nIn this example, on line 26, `D` publishes the values for `x` and `tok`, which creates the contract.\nAfter the `publish`, now `getContract` is called and it returns the value `x` in token `tok` of the contract created in the publication.\n",
  "getUntrackedFunds": "\n```javascript\nconst f1 = getUntrackedFunds();\ntransfer(f1).to(Alice);\nconst f2 = getUntrackedFunds(tok);\ntransfer(f2, tok).to(Alice);\n```\n\n `getUntrackedFunds(?token)` takes an optional `Token` argument and returns the difference between the actual balance of the contract and Reach's expectation of the balance for the given token, or network token if no argument is provided.\nFor example, if funds were externally sent to the contract or rewards were earned, this function gives you access to them.\nOnce this function is called, the amount returned is incorporated into Reach's expectation of the balance.\nSo, the amount returned must eventually be transferred out of the contract to satisfy the token linearity property.\n\n If a contract were to have its funds improperly removed, through clawback or other means, and the actual balance is less\nthan Reach's expectation, this function will return `0`.\n",
  "gt": "\n```javascript\nand(a, b)     // &&\nor(a, b)      // ||\nxor(a, b)     // ^\nadd(a, b)     // +\nsub(a, b)     // -\nmul(a, b)     // *\ndiv(a, b)     // /\npolyMod(a, b) // %\neq(a, b)      // ==\nlt(a, b)      // <\nle(a, b)      // <=\nge(a, b)      // >=\ngt(a, b)      // >\nlsh(a, b)     // <<\nrsh(a, b)     // >>\nband(a, b)    // &\nbior(a, b)    // |\npolyEq(a, b)  // ==, ===\npolyNeq(a, b) // !=, !==\n```\n\nAll binary expression operators have a corresponding named function in the standard library.\nWhile `&&` and `||` may not evaluate their second argument,\ntheir corresponding named functions `and`, `or`, and `xor`, always do.\n\n\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "hasConsoleLogger": "\n\n```javascript\nhasConsoleLogger\n```\n\n A participant interact interface which specifies `log` with an unconstrained domain function type that returns `Null`. Reach provides a default frontend implementation via hasConsoleLogger (Frontend).\n",
  "hasConsoleLogger.log": "\n```javascript\nhasConsoleLogger\n```\n\n A participant interact interface which specifies `log` with an unconstrained domain function type that returns `Null`. Reach provides a default frontend implementation via hasConsoleLogger (Frontend).\n",
  "hasRandom": "\n\n```javascript\nhasRandom\n```\n\n A participant interact interface which specifies `random` as a function that takes no arguments and returns an unsigned integer of bit width bits. Reach provides a default frontend implementation via hasRandom (Frontend).\n \n ```javascript\nconst Player = {\n  ...hasRandom,\n  getHand: Fun([], UInt),\n  seeOutcome: Fun([UInt], Null),\n  informTimeout: Fun([], Null),\n```\n\nThis code section gives the `Player` object the method `hasRandom` so that a random number is used to select a hand in the [Rock, Paper, Scissors!](https://docs.reach.sh/tut/rps/#tut) tutorial.\n",
  "hasRandom.random": "\n```javascript\nhasRandom\n```\n\n A participant interact interface which specifies `random` as a function that takes no arguments and returns an unsigned integer of bit width bits. Reach provides a default frontend implementation via hasRandom (Frontend).\n \n ```javascript\nconst Player = {\n  ...hasRandom,\n  getHand: Fun([], UInt),\n  seeOutcome: Fun([UInt], Null),\n  informTimeout: Fun([], Null),\n```\n\nThis code section gives the `Player` object the method `hasRandom` so that a random number is used to select a hand in the [Rock, Paper, Scissors!](https://docs.reach.sh/tut/rps/#tut) tutorial.\n",
  "iadd": "\n `iadd(x, y)` adds the `Int` `x` and the `Int` `y`.\n\n\n `isub(x, y)` subtracts the `Int` `y` from the `Int` `x`.\n\n\n `imul(x, y)` multiplies the `Int` `x` and the `Int` `y`.\n\n\n `idiv(x, y)` divides the `Int` `x` by the `Int` `y`.\n\n\n `imod(x, y)` finds the remainder of dividing the `Int` `x` by the `Int` `y`.\n\n\n `ilt(x, y)` determines whether `x` is less than `y`.\n\n\n `ile(x, y)` determines whether `x` is less than or equal to `y`.\n\n\n `igt(x, y)` determines whether `x` is greather than `y`.\n\n\n `ige(x, y)` determines whether `x` is greater than or equal to `y`.\n\n\n `ieq(x, y)` determines whether `x` is equal to `y`.\n\n\n `ine(x, y)` determines whether `x` is not equal to `y`.\n\n\n `imax(x, y)` returns the larger of two `Int`s.\n\n\n `abs(i)` returns the absolute value of an `Int`. The return value is of type `UInt`.\n",
  "idiv": "\n `idiv(x, y)` divides the `Int` `x` by the `Int` `y`.\n\n\n `imod(x, y)` finds the remainder of dividing the `Int` `x` by the `Int` `y`.\n\n\n `ilt(x, y)` determines whether `x` is less than `y`.\n\n\n `ile(x, y)` determines whether `x` is less than or equal to `y`.\n\n\n `igt(x, y)` determines whether `x` is greather than `y`.\n\n\n `ige(x, y)` determines whether `x` is greater than or equal to `y`.\n\n\n `ieq(x, y)` determines whether `x` is equal to `y`.\n\n\n `ine(x, y)` determines whether `x` is not equal to `y`.\n\n\n `imax(x, y)` returns the larger of two `Int`s.\n\n\n `abs(i)` returns the absolute value of an `Int`. The return value is of type `UInt`.\n",
  "ieq": "\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "if": "\n```javascript\nif ( 1 + 2 < 3 ) {\n  return \"Yes!\";\n} else {\n  return \"No, waaah!\"; }\n```\n\nA conditional statement,\nwritten `if (COND) NOT_FALSE else FALSE`,\nwhere `COND` is an expression\nand `NOT_FALSE` and `FALSE` as statements\n(potentially block statements),\nselects between the `NOT_FALSE` statement and `FALSE` statement based on whether `COND` evaluates to `false`.\n\nBoth `NOT_FALSE` and `FALSE` have empty tails, i.e. the tail of the conditional statement is not propagated. For example,\n\n```javascript\nif ( x < y ) {\n  const z = 3; }\nelse {\n  const z = 4; }\nreturn z;\n```\n\nis erroneous, because the identifier `z` is not bound outside the conditional statement.\n\nA conditional statement may only include a consensus transfer in `NOT_FALSE` or `FALSE` if it is within a consensus step, because its statements are in the same context as the conditional statement itself.\n\nIf one branch of a conditional contains a `return`, then both must.\n",
  "ige": "\n `ige(x, y)` determines whether `x` is greater than or equal to `y`.\n\n\n `ieq(x, y)` determines whether `x` is equal to `y`.\n\n\n `ine(x, y)` determines whether `x` is not equal to `y`.\n\n\n `imax(x, y)` returns the larger of two `Int`s.\n\n\n `abs(i)` returns the absolute value of an `Int`. The return value is of type `UInt`.\n",
  "igt": "\n `igt(x, y)` determines whether `x` is greather than `y`.\n\n\n `ige(x, y)` determines whether `x` is greater than or equal to `y`.\n\n\n `ieq(x, y)` determines whether `x` is equal to `y`.\n\n\n `ine(x, y)` determines whether `x` is not equal to `y`.\n\n\n `imax(x, y)` returns the larger of two `Int`s.\n\n\n `abs(i)` returns the absolute value of an `Int`. The return value is of type `UInt`.\n",
  "ile": "\n `ile(x, y)` determines whether `x` is less than or equal to `y`.\n\n\n `igt(x, y)` determines whether `x` is greather than `y`.\n\n\n `ige(x, y)` determines whether `x` is greater than or equal to `y`.\n\n\n `ieq(x, y)` determines whether `x` is equal to `y`.\n\n\n `ine(x, y)` determines whether `x` is not equal to `y`.\n\n\n `imax(x, y)` returns the larger of two `Int`s.\n\n\n `abs(i)` returns the absolute value of an `Int`. The return value is of type `UInt`.\n",
  "ilt": "\n `ilt(x, y)` determines whether `x` is less than `y`.\n\n\n `ile(x, y)` determines whether `x` is less than or equal to `y`.\n\n\n `igt(x, y)` determines whether `x` is greather than `y`.\n\n\n `ige(x, y)` determines whether `x` is greater than or equal to `y`.\n\n\n `ieq(x, y)` determines whether `x` is equal to `y`.\n\n\n `ine(x, y)` determines whether `x` is not equal to `y`.\n\n\n `imax(x, y)` returns the larger of two `Int`s.\n\n\n `abs(i)` returns the absolute value of an `Int`. The return value is of type `UInt`.\n",
  "imax": "\n `imax(x, y)` returns the larger of two `Int`s.\n\n\n `abs(i)` returns the absolute value of an `Int`. The return value is of type `UInt`.\n",
  "imod": "\n `imod(x, y)` finds the remainder of dividing the `Int` `x` by the `Int` `y`.\n\n\n `ilt(x, y)` determines whether `x` is less than `y`.\n\n\n `ile(x, y)` determines whether `x` is less than or equal to `y`.\n\n\n `igt(x, y)` determines whether `x` is greather than `y`.\n\n\n `ige(x, y)` determines whether `x` is greater than or equal to `y`.\n\n\n `ieq(x, y)` determines whether `x` is equal to `y`.\n\n\n `ine(x, y)` determines whether `x` is not equal to `y`.\n\n\n `imax(x, y)` returns the larger of two `Int`s.\n\n\n `abs(i)` returns the absolute value of an `Int`. The return value is of type `UInt`.\n",
  "implies": "\n```javascript\nimplies( x, y )\n```\n\n Returns `true` if `x` is `false` or `y` is `true`.\n",
  "import": "\nReach supports two types of module imports: local imports,\nwhich refer to modules that exist within your project, and\npackage imports, which refer to remote libraries that may be fetched\nfrom external sources such as [GitHub](https://github.com).\n---\n**NOTE**\n\nRead [the guide section on packages](https://docs.reach.sh/guide/packages/#guide-packages) for more details.\n\n---\n\nPackage imports are easily distinguished from local imports by a\nmandatory `@` character at the beginning of the path string.\n",
  "imul": "\n `imul(x, y)` multiplies the `Int` `x` and the `Int` `y`.\n\n\n `idiv(x, y)` divides the `Int` `x` by the `Int` `y`.\n\n\n `imod(x, y)` finds the remainder of dividing the `Int` `x` by the `Int` `y`.\n\n\n `ilt(x, y)` determines whether `x` is less than `y`.\n\n\n `ile(x, y)` determines whether `x` is less than or equal to `y`.\n\n\n `igt(x, y)` determines whether `x` is greather than `y`.\n\n\n `ige(x, y)` determines whether `x` is greater than or equal to `y`.\n\n\n `ieq(x, y)` determines whether `x` is equal to `y`.\n\n\n `ine(x, y)` determines whether `x` is not equal to `y`.\n\n\n `imax(x, y)` returns the larger of two `Int`s.\n\n\n `abs(i)` returns the absolute value of an `Int`. The return value is of type `UInt`.\n",
  "in": "\n\n\n\n\n\n\n\n\n\nThis error indicates you are using an illegal JavaScript expression in Reach. Not all JavaScript\nexpressions are valid Reach, as they are not applicable to the language.\n",
  "ine": "\n `ine(x, y)` determines whether `x` is not equal to `y`.\n\n\n `imax(x, y)` returns the larger of two `Int`s.\n\n\n `abs(i)` returns the absolute value of an `Int`. The return value is of type `UInt`.\n",
  "init": "\nA init statement, written `init();`, finalizes all of the available participants, views, and compilation options.\n\n\nIn earlier versions of Reach, this was called `deploy()`, but it was\nchanged because that name was misleading.\n\nIts continuation is a step, which means its content is specified by [Steps](https://docs.reach.sh/rsh/step/#ref-programs-step).\nIt represents the body of the DApp to be compiled.\n\nIn the example below, see how `init();` is used to finalize the available `Participant` and `API`. \nAfter which a local step is introduced:\n\n```javascript\nexport const main = Reach.App(() => {\n  const A = Participant('Admin', {\n    deployed: Fun(true, Null),\n    n: UInt,\n  });\n  const U = API('Writer', {\n    f: Fun([], UInt),\n  });\n  init();\n  A.only(() => {\n    const n = declassify(interact.n);\n  });\n```\n",
  "instanceOf": "\n\n\n\n\n\n\n\n\nThis error indicates you are using an illegal JavaScript expression in Reach. Not all JavaScript\nexpressions are valid Reach, as they are not applicable to the language.\n",
  "int": "\n```javascript\nint(Pos, 4); // represents 4\nint(Neg, 4); // represents -4\n-4;          // represents -4\n+4;          // represents 4 : Int\n 4;          // represents 4 : UInt\n```\n\n\n `iadd(x, y)` adds the `Int` `x` and the `Int` `y`.\n\n\n `isub(x, y)` subtracts the `Int` `y` from the `Int` `x`.\n\n\n `imul(x, y)` multiplies the `Int` `x` and the `Int` `y`.\n\n\n `idiv(x, y)` divides the `Int` `x` by the `Int` `y`.\n\n\n `imod(x, y)` finds the remainder of dividing the `Int` `x` by the `Int` `y`.\n\n\n `ilt(x, y)` determines whether `x` is less than `y`.\n\n\n `ile(x, y)` determines whether `x` is less than or equal to `y`.\n\n\n `igt(x, y)` determines whether `x` is greather than `y`.\n\n\n `ige(x, y)` determines whether `x` is greater than or equal to `y`.\n\n\n `ieq(x, y)` determines whether `x` is equal to `y`.\n\n\n `ine(x, y)` determines whether `x` is not equal to `y`.\n\n\n `imax(x, y)` returns the larger of two `Int`s.\n\n\n `abs(i)` returns the absolute value of an `Int`. The return value is of type `UInt`.\n",
  "intEq": "\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "interval": "\n\n\n\n\n `interval(IntervalType, Int, Int, IntervalType)` constructs an interval where the first and second argument\nrepresent the left endpoint and whether it's open or closed; the third and fourth argument represent the right endpoint and whether it's open or closed.\n\n `intervalCC(l, r)` constructs a closed interval from two endpoints of type `Int`.\n\n `intervalCO(l, r)` constructs a half-open interval from two endpoints of type `Int` where the left endpoint is closed and the right endpoint is open.\n\n `intervalOC(l, r)` constructs a half-open interval from two endpoints of type `Int` where the left endpoint is open and the right endpoint is closed.\n\n `intervalOO(l, r)` constructs an open interval from two endpoints of type `Int`.\n",
  "intervalAbs": "\n```javascript\nintervalAbs(intervalCC(+1, +10)); // +10\n```\n\n `intervalAbs(i)` returns the absolute value of an interval.\n",
  "intervalAdd": "\n\n\n\n `intervalAdd(l, r)` adds the two intervals.\n\n `intervalSub(l, r)` subtracts the two intervals.\n\n `intervalMul(l, r)` multiplies the two intervals.\n\n `intervalDiv(l, r)` divides the two intervals.\n",
  "intervalCC": "\n\n\n\n `interval(IntervalType, Int, Int, IntervalType)` constructs an interval where the first and second argument\nrepresent the left endpoint and whether it's open or closed; the third and fourth argument represent the right endpoint and whether it's open or closed.\n\n `intervalCC(l, r)` constructs a closed interval from two endpoints of type `Int`.\n\n `intervalCO(l, r)` constructs a half-open interval from two endpoints of type `Int` where the left endpoint is closed and the right endpoint is open.\n\n `intervalOC(l, r)` constructs a half-open interval from two endpoints of type `Int` where the left endpoint is open and the right endpoint is closed.\n\n `intervalOO(l, r)` constructs an open interval from two endpoints of type `Int`.\n",
  "intervalCO": "\n\n\n `interval(IntervalType, Int, Int, IntervalType)` constructs an interval where the first and second argument\nrepresent the left endpoint and whether it's open or closed; the third and fourth argument represent the right endpoint and whether it's open or closed.\n\n `intervalCC(l, r)` constructs a closed interval from two endpoints of type `Int`.\n\n `intervalCO(l, r)` constructs a half-open interval from two endpoints of type `Int` where the left endpoint is closed and the right endpoint is open.\n\n `intervalOC(l, r)` constructs a half-open interval from two endpoints of type `Int` where the left endpoint is open and the right endpoint is closed.\n\n `intervalOO(l, r)` constructs an open interval from two endpoints of type `Int`.\n",
  "intervalDiv": "\n `intervalAdd(l, r)` adds the two intervals.\n\n `intervalSub(l, r)` subtracts the two intervals.\n\n `intervalMul(l, r)` multiplies the two intervals.\n\n `intervalDiv(l, r)` divides the two intervals.\n",
  "intervalEq": "\n\n\n\n\n\nIntervals may be compared with the following functions:\n\n `intervalEq(l, r)` tests whether the intervals are equal.\n\n `intervalNe(l, r)` tests whether the intervals are not equal.\n\n `intervalLt(l, r)` tests whether the left interval is less than the right interval.\n\n `intervalLte(l, r)` tests whether the left interval is less than or equal to the right interval.\n\n `intervalGt(l, r)` tests whether the left interval is greater than the right interval.\n\n `intervalGte(l, r)` tests whether the left interval is greater than or equal to the right interval.\n",
  "intervalGt": "\n\nIntervals may be compared with the following functions:\n\n `intervalEq(l, r)` tests whether the intervals are equal.\n\n `intervalNe(l, r)` tests whether the intervals are not equal.\n\n `intervalLt(l, r)` tests whether the left interval is less than the right interval.\n\n `intervalLte(l, r)` tests whether the left interval is less than or equal to the right interval.\n\n `intervalGt(l, r)` tests whether the left interval is greater than the right interval.\n\n `intervalGte(l, r)` tests whether the left interval is greater than or equal to the right interval.\n",
  "intervalGte": "\nIntervals may be compared with the following functions:\n\n `intervalEq(l, r)` tests whether the intervals are equal.\n\n `intervalNe(l, r)` tests whether the intervals are not equal.\n\n `intervalLt(l, r)` tests whether the left interval is less than the right interval.\n\n `intervalLte(l, r)` tests whether the left interval is less than or equal to the right interval.\n\n `intervalGt(l, r)` tests whether the left interval is greater than the right interval.\n\n `intervalGte(l, r)` tests whether the left interval is greater than or equal to the right interval.\n",
  "intervalIntersection": "\n```javascript\nconst i1 = intervalOO(+3, +11); // (+3, +11)\nconst i2 = intervalCC(+7, +9);  // [+7, +9]\nintervalIntersection(i1, i2);   // [+7, +11)\n```\n\n `intervalIntersection(x, y)` returns the intersection of two intervals.\n\n\n```javascript\nconst i1 = intervalOO(+3, +9);  // (+3, +9)\nconst i2 = intervalCC(+7, +11); // [+7, +11]\nintervalUnion(i1, i2);          // (+3, +11]\n```\n\n `intervalUnion(x, y)` returns the union of two intervals.\n\n\n```javascript\nintervalWidth(intervalCC(+4, +45)); // +41\n```\n\n `intervalWidth(i)` returns the width of an interval.\n\n\n```javascript\nintervalAbs(intervalCC(+1, +10)); // +10\n```\n\n `intervalAbs(i)` returns the absolute value of an interval.\n",
  "intervalLt": "\n\n\n\nIntervals may be compared with the following functions:\n\n `intervalEq(l, r)` tests whether the intervals are equal.\n\n `intervalNe(l, r)` tests whether the intervals are not equal.\n\n `intervalLt(l, r)` tests whether the left interval is less than the right interval.\n\n `intervalLte(l, r)` tests whether the left interval is less than or equal to the right interval.\n\n `intervalGt(l, r)` tests whether the left interval is greater than the right interval.\n\n `intervalGte(l, r)` tests whether the left interval is greater than or equal to the right interval.\n",
  "intervalLte": "\n\n\nIntervals may be compared with the following functions:\n\n `intervalEq(l, r)` tests whether the intervals are equal.\n\n `intervalNe(l, r)` tests whether the intervals are not equal.\n\n `intervalLt(l, r)` tests whether the left interval is less than the right interval.\n\n `intervalLte(l, r)` tests whether the left interval is less than or equal to the right interval.\n\n `intervalGt(l, r)` tests whether the left interval is greater than the right interval.\n\n `intervalGte(l, r)` tests whether the left interval is greater than or equal to the right interval.\n",
  "intervalMul": "\n\n `intervalAdd(l, r)` adds the two intervals.\n\n `intervalSub(l, r)` subtracts the two intervals.\n\n `intervalMul(l, r)` multiplies the two intervals.\n\n `intervalDiv(l, r)` divides the two intervals.\n",
  "intervalNeq": "\n\n\n\n\nIntervals may be compared with the following functions:\n\n `intervalEq(l, r)` tests whether the intervals are equal.\n\n `intervalNe(l, r)` tests whether the intervals are not equal.\n\n `intervalLt(l, r)` tests whether the left interval is less than the right interval.\n\n `intervalLte(l, r)` tests whether the left interval is less than or equal to the right interval.\n\n `intervalGt(l, r)` tests whether the left interval is greater than the right interval.\n\n `intervalGte(l, r)` tests whether the left interval is greater than or equal to the right interval.\n",
  "intervalOC": "\n\n `interval(IntervalType, Int, Int, IntervalType)` constructs an interval where the first and second argument\nrepresent the left endpoint and whether it's open or closed; the third and fourth argument represent the right endpoint and whether it's open or closed.\n\n `intervalCC(l, r)` constructs a closed interval from two endpoints of type `Int`.\n\n `intervalCO(l, r)` constructs a half-open interval from two endpoints of type `Int` where the left endpoint is closed and the right endpoint is open.\n\n `intervalOC(l, r)` constructs a half-open interval from two endpoints of type `Int` where the left endpoint is open and the right endpoint is closed.\n\n `intervalOO(l, r)` constructs an open interval from two endpoints of type `Int`.\n",
  "intervalOO": "\n `interval(IntervalType, Int, Int, IntervalType)` constructs an interval where the first and second argument\nrepresent the left endpoint and whether it's open or closed; the third and fourth argument represent the right endpoint and whether it's open or closed.\n\n `intervalCC(l, r)` constructs a closed interval from two endpoints of type `Int`.\n\n `intervalCO(l, r)` constructs a half-open interval from two endpoints of type `Int` where the left endpoint is closed and the right endpoint is open.\n\n `intervalOC(l, r)` constructs a half-open interval from two endpoints of type `Int` where the left endpoint is open and the right endpoint is closed.\n\n `intervalOO(l, r)` constructs an open interval from two endpoints of type `Int`.\n",
  "intervalSub": "\n\n\n `intervalAdd(l, r)` adds the two intervals.\n\n `intervalSub(l, r)` subtracts the two intervals.\n\n `intervalMul(l, r)` multiplies the two intervals.\n\n `intervalDiv(l, r)` divides the two intervals.\n",
  "intervalUnion": "\n```javascript\nconst i1 = intervalOO(+3, +9);  // (+3, +9)\nconst i2 = intervalCC(+7, +11); // [+7, +11]\nintervalUnion(i1, i2);          // (+3, +11]\n```\n\n `intervalUnion(x, y)` returns the union of two intervals.\n\n\n```javascript\nintervalWidth(intervalCC(+4, +45)); // +41\n```\n\n `intervalWidth(i)` returns the width of an interval.\n\n\n```javascript\nintervalAbs(intervalCC(+1, +10)); // +10\n```\n\n `intervalAbs(i)` returns the absolute value of an interval.\n",
  "intervalWidth": "\n```javascript\nintervalWidth(intervalCC(+4, +45)); // +41\n```\n\n `intervalWidth(i)` returns the width of an interval.\n\n\n```javascript\nintervalAbs(intervalCC(+1, +10)); // +10\n```\n\n `intervalAbs(i)` returns the absolute value of an interval.\n",
  "is": "\n```javascript\ntypeOf(x) // type\nisType(t) // Bool\nis(x, t) // t\n```\n\nThe `typeOf` primitive function is the same as `typeof`:\nit returns the type of its argument.\n\nThe `isType` function returns `true` if its argument is a type.\nAny expression satisfying `isType` is compiled away and does not exist at runtime.\n\nThe `is` function returns its first argument if it satisfies the type specified by the second argument.\nIf it is not, then the program is invalid.\nFor example, `is(5, UInt)` returns `5`, while `is(5, Bool)` is an invalid program.\nThe value returned by `is` may not be identical to the input, because in some cases, such as for functions, it will record the applied to type and enforce it on future invocations.\nThese applications are considered negative positions for `Refine`.\n",
  "isIntervalType": "\n\n\n```javascript\nexport const [ isIntervalType, Closed, Open ] = mkEnum(2);\nexport const IntervalType = Refine(UInt, isIntervalType);\n```\n",
  "isLeft": "\n```javascript\nconst e = Either(UInt, Bool);\nconst l = e.Left(1);\nconst r = e.Right(true);\nisLeft(l);  // true\nisRight(l); // false\nconst x = fromLeft(l, 0);      // x = 1\nconst y = fromRight(l, false); // y = false\n```\n\n `isLeft` is a convenience method that determines whether the variant is `Left`.\n\n `isRight` is a convenience method that determines whether the variant is `Right`.\n\n `fromLeft(e, default)` is a convenience method that returns the value in `Left`,\nor `default` if the variant is `Right`.\n\n `fromRight(e, default)` is a convenience method that returns the value in `Right`,\nor `default` if the variant is `Left`.\n",
  "isNone": "\n```javascript\nconst m = Maybe(UInt).Some(5);\nisNone(m); // false\nisSome(m); // true\n```\n\n `isNone` is a convenience method that determines whether the variant is `None`.\n\n `isSome` is a convenience method that determines whether the variant is `Some`.\n\n\n```javascript\nfromSome(Maybe(UInt).Some(1), 0); // 1\nfromSome(Maybe(UInt).None(), 0);  // 0\n```\n\n `fromSome` receives a `Maybe` value and a default value as arguments and will return the value inside\nof the `Some` variant or the default value otherwise.\n\n\n```javascript\nconst add1 = (x) => x + 1;\nmaybe(Maybe(UInt).Some(1), 0, add1); // 2\nmaybe(Maybe(UInt).None(), 0, add1);  // 0\n```\n\n `maybe(m, defaultVal, f)` receives a `Maybe` value, a default value, and a unary function as arguments. The function will\neither return the application of the function, `f`, to the `Some` value or return the default value provided.\n\nThe following examples demonstrate different usage of `Maybe`:\n\n```javascript\nconst MUInt = Maybe(UInt);\n```\n\n```javascript\n        interact.printBool(Maybe(UInt).Some(5) == Maybe(UInt).Some(5));\n```\n\n```javascript\n  var [ claimed_by, keep_going ] = [ Maybe(Address).None(), true ];\n```\n",
  "isRight": "\n```javascript\nconst e = Either(UInt, Bool);\nconst l = e.Left(1);\nconst r = e.Right(true);\nisLeft(l);  // true\nisRight(l); // false\nconst x = fromLeft(l, 0);      // x = 1\nconst y = fromRight(l, false); // y = false\n```\n\n `isLeft` is a convenience method that determines whether the variant is `Left`.\n\n `isRight` is a convenience method that determines whether the variant is `Right`.\n\n `fromLeft(e, default)` is a convenience method that returns the value in `Left`,\nor `default` if the variant is `Right`.\n\n `fromRight(e, default)` is a convenience method that returns the value in `Right`,\nor `default` if the variant is `Left`.\n",
  "isSome": "\n```javascript\nconst m = Maybe(UInt).Some(5);\nisNone(m); // false\nisSome(m); // true\n```\n\n `isNone` is a convenience method that determines whether the variant is `None`.\n\n `isSome` is a convenience method that determines whether the variant is `Some`.\n\n\n```javascript\nfromSome(Maybe(UInt).Some(1), 0); // 1\nfromSome(Maybe(UInt).None(), 0);  // 0\n```\n\n `fromSome` receives a `Maybe` value and a default value as arguments and will return the value inside\nof the `Some` variant or the default value otherwise.\n\n\n```javascript\nconst add1 = (x) => x + 1;\nmaybe(Maybe(UInt).Some(1), 0, add1); // 2\nmaybe(Maybe(UInt).None(), 0, add1);  // 0\n```\n\n `maybe(m, defaultVal, f)` receives a `Maybe` value, a default value, and a unary function as arguments. The function will\neither return the application of the function, `f`, to the `Some` value or return the default value provided.\n\nThe following examples demonstrate different usage of `Maybe`:\n\n```javascript\nconst MUInt = Maybe(UInt);\n```\n\n```javascript\n        interact.printBool(Maybe(UInt).Some(5) == Maybe(UInt).Some(5));\n```\n\n```javascript\n  var [ claimed_by, keep_going ] = [ Maybe(Address).None(), true ];\n```\n",
  "isType": "\n```javascript\ntypeOf(x) // type\nisType(t) // Bool\nis(x, t) // t\n```\n\nThe `typeOf` primitive function is the same as `typeof`:\nit returns the type of its argument.\n\nThe `isType` function returns `true` if its argument is a type.\nAny expression satisfying `isType` is compiled away and does not exist at runtime.\n\nThe `is` function returns its first argument if it satisfies the type specified by the second argument.\nIf it is not, then the program is invalid.\nFor example, `is(5, UInt)` returns `5`, while `is(5, Bool)` is an invalid program.\nThe value returned by `is` may not be identical to the input, because in some cases, such as for functions, it will record the applied to type and enforce it on future invocations.\nThese applications are considered negative positions for `Refine`.\n",
  "isub": "\n `isub(x, y)` subtracts the `Int` `y` from the `Int` `x`.\n\n\n `imul(x, y)` multiplies the `Int` `x` and the `Int` `y`.\n\n\n `idiv(x, y)` divides the `Int` `x` by the `Int` `y`.\n\n\n `imod(x, y)` finds the remainder of dividing the `Int` `x` by the `Int` `y`.\n\n\n `ilt(x, y)` determines whether `x` is less than `y`.\n\n\n `ile(x, y)` determines whether `x` is less than or equal to `y`.\n\n\n `igt(x, y)` determines whether `x` is greather than `y`.\n\n\n `ige(x, y)` determines whether `x` is greater than or equal to `y`.\n\n\n `ieq(x, y)` determines whether `x` is equal to `y`.\n\n\n `ine(x, y)` determines whether `x` is not equal to `y`.\n\n\n `imax(x, y)` returns the larger of two `Int`s.\n\n\n `abs(i)` returns the absolute value of an `Int`. The return value is of type `UInt`.\n",
  "ite": "\n```javascript\nite(choosesFirst, [heap1 - amount, heap2], [heap1, heap2 - amount])\n```\n\nConditional expressions may also be written with the `ite` function,\nhowever, note that this function always evaluates both of its branches.\n",
  "lastConsensusSecs": "\n```javascript\nlastConsensusSecs()\n```\n\nlastConsensusSecs is like `lastConsensusTime`, except it returns the network seconds.\n",
  "lastConsensusTime": "\n```javascript\nlastConsensusTime()\n```\n\nThe lastConsensusTime primitive returns the network time of the last publication of the DApp.\nThis may not be available if there was no such previous publication, such as at the beginning of an application before the first publication.\n\n---\n\n\n```javascript\nlastConsensusSecs()\n```\n\nlastConsensusSecs is like `lastConsensusTime`, except it returns the network seconds.\n",
  "le": "\n```javascript\nand(a, b)     // &&\nor(a, b)      // ||\nxor(a, b)     // ^\nadd(a, b)     // +\nsub(a, b)     // -\nmul(a, b)     // *\ndiv(a, b)     // /\npolyMod(a, b) // %\neq(a, b)      // ==\nlt(a, b)      // <\nle(a, b)      // <=\nge(a, b)      // >=\ngt(a, b)      // >\nlsh(a, b)     // <<\nrsh(a, b)     // >>\nband(a, b)    // &\nbior(a, b)    // |\npolyEq(a, b)  // ==, ===\npolyNeq(a, b) // !=, !==\n```\n\nAll binary expression operators have a corresponding named function in the standard library.\nWhile `&&` and `||` may not evaluate their second argument,\ntheir corresponding named functions `and`, `or`, and `xor`, always do.\n\n\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "leftEndpoint": "\n\n `leftEndpoint(i)` will return the `Int` that represents the left endpoint of an interval.\n\n `rightEndpoint(i)` will return the `Int` that represents the right endpoint of an interval.\n",
  "let": "\n\n\n\n\n\n\n\nThis error indicates you are using an illegal JavaScript expression in Reach. Not all JavaScript\nexpressions are valid Reach, as they are not applicable to the language.\n",
  "lsh": "\n```javascript\nand(a, b)     // &&\nor(a, b)      // ||\nxor(a, b)     // ^\nadd(a, b)     // +\nsub(a, b)     // -\nmul(a, b)     // *\ndiv(a, b)     // /\npolyMod(a, b) // %\neq(a, b)      // ==\nlt(a, b)      // <\nle(a, b)      // <=\nge(a, b)      // >=\ngt(a, b)      // >\nlsh(a, b)     // <<\nrsh(a, b)     // >>\nband(a, b)    // &\nbior(a, b)    // |\npolyEq(a, b)  // ==, ===\npolyNeq(a, b) // !=, !==\n```\n\nAll binary expression operators have a corresponding named function in the standard library.\nWhile `&&` and `||` may not evaluate their second argument,\ntheir corresponding named functions `and`, `or`, and `xor`, always do.\n\n\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "lt": "\n```javascript\nand(a, b)     // &&\nor(a, b)      // ||\nxor(a, b)     // ^\nadd(a, b)     // +\nsub(a, b)     // -\nmul(a, b)     // *\ndiv(a, b)     // /\npolyMod(a, b) // %\neq(a, b)      // ==\nlt(a, b)      // <\nle(a, b)      // <=\nge(a, b)      // >=\ngt(a, b)      // >\nlsh(a, b)     // <<\nrsh(a, b)     // >>\nband(a, b)    // &\nbior(a, b)    // |\npolyEq(a, b)  // ==, ===\npolyNeq(a, b) // !=, !==\n```\n\nAll binary expression operators have a corresponding named function in the standard library.\nWhile `&&` and `||` may not evaluate their second argument,\ntheir corresponding named functions `and`, `or`, and `xor`, always do.\n\n\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "makeCommitment": "\n```javascript\nmakeCommitment( interact, x ) \n```\n\nReturns two values, `[ commitment, salt ]`, where `salt` is the result of calling `interact.random()`, and\n`commitment` is the digest of `salt` and `x`.\nThis is used in a local step before `checkCommitment` is used in a consensus step.\n\nThis is demonstrated in the example below. \n`makeCommitment` is used on line 18 before `checkCommitment` on line 21:\n\n```javascript\n    Alice.only(() => {\n      const obj = declassify(interact.getObj());\n      const commitment = declassify(makeCommitment(interact, obj));\n    });\n    Alice.publish(obj, commitment);\n    checkCommitment(...commitment, obj);\n    commit();\n```\n",
  "makeDeadline": "\n```javascript\nconst [ timeRemaining, keepGoing ] = makeDeadline(10);\n```\n\n `makeDeadline(deadline)` takes a `UInt` as an argument and returns a pair of functions\nthat can be used for dealing with absolute deadlines. It internally determines the end time based off of the deadline\nand the last consensus timeat the time of calling `makeDeadline`. `timeRemaining` will calculate the difference\nbetween the end time and the current last consensus time. `keepGoing` determines whether the current last consensus time\nis less than the end time. It is typical to use the two fields for the `while` and `timeout` field of a `parallelReduce`\nexpression. For example:\n\n```javascript\nconst [ timeRemaining, keepGoing ] = makeDeadline(10);\nconst _ = parallelReduce(...)\n  .invariant(...)\n  .while( keepGoing() )\n  .case(...)\n  .timeout( timeRemaining(), () => { ... })\n```\n\nThis pattern is so common that it can be abbreviated as `.timeRemaining`.\n\n```javascript\n      const [ buyTimeout, keepBuying ] =\n        makeDeadline(deadline);\n      const [ returnTimeout, keepReturning ] =\n        makeDeadline(2 * deadline);\n```\n\nAs can be seen in this code block from the Raffle example, `makeDeadline` is being used to set the `deadline` to double the original amount of network blocks if someone returns a ticket.\n",
  "makeEnum": "\n```javascript\nconst [ isHand, ROCK, PAPER, SCISSORS ] = makeEnum(3);\n```\n\nAn enumeration (or enum, for short),\ncan be created by calling the `makeEnum` function, as in `makeEnum(N)`,\nwhere `N` is the number of distinct values in the enum.\nThis produces a tuple of `N+1` values,\nwhere the first value is a `Fun([UInt], Bool)`\nwhich tells you if its argument is one of the enum's values,\nand the next N values are distinct `UInt`s.\n",
  "maybe": "\n```javascript\nconst add1 = (x) => x + 1;\nmaybe(Maybe(UInt).Some(1), 0, add1); // 2\nmaybe(Maybe(UInt).None(), 0, add1);  // 0\n```\n\n `maybe(m, defaultVal, f)` receives a `Maybe` value, a default value, and a unary function as arguments. The function will\neither return the application of the function, `f`, to the `Some` value or return the default value provided.\n\nThe following examples demonstrate different usage of `Maybe`:\n\n```javascript\nconst MUInt = Maybe(UInt);\n```\n\n```javascript\n        interact.printBool(Maybe(UInt).Some(5) == Maybe(UInt).Some(5));\n```\n\n```javascript\n  var [ claimed_by, keep_going ] = [ Maybe(Address).None(), true ];\n```\n",
  "minus": "\n```javascript\n! a  // not\n- a  // minus\n+ a  // plus\ntypeof a\nvoid a\n```\n\nA unary expression, written `UNAOP EXPR_rhs`, where `EXPR_rhs` is an expression and `UNAOP` is one of the unary operators: `! - + typeof void`. All the unary operators, besides `typeof`, have a\ncorresponding named version in the standard library.\n\nIt is invalid to use unary operations on the wrong types of values.\n\nWhen applied to values of type `UInt`, unary `-` and `+` operators will cast\ntheir arguments to type `Int`. The unary `-` and `+` operations are defined for\nvalues of type: `Int`, and `FixedPoint`.\n\n`void a` evaluates to `null` for all arguments.\n\n---\n\n@{ref(\"rsh\", \"&&\")}@{ref(\"rsh\", \"||\")}@{ref(\"rsh\", \"+\")}@{ref(\"rsh\", \"-\")}@{ref(\"rsh\", \"*\")}@{ref(\"rsh\", \"/\")}@{ref(\"rsh\", \"%\")}@{ref(\"rsh\", \"|\")}@{ref(\"rsh\", \"&\")}@{ref(\"rsh\", \"^\")}@{ref(\"rsh\", \"<<\")}@{ref(\"rsh\", \">>\")}@{ref(\"rsh\", \"==\")}@{ref(\"rsh\", \"!=\")}@{ref(\"rsh\", \"===\")}@{ref(\"rsh\", \"!==\")}@{ref(\"rsh\", \">\")}@{ref(\"rsh\", \">=\")}@{ref(\"rsh\", \"<=\")}@{ref(\"rsh\", \"<\")}\n```javascript\na && b\na || b\na + b\na - b\na * b\na / b\na % b\na | b\na & b\na ^ b\na << b\na >> b\na == b\na != b\na === b\na !== b\na > b\na >= b\na <= b\na < b\n```\n\n---\n**NOTE**\n\nBitwise operations are not supported by all consensus networks and greatly decrease the efficiency of verification.\n\n---\n\nA binary expression is written `EXPR_lhs BINOP EXPR_rhs`, where `EXPR_lhs` and `EXPR_rhs` are expressions and `BINOP` is one of the binary operators: `&& || + - * / % | & ^ << >> == != === !== > >= <= <`.\nNumeric operations, like `+` and `>`, only operate on numbers.\nSince all numbers in Reach are integers, operations like `/` truncate their result.\nBoolean operations, like `&&`, only operate on booleans.\n`xor` operates on `UInt`s, `UInt256`s, `Bool`s, `Digest`s, and `Bytes` of the same length.\n`polyMod` operates on `UInt`s and `UInt256`. The first argument may be a `Digest` or `Bytes`.\nIt is invalid to use binary operations on the wrong types of values.\n\n\n```javascript\nand(a, b)     // &&\nor(a, b)      // ||\nxor(a, b)     // ^\nadd(a, b)     // +\nsub(a, b)     // -\nmul(a, b)     // *\ndiv(a, b)     // /\npolyMod(a, b) // %\neq(a, b)      // ==\nlt(a, b)      // <\nle(a, b)      // <=\nge(a, b)      // >=\ngt(a, b)      // >\nlsh(a, b)     // <<\nrsh(a, b)     // >>\nband(a, b)    // &\nbior(a, b)    // |\npolyEq(a, b)  // ==, ===\npolyNeq(a, b) // !=, !==\n```\n\nAll binary expression operators have a corresponding named function in the standard library.\nWhile `&&` and `||` may not evaluate their second argument,\ntheir corresponding named functions `and`, `or`, and `xor`, always do.\n\n\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "mod": "\n```javascript\nand(a, b)     // &&\nor(a, b)      // ||\nxor(a, b)     // ^\nadd(a, b)     // +\nsub(a, b)     // -\nmul(a, b)     // *\ndiv(a, b)     // /\npolyMod(a, b) // %\neq(a, b)      // ==\nlt(a, b)      // <\nle(a, b)      // <=\nge(a, b)      // >=\ngt(a, b)      // >\nlsh(a, b)     // <<\nrsh(a, b)     // >>\nband(a, b)    // &\nbior(a, b)    // |\npolyEq(a, b)  // ==, ===\npolyNeq(a, b) // !=, !==\n```\n\nAll binary expression operators have a corresponding named function in the standard library.\nWhile `&&` and `||` may not evaluate their second argument,\ntheir corresponding named functions `and`, `or`, and `xor`, always do.\n\n\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "mul": "\n```javascript\nand(a, b)     // &&\nor(a, b)      // ||\nxor(a, b)     // ^\nadd(a, b)     // +\nsub(a, b)     // -\nmul(a, b)     // *\ndiv(a, b)     // /\npolyMod(a, b) // %\neq(a, b)      // ==\nlt(a, b)      // <\nle(a, b)      // <=\nge(a, b)      // >=\ngt(a, b)      // >\nlsh(a, b)     // <<\nrsh(a, b)     // >>\nband(a, b)    // &\nbior(a, b)    // |\npolyEq(a, b)  // ==, ===\npolyNeq(a, b) // !=, !==\n```\n\nAll binary expression operators have a corresponding named function in the standard library.\nWhile `&&` and `||` may not evaluate their second argument,\ntheir corresponding named functions `and`, `or`, and `xor`, always do.\n\n\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "muldiv": "\n```javascript\nmuldiv(a, b, c)\n```\n\n Multiplies `a` by `b`, then immediately divides the product by `c`.\nThe intermediate value may be larger than `UInt.max` if the connector supports wide arithmetic operations.\nThe resulting quotient must be less than `UInt.max`.\n",
  "new": "\n\n\n\n`new f(a)` is equivalent to `f.new(a)` and is a convenient short-hand for writing class-oriented programs.\n",
  "not": "\n```javascript\n! a  // not\n- a  // minus\n+ a  // plus\ntypeof a\nvoid a\n```\n\nA unary expression, written `UNAOP EXPR_rhs`, where `EXPR_rhs` is an expression and `UNAOP` is one of the unary operators: `! - + typeof void`. All the unary operators, besides `typeof`, have a\ncorresponding named version in the standard library.\n\nIt is invalid to use unary operations on the wrong types of values.\n\nWhen applied to values of type `UInt`, unary `-` and `+` operators will cast\ntheir arguments to type `Int`. The unary `-` and `+` operations are defined for\nvalues of type: `Int`, and `FixedPoint`.\n\n`void a` evaluates to `null` for all arguments.\n\n---\n\n@{ref(\"rsh\", \"&&\")}@{ref(\"rsh\", \"||\")}@{ref(\"rsh\", \"+\")}@{ref(\"rsh\", \"-\")}@{ref(\"rsh\", \"*\")}@{ref(\"rsh\", \"/\")}@{ref(\"rsh\", \"%\")}@{ref(\"rsh\", \"|\")}@{ref(\"rsh\", \"&\")}@{ref(\"rsh\", \"^\")}@{ref(\"rsh\", \"<<\")}@{ref(\"rsh\", \">>\")}@{ref(\"rsh\", \"==\")}@{ref(\"rsh\", \"!=\")}@{ref(\"rsh\", \"===\")}@{ref(\"rsh\", \"!==\")}@{ref(\"rsh\", \">\")}@{ref(\"rsh\", \">=\")}@{ref(\"rsh\", \"<=\")}@{ref(\"rsh\", \"<\")}\n```javascript\na && b\na || b\na + b\na - b\na * b\na / b\na % b\na | b\na & b\na ^ b\na << b\na >> b\na == b\na != b\na === b\na !== b\na > b\na >= b\na <= b\na < b\n```\n\n---\n**NOTE**\n\nBitwise operations are not supported by all consensus networks and greatly decrease the efficiency of verification.\n\n---\n\nA binary expression is written `EXPR_lhs BINOP EXPR_rhs`, where `EXPR_lhs` and `EXPR_rhs` are expressions and `BINOP` is one of the binary operators: `&& || + - * / % | & ^ << >> == != === !== > >= <= <`.\nNumeric operations, like `+` and `>`, only operate on numbers.\nSince all numbers in Reach are integers, operations like `/` truncate their result.\nBoolean operations, like `&&`, only operate on booleans.\n`xor` operates on `UInt`s, `UInt256`s, `Bool`s, `Digest`s, and `Bytes` of the same length.\n`polyMod` operates on `UInt`s and `UInt256`. The first argument may be a `Digest` or `Bytes`.\nIt is invalid to use binary operations on the wrong types of values.\n\n\n```javascript\nand(a, b)     // &&\nor(a, b)      // ||\nxor(a, b)     // ^\nadd(a, b)     // +\nsub(a, b)     // -\nmul(a, b)     // *\ndiv(a, b)     // /\npolyMod(a, b) // %\neq(a, b)      // ==\nlt(a, b)      // <\nle(a, b)      // <=\nge(a, b)      // >=\ngt(a, b)      // >\nlsh(a, b)     // <<\nrsh(a, b)     // >>\nband(a, b)    // &\nbior(a, b)    // |\npolyEq(a, b)  // ==, ===\npolyNeq(a, b) // !=, !==\n```\n\nAll binary expression operators have a corresponding named function in the standard library.\nWhile `&&` and `||` may not evaluate their second argument,\ntheir corresponding named functions `and`, `or`, and `xor`, always do.\n\n\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "of": "\n\n\n\n\n\n\nThis error indicates you are using an illegal JavaScript expression in Reach. Not all JavaScript\nexpressions are valid Reach, as they are not applicable to the language.\n",
  "or": "\n```javascript\nand(a, b)     // &&\nor(a, b)      // ||\nxor(a, b)     // ^\nadd(a, b)     // +\nsub(a, b)     // -\nmul(a, b)     // *\ndiv(a, b)     // /\npolyMod(a, b) // %\neq(a, b)      // ==\nlt(a, b)      // <\nle(a, b)      // <=\nge(a, b)      // >=\ngt(a, b)      // >\nlsh(a, b)     // <<\nrsh(a, b)     // >>\nband(a, b)    // &\nbior(a, b)    // |\npolyEq(a, b)  // ==, ===\npolyNeq(a, b) // !=, !==\n```\n\nAll binary expression operators have a corresponding named function in the standard library.\nWhile `&&` and `||` may not evaluate their second argument,\ntheir corresponding named functions `and`, `or`, and `xor`, always do.\n\n\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "parallelReduce": "\n```javascript\nconst [ keepGoing, as, bs ] =\n  parallelReduce([ true, 0, 0 ])\n  .invariant(balance() == 2 * wager)\n  .while(keepGoing)\n  .case(Alice, (() => ({\n    when: declassify(interact.keepGoing()) })),\n    (_) => {\n      each([Alice, Bob], () => {\n        interact.roundWinnerWas(true); });\n      return [ true, 1 + as, bs ]; })\n  .case(Bob, (() => ({\n    when: declassify(interact.keepGoing()) })),\n    (_) => {\n      each([Alice, Bob], () => {\n        interact.roundWinnerWas(false); });\n      return [ true, as, 1 + bs ]; })\n  .timeout(deadline, () => {\n    showOutcome(TIMEOUT)();\n    race(Alice, Bob).publish();\n    return [ false, as, bs ]; });\n```\n\n---\n**NOTE**\n\nIf you're unsure of what kind of consensus transfer to use, you may want to read the [explanation of the differences](https://docs.reach.sh/guide/ctransfers/#guide-ctransfers) in the Guide.\n\n---\n\nA parallel reduce statement is written:\n\n\n\n\n\n\n\n@{ref(\"rsh\", \"parallelReduce.api_\")}\n\n```javascript\nconst LHS =\n  parallelReduce(INIT_EXPR)\n  .define(() => DEFINE_BLOCK)\n  .invariant(INVARIANT_EXPR)\n  .while(COND_EXPR)\n  .paySpec(TOKENS_EXPR)\n  .case(PART_EXPR,\n    CHECK_EXPR,\n    PUBLISH_EXPR,\n    PAY_EXPR,\n    CONSENSUS_EXPR)\n  .api(API_EXPR,\n    ASSUME_EXPR,\n    PAY_EXPR,\n    CONSENSUS_EXPR)\n  .api_(API_EXPR,\n    CHECKED_CONSENSUS_EXPR)\n  .timeout(DELAY_EXPR, () =>\n    TIMEOUT_BLOCK);\n```\n\nThe `LHS` and `INIT_EXPR` are like the initialization component of a `while` loop; and,\nthe `.invariant` and `.while` components are like the invariant and condition of a `while` loop;\nthe `DEFINE_BLOCK` is like the `DEFINE_BLOCK` of a `while` loop. It may be specified multiple times;\nwhile the `.case`, `.api`, `.api_`, `.timeout`, and `.paySpec` components are like the corresponding components of a `fork` statement.\n\nThe `.case` component may be repeated many times, just like in a `fork` statement.\n\nThe `.define` component may define bindings that reference the `LHS` values. These bindings are accessible\nfrom every component of the `parallelReduce` statement, except for the `INIT_EXPR`.\n",
  "plus": "\n```javascript\n! a  // not\n- a  // minus\n+ a  // plus\ntypeof a\nvoid a\n```\n\nA unary expression, written `UNAOP EXPR_rhs`, where `EXPR_rhs` is an expression and `UNAOP` is one of the unary operators: `! - + typeof void`. All the unary operators, besides `typeof`, have a\ncorresponding named version in the standard library.\n\nIt is invalid to use unary operations on the wrong types of values.\n\nWhen applied to values of type `UInt`, unary `-` and `+` operators will cast\ntheir arguments to type `Int`. The unary `-` and `+` operations are defined for\nvalues of type: `Int`, and `FixedPoint`.\n\n`void a` evaluates to `null` for all arguments.\n\n---\n\n@{ref(\"rsh\", \"&&\")}@{ref(\"rsh\", \"||\")}@{ref(\"rsh\", \"+\")}@{ref(\"rsh\", \"-\")}@{ref(\"rsh\", \"*\")}@{ref(\"rsh\", \"/\")}@{ref(\"rsh\", \"%\")}@{ref(\"rsh\", \"|\")}@{ref(\"rsh\", \"&\")}@{ref(\"rsh\", \"^\")}@{ref(\"rsh\", \"<<\")}@{ref(\"rsh\", \">>\")}@{ref(\"rsh\", \"==\")}@{ref(\"rsh\", \"!=\")}@{ref(\"rsh\", \"===\")}@{ref(\"rsh\", \"!==\")}@{ref(\"rsh\", \">\")}@{ref(\"rsh\", \">=\")}@{ref(\"rsh\", \"<=\")}@{ref(\"rsh\", \"<\")}\n```javascript\na && b\na || b\na + b\na - b\na * b\na / b\na % b\na | b\na & b\na ^ b\na << b\na >> b\na == b\na != b\na === b\na !== b\na > b\na >= b\na <= b\na < b\n```\n\n---\n**NOTE**\n\nBitwise operations are not supported by all consensus networks and greatly decrease the efficiency of verification.\n\n---\n\nA binary expression is written `EXPR_lhs BINOP EXPR_rhs`, where `EXPR_lhs` and `EXPR_rhs` are expressions and `BINOP` is one of the binary operators: `&& || + - * / % | & ^ << >> == != === !== > >= <= <`.\nNumeric operations, like `+` and `>`, only operate on numbers.\nSince all numbers in Reach are integers, operations like `/` truncate their result.\nBoolean operations, like `&&`, only operate on booleans.\n`xor` operates on `UInt`s, `UInt256`s, `Bool`s, `Digest`s, and `Bytes` of the same length.\n`polyMod` operates on `UInt`s and `UInt256`. The first argument may be a `Digest` or `Bytes`.\nIt is invalid to use binary operations on the wrong types of values.\n\n\n```javascript\nand(a, b)     // &&\nor(a, b)      // ||\nxor(a, b)     // ^\nadd(a, b)     // +\nsub(a, b)     // -\nmul(a, b)     // *\ndiv(a, b)     // /\npolyMod(a, b) // %\neq(a, b)      // ==\nlt(a, b)      // <\nle(a, b)      // <=\nge(a, b)      // >=\ngt(a, b)      // >\nlsh(a, b)     // <<\nrsh(a, b)     // >>\nband(a, b)    // &\nbior(a, b)    // |\npolyEq(a, b)  // ==, ===\npolyNeq(a, b) // !=, !==\n```\n\nAll binary expression operators have a corresponding named function in the standard library.\nWhile `&&` and `||` may not evaluate their second argument,\ntheir corresponding named functions `and`, `or`, and `xor`, always do.\n\n\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "polyEq": "\n```javascript\nand(a, b)     // &&\nor(a, b)      // ||\nxor(a, b)     // ^\nadd(a, b)     // +\nsub(a, b)     // -\nmul(a, b)     // *\ndiv(a, b)     // /\npolyMod(a, b) // %\neq(a, b)      // ==\nlt(a, b)      // <\nle(a, b)      // <=\nge(a, b)      // >=\ngt(a, b)      // >\nlsh(a, b)     // <<\nrsh(a, b)     // >>\nband(a, b)    // &\nbior(a, b)    // |\npolyEq(a, b)  // ==, ===\npolyNeq(a, b) // !=, !==\n```\n\nAll binary expression operators have a corresponding named function in the standard library.\nWhile `&&` and `||` may not evaluate their second argument,\ntheir corresponding named functions `and`, `or`, and `xor`, always do.\n\n\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "polyMod": "\n```javascript\nand(a, b)     // &&\nor(a, b)      // ||\nxor(a, b)     // ^\nadd(a, b)     // +\nsub(a, b)     // -\nmul(a, b)     // *\ndiv(a, b)     // /\npolyMod(a, b) // %\neq(a, b)      // ==\nlt(a, b)      // <\nle(a, b)      // <=\nge(a, b)      // >=\ngt(a, b)      // >\nlsh(a, b)     // <<\nrsh(a, b)     // >>\nband(a, b)    // &\nbior(a, b)    // |\npolyEq(a, b)  // ==, ===\npolyNeq(a, b) // !=, !==\n```\n\nAll binary expression operators have a corresponding named function in the standard library.\nWhile `&&` and `||` may not evaluate their second argument,\ntheir corresponding named functions `and`, `or`, and `xor`, always do.\n\n\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "polyNeq": "\n```javascript\nand(a, b)     // &&\nor(a, b)      // ||\nxor(a, b)     // ^\nadd(a, b)     // +\nsub(a, b)     // -\nmul(a, b)     // *\ndiv(a, b)     // /\npolyMod(a, b) // %\neq(a, b)      // ==\nlt(a, b)      // <\nle(a, b)      // <=\nge(a, b)      // >=\ngt(a, b)      // >\nlsh(a, b)     // <<\nrsh(a, b)     // >>\nband(a, b)    // &\nbior(a, b)    // |\npolyEq(a, b)  // ==, ===\npolyNeq(a, b) // !=, !==\n```\n\nAll binary expression operators have a corresponding named function in the standard library.\nWhile `&&` and `||` may not evaluate their second argument,\ntheir corresponding named functions `and`, `or`, and `xor`, always do.\n\n\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "possible": "\n```javascript\npossible( claim, [msg] )\n```\n\n A possibility assertion which is only valid if it is possible for `claim` to evaluate to `true` with honest frontends and participants.\nIt accepts an optional bytes argument, which is included in any reported violation.\n",
  "pow": "\n```javascript\npow (2, 40, 10) // => 1,099,511,627,776\n```\n\n `pow(base, power, precision)` calculates the approximate value of raising base to power.\nThe third argument must be a `UInt` whose value is known at compile time, which represents the number\nof iterations the algorithm should perform.\nFor reference, `6` iterations provides enough accuracy to calculate up to `2^64 - 1`, so the largest power it can compute is `2^63`.\nIf the number of iterations is not large enough to compute the power, then the result is completely inaccurate.\nIt is recommended to create `assert` tests to ensure the possible values your program can compute are accurate.\n",
  "race": "\n```javascript\nrace(Alice, Bob).publish(bet);\n```\n\n---\n**NOTE**\n\nIf you're unsure of what kind of consensus transfer to use, you may want to read the [explanation of the differences](https://docs.reach.sh/guide/ctransfers/#guide-ctransfers) in the Guide.\n\n---\n\nA race expression, written `race(PARTICIPANT_0, ..., PARTICIPANT_n);`, constructs a participant that may be used in a consensus transfer statement, such as `publish` or `pay`, where the various participants race to be the first one to perform the consensus transfer.\n\nReach provides a shorthand, `Anybody`, which serves as a `race` between all the participants.\n\n---\n**NOTE**\n\nSee [the guide section on races](https://docs.reach.sh/guide/race/#guide-race) to understand the benefits and dangers of using `race`.\n\n---\n\n```javascript\n      race(Alice, Bob).publish(outcome);\n      const winner = outcome == ALICE_WINS ? Alice : Bob;\n      transfer(balance()).to(winner);\n      commit();\n      showOutcome(outcome)();\n```\n\nIn this example, Bob and Alice are doing a race and whoever publishes first is the winner.\nOnce the first publish is completed, the outcome is decided by checking if `ALICE_WINS` is true or false.\nIf `ALICE_WINS` evaluates to true, Alice is declared the winner and the balance of the wager is then transferred to her.\n",
  "relativeSecs": "\n```javascript\nrelativeTime(amt, ?claim)\nabsoluteTime(time, ?claim)\nrelativeSecs(amt, ?claim)\nabsoluteSecs(secs, ?claim)\n```\n\nThese functions return time arguments, which are instances of the type `Either(UInt, UInt)`, where `Left` variants refer to absolute network time and `Right` variants refer to absolute network seconds.\n\nThese functions take an optional function argument, `claim`, which will be used to verify arithmetic when necessary.\nIn most cases, one would pass `assume`, `require`, or `assert`.\nThis argument is only needed when `verifyArithmetic` is enabled.\nThe default value of this argument is a no-op.\n\nThe `absoluteTime` and `absoluteSecs` are equivalent to `Left` and `Right` variant tags.\n\nThe `relativeTime` and `relativeSecs` functions add `baseWaitTime` and `baseWaitSecs` to their arguments before tagging with the appropriate variant.\n\nIf a time argument is required, an integer value is allowed and is interpreted as a `relativeTime`, but this behavior is deprecated and you will see a warning.\n",
  "relativeTime": "\n```javascript\nrelativeTime(amt, ?claim)\nabsoluteTime(time, ?claim)\nrelativeSecs(amt, ?claim)\nabsoluteSecs(secs, ?claim)\n```\n\nThese functions return time arguments, which are instances of the type `Either(UInt, UInt)`, where `Left` variants refer to absolute network time and `Right` variants refer to absolute network seconds.\n\nThese functions take an optional function argument, `claim`, which will be used to verify arithmetic when necessary.\nIn most cases, one would pass `assume`, `require`, or `assert`.\nThis argument is only needed when `verifyArithmetic` is enabled.\nThe default value of this argument is a no-op.\n\nThe `absoluteTime` and `absoluteSecs` are equivalent to `Left` and `Right` variant tags.\n\nThe `relativeTime` and `relativeSecs` functions add `baseWaitTime` and `baseWaitSecs` to their arguments before tagging with the appropriate variant.\n\nIf a time argument is required, an integer value is allowed and is interpreted as a `relativeTime`, but this behavior is deprecated and you will see a warning.\n",
  "remote": "\n```javascript\nconst randomOracle =\n  remote( randomOracleCtcInfo, {\n    getRandom: Fun([], UInt),\n  });\nconst randomVal = randomOracle.getRandom.pay(randomFee)();\n```\n\n---\n**NOTE**\n\n[Networks](https://docs.reach.sh/networks/#ref-networks) discusses how Reach supports remote objects on specific consensus networks.\n\n---\n\nA remote object represents a foreign contract in a Reach application.\nDuring a consensus step, a Reach computation may consensually communicate with such an object via a prescribed interface.\n\nA remote object is constructed by calling the `remote` function with a `Contract`, an interface---an object where each key is bound to a function type, and an optional object of aliases.\nThe alias object maps function names from the interface to function names on the remote contract.\nIt allows users to bind specific instances of an overloaded remote function.\nFor example:\n```javascript\nconst randomOracle =\n  remote( randomOracleCtcInfo, {\n    getRandom: Fun([], UInt),\n    getRandom1: Fun([UInt], UInt),\n  }, {\n    getRandom: \"random\",\n    getRandom1: \"random\",\n  });\nconst token =\n  remote( tokenCtcInfo, {\n    balanceOf: Fun([Address], UInt),\n    transferTo: Fun([UInt, Address], Null),\n  });\n```\n\nIn this example, the random oracle contract has an overloaded method, `random`.\nThis `random` method accepts 0 or 1 parameters.\nWe explicitly specify that `getRandom` refers to calling the `random` function with no arguments, and `getRandom1` refers to calling the `random` function with 1 argument.\n\nOnce constructed, the fields of a remote object represent those remote contract interactions, referred to as remote functions.\nFor example, `randomOracle.getRandom`, `token.balanceOf`, and `token.transferTo` are remote functions in the example.\n\nA remote function may be invoked by calling it with the appropriate arguments, whereupon it returns the specified output.\nIn addition, a remote function may be augmented with one of the following operations:\n\n+ `REMOTE_FUN.pay(AMT)` ---\n  Returns a remote function that receives a pay amount, `AMT`, _from_ the caller when it is called.\n+  `REMOTE_FUN.bill(AMT)` ---\n  Returns a remote function that provides a pay amount, `AMT`, _to_ the caller when it returns.\n+  `REMOTE_FUN.withBill()` ---\n  Returns a remote function that provides some number of network tokens and, possibly, non-network tokens _to_ the caller when it returns.\n  The exact amount is returned from the invocation by wrapping the original result in a tuple.\n+  `REMOTE_FUN.ALGO(opts)` ---\n  Returns a remote function that records the need for additional resources on Algorand.\n  + `opts.fees` records extra fees.\n    If this is needed, and not included, then the consensus transfer to the current consensus step will fail with an insufficient fee error.\n  + `opts.assets` records extra assets.\n    If this is needed, and not included, then the consensus transfer to the current consensus step will fail with an invalid asset reference.\n  + `opts.addressToAccount` changes `Address` arguments to `Account` array references.\n    If this is needed, and not included, then the consensus transfer to the current consensus step will fail because an incorrectly typed argument was provided to the remote object.\n\nIf the remote contract is not expected to return non-network tokens then a pair is returned, where the amount of network tokens received is the first element, and the original result is the second element.\n\nIf the remote contract is expected to return non-network tokens then a triple is returned, where the amount of network tokens received\nis the first element, a tuple of the non-network tokens received is the second element, and the original result is the third element.\nIf the caller expects to receive non-network tokens, they must provide a tuple of tokens as an argument to `withBill`.\nThe ordering of tokens in the argument is preserved when returning the amounts received.\nFor example,\n\n```javascript\nconst [ netRecv, [gilRecv, zmdRecv], randomValue ] =\n  randomOracle.getRandom.pay(stipend).withBill([gil, zmd])();\n```\n\nmight be the way to communicate with a random oracle that receives a conservative approximation of its actual cost and returns what it does not use, along with some amount of network tokens, `GIL`, and `ZMD`.\nThis operation may not be used with `REMOTE_FUN.bill`.\n",
  "require": "\n```javascript\nrequire( claim, [msg] )\n```\n\n A requirement where `claim` evaluates to `true` with honest participants.\nThis may only appear in a consensus step.\nIt accepts an optional bytes argument, which is included in any reported violation.\n\nIf a publication would violate the requirement, the consensus network rejects the transaction.\n\n```javascript\n  A.publish(token1, token2, amt);\n  require(token1 != token2);\n  commit();\n```\n\nThe example above has Alice publish two tokens named `token1` and `token2` and the `require` statement checks if they are different tokens.\nIf they are not different tokens, then the transaction is rejected.\n",
  "return": "\n```javascript\nreturn 17;\nreturn 3 + 4;\nreturn f(2, false);\nreturn;\n```\n\nA return statement, written `return EXPR;`, where `EXPR` is an expression, evaluates to the same value as `EXPR`.\nAs a special case, `return;` is interpreted the same as `return null;`.\n\nA return statement returns its value to the surrounding function application.\n\nA return statement is a terminator statement, so it must have an empty tail.\nFor example,\n\n```javascript\n{ return 1;\n  return 2; }\n```\n\nis invalid, because the first `return`'s tail is not empty.\n\nFurthermore, a `return` must have an empty continuation (i.e. it must be in tail position.)\n",
  "rightEndpoint": "\n `leftEndpoint(i)` will return the `Int` that represents the left endpoint of an interval.\n\n `rightEndpoint(i)` will return the `Int` that represents the right endpoint of an interval.\n",
  "rsh": "\n```javascript\nand(a, b)     // &&\nor(a, b)      // ||\nxor(a, b)     // ^\nadd(a, b)     // +\nsub(a, b)     // -\nmul(a, b)     // *\ndiv(a, b)     // /\npolyMod(a, b) // %\neq(a, b)      // ==\nlt(a, b)      // <\nle(a, b)      // <=\nge(a, b)      // >=\ngt(a, b)      // >\nlsh(a, b)     // <<\nrsh(a, b)     // >>\nband(a, b)    // &\nbior(a, b)    // |\npolyEq(a, b)  // ==, ===\npolyNeq(a, b) // !=, !==\n```\n\nAll binary expression operators have a corresponding named function in the standard library.\nWhile `&&` and `||` may not evaluate their second argument,\ntheir corresponding named functions `and`, `or`, and `xor`, always do.\n\n\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "setOptions": "\n```javascript\nsetOptions({ verifyArithmetic: true });\nsetOptions({});\n```\n\nThe compilation options for the DApp may be set by calling `setOptions(OBJ_EXPR);` where `OBJ_EXPR` is an object with the following keys and values:\n\n+  `untrustworthyMaps`\n\n  `true` or `false` (default)\n\n  Determines whether mappings are treated as trustworthy.\n  A mapping is trustworthy if its values are guaranteed to be preserved across interactions.\n  When this is `true`, the verifier will enforce that your program does not rely on values being preserved.\n\n  See example below:\n  ```javascript\n  export const main = Reach.App(() => {\n  setOptions({ untrustworthyMaps: true });\n  const common = {\n  ```\n\n  Reach cannot provide trustworthy mappings with some connectors; therefore it is dangerous to not set this to `true` on such connectors.\n  Reach will emit a warning during compilation if you do such a dangerous thing.\n\n+  `verifyArithmetic`\n\n  `true` or `false` (default)\n\n  Determines whether arithmetic operations automatically introduce static assertions that they do not overflow beyond `UInt.max`.\n\n  See example below:\n  ```javascript\n  export const veriC = Reach.App(() => {\n  setOptions({ verifyArithmetic: true });\n  const A = Participant('A', { x: UInt256 });\n  ```\n\n  This defaults to `false`, because it is onerous to verify.\n  We recommend turning it on before final deployment, but leaving it off during development.\n  When it is `false`, connectors will ensure that overflows do not actually occur on the network.\n\n+  `verifyPerConnector`\n\n  `true` or `false` (default)\n\n  Determines whether verification is done per connector, or once for a generic connector.\n  When this is `true`, then connector-specific constants, like `UInt.max`, will be instantiated to literal numbers.\n  This concretization of these constants can induce performance degradation in the verifier.\n\n  See example below:\n  ```javascript\n  export const main = Reach.App(\n  { verifyArithmetic: true,\n    verifyPerConnector: true },\n  [Participant('A', { get: Fun([], UInt),\n  ```\n\n+  `connectors`\n\n   `[ETH, ALGO]` (default)\n\n  A tuple of the connectors that the application should be compiled for.\n  By default, all available connectors are chosen.\n\n  In the example below, only `ETH` and `ALGO` are chosen:\n  ```javascript\n  export const main =\n  Reach.App(() => {\n\n    setOptions({ connectors: [ETH, ALGO ]});\n\n    const Pollster =\n  ```\n",
  "sqrt": "\n```javascript\nsqrt(81)\n```\n\n`sqrt(x)` returns the largest integer `i` such that `i * i <= x`.\n",
  "sqrtApprox": "\n```javascript\nsqrtApprox(81, 10)\n```\n\nCalculates an approximate square root of the first argument.\nThis method utilizes the [Babylonian Method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method) for computing the square root.\nThe second argument must be a `UInt` whose value is known at compile time, which represents the number of iterations the algorithm should perform.\n\nFor reference, when performing `5` iterations, the algorithm can reliably calculate the square root up to `32` squared, or `1,024`.\nWhen performing `10` iterations, the algorithm can reliably calculate the square root up to `580` squared, or `336,400`.\n",
  "static": "\n\n\n\n\n\nThis error indicates you are using an illegal JavaScript expression in Reach. Not all JavaScript\nexpressions are valid Reach, as they are not applicable to the language.\n",
  "sub": "\n```javascript\nand(a, b)     // &&\nor(a, b)      // ||\nxor(a, b)     // ^\nadd(a, b)     // +\nsub(a, b)     // -\nmul(a, b)     // *\ndiv(a, b)     // /\npolyMod(a, b) // %\neq(a, b)      // ==\nlt(a, b)      // <\nle(a, b)      // <=\nge(a, b)      // >=\ngt(a, b)      // >\nlsh(a, b)     // <<\nrsh(a, b)     // >>\nband(a, b)    // &\nbior(a, b)    // |\npolyEq(a, b)  // ==, ===\npolyNeq(a, b) // !=, !==\n```\n\nAll binary expression operators have a corresponding named function in the standard library.\nWhile `&&` and `||` may not evaluate their second argument,\ntheir corresponding named functions `and`, `or`, and `xor`, always do.\n\n\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "switch": "\n```javascript\nconst mi = Maybe(UInt).Some(42);\nswitch ( mi ) {\n case None: return 8;\n case Some: return mi + 10; }\nswitch ( mi ) {\n case None: return 8;\n default: return 41; }\n```\n\nA switch statement,\nwritten `switch (VAR) { CASE ... }`,\nwhere `VAR` is a variable bound to a data instance\nand `CASE` is either `case VARIANT: STMT ...`, where `VARIANT` is a variant, or `default: STMT ...`, and `STMT` is a sequence of statements,\nselects the appropriate sequence of statements based on which variant `VAR` holds.\nWithin the body of a `switch` case, `VAR` has the type of variant; i.e. in a `Some` case of a `Maybe(UInt)` `switch`, the variable is bound to an integer.\n\nAll cases have empty tails, i.e. the tail of the switch statement is not propagated.\n\nA switch statement may only include a consensus transfer in its cases if it is within a consensus step, because its statements are in the same context as the conditional statement itself.\n\nIt is invalid for a case to appear multiple times, or be missing, or to be superfluous (i.e. for a variant that does not exist in the `Data` type of `VAR`).\n\nIf one case of a `switch` contains a `return`, then all must.\n",
  "this": "\nThe identifier `this` has a special meaning inside of a local step (i.e. the body of an `only` or `each` expression), as well as in a consensus step (i.e. the tail of `publish` or `pay` statement and before a `commit` statement). For details, see [this](https://docs.reach.sh/rsh/local/#ref-programs-local-this) and [this](https://docs.reach.sh/rsh/consensus/#ref-programs-consensus-this).\n",
  "thisConsensusSecs": "\n```javascript\nthisConsensusSecs()\n```\n\nthisConsensusSecs is like `thisConsensusTime`, except it returns the network seconds.\n",
  "thisConsensusTime": "\n```javascript\nthisConsensusTime()\n```\n\nThe thisConsensusTime primitive returns the network time of the current publication of the DApp.\n\n---\n**NOTE**\n\nSome networks do not support observing the time of a consensus operation until after it has finalized.\n\n---\n\n---\n\n\n```javascript\nthisConsensusSecs()\n```\n\nthisConsensusSecs is like `thisConsensusTime`, except it returns the network seconds.\n",
  "throw": "\n\n\n\n\nThis error indicates you are using an illegal JavaScript expression in Reach. Not all JavaScript\nexpressions are valid Reach, as they are not applicable to the language.\n",
  "transfer": "\n\nA transfer expression,\nwritten `transfer(PAY_AMOUNT_EXPR).to(ADDR_EXPR)`,\nwhere `PAY_AMOUNT_EXPR` is an expression that evaluates to a [pay amount](https://docs.reach.sh/rsh/step/#payAmt), and\n`ADDR_EXPR` evaluates to an address,\nperforms a transfer of network tokens or non-network tokens from the contract to the named participant.\nThe amount transfered must evaluate to less than or equal to the balance of the network and non-network tokens in the contract account.\n\nA transfer expression may only occur within a consensus step.\n\n```javascript\n  transfer(lastPrice).to(Creator);\n  transfer(amt, nftId).to(highestBidder);\n```\n\nThe first `transfer` example from the Simple NFT Auction pays the `lastPrice` to the NFT `Creator`.\nThe second `transfer` example gives the sale quantity of the NFT to the `Participant` that bid the highest price.\n",
  "try": "\n\n\n\nThis error indicates you are using an illegal JavaScript expression in Reach. Not all JavaScript\nexpressions are valid Reach, as they are not applicable to the language.\n",
  "typeEq": "\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "typeOf": "\n```javascript\ntypeOf(x) // type\nisType(t) // Bool\nis(x, t) // t\n```\n\nThe `typeOf` primitive function is the same as `typeof`:\nit returns the type of its argument.\n\nThe `isType` function returns `true` if its argument is a type.\nAny expression satisfying `isType` is compiled away and does not exist at runtime.\n\nThe `is` function returns its first argument if it satisfies the type specified by the second argument.\nIf it is not, then the program is invalid.\nFor example, `is(5, UInt)` returns `5`, while `is(5, Bool)` is an invalid program.\nThe value returned by `is` may not be identical to the input, because in some cases, such as for functions, it will record the applied to type and enforce it on future invocations.\nThese applications are considered negative positions for `Refine`.\n",
  "typeof": "\n```javascript\n! a  // not\n- a  // minus\n+ a  // plus\ntypeof a\nvoid a\n```\n\nA unary expression, written `UNAOP EXPR_rhs`, where `EXPR_rhs` is an expression and `UNAOP` is one of the unary operators: `! - + typeof void`. All the unary operators, besides `typeof`, have a\ncorresponding named version in the standard library.\n\nIt is invalid to use unary operations on the wrong types of values.\n\nWhen applied to values of type `UInt`, unary `-` and `+` operators will cast\ntheir arguments to type `Int`. The unary `-` and `+` operations are defined for\nvalues of type: `Int`, and `FixedPoint`.\n\n`void a` evaluates to `null` for all arguments.\n\n---\n\n@{ref(\"rsh\", \"&&\")}@{ref(\"rsh\", \"||\")}@{ref(\"rsh\", \"+\")}@{ref(\"rsh\", \"-\")}@{ref(\"rsh\", \"*\")}@{ref(\"rsh\", \"/\")}@{ref(\"rsh\", \"%\")}@{ref(\"rsh\", \"|\")}@{ref(\"rsh\", \"&\")}@{ref(\"rsh\", \"^\")}@{ref(\"rsh\", \"<<\")}@{ref(\"rsh\", \">>\")}@{ref(\"rsh\", \"==\")}@{ref(\"rsh\", \"!=\")}@{ref(\"rsh\", \"===\")}@{ref(\"rsh\", \"!==\")}@{ref(\"rsh\", \">\")}@{ref(\"rsh\", \">=\")}@{ref(\"rsh\", \"<=\")}@{ref(\"rsh\", \"<\")}\n```javascript\na && b\na || b\na + b\na - b\na * b\na / b\na % b\na | b\na & b\na ^ b\na << b\na >> b\na == b\na != b\na === b\na !== b\na > b\na >= b\na <= b\na < b\n```\n\n---\n**NOTE**\n\nBitwise operations are not supported by all consensus networks and greatly decrease the efficiency of verification.\n\n---\n\nA binary expression is written `EXPR_lhs BINOP EXPR_rhs`, where `EXPR_lhs` and `EXPR_rhs` are expressions and `BINOP` is one of the binary operators: `&& || + - * / % | & ^ << >> == != === !== > >= <= <`.\nNumeric operations, like `+` and `>`, only operate on numbers.\nSince all numbers in Reach are integers, operations like `/` truncate their result.\nBoolean operations, like `&&`, only operate on booleans.\n`xor` operates on `UInt`s, `UInt256`s, `Bool`s, `Digest`s, and `Bytes` of the same length.\n`polyMod` operates on `UInt`s and `UInt256`. The first argument may be a `Digest` or `Bytes`.\nIt is invalid to use binary operations on the wrong types of values.\n\n\n```javascript\nand(a, b)     // &&\nor(a, b)      // ||\nxor(a, b)     // ^\nadd(a, b)     // +\nsub(a, b)     // -\nmul(a, b)     // *\ndiv(a, b)     // /\npolyMod(a, b) // %\neq(a, b)      // ==\nlt(a, b)      // <\nle(a, b)      // <=\nge(a, b)      // >=\ngt(a, b)      // >\nlsh(a, b)     // <<\nrsh(a, b)     // >>\nband(a, b)    // &\nbior(a, b)    // |\npolyEq(a, b)  // ==, ===\npolyNeq(a, b) // !=, !==\n```\n\nAll binary expression operators have a corresponding named function in the standard library.\nWhile `&&` and `||` may not evaluate their second argument,\ntheir corresponding named functions `and`, `or`, and `xor`, always do.\n\n\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "unknowable": "\n```javascript\nunknowable( Notter, Knower(var_0, ..., var_N), [msg] )\n```\n\nA knowledge assertion that the participant `Notter` _does not_ know the results of the variables `var_0` through `var_N`, but that the participant `Knower` _does_ know those values.\nIt accepts an optional bytes argument, which is included in any reported violation.\n\n```javascript\n    unknowable(Bob, Alice(_handAlice, _saltAlice));\n```\n\nThis example from the [Rock, Paper, Scissors!](https://docs.reach.sh/tut/rps/#tut) tutorial checks that both Alice's hand and salt are unknowable to ensure Bob cannot cheat.\n",
  "unstrict": "\n```javascript\nassert(unstrict(() => {\n  'use strict';\n  // the following fails in strict mode due to a type mismatch\n  return 1 != true;\n}));\n```\n\n `unstrict` applies a thunk, ignoring any usage of strict mode. This\ncan be useful when dealing with libraries that are written in strict mode.\n",
  "var": "\n```javascript\nvar [ heap1, heap2 ] = [ 21, 21 ];\n{ const sum = () => heap1 + heap2; }\ninvariant(balance() == 2 * wagerAmount);\nwhile ( sum() > 0 ) {\n  ....\n  [ heap1, heap2 ] = [ heap1 - 1, heap2 ];\n  continue; }\n```\n\nA while statement may occur within a consensus step and is written:\n\n```javascript\nvar LHS = INIT_EXPR;\nDEFINE_BLOCK; // optional\ninvariant(INVARIANT_EXPR);\nwhile( COND_EXPR ) BLOCK\n```\n\nwhere `LHS` is a valid left-hand side of an identifier definition where the expression `INIT_EXPR` is the right-hand side, and\n`DEFINE_BLOCK` is an optional block that may define bindings that use the `LHS` values which are bound inside the rest of the `while` and its tail, and\n`INVARIANT_EXPR` is an expression, called the loop invariant, that must be true before and after every execution of the block `BLOCK`, and\nif `COND_EXPR` is true, then the block executes,\nand if not, then the loop terminates and control transfers to the continuation of the while statement.\nThe identifiers bound by `LHS` are bound within `DEFINE_BLOCK`, `INVARIANT_EXPR`, `COND_EXPR`, `BLOCK`, and the tail of the while statement.\n\n---\n**NOTE**\n\nRead about finding [loop invariants](https://docs.reach.sh/guide/loop-invs/#guide-loop-invs) in the Reach guide.\n\n---\n\n```javascript\n      while ( keepGoing ) {\n        commit();\n\n        each([Alice, Bob], () => {\n          const go = declassify(interact.keepGoing()); });\n        Alice.only(() => {\n          const isAlice = true; });\n        Bob.only(() => {\n          const isAlice = false; });\n\n        race(Alice, Bob).publish(isAlice).when(go)\n          .timeout(relativeTime(deadline), () => {\n            showOutcome(TIMEOUT)();\n            race(Alice, Bob).publish();\n            keepGoing = false;\n            continue; });\n        const [ da, db ] = isAlice ? [ 1, 0 ] : [ 0, 1 ];\n        each([Alice, Bob], () => {\n          interact.roundWinnerWas(isAlice); });\n        [ keepGoing, as, bs ] = [ true, as + da, bs + db ];\n        continue;\n      }\n```\n",
  "verifyAbsoluteSecs": "\n```javascript\nverifyRelativeTime(amt, claim)\nverifyAbsoluteTime(time, claim)\nverifyRelativeSecs(amt, claim)\nverifyAbsoluteSecs(secs, claim)\n```\n\nWhen using `verifyArithmetic` and a dynamic timeout argument, it will be necessary to verify that the timeout calculation will not overflow. When producing the interact timeout value, you will want to use these functions to make `assume` and `require` claims about the value. For example:\n\n```javascript\nA.only(() => {\n  const t = declassify(interact.getTimeout());\n  verifyAbsoluteTime(t, assume);\n});\nA.publish(t);\nverifyAbsoluteTime(t, require);\n// ...\n```\n\nUse the identity function as the `claim` for use inside of invariants.\n",
  "verifyAbsoluteTime": "\n```javascript\nverifyRelativeTime(amt, claim)\nverifyAbsoluteTime(time, claim)\nverifyRelativeSecs(amt, claim)\nverifyAbsoluteSecs(secs, claim)\n```\n\nWhen using `verifyArithmetic` and a dynamic timeout argument, it will be necessary to verify that the timeout calculation will not overflow. When producing the interact timeout value, you will want to use these functions to make `assume` and `require` claims about the value. For example:\n\n```javascript\nA.only(() => {\n  const t = declassify(interact.getTimeout());\n  verifyAbsoluteTime(t, assume);\n});\nA.publish(t);\nverifyAbsoluteTime(t, require);\n// ...\n```\n\nUse the identity function as the `claim` for use inside of invariants.\n",
  "verifyMuldiv": "\n```javascript\nA.only(() => {\n  const { x, y, z} = declassify(interact.params);\n  verifyMuldiv(x, y, z);\n});\nA.publish(x, y, z);\nverifyMuldiv(x, y, z);\nconst r = muldiv(x, y, z);\n```\n\n `verifyMuldiv` generates a claim that the result of applying the same arguments to `muldiv` will not overflow.\nWhen used inside of a local step or export, it will generate an `assume` claim.\nWhen used inside of a consensus step, it will generate a `require` claim.\nWhen used inside of any other step, it will generate an `assert` claim.\n",
  "verifyRelativeSecs": "\n```javascript\nverifyRelativeTime(amt, claim)\nverifyAbsoluteTime(time, claim)\nverifyRelativeSecs(amt, claim)\nverifyAbsoluteSecs(secs, claim)\n```\n\nWhen using `verifyArithmetic` and a dynamic timeout argument, it will be necessary to verify that the timeout calculation will not overflow. When producing the interact timeout value, you will want to use these functions to make `assume` and `require` claims about the value. For example:\n\n```javascript\nA.only(() => {\n  const t = declassify(interact.getTimeout());\n  verifyAbsoluteTime(t, assume);\n});\nA.publish(t);\nverifyAbsoluteTime(t, require);\n// ...\n```\n\nUse the identity function as the `claim` for use inside of invariants.\n",
  "verifyRelativeTime": "\n```javascript\nverifyRelativeTime(amt, claim)\nverifyAbsoluteTime(time, claim)\nverifyRelativeSecs(amt, claim)\nverifyAbsoluteSecs(secs, claim)\n```\n\nWhen using `verifyArithmetic` and a dynamic timeout argument, it will be necessary to verify that the timeout calculation will not overflow. When producing the interact timeout value, you will want to use these functions to make `assume` and `require` claims about the value. For example:\n\n```javascript\nA.only(() => {\n  const t = declassify(interact.getTimeout());\n  verifyAbsoluteTime(t, assume);\n});\nA.publish(t);\nverifyAbsoluteTime(t, require);\n// ...\n```\n\nUse the identity function as the `claim` for use inside of invariants.\n",
  "wait": "\n```javascript\nwait(TIME);\n```\n\nA wait statement, written `wait(TIME);`, delays the computation until the `TIME` time argument passes.\n`TIME` must be pure and may only reference values known by the consensus state.\n\nIn this example, `wait` is used so Bob doesn't have an advantage over Alice by making two separate `publish` statements at the same time.\n`wait` ensures that Alice has enough time to verify that Bob accepted the `wager` before beginning a `race`.\n\n---\n**NOTE**\n\nLearn more about the `race` expression in the guide, [Racing non-determinism in decentralized applications](https://docs.reach.sh/guide/race/#guide-race).\n\n---\n\n```javascript\nBob.only(() => {\n  interact.confirmWager(wager); });\nBob.pay(wager)\n  .timeout(relativeTime(deadline), () => closeTo(Alice, showOutcome(TIMEOUT)));\ncommit();\n\nwait(relativeTime(deadline));\n```\n\n`wait` does not execute on chain,\ninstead, it constrains the next action that may occur on chain.\nThus, `wait` may only occur in a step.\n",
  "while": "\n```javascript\nvar [ heap1, heap2 ] = [ 21, 21 ];\n{ const sum = () => heap1 + heap2; }\ninvariant(balance() == 2 * wagerAmount);\nwhile ( sum() > 0 ) {\n  ....\n  [ heap1, heap2 ] = [ heap1 - 1, heap2 ];\n  continue; }\n```\n\nA while statement may occur within a consensus step and is written:\n\n```javascript\nvar LHS = INIT_EXPR;\nDEFINE_BLOCK; // optional\ninvariant(INVARIANT_EXPR);\nwhile( COND_EXPR ) BLOCK\n```\n\nwhere `LHS` is a valid left-hand side of an identifier definition where the expression `INIT_EXPR` is the right-hand side, and\n`DEFINE_BLOCK` is an optional block that may define bindings that use the `LHS` values which are bound inside the rest of the `while` and its tail, and\n`INVARIANT_EXPR` is an expression, called the loop invariant, that must be true before and after every execution of the block `BLOCK`, and\nif `COND_EXPR` is true, then the block executes,\nand if not, then the loop terminates and control transfers to the continuation of the while statement.\nThe identifiers bound by `LHS` are bound within `DEFINE_BLOCK`, `INVARIANT_EXPR`, `COND_EXPR`, `BLOCK`, and the tail of the while statement.\n\n---\n**NOTE**\n\nRead about finding [loop invariants](https://docs.reach.sh/guide/loop-invs/#guide-loop-invs) in the Reach guide.\n\n---\n\n```javascript\n      while ( keepGoing ) {\n        commit();\n\n        each([Alice, Bob], () => {\n          const go = declassify(interact.keepGoing()); });\n        Alice.only(() => {\n          const isAlice = true; });\n        Bob.only(() => {\n          const isAlice = false; });\n\n        race(Alice, Bob).publish(isAlice).when(go)\n          .timeout(relativeTime(deadline), () => {\n            showOutcome(TIMEOUT)();\n            race(Alice, Bob).publish();\n            keepGoing = false;\n            continue; });\n        const [ da, db ] = isAlice ? [ 1, 0 ] : [ 0, 1 ];\n        each([Alice, Bob], () => {\n          interact.roundWinnerWas(isAlice); });\n        [ keepGoing, as, bs ] = [ true, as + da, bs + db ];\n        continue;\n      }\n```\n",
  "with": "\n\n\nThis error indicates you are using an illegal JavaScript expression in Reach. Not all JavaScript\nexpressions are valid Reach, as they are not applicable to the language.\n",
  "xor": "\n```javascript\nand(a, b)     // &&\nor(a, b)      // ||\nxor(a, b)     // ^\nadd(a, b)     // +\nsub(a, b)     // -\nmul(a, b)     // *\ndiv(a, b)     // /\npolyMod(a, b) // %\neq(a, b)      // ==\nlt(a, b)      // <\nle(a, b)      // <=\nge(a, b)      // >=\ngt(a, b)      // >\nlsh(a, b)     // <<\nrsh(a, b)     // >>\nband(a, b)    // &\nbior(a, b)    // |\npolyEq(a, b)  // ==, ===\npolyNeq(a, b) // !=, !==\n```\n\nAll binary expression operators have a corresponding named function in the standard library.\nWhile `&&` and `||` may not evaluate their second argument,\ntheir corresponding named functions `and`, `or`, and `xor`, always do.\n\n\n```javascript\npolyEq(a, b)    // eq on all types\nboolEq(a, b)    // eq on Bool\ntypeEq(a, b)    // eq on types\nintEq(a, b)     // eq on UInt and UInt256\ndigestEq(a, b)  // eq on Digest\naddressEq(a, b) // eq on Addresses\nfxeq(a, b)      // eq on FixedPoint\nieq(a, b)       // eq on Int\n```\n\nEquality functions, like `==`, `===`, `!=`, and `!==`, operate on all types.\nHowever, values with different types are always not equal.\nBoth arguments must be of the same type.\nSpecialized functions exist for equality checking on each supported type.\n\n---\n\nIf `verifyArithmetic` is `true`, then arithmetic operations automatically make a static assertion that their arguments would not overflow the bit width of the enabled consensus networks.\nIf it is `false`, then the connector will ensure this dynamically.\n",
  "yield": "\n\nThis error indicates you are using an illegal JavaScript expression in Reach. Not all JavaScript\nexpressions are valid Reach, as they are not applicable to the language.\n",
  "interact": "\n```javascript\ninteract.amount\ninteract.notify(handA, handB)\ninteract.chooseAmount(heap1, heap2) \n```\n\nAn interaction expression, written `interact.METHOD(EXPR_0, ..., EXPR_n)`, where `METHOD` is an identifier bound in the participant interact interface to a function type, and `EXPR_0` through `EXPR_n` are expressions that evaluate to the result of an interaction with a frontend that receives the evaluation of the `n` expressions and sends a value.\n\nAn interaction expression may also be written `interact.KEY`, where `KEY` is bound in the participant interact interface to a non-function type.\n\nAn interaction expression may only occur in a local step.\n\n```javascript\n  Alice.only(() => {\n    const wager = declassify(interact.wager);\n    const deadline = declassify(interact.deadline);\n  });\n```\n\nIn this example from the [Rock, Paper Scissors](https://docs.reach.sh/tut/rps/#tut) tutorial, the program is in the local step of Alice.\nIt has Alice `declassify` the `interact` object for both the `wager` and the `deadline` for Bob, so that Bob can accept them.\n",
  "only": "\n```javascript\nAlice.only(() => {\n  const pretzel = interact.random(); });\n```\n\nA local step statement is written `PART.only(() => BLOCK)`, where `PART` is a participant identifier and `BLOCK` is a block.\nWithin `BLOCK`, `PART` is bound to the address of the participant.\nAny bindings defined within the block of a local step are available in the statement's tail as new local state.\nFor example,\n\n```javascript\nAlice.only(() => {\n  const x = 3; });\nAlice.only(() => {\n  const y = x + 1; });\n```\n\nis a valid program where `Alice`'s local state includes the private values `x` (bound to `3`) and `y` (bound to `4`).\nHowever, such bindings are _not_ consensus state, so they are purely local state.\nFor example,\n\n```javascript\nAlice.only(() => {\n  const x = 3; });\nBob.only(() => {\n  const y = x + 1; });\n```\n\nis an invalid program, because `Bob` does not know `x`.\n\nThe interact shorthand, written `PART.interact.METHOD(EXPR_0, ..., EXPR_n)`, is available for calling an `interact` function from outside of an `only` block.\nSuch functions must return `Null`; therefore, they are only useful if they produce side-effects, such as logging on the frontend.\nFor example, the function `log` in the participant interact interface of `Alice` may be called via:\n\n```javascript\nAlice.interact.log(x);\n```\n\n---\n\n\n```javascript\neach([Alice, Bob], () => {\n  const pretzel = interact.random(); });\n```\n\nAn each local step statement can be written as `each(PART_TUPLE () => BLOCK)`, where `PART_TUPLE` is a tuple of participants and `BLOCK` is a block.\nIt is an abbreviation of many local step statements that could have been written with `only`.\n",
  "pay": "\n```javascript\nAlice.publish(wagerAmount)\n     .pay(wagerAmount)\n     .timeout(DELAY, () => {\n       Bob.publish();\n       commit();\n       return false; });\n```\n\n```javascript\nAlice.publish(wagerAmount)\n     .pay(wagerAmount)\n     .timeout(DELAY, () => closeTo(Bob, false));\n```\n\n```javascript\nAlice.publish(wagerAmount)\n     .pay(wagerAmount)\n     .timeout(false);\n```\n\n---\n**NOTE**\n\nIf you're unsure of what kind of consensus transfer to use, you may want to read the [explanation of the differences](https://docs.reach.sh/guide/ctransfers/#guide-ctransfers) in the Guide.\n\n---\n\nA consensus transfer is written\n```javascript\nPART_EXPR.publish(ID_0, ..., ID_n)\n .pay(PAY_EXPR, ?PAY_REQUIRE_EXPR)\n .when(WHEN_EXPR)\n .timeout(DELAY_EXPR, () =>\n   TIMEOUT_BLOCK)\n // or\n .throwTimeout(DELAY_EXPR, THROWN_EXPR)\n```\n\nwhere `PART_EXPR` is an expression that evaluates to a participant or race expression,\n`ID_0` through `ID_n` are identifiers for `PART`'s public local state,\n`PAY_EXPR` is a public expression that evaluates to a pay amount.\n`PAY_REQUIRE_EXPR` is an optional nullary function that can be used to make `require` claims about the `PAY_EXPR`.\n`WHEN_EXPR` is a public expression evaluating to a boolean and determines if the consensus transfer takes place,\n`DELAY_EXPR` is a public expression that depends on only consensus state and evaluates to a time argument,\n`TIMEOUT_BLOCK` is a timeout block, which will be executed after the `DELAY_EXPR` time argument passes without `PART` executing this consensus transfer.\n\nAll of the expressions within a consensus transfer are evaluated in a pure context, which may not alter the state of the application.\nThe `PAY_EXPR`, `WHEN_EXPR`, and `DELAY_EXPR` expressions must refer only to the consensus state, including the new data published via the `.publish` component.\n\nThe continuation of a consensus transfer statement is a consensus step, which is finalized with a commit statement.\nThe continuation of a timeout block is the same as the continuation of the function the timeout occurs within.\n\n---\n**NOTE**\n\nSee [the guide section on non-participation](https://docs.reach.sh/guide/timeout/#guide-timeout) to understand when to use timeouts and how to use them most effectively.\n\n---\n\nThe `publish` component exclusive-or the `pay` component may be omitted, if either there is no publication or no transfer of network tokens to accompany this consensus transfer.\nThe `when` component may always be omitted, in which case it is assumed to be `true`.\n`publish` or `pay` must occur first, after which components may occur in any order.\nFor example, the following are all valid:\n\n```javascript\nAlice.publish(coinFlip);\n\nAlice.pay(penaltyAmount);\n\nAlice.pay(penaltyAmount).publish(coinFlip);\n\nAlice.publish(coinFlip)\n     .timeout(DELAY, () => closeTo(Bob, () => exit()));\n\nAlice.pay(penaltyAmount)\n     .timeout(DELAY, () => {\n       Bob.publish();\n       commit();\n       exit(); });\n\nAlice.publish(bid).when(wantsToBid);\n\n```\n\nThe `timeout` component must be included if `when` is not statically `true`.\nThis ensures that your clients will eventually complete the program.\nIf a consensus transfer is a guaranteed race between non-class participants and a participant class that _may_ attempt to transfer (i.e. `when` is not statically `false`), then a `timeout` may be explicitly omitted by writing `.timeout(false)`.\n\n\n`.throwTimeout` may be used in place of `.timeout`. It accepts a `DELAY_EXPR` and an `EXPR`, which will be thrown if a timeout should occur.\nIf an `EXPR` is not provided, then `null` will be thrown.\nIf a consensus transfer uses `.throwTimeout`, it must be within a try statement.\n\nIf a consensus transfer specifies a single participant, which has not yet been fixed in the application and is not a participant class, then this statement does so; therefore, after it the `PART` may be used as an address.\n\nIf a consensus transfer specificies a single participant class, then all members of that class will attempt to perform the transfer, but only one will succeed.\n\nA consensus transfer binds the identifiers `ID_0` through `ID_n` for all participants to the values included in the consensus transfer, overwriting any bindings that already exist for those identifiers.\nIf an existing participant, not included in `PART_EXPR`, has previously bound one of these identifiers, then the program is not valid. In other words, the following program is not valid:\n\n```javascript\nAlice.only(() => {\n const x = 1; });\nBob.only(() => {\n const x = 2; });\nClaire.only(() => {\n const x = 3; });\nrace(Alice, Bob).publish(x);\ncommit();\n```\n\nbecause `Claire` is not included in the `race`.\nHowever, if we were to rename `Claire`'s `x` into `y`, then it would be valid, because although `Alice` and `Bob` both bind `x`, they participate in the `race`, so it is allowed.\nIn the tail of this program, `x` is bound to either `1` or `2`, i.e., either `Alice` or `Bob`'s value is overwritten.\nThis overwriting applies even if `Alice` wins and `Alice` is a participant class, i.e., the value of `x` in the tail is guaranteed to be the single value that was agreed upon in the consensus.\n",
  "publish": "\n```javascript\nAlice.publish(wagerAmount)\n     .pay(wagerAmount)\n     .timeout(DELAY, () => {\n       Bob.publish();\n       commit();\n       return false; });\n```\n\n```javascript\nAlice.publish(wagerAmount)\n     .pay(wagerAmount)\n     .timeout(DELAY, () => closeTo(Bob, false));\n```\n\n```javascript\nAlice.publish(wagerAmount)\n     .pay(wagerAmount)\n     .timeout(false);\n```\n\n---\n**NOTE**\n\nIf you're unsure of what kind of consensus transfer to use, you may want to read the [explanation of the differences](https://docs.reach.sh/guide/ctransfers/#guide-ctransfers) in the Guide.\n\n---\n\nA consensus transfer is written\n```javascript\nPART_EXPR.publish(ID_0, ..., ID_n)\n .pay(PAY_EXPR, ?PAY_REQUIRE_EXPR)\n .when(WHEN_EXPR)\n .timeout(DELAY_EXPR, () =>\n   TIMEOUT_BLOCK)\n // or\n .throwTimeout(DELAY_EXPR, THROWN_EXPR)\n```\n\nwhere `PART_EXPR` is an expression that evaluates to a participant or race expression,\n`ID_0` through `ID_n` are identifiers for `PART`'s public local state,\n`PAY_EXPR` is a public expression that evaluates to a pay amount.\n`PAY_REQUIRE_EXPR` is an optional nullary function that can be used to make `require` claims about the `PAY_EXPR`.\n`WHEN_EXPR` is a public expression evaluating to a boolean and determines if the consensus transfer takes place,\n`DELAY_EXPR` is a public expression that depends on only consensus state and evaluates to a time argument,\n`TIMEOUT_BLOCK` is a timeout block, which will be executed after the `DELAY_EXPR` time argument passes without `PART` executing this consensus transfer.\n\nAll of the expressions within a consensus transfer are evaluated in a pure context, which may not alter the state of the application.\nThe `PAY_EXPR`, `WHEN_EXPR`, and `DELAY_EXPR` expressions must refer only to the consensus state, including the new data published via the `.publish` component.\n\nThe continuation of a consensus transfer statement is a consensus step, which is finalized with a commit statement.\nThe continuation of a timeout block is the same as the continuation of the function the timeout occurs within.\n\n---\n**NOTE**\n\nSee [the guide section on non-participation](https://docs.reach.sh/guide/timeout/#guide-timeout) to understand when to use timeouts and how to use them most effectively.\n\n---\n\nThe `publish` component exclusive-or the `pay` component may be omitted, if either there is no publication or no transfer of network tokens to accompany this consensus transfer.\nThe `when` component may always be omitted, in which case it is assumed to be `true`.\n`publish` or `pay` must occur first, after which components may occur in any order.\nFor example, the following are all valid:\n\n```javascript\nAlice.publish(coinFlip);\n\nAlice.pay(penaltyAmount);\n\nAlice.pay(penaltyAmount).publish(coinFlip);\n\nAlice.publish(coinFlip)\n     .timeout(DELAY, () => closeTo(Bob, () => exit()));\n\nAlice.pay(penaltyAmount)\n     .timeout(DELAY, () => {\n       Bob.publish();\n       commit();\n       exit(); });\n\nAlice.publish(bid).when(wantsToBid);\n\n```\n\nThe `timeout` component must be included if `when` is not statically `true`.\nThis ensures that your clients will eventually complete the program.\nIf a consensus transfer is a guaranteed race between non-class participants and a participant class that _may_ attempt to transfer (i.e. `when` is not statically `false`), then a `timeout` may be explicitly omitted by writing `.timeout(false)`.\n\n\n`.throwTimeout` may be used in place of `.timeout`. It accepts a `DELAY_EXPR` and an `EXPR`, which will be thrown if a timeout should occur.\nIf an `EXPR` is not provided, then `null` will be thrown.\nIf a consensus transfer uses `.throwTimeout`, it must be within a try statement.\n\nIf a consensus transfer specifies a single participant, which has not yet been fixed in the application and is not a participant class, then this statement does so; therefore, after it the `PART` may be used as an address.\n\nIf a consensus transfer specificies a single participant class, then all members of that class will attempt to perform the transfer, but only one will succeed.\n\nA consensus transfer binds the identifiers `ID_0` through `ID_n` for all participants to the values included in the consensus transfer, overwriting any bindings that already exist for those identifiers.\nIf an existing participant, not included in `PART_EXPR`, has previously bound one of these identifiers, then the program is not valid. In other words, the following program is not valid:\n\n```javascript\nAlice.only(() => {\n const x = 1; });\nBob.only(() => {\n const x = 2; });\nClaire.only(() => {\n const x = 3; });\nrace(Alice, Bob).publish(x);\ncommit();\n```\n\nbecause `Claire` is not included in the `race`.\nHowever, if we were to rename `Claire`'s `x` into `y`, then it would be valid, because although `Alice` and `Bob` both bind `x`, they participate in the `race`, so it is allowed.\nIn the tail of this program, `x` is bound to either `1` or `2`, i.e., either `Alice` or `Bob`'s value is overwritten.\nThis overwriting applies even if `Alice` wins and `Alice` is a participant class, i.e., the value of `x` in the tail is guaranteed to be the single value that was agreed upon in the consensus.\n",
  "timeout": "\n```javascript\nAlice.publish(wagerAmount)\n     .pay(wagerAmount)\n     .timeout(DELAY, () => {\n       Bob.publish();\n       commit();\n       return false; });\n```\n\n```javascript\nAlice.publish(wagerAmount)\n     .pay(wagerAmount)\n     .timeout(DELAY, () => closeTo(Bob, false));\n```\n\n```javascript\nAlice.publish(wagerAmount)\n     .pay(wagerAmount)\n     .timeout(false);\n```\n\n---\n**NOTE**\n\nIf you're unsure of what kind of consensus transfer to use, you may want to read the [explanation of the differences](https://docs.reach.sh/guide/ctransfers/#guide-ctransfers) in the Guide.\n\n---\n\nA consensus transfer is written\n```javascript\nPART_EXPR.publish(ID_0, ..., ID_n)\n .pay(PAY_EXPR, ?PAY_REQUIRE_EXPR)\n .when(WHEN_EXPR)\n .timeout(DELAY_EXPR, () =>\n   TIMEOUT_BLOCK)\n // or\n .throwTimeout(DELAY_EXPR, THROWN_EXPR)\n```\n\nwhere `PART_EXPR` is an expression that evaluates to a participant or race expression,\n`ID_0` through `ID_n` are identifiers for `PART`'s public local state,\n`PAY_EXPR` is a public expression that evaluates to a pay amount.\n`PAY_REQUIRE_EXPR` is an optional nullary function that can be used to make `require` claims about the `PAY_EXPR`.\n`WHEN_EXPR` is a public expression evaluating to a boolean and determines if the consensus transfer takes place,\n`DELAY_EXPR` is a public expression that depends on only consensus state and evaluates to a time argument,\n`TIMEOUT_BLOCK` is a timeout block, which will be executed after the `DELAY_EXPR` time argument passes without `PART` executing this consensus transfer.\n\nAll of the expressions within a consensus transfer are evaluated in a pure context, which may not alter the state of the application.\nThe `PAY_EXPR`, `WHEN_EXPR`, and `DELAY_EXPR` expressions must refer only to the consensus state, including the new data published via the `.publish` component.\n\nThe continuation of a consensus transfer statement is a consensus step, which is finalized with a commit statement.\nThe continuation of a timeout block is the same as the continuation of the function the timeout occurs within.\n\n---\n**NOTE**\n\nSee [the guide section on non-participation](https://docs.reach.sh/guide/timeout/#guide-timeout) to understand when to use timeouts and how to use them most effectively.\n\n---\n\nThe `publish` component exclusive-or the `pay` component may be omitted, if either there is no publication or no transfer of network tokens to accompany this consensus transfer.\nThe `when` component may always be omitted, in which case it is assumed to be `true`.\n`publish` or `pay` must occur first, after which components may occur in any order.\nFor example, the following are all valid:\n\n```javascript\nAlice.publish(coinFlip);\n\nAlice.pay(penaltyAmount);\n\nAlice.pay(penaltyAmount).publish(coinFlip);\n\nAlice.publish(coinFlip)\n     .timeout(DELAY, () => closeTo(Bob, () => exit()));\n\nAlice.pay(penaltyAmount)\n     .timeout(DELAY, () => {\n       Bob.publish();\n       commit();\n       exit(); });\n\nAlice.publish(bid).when(wantsToBid);\n\n```\n\nThe `timeout` component must be included if `when` is not statically `true`.\nThis ensures that your clients will eventually complete the program.\nIf a consensus transfer is a guaranteed race between non-class participants and a participant class that _may_ attempt to transfer (i.e. `when` is not statically `false`), then a `timeout` may be explicitly omitted by writing `.timeout(false)`.\n\n\n`.throwTimeout` may be used in place of `.timeout`. It accepts a `DELAY_EXPR` and an `EXPR`, which will be thrown if a timeout should occur.\nIf an `EXPR` is not provided, then `null` will be thrown.\nIf a consensus transfer uses `.throwTimeout`, it must be within a try statement.\n\nIf a consensus transfer specifies a single participant, which has not yet been fixed in the application and is not a participant class, then this statement does so; therefore, after it the `PART` may be used as an address.\n\nIf a consensus transfer specificies a single participant class, then all members of that class will attempt to perform the transfer, but only one will succeed.\n\nA consensus transfer binds the identifiers `ID_0` through `ID_n` for all participants to the values included in the consensus transfer, overwriting any bindings that already exist for those identifiers.\nIf an existing participant, not included in `PART_EXPR`, has previously bound one of these identifiers, then the program is not valid. In other words, the following program is not valid:\n\n```javascript\nAlice.only(() => {\n const x = 1; });\nBob.only(() => {\n const x = 2; });\nClaire.only(() => {\n const x = 3; });\nrace(Alice, Bob).publish(x);\ncommit();\n```\n\nbecause `Claire` is not included in the `race`.\nHowever, if we were to rename `Claire`'s `x` into `y`, then it would be valid, because although `Alice` and `Bob` both bind `x`, they participate in the `race`, so it is allowed.\nIn the tail of this program, `x` is bound to either `1` or `2`, i.e., either `Alice` or `Bob`'s value is overwritten.\nThis overwriting applies even if `Alice` wins and `Alice` is a participant class, i.e., the value of `x` in the tail is guaranteed to be the single value that was agreed upon in the consensus.\n",
  "when": "\n```javascript\nAlice.publish(wagerAmount)\n     .pay(wagerAmount)\n     .timeout(DELAY, () => {\n       Bob.publish();\n       commit();\n       return false; });\n```\n\n```javascript\nAlice.publish(wagerAmount)\n     .pay(wagerAmount)\n     .timeout(DELAY, () => closeTo(Bob, false));\n```\n\n```javascript\nAlice.publish(wagerAmount)\n     .pay(wagerAmount)\n     .timeout(false);\n```\n\n---\n**NOTE**\n\nIf you're unsure of what kind of consensus transfer to use, you may want to read the [explanation of the differences](https://docs.reach.sh/guide/ctransfers/#guide-ctransfers) in the Guide.\n\n---\n\nA consensus transfer is written\n```javascript\nPART_EXPR.publish(ID_0, ..., ID_n)\n .pay(PAY_EXPR, ?PAY_REQUIRE_EXPR)\n .when(WHEN_EXPR)\n .timeout(DELAY_EXPR, () =>\n   TIMEOUT_BLOCK)\n // or\n .throwTimeout(DELAY_EXPR, THROWN_EXPR)\n```\n\nwhere `PART_EXPR` is an expression that evaluates to a participant or race expression,\n`ID_0` through `ID_n` are identifiers for `PART`'s public local state,\n`PAY_EXPR` is a public expression that evaluates to a pay amount.\n`PAY_REQUIRE_EXPR` is an optional nullary function that can be used to make `require` claims about the `PAY_EXPR`.\n`WHEN_EXPR` is a public expression evaluating to a boolean and determines if the consensus transfer takes place,\n`DELAY_EXPR` is a public expression that depends on only consensus state and evaluates to a time argument,\n`TIMEOUT_BLOCK` is a timeout block, which will be executed after the `DELAY_EXPR` time argument passes without `PART` executing this consensus transfer.\n\nAll of the expressions within a consensus transfer are evaluated in a pure context, which may not alter the state of the application.\nThe `PAY_EXPR`, `WHEN_EXPR`, and `DELAY_EXPR` expressions must refer only to the consensus state, including the new data published via the `.publish` component.\n\nThe continuation of a consensus transfer statement is a consensus step, which is finalized with a commit statement.\nThe continuation of a timeout block is the same as the continuation of the function the timeout occurs within.\n\n---\n**NOTE**\n\nSee [the guide section on non-participation](https://docs.reach.sh/guide/timeout/#guide-timeout) to understand when to use timeouts and how to use them most effectively.\n\n---\n\nThe `publish` component exclusive-or the `pay` component may be omitted, if either there is no publication or no transfer of network tokens to accompany this consensus transfer.\nThe `when` component may always be omitted, in which case it is assumed to be `true`.\n`publish` or `pay` must occur first, after which components may occur in any order.\nFor example, the following are all valid:\n\n```javascript\nAlice.publish(coinFlip);\n\nAlice.pay(penaltyAmount);\n\nAlice.pay(penaltyAmount).publish(coinFlip);\n\nAlice.publish(coinFlip)\n     .timeout(DELAY, () => closeTo(Bob, () => exit()));\n\nAlice.pay(penaltyAmount)\n     .timeout(DELAY, () => {\n       Bob.publish();\n       commit();\n       exit(); });\n\nAlice.publish(bid).when(wantsToBid);\n\n```\n\nThe `timeout` component must be included if `when` is not statically `true`.\nThis ensures that your clients will eventually complete the program.\nIf a consensus transfer is a guaranteed race between non-class participants and a participant class that _may_ attempt to transfer (i.e. `when` is not statically `false`), then a `timeout` may be explicitly omitted by writing `.timeout(false)`.\n\n\n`.throwTimeout` may be used in place of `.timeout`. It accepts a `DELAY_EXPR` and an `EXPR`, which will be thrown if a timeout should occur.\nIf an `EXPR` is not provided, then `null` will be thrown.\nIf a consensus transfer uses `.throwTimeout`, it must be within a try statement.\n\nIf a consensus transfer specifies a single participant, which has not yet been fixed in the application and is not a participant class, then this statement does so; therefore, after it the `PART` may be used as an address.\n\nIf a consensus transfer specificies a single participant class, then all members of that class will attempt to perform the transfer, but only one will succeed.\n\nA consensus transfer binds the identifiers `ID_0` through `ID_n` for all participants to the values included in the consensus transfer, overwriting any bindings that already exist for those identifiers.\nIf an existing participant, not included in `PART_EXPR`, has previously bound one of these identifiers, then the program is not valid. In other words, the following program is not valid:\n\n```javascript\nAlice.only(() => {\n const x = 1; });\nBob.only(() => {\n const x = 2; });\nClaire.only(() => {\n const x = 3; });\nrace(Alice, Bob).publish(x);\ncommit();\n```\n\nbecause `Claire` is not included in the `race`.\nHowever, if we were to rename `Claire`'s `x` into `y`, then it would be valid, because although `Alice` and `Bob` both bind `x`, they participate in the `race`, so it is allowed.\nIn the tail of this program, `x` is bound to either `1` or `2`, i.e., either `Alice` or `Bob`'s value is overwritten.\nThis overwriting applies even if `Alice` wins and `Alice` is a participant class, i.e., the value of `x` in the tail is guaranteed to be the single value that was agreed upon in the consensus.\n"
};

export default KEYWORD_TO_DOCUMENTATION;
