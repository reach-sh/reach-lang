[{"bookPath":"guide","title":"What are Reach's limitations?","titleId":"guide-limits","hasOtp":true,"hasPageHeader":true},"<p>\n  <i id=\"p_0\" class=\"pid\"></i>Today, Reach is a powerful language for building decentralized applications, as demonstrated in <a href=\"/tut/overview/#overview\">the overview</a>, <a href=\"/tut/rps/#tut\">the tutorial</a>, and the <a href=\"/workshop/#workshop\">workshop series</a>.\n  However, it has a lot of potential for growth.\n  This section describes a few of these areas and gives brief sketches of our roadmap for directing this growth.\n  We welcome your contributions on <a href=\"https://github.com/reach-sh/reach-lang\">GitHub</a> and in <a href=\"https://discord.gg/AZsgcXu\">the Discord community</a> to help bring these plans to fruition.<a href=\"#p_0\" class=\"pid\">0</a>\n</p>\n<hr>\n<p>\n  <i id=\"p_1\" class=\"pid\"></i><strong>Connectors.</strong> Foremost, Reach is a consensus network-agnostic language, so one of our highest priorities is supporting a wide variety of platforms, including layer-2 abstractions over other layer-1 networks.\n  Presently, we have a robust <a href=\"/networks/#ref-network-eth\">Ethereum backend</a> and <a href=\"/networks/#ref-network-algo\">Algorand backend</a>.<a href=\"#p_1\" class=\"pid\">1</a>\n</p>\n<hr>\n<p>\n  <i id=\"p_2\" class=\"pid\"></i><strong>Backends.</strong> Presently, Reach has a robust backend for JavaScript that is well-suited for client-facing applications and JavaScript servers.\n  However, we believe that many decentralized application developers would like to make use of languages like Go and Rust for their participants.\n  Presently, this can be accomplished via the <a href=\"/rpc/#ref-backends-rpc\">RPC server</a>, but we'd like to build a dedicated backend for languages like these.<a href=\"#p_2\" class=\"pid\">2</a>\n</p>\n<hr>\n<p>\n  <i id=\"p_3\" class=\"pid\"></i><strong>Computation.</strong> Reach's computational language is based on JavaScript and contains many of JavaScript's most desirable features, like arrow expressions, free-form objects, destructuring bindings, robust <span class=\"snip\"><a href=\"/rsh/module/#rsh_import\" title=\"rsh: import\"><span style=\"color: var(--shiki-token-keyword)\">import</span></a></span> and <span class=\"snip\"><a href=\"/rsh/module/#rsh_export\" title=\"rsh: export\"><span style=\"color: var(--shiki-token-keyword)\">export</span></a></span> specificiers, and so on.\n  However, there are some differences that represent limitations, such as the inability to use functions as values at runtime and the need to enforce finite limits on data.<a href=\"#p_3\" class=\"pid\">3</a>\n</p>\n<hr>\n<p><i id=\"p_4\" class=\"pid\"></i><strong>Verification.</strong> Reach's verifier is robust in the face of many complex and interesting theorems about decentralized application behavior, but it is inherently conservative and does not presently allow users to manually prove theorems that are conservatively rejected.<a href=\"#p_4\" class=\"pid\">4</a></p>\n<hr>\n<p>\n  <i id=\"p_5\" class=\"pid\"></i><strong>Network Integration.</strong> Since Reach is consensus network-agnostic, it is not possible for Reach programs to directly integrate with network-specific features, such as observing the blockhash on Ethereum.\n  Reach programs can instead interact with these low-level details of their chosen consensus network via remote object interaction.<a href=\"#p_5\" class=\"pid\">5</a>\n</p>\n<hr>\n<p>\n  <i id=\"p_6\" class=\"pid\"></i><strong>Communication.</strong>\n  Reach's communication language has some limitations that we have plans to remove, which are discussed in <a href=\"/guide/roadmap/#guide-roadmap\">roadmap</a>, but there are some for which we do not have plans to remove.\n  For example, we do not intend to support co-inductive or cyclic state, nor expose an arbitrary consensus heap to programmers.<a href=\"#p_6\" class=\"pid\">6</a>\n</p>","<ul><li class=\"dynamic\"><a href=\"#guide-limits\">What are Reach's limitations?</a></li></ul>"]